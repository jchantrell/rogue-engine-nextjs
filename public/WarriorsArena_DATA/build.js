!(function webpackUniversalModuleDefinition(e, t) {
  "object" === typeof exports && "object" === typeof module
    ? (module.exports = t())
    : "function" === typeof define && define.amd
    ? define([], t)
    : "object" === typeof exports
    ? (exports.three = t())
    : (e.three = t());
})(window, function () {
  return (function (e) {
    var t = {};
    function __webpack_require__(n) {
      if (t[n]) return t[n].exports;
      var r = (t[n] = { i: n, l: !1, exports: {} });
      return (
        e[n].call(r.exports, r, r.exports, __webpack_require__),
        (r.l = !0),
        r.exports
      );
    }
    return (
      (__webpack_require__.m = e),
      (__webpack_require__.c = t),
      (__webpack_require__.d = function (e, t, n) {
        __webpack_require__.o(e, t) ||
          Object.defineProperty(e, t, { enumerable: !0, get: n });
      }),
      (__webpack_require__.r = function (e) {
        "undefined" !== typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(e, "__esModule", { value: !0 });
      }),
      (__webpack_require__.t = function (e, t) {
        if ((1 & t && (e = __webpack_require__(e)), 8 & t)) return e;
        if (4 & t && "object" === typeof e && e && e.__esModule) return e;
        var n = Object.create(null);
        if (
          (__webpack_require__.r(n),
          Object.defineProperty(n, "default", { enumerable: !0, value: e }),
          2 & t && "string" != typeof e)
        )
          for (var r in e)
            __webpack_require__.d(
              n,
              r,
              function (t) {
                return e[t];
              }.bind(null, r)
            );
        return n;
      }),
      (__webpack_require__.n = function (e) {
        var t =
          e && e.__esModule
            ? function getDefault() {
                return e.default;
              }
            : function getModuleExports() {
                return e;
              };
        return __webpack_require__.d(t, "a", t), t;
      }),
      (__webpack_require__.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }),
      (__webpack_require__.p = "./"),
      __webpack_require__((__webpack_require__.s = 151))
    );
  })({
    10: function (e, t, n) {
      "use strict";
      var r = n(3);
      function get_get(e, t, n) {
        return (get_get =
          "undefined" !== typeof Reflect && Reflect.get
            ? Reflect.get
            : function _get(e, t, n) {
                var i = (function _superPropBase(e, t) {
                  for (
                    ;
                    !Object.prototype.hasOwnProperty.call(e, t) &&
                    null !== (e = Object(r.a)(e));

                  );
                  return e;
                })(e, t);
                if (i) {
                  var a = Object.getOwnPropertyDescriptor(i, t);
                  return a.get ? a.get.call(n) : a.value;
                }
              })(e, t, n || e);
      }
      n.d(t, "a", function () {
        return get_get;
      });
    },
    13: function (e, t, n) {
      "use strict";
      function _assertThisInitialized(e) {
        if (void 0 === e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return e;
      }
      n.d(t, "a", function () {
        return _assertThisInitialized;
      });
    },
    15: function (e, t, n) {
      e.exports = n(77);
    },
    151: function (e, t, n) {
      "use strict";
      n.r(t);
      var r = n(3),
        i = n(20);
      function construct_construct(e, t, n) {
        return (construct_construct = (function isNativeReflectConstruct() {
          if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" === typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (e) {
            return !1;
          }
        })()
          ? Reflect.construct
          : function _construct(e, t, n) {
              var r = [null];
              r.push.apply(r, t);
              var a = new (Function.bind.apply(e, r))();
              return n && Object(i.a)(a, n.prototype), a;
            }).apply(null, arguments);
      }
      function wrapNativeSuper_wrapNativeSuper(e) {
        var t = "function" === typeof Map ? new Map() : void 0;
        return (wrapNativeSuper_wrapNativeSuper = function _wrapNativeSuper(e) {
          if (
            null === e ||
            !(function _isNativeFunction(e) {
              return -1 !== Function.toString.call(e).indexOf("[native code]");
            })(e)
          )
            return e;
          if ("function" !== typeof e)
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          if ("undefined" !== typeof t) {
            if (t.has(e)) return t.get(e);
            t.set(e, Wrapper);
          }
          function Wrapper() {
            return construct_construct(
              e,
              arguments,
              Object(r.a)(this).constructor
            );
          }
          return (
            (Wrapper.prototype = Object.create(e.prototype, {
              constructor: {
                value: Wrapper,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
            Object(i.a)(Wrapper, e)
          );
        })(e);
      }
      function _toConsumableArray(e) {
        return (
          (function _arrayWithoutHoles(e) {
            if (Array.isArray(e)) {
              for (var t = 0, n = new Array(e.length); t < e.length; t++)
                n[t] = e[t];
              return n;
            }
          })(e) ||
          (function _iterableToArray(e) {
            if (
              Symbol.iterator in Object(e) ||
              "[object Arguments]" === Object.prototype.toString.call(e)
            )
              return Array.from(e);
          })(e) ||
          (function _nonIterableSpread() {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance"
            );
          })()
        );
      }
      function asyncGeneratorStep(e, t, n, r, i, a, o) {
        try {
          var s = e[a](o),
            u = s.value;
        } catch (l) {
          return void n(l);
        }
        s.done ? t(u) : Promise.resolve(u).then(r, i);
      }
      function _asyncToGenerator(e) {
        return function () {
          var t = this,
            n = arguments;
          return new Promise(function (r, i) {
            var a = e.apply(t, n);
            function _next(e) {
              asyncGeneratorStep(a, r, i, _next, _throw, "next", e);
            }
            function _throw(e) {
              asyncGeneratorStep(a, r, i, _next, _throw, "throw", e);
            }
            _next(void 0);
          });
        };
      }
      var a = n(21),
        o = n(10),
        s = n(8),
        u = n(9),
        l = n(13);
      function _defineProperty(e, t, n) {
        return (
          t in e
            ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = n),
          e
        );
      }
      var c,
        h = n(15),
        d = n.n(h),
        f = n(4),
        p = n(6);
      n.d(t, "ACESFilmicToneMapping", function () {
        return me;
      }),
        n.d(t, "AddEquation", function () {
          return N;
        }),
        n.d(t, "AddOperation", function () {
          return ce;
        }),
        n.d(t, "AdditiveAnimationBlendMode", function () {
          return Gt;
        }),
        n.d(t, "AdditiveBlending", function () {
          return I;
        }),
        n.d(t, "AlphaFormat", function () {
          return Xe;
        }),
        n.d(t, "AlwaysDepth", function () {
          return te;
        }),
        n.d(t, "AlwaysStencilFunc", function () {
          return vn;
        }),
        n.d(t, "AmbientLight", function () {
          return yl;
        }),
        n.d(t, "AmbientLightProbe", function () {
          return Il;
        }),
        n.d(t, "AnimationClip", function () {
          return Uu;
        }),
        n.d(t, "AnimationLoader", function () {
          return Ku;
        }),
        n.d(t, "AnimationMixer", function () {
          return uc;
        }),
        n.d(t, "AnimationObjectGroup", function () {
          return ac;
        }),
        n.d(t, "AnimationUtils", function () {
          return Lu;
        }),
        n.d(t, "ArcCurve", function () {
          return Ls;
        }),
        n.d(t, "ArrayCamera", function () {
          return ho;
        }),
        n.d(t, "ArrowHelper", function () {
          return Yc;
        }),
        n.d(t, "Audio", function () {
          return Hl;
        }),
        n.d(t, "AudioAnalyser", function () {
          return Kl;
        }),
        n.d(t, "AudioContext", function () {
          return El;
        }),
        n.d(t, "AudioListener", function () {
          return Wl;
        }),
        n.d(t, "AudioLoader", function () {
          return Pl;
        }),
        n.d(t, "AxesHelper", function () {
          return Zc;
        }),
        n.d(t, "BackSide", function () {
          return C;
        }),
        n.d(t, "BasicDepthPacking", function () {
          return Xt;
        }),
        n.d(t, "BasicShadowMap", function () {
          return S;
        }),
        n.d(t, "Bone", function () {
          return Yo;
        }),
        n.d(t, "BooleanKeyframeTrack", function () {
          return Du;
        }),
        n.d(t, "Box2", function () {
          return yc;
        }),
        n.d(t, "Box3", function () {
          return sr;
        }),
        n.d(t, "Box3Helper", function () {
          return qc;
        }),
        n.d(t, "BoxBufferGeometry", function () {
          return aa;
        }),
        n.d(t, "BoxGeometry", function () {
          return aa;
        }),
        n.d(t, "BoxHelper", function () {
          return Hc;
        }),
        n.d(t, "BufferAttribute", function () {
          return Mi;
        }),
        n.d(t, "BufferGeometry", function () {
          return Fi;
        }),
        n.d(t, "BufferGeometryLoader", function () {
          return Tl;
        }),
        n.d(t, "ByteType", function () {
          return Be;
        }),
        n.d(t, "Cache", function () {
          return Wu;
        }),
        n.d(t, "Camera", function () {
          return ca;
        }),
        n.d(t, "CameraHelper", function () {
          return Gc;
        }),
        n.d(t, "CanvasTexture", function () {
          return As;
        }),
        n.d(t, "CapsuleBufferGeometry", function () {
          return qs;
        }),
        n.d(t, "CapsuleGeometry", function () {
          return qs;
        }),
        n.d(t, "CatmullRomCurve3", function () {
          return Is;
        }),
        n.d(t, "CineonToneMapping", function () {
          return pe;
        }),
        n.d(t, "CircleBufferGeometry", function () {
          return Xs;
        }),
        n.d(t, "CircleGeometry", function () {
          return Xs;
        }),
        n.d(t, "ClampToEdgeWrapping", function () {
          return we;
        }),
        n.d(t, "Clock", function () {
          return zl;
        }),
        n.d(t, "Color", function () {
          return Hn;
        }),
        n.d(t, "ColorKeyframeTrack", function () {
          return ju;
        }),
        n.d(t, "ColorManagement", function () {
          return zn;
        }),
        n.d(t, "CompressedTexture", function () {
          return Ts;
        }),
        n.d(t, "CompressedTextureLoader", function () {
          return Qu;
        }),
        n.d(t, "ConeBufferGeometry", function () {
          return Ys;
        }),
        n.d(t, "ConeGeometry", function () {
          return Ys;
        }),
        n.d(t, "CubeCamera", function () {
          return pa;
        }),
        n.d(t, "CubeReflectionMapping", function () {
          return ye;
        }),
        n.d(t, "CubeRefractionMapping", function () {
          return be;
        }),
        n.d(t, "CubeTexture", function () {
          return ma;
        }),
        n.d(t, "CubeTextureLoader", function () {
          return el;
        }),
        n.d(t, "CubeUVReflectionMapping", function () {
          return Me;
        }),
        n.d(t, "CubicBezierCurve", function () {
          return Ds;
        }),
        n.d(t, "CubicBezierCurve3", function () {
          return js;
        }),
        n.d(t, "CubicInterpolant", function () {
          return Eu;
        }),
        n.d(t, "CullFaceBack", function () {
          return x;
        }),
        n.d(t, "CullFaceFront", function () {
          return _;
        }),
        n.d(t, "CullFaceFrontBack", function () {
          return M;
        }),
        n.d(t, "CullFaceNone", function () {
          return b;
        }),
        n.d(t, "Curve", function () {
          return Os;
        }),
        n.d(t, "CurvePath", function () {
          return Vs;
        }),
        n.d(t, "CustomBlending", function () {
          return B;
        }),
        n.d(t, "CustomToneMapping", function () {
          return ve;
        }),
        n.d(t, "CylinderBufferGeometry", function () {
          return Js;
        }),
        n.d(t, "CylinderGeometry", function () {
          return Js;
        }),
        n.d(t, "Cylindrical", function () {
          return vc;
        }),
        n.d(t, "Data3DTexture", function () {
          return er;
        }),
        n.d(t, "DataArrayTexture", function () {
          return Qn;
        }),
        n.d(t, "DataTexture", function () {
          return Zo;
        }),
        n.d(t, "DataTexture2DArray", function () {
          return rh;
        }),
        n.d(t, "DataTexture3D", function () {
          return ih;
        }),
        n.d(t, "DataTextureLoader", function () {
          return tl;
        }),
        n.d(t, "DataUtils", function () {
          return $c;
        }),
        n.d(t, "DecrementStencilOp", function () {
          return an;
        }),
        n.d(t, "DecrementWrapStencilOp", function () {
          return sn;
        }),
        n.d(t, "DefaultLoadingManager", function () {
          return qu;
        }),
        n.d(t, "DepthFormat", function () {
          return Qe;
        }),
        n.d(t, "DepthStencilFormat", function () {
          return $e;
        }),
        n.d(t, "DepthTexture", function () {
          return vo;
        }),
        n.d(t, "DirectionalLight", function () {
          return gl;
        }),
        n.d(t, "DirectionalLightHelper", function () {
          return Nc;
        }),
        n.d(t, "DiscreteInterpolant", function () {
          return Ru;
        }),
        n.d(t, "DodecahedronBufferGeometry", function () {
          return Ks;
        }),
        n.d(t, "DodecahedronGeometry", function () {
          return Ks;
        }),
        n.d(t, "DoubleSide", function () {
          return L;
        }),
        n.d(t, "DstAlphaFactor", function () {
          return Y;
        }),
        n.d(t, "DstColorFactor", function () {
          return K;
        }),
        n.d(t, "DynamicCopyUsage", function () {
          return wn;
        }),
        n.d(t, "DynamicDrawUsage", function () {
          return yn;
        }),
        n.d(t, "DynamicReadUsage", function () {
          return _n;
        }),
        n.d(t, "EdgesGeometry", function () {
          return nu;
        }),
        n.d(t, "EllipseCurve", function () {
          return Cs;
        }),
        n.d(t, "EqualDepth", function () {
          return ie;
        }),
        n.d(t, "EqualStencilFunc", function () {
          return hn;
        }),
        n.d(t, "EquirectangularReflectionMapping", function () {
          return xe;
        }),
        n.d(t, "EquirectangularRefractionMapping", function () {
          return _e;
        }),
        n.d(t, "Euler", function () {
          return Wr;
        }),
        n.d(t, "EventDispatcher", function () {
          return Ln;
        }),
        n.d(t, "ExtrudeBufferGeometry", function () {
          return ou;
        }),
        n.d(t, "ExtrudeGeometry", function () {
          return ou;
        }),
        n.d(t, "FileLoader", function () {
          return Zu;
        }),
        n.d(t, "FlatShading", function () {
          return k;
        }),
        n.d(t, "Float16BufferAttribute", function () {
          return ki;
        }),
        n.d(t, "Float32BufferAttribute", function () {
          return Ei;
        }),
        n.d(t, "Float64BufferAttribute", function () {
          return Pi;
        }),
        n.d(t, "FloatType", function () {
          return Ue;
        }),
        n.d(t, "Fog", function () {
          return _o;
        }),
        n.d(t, "FogExp2", function () {
          return xo;
        }),
        n.d(t, "Font", function () {
          return Font;
        }),
        n.d(t, "FontLoader", function () {
          return FontLoader;
        }),
        n.d(t, "FramebufferTexture", function () {
          return ws;
        }),
        n.d(t, "FrontSide", function () {
          return O;
        }),
        n.d(t, "Frustum", function () {
          return Sa;
        }),
        n.d(t, "GLBufferAttribute", function () {
          return fc;
        }),
        n.d(t, "GLSL1", function () {
          return An;
        }),
        n.d(t, "GLSL3", function () {
          return On;
        }),
        n.d(t, "GreaterDepth", function () {
          return oe;
        }),
        n.d(t, "GreaterEqualDepth", function () {
          return ae;
        }),
        n.d(t, "GreaterEqualStencilFunc", function () {
          return mn;
        }),
        n.d(t, "GreaterStencilFunc", function () {
          return fn;
        }),
        n.d(t, "GridHelper", function () {
          return Rc;
        }),
        n.d(t, "Group", function () {
          return fo;
        }),
        n.d(t, "HalfFloatType", function () {
          return Ve;
        }),
        n.d(t, "HemisphereLight", function () {
          return il;
        }),
        n.d(t, "HemisphereLightHelper", function () {
          return Pc;
        }),
        n.d(t, "HemisphereLightProbe", function () {
          return Rl;
        }),
        n.d(t, "IcosahedronBufferGeometry", function () {
          return uu;
        }),
        n.d(t, "IcosahedronGeometry", function () {
          return uu;
        }),
        n.d(t, "ImageBitmapLoader", function () {
          return kl;
        }),
        n.d(t, "ImageLoader", function () {
          return $u;
        }),
        n.d(t, "ImageUtils", function () {
          return qn;
        }),
        n.d(t, "ImmediateRenderObject", function () {
          return ImmediateRenderObject;
        }),
        n.d(t, "IncrementStencilOp", function () {
          return rn;
        }),
        n.d(t, "IncrementWrapStencilOp", function () {
          return on;
        }),
        n.d(t, "InstancedBufferAttribute", function () {
          return es;
        }),
        n.d(t, "InstancedBufferGeometry", function () {
          return wl;
        }),
        n.d(t, "InstancedInterleavedBuffer", function () {
          return dc;
        }),
        n.d(t, "InstancedMesh", function () {
          return as;
        }),
        n.d(t, "Int16BufferAttribute", function () {
          return Ai;
        }),
        n.d(t, "Int32BufferAttribute", function () {
          return Ci;
        }),
        n.d(t, "Int8BufferAttribute", function () {
          return Si;
        }),
        n.d(t, "IntType", function () {
          return Fe;
        }),
        n.d(t, "InterleavedBuffer", function () {
          return So;
        }),
        n.d(t, "InterleavedBufferAttribute", function () {
          return To;
        }),
        n.d(t, "Interpolant", function () {
          return ku;
        }),
        n.d(t, "InterpolateDiscrete", function () {
          return It;
        }),
        n.d(t, "InterpolateLinear", function () {
          return Dt;
        }),
        n.d(t, "InterpolateSmooth", function () {
          return jt;
        }),
        n.d(t, "InvertStencilOp", function () {
          return un;
        }),
        n.d(t, "KeepStencilOp", function () {
          return tn;
        }),
        n.d(t, "KeyframeTrack", function () {
          return Iu;
        }),
        n.d(t, "LOD", function () {
          return Uo;
        }),
        n.d(t, "LatheBufferGeometry", function () {
          return Hs;
        }),
        n.d(t, "LatheGeometry", function () {
          return Hs;
        }),
        n.d(t, "Layers", function () {
          return Hr;
        }),
        n.d(t, "LessDepth", function () {
          return ne;
        }),
        n.d(t, "LessEqualDepth", function () {
          return re;
        }),
        n.d(t, "LessEqualStencilFunc", function () {
          return dn;
        }),
        n.d(t, "LessStencilFunc", function () {
          return cn;
        }),
        n.d(t, "Light", function () {
          return rl;
        }),
        n.d(t, "LightProbe", function () {
          return _l;
        }),
        n.d(t, "Line", function () {
          return ds;
        }),
        n.d(t, "Line3", function () {
          return _c;
        }),
        n.d(t, "LineBasicMaterial", function () {
          return os;
        }),
        n.d(t, "LineCurve", function () {
          return Bs;
        }),
        n.d(t, "LineCurve3", function () {
          return Ns;
        }),
        n.d(t, "LineDashedMaterial", function () {
          return Cu;
        }),
        n.d(t, "LineLoop", function () {
          return vs;
        }),
        n.d(t, "LineSegments", function () {
          return ms;
        }),
        n.d(t, "LinearEncoding", function () {
          return Ht;
        }),
        n.d(t, "LinearFilter", function () {
          return Ee;
        }),
        n.d(t, "LinearInterpolant", function () {
          return Pu;
        }),
        n.d(t, "LinearMipMapLinearFilter", function () {
          return De;
        }),
        n.d(t, "LinearMipMapNearestFilter", function () {
          return Re;
        }),
        n.d(t, "LinearMipmapLinearFilter", function () {
          return Ie;
        }),
        n.d(t, "LinearMipmapNearestFilter", function () {
          return Pe;
        }),
        n.d(t, "LinearSRGBColorSpace", function () {
          return $t;
        }),
        n.d(t, "LinearToneMapping", function () {
          return de;
        }),
        n.d(t, "Loader", function () {
          return Xu;
        }),
        n.d(t, "LoaderUtils", function () {
          return Sl;
        }),
        n.d(t, "LoadingManager", function () {
          return Hu;
        }),
        n.d(t, "LoopOnce", function () {
          return Et;
        }),
        n.d(t, "LoopPingPong", function () {
          return Rt;
        }),
        n.d(t, "LoopRepeat", function () {
          return Pt;
        }),
        n.d(t, "LuminanceAlphaFormat", function () {
          return Ke;
        }),
        n.d(t, "LuminanceFormat", function () {
          return Ze;
        }),
        n.d(t, "MOUSE", function () {
          return g;
        }),
        n.d(t, "Material", function () {
          return yi;
        }),
        n.d(t, "MaterialLoader", function () {
          return Ml;
        }),
        n.d(t, "MathUtils", function () {
          return In;
        }),
        n.d(t, "Matrix3", function () {
          return jn;
        }),
        n.d(t, "Matrix4", function () {
          return Ir;
        }),
        n.d(t, "MaxEquation", function () {
          return U;
        }),
        n.d(t, "Mesh", function () {
          return ia;
        }),
        n.d(t, "MeshBasicMaterial", function () {
          return bi;
        }),
        n.d(t, "MeshDepthMaterial", function () {
          return so;
        }),
        n.d(t, "MeshDistanceMaterial", function () {
          return uo;
        }),
        n.d(t, "MeshLambertMaterial", function () {
          return Au;
        }),
        n.d(t, "MeshMatcapMaterial", function () {
          return Ou;
        }),
        n.d(t, "MeshNormalMaterial", function () {
          return Tu;
        }),
        n.d(t, "MeshPhongMaterial", function () {
          return Su;
        }),
        n.d(t, "MeshPhysicalMaterial", function () {
          return Mu;
        }),
        n.d(t, "MeshStandardMaterial", function () {
          return _u;
        }),
        n.d(t, "MeshToonMaterial", function () {
          return wu;
        }),
        n.d(t, "MinEquation", function () {
          return G;
        }),
        n.d(t, "MirroredRepeatWrapping", function () {
          return Te;
        }),
        n.d(t, "MixOperation", function () {
          return le;
        }),
        n.d(t, "MultiplyBlending", function () {
          return j;
        }),
        n.d(t, "MultiplyOperation", function () {
          return ue;
        }),
        n.d(t, "NearestFilter", function () {
          return Ae;
        }),
        n.d(t, "NearestMipMapLinearFilter", function () {
          return ke;
        }),
        n.d(t, "NearestMipMapNearestFilter", function () {
          return Ce;
        }),
        n.d(t, "NearestMipmapLinearFilter", function () {
          return Le;
        }),
        n.d(t, "NearestMipmapNearestFilter", function () {
          return Oe;
        }),
        n.d(t, "NeverDepth", function () {
          return ee;
        }),
        n.d(t, "NeverStencilFunc", function () {
          return ln;
        }),
        n.d(t, "NoBlending", function () {
          return P;
        }),
        n.d(t, "NoColorSpace", function () {
          return Kt;
        }),
        n.d(t, "NoToneMapping", function () {
          return he;
        }),
        n.d(t, "NormalAnimationBlendMode", function () {
          return Ft;
        }),
        n.d(t, "NormalBlending", function () {
          return R;
        }),
        n.d(t, "NotEqualDepth", function () {
          return se;
        }),
        n.d(t, "NotEqualStencilFunc", function () {
          return pn;
        }),
        n.d(t, "NumberKeyframeTrack", function () {
          return Bu;
        }),
        n.d(t, "Object3D", function () {
          return ai;
        }),
        n.d(t, "ObjectLoader", function () {
          return Al;
        }),
        n.d(t, "ObjectSpaceNormalMap", function () {
          return Zt;
        }),
        n.d(t, "OctahedronBufferGeometry", function () {
          return lu;
        }),
        n.d(t, "OctahedronGeometry", function () {
          return lu;
        }),
        n.d(t, "OneFactor", function () {
          return W;
        }),
        n.d(t, "OneMinusDstAlphaFactor", function () {
          return Z;
        }),
        n.d(t, "OneMinusDstColorFactor", function () {
          return Q;
        }),
        n.d(t, "OneMinusSrcAlphaFactor", function () {
          return J;
        }),
        n.d(t, "OneMinusSrcColorFactor", function () {
          return q;
        }),
        n.d(t, "OrthographicCamera", function () {
          return Ca;
        }),
        n.d(t, "PCFShadowMap", function () {
          return w;
        }),
        n.d(t, "PCFSoftShadowMap", function () {
          return T;
        }),
        n.d(t, "PMREMGenerator", function () {
          return Na;
        }),
        n.d(t, "ParametricGeometry", function () {
          return eh;
        }),
        n.d(t, "Path", function () {
          return Ws;
        }),
        n.d(t, "PerspectiveCamera", function () {
          return ha;
        }),
        n.d(t, "Plane", function () {
          return xa;
        }),
        n.d(t, "PlaneBufferGeometry", function () {
          return wa;
        }),
        n.d(t, "PlaneGeometry", function () {
          return wa;
        }),
        n.d(t, "PlaneHelper", function () {
          return Xc;
        }),
        n.d(t, "PointLight", function () {
          return ml;
        }),
        n.d(t, "PointLightHelper", function () {
          return Cc;
        }),
        n.d(t, "Points", function () {
          return Ms;
        }),
        n.d(t, "PointsMaterial", function () {
          return gs;
        }),
        n.d(t, "PolarGridHelper", function () {
          return Ic;
        }),
        n.d(t, "PolyhedronBufferGeometry", function () {
          return Zs;
        }),
        n.d(t, "PolyhedronGeometry", function () {
          return Zs;
        }),
        n.d(t, "PositionalAudio", function () {
          return Zl;
        }),
        n.d(t, "PropertyBinding", function () {
          return ic;
        }),
        n.d(t, "PropertyMixer", function () {
          return Ql;
        }),
        n.d(t, "QuadraticBezierCurve", function () {
          return zs;
        }),
        n.d(t, "QuadraticBezierCurve3", function () {
          return Fs;
        }),
        n.d(t, "Quaternion", function () {
          return rr;
        }),
        n.d(t, "QuaternionKeyframeTrack", function () {
          return zu;
        }),
        n.d(t, "QuaternionLinearInterpolant", function () {
          return Nu;
        }),
        n.d(t, "REVISION", function () {
          return m;
        }),
        n.d(t, "RGBADepthPacking", function () {
          return Jt;
        }),
        n.d(t, "RGBAFormat", function () {
          return Ye;
        }),
        n.d(t, "RGBAIntegerFormat", function () {
          return it;
        }),
        n.d(t, "RGBA_ASTC_10x10_Format", function () {
          return Ot;
        }),
        n.d(t, "RGBA_ASTC_10x5_Format", function () {
          return wt;
        }),
        n.d(t, "RGBA_ASTC_10x6_Format", function () {
          return Tt;
        }),
        n.d(t, "RGBA_ASTC_10x8_Format", function () {
          return At;
        }),
        n.d(t, "RGBA_ASTC_12x10_Format", function () {
          return Ct;
        }),
        n.d(t, "RGBA_ASTC_12x12_Format", function () {
          return Lt;
        }),
        n.d(t, "RGBA_ASTC_4x4_Format", function () {
          return vt;
        }),
        n.d(t, "RGBA_ASTC_5x4_Format", function () {
          return gt;
        }),
        n.d(t, "RGBA_ASTC_5x5_Format", function () {
          return yt;
        }),
        n.d(t, "RGBA_ASTC_6x5_Format", function () {
          return bt;
        }),
        n.d(t, "RGBA_ASTC_6x6_Format", function () {
          return xt;
        }),
        n.d(t, "RGBA_ASTC_8x5_Format", function () {
          return _t;
        }),
        n.d(t, "RGBA_ASTC_8x6_Format", function () {
          return Mt;
        }),
        n.d(t, "RGBA_ASTC_8x8_Format", function () {
          return St;
        }),
        n.d(t, "RGBA_BPTC_Format", function () {
          return kt;
        }),
        n.d(t, "RGBA_ETC2_EAC_Format", function () {
          return mt;
        }),
        n.d(t, "RGBA_PVRTC_2BPPV1_Format", function () {
          return dt;
        }),
        n.d(t, "RGBA_PVRTC_4BPPV1_Format", function () {
          return ht;
        }),
        n.d(t, "RGBA_S3TC_DXT1_Format", function () {
          return ot;
        }),
        n.d(t, "RGBA_S3TC_DXT3_Format", function () {
          return st;
        }),
        n.d(t, "RGBA_S3TC_DXT5_Format", function () {
          return ut;
        }),
        n.d(t, "RGBFormat", function () {
          return Je;
        }),
        n.d(t, "RGB_ETC1_Format", function () {
          return ft;
        }),
        n.d(t, "RGB_ETC2_Format", function () {
          return pt;
        }),
        n.d(t, "RGB_PVRTC_2BPPV1_Format", function () {
          return ct;
        }),
        n.d(t, "RGB_PVRTC_4BPPV1_Format", function () {
          return lt;
        }),
        n.d(t, "RGB_S3TC_DXT1_Format", function () {
          return at;
        }),
        n.d(t, "RGFormat", function () {
          return nt;
        }),
        n.d(t, "RGIntegerFormat", function () {
          return rt;
        }),
        n.d(t, "RawShaderMaterial", function () {
          return xu;
        }),
        n.d(t, "Ray", function () {
          return Rr;
        }),
        n.d(t, "Raycaster", function () {
          return pc;
        }),
        n.d(t, "RectAreaLight", function () {
          return bl;
        }),
        n.d(t, "RedFormat", function () {
          return et;
        }),
        n.d(t, "RedIntegerFormat", function () {
          return tt;
        }),
        n.d(t, "ReinhardToneMapping", function () {
          return fe;
        }),
        n.d(t, "RepeatWrapping", function () {
          return Se;
        }),
        n.d(t, "ReplaceStencilOp", function () {
          return nn;
        }),
        n.d(t, "ReverseSubtractEquation", function () {
          return F;
        }),
        n.d(t, "RingBufferGeometry", function () {
          return cu;
        }),
        n.d(t, "RingGeometry", function () {
          return cu;
        }),
        n.d(t, "SRGBColorSpace", function () {
          return Qt;
        }),
        n.d(t, "Scene", function () {
          return Mo;
        }),
        n.d(t, "ShaderChunk", function () {
          return Ta;
        }),
        n.d(t, "ShaderLib", function () {
          return Oa;
        }),
        n.d(t, "ShaderMaterial", function () {
          return la;
        }),
        n.d(t, "ShadowMaterial", function () {
          return bu;
        }),
        n.d(t, "Shape", function () {
          return ru;
        }),
        n.d(t, "ShapeBufferGeometry", function () {
          return hu;
        }),
        n.d(t, "ShapeGeometry", function () {
          return hu;
        }),
        n.d(t, "ShapePath", function () {
          return Kc;
        }),
        n.d(t, "ShapeUtils", function () {
          return au;
        }),
        n.d(t, "ShortType", function () {
          return Ne;
        }),
        n.d(t, "Skeleton", function () {
          return $o;
        }),
        n.d(t, "SkeletonHelper", function () {
          return Oc;
        }),
        n.d(t, "SkinnedMesh", function () {
          return Jo;
        }),
        n.d(t, "SmoothShading", function () {
          return E;
        }),
        n.d(t, "Source", function () {
          return Xn;
        }),
        n.d(t, "Sphere", function () {
          return Tr;
        }),
        n.d(t, "SphereBufferGeometry", function () {
          return du;
        }),
        n.d(t, "SphereGeometry", function () {
          return du;
        }),
        n.d(t, "Spherical", function () {
          return mc;
        }),
        n.d(t, "SphericalHarmonics3", function () {
          return xl;
        }),
        n.d(t, "SplineCurve", function () {
          return Gs;
        }),
        n.d(t, "SpotLight", function () {
          return cl;
        }),
        n.d(t, "SpotLightHelper", function () {
          return Sc;
        }),
        n.d(t, "Sprite", function () {
          return zo;
        }),
        n.d(t, "SpriteMaterial", function () {
          return Ao;
        }),
        n.d(t, "SrcAlphaFactor", function () {
          return X;
        }),
        n.d(t, "SrcAlphaSaturateFactor", function () {
          return $;
        }),
        n.d(t, "SrcColorFactor", function () {
          return H;
        }),
        n.d(t, "StaticCopyUsage", function () {
          return Sn;
        }),
        n.d(t, "StaticDrawUsage", function () {
          return gn;
        }),
        n.d(t, "StaticReadUsage", function () {
          return xn;
        }),
        n.d(t, "StereoCamera", function () {
          return Nl;
        }),
        n.d(t, "StreamCopyUsage", function () {
          return Tn;
        }),
        n.d(t, "StreamDrawUsage", function () {
          return bn;
        }),
        n.d(t, "StreamReadUsage", function () {
          return Mn;
        }),
        n.d(t, "StringKeyframeTrack", function () {
          return Fu;
        }),
        n.d(t, "SubtractEquation", function () {
          return z;
        }),
        n.d(t, "SubtractiveBlending", function () {
          return D;
        }),
        n.d(t, "TOUCH", function () {
          return y;
        }),
        n.d(t, "TangentSpaceNormalMap", function () {
          return Yt;
        }),
        n.d(t, "TetrahedronBufferGeometry", function () {
          return fu;
        }),
        n.d(t, "TetrahedronGeometry", function () {
          return fu;
        }),
        n.d(t, "TextGeometry", function () {
          return th;
        }),
        n.d(t, "Texture", function () {
          return Yn;
        }),
        n.d(t, "TextureLoader", function () {
          return nl;
        }),
        n.d(t, "TorusBufferGeometry", function () {
          return pu;
        }),
        n.d(t, "TorusGeometry", function () {
          return pu;
        }),
        n.d(t, "TorusKnotBufferGeometry", function () {
          return mu;
        }),
        n.d(t, "TorusKnotGeometry", function () {
          return mu;
        }),
        n.d(t, "Triangle", function () {
          return vi;
        }),
        n.d(t, "TriangleFanDrawMode", function () {
          return Wt;
        }),
        n.d(t, "TriangleStripDrawMode", function () {
          return Vt;
        }),
        n.d(t, "TrianglesDrawMode", function () {
          return Ut;
        }),
        n.d(t, "TubeBufferGeometry", function () {
          return vu;
        }),
        n.d(t, "TubeGeometry", function () {
          return vu;
        }),
        n.d(t, "UVMapping", function () {
          return ge;
        }),
        n.d(t, "Uint16BufferAttribute", function () {
          return Oi;
        }),
        n.d(t, "Uint32BufferAttribute", function () {
          return Li;
        }),
        n.d(t, "Uint8BufferAttribute", function () {
          return wi;
        }),
        n.d(t, "Uint8ClampedBufferAttribute", function () {
          return Ti;
        }),
        n.d(t, "Uniform", function () {
          return lc;
        }),
        n.d(t, "UniformsGroup", function () {
          return hc;
        }),
        n.d(t, "UniformsLib", function () {
          return Aa;
        }),
        n.d(t, "UniformsUtils", function () {
          return oa;
        }),
        n.d(t, "UnsignedByteType", function () {
          return je;
        }),
        n.d(t, "UnsignedInt248Type", function () {
          return qe;
        }),
        n.d(t, "UnsignedIntType", function () {
          return Ge;
        }),
        n.d(t, "UnsignedShort4444Type", function () {
          return We;
        }),
        n.d(t, "UnsignedShort5551Type", function () {
          return He;
        }),
        n.d(t, "UnsignedShortType", function () {
          return ze;
        }),
        n.d(t, "VSMShadowMap", function () {
          return A;
        }),
        n.d(t, "Vector2", function () {
          return Dn;
        }),
        n.d(t, "Vector3", function () {
          return ir;
        }),
        n.d(t, "Vector4", function () {
          return Zn;
        }),
        n.d(t, "VectorKeyframeTrack", function () {
          return Gu;
        }),
        n.d(t, "VideoTexture", function () {
          return Ss;
        }),
        n.d(t, "WebGL1Renderer", function () {
          return yo;
        }),
        n.d(t, "WebGL3DRenderTarget", function () {
          return tr;
        }),
        n.d(t, "WebGLArrayRenderTarget", function () {
          return $n;
        }),
        n.d(t, "WebGLCubeRenderTarget", function () {
          return va;
        }),
        n.d(t, "WebGLMultipleRenderTargets", function () {
          return nr;
        }),
        n.d(t, "WebGLMultisampleRenderTarget", function () {
          return nh;
        }),
        n.d(t, "WebGLRenderTarget", function () {
          return Kn;
        }),
        n.d(t, "WebGLRenderer", function () {
          return WebGLRenderer;
        }),
        n.d(t, "WebGLUtils", function () {
          return WebGLUtils;
        }),
        n.d(t, "WireframeGeometry", function () {
          return gu;
        }),
        n.d(t, "WrapAroundEnding", function () {
          return zt;
        }),
        n.d(t, "ZeroCurvatureEnding", function () {
          return Bt;
        }),
        n.d(t, "ZeroFactor", function () {
          return V;
        }),
        n.d(t, "ZeroSlopeEnding", function () {
          return Nt;
        }),
        n.d(t, "ZeroStencilOp", function () {
          return en;
        }),
        n.d(t, "_SRGBAFormat", function () {
          return Cn;
        }),
        n.d(t, "sRGBEncoding", function () {
          return qt;
        });
      var m = "143",
        g = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        y = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        b = 0,
        x = 1,
        _ = 2,
        M = 3,
        S = 0,
        w = 1,
        T = 2,
        A = 3,
        O = 0,
        C = 1,
        L = 2,
        k = 1,
        E = 2,
        P = 0,
        R = 1,
        I = 2,
        D = 3,
        j = 4,
        B = 5,
        N = 100,
        z = 101,
        F = 102,
        G = 103,
        U = 104,
        V = 200,
        W = 201,
        H = 202,
        q = 203,
        X = 204,
        J = 205,
        Y = 206,
        Z = 207,
        K = 208,
        Q = 209,
        $ = 210,
        ee = 0,
        te = 1,
        ne = 2,
        re = 3,
        ie = 4,
        ae = 5,
        oe = 6,
        se = 7,
        ue = 0,
        le = 1,
        ce = 2,
        he = 0,
        de = 1,
        fe = 2,
        pe = 3,
        me = 4,
        ve = 5,
        ge = 300,
        ye = 301,
        be = 302,
        xe = 303,
        _e = 304,
        Me = 306,
        Se = 1e3,
        we = 1001,
        Te = 1002,
        Ae = 1003,
        Oe = 1004,
        Ce = 1004,
        Le = 1005,
        ke = 1005,
        Ee = 1006,
        Pe = 1007,
        Re = 1007,
        Ie = 1008,
        De = 1008,
        je = 1009,
        Be = 1010,
        Ne = 1011,
        ze = 1012,
        Fe = 1013,
        Ge = 1014,
        Ue = 1015,
        Ve = 1016,
        We = 1017,
        He = 1018,
        qe = 1020,
        Xe = 1021,
        Je = 1022,
        Ye = 1023,
        Ze = 1024,
        Ke = 1025,
        Qe = 1026,
        $e = 1027,
        et = 1028,
        tt = 1029,
        nt = 1030,
        rt = 1031,
        it = 1033,
        at = 33776,
        ot = 33777,
        st = 33778,
        ut = 33779,
        lt = 35840,
        ct = 35841,
        ht = 35842,
        dt = 35843,
        ft = 36196,
        pt = 37492,
        mt = 37496,
        vt = 37808,
        gt = 37809,
        yt = 37810,
        bt = 37811,
        xt = 37812,
        _t = 37813,
        Mt = 37814,
        St = 37815,
        wt = 37816,
        Tt = 37817,
        At = 37818,
        Ot = 37819,
        Ct = 37820,
        Lt = 37821,
        kt = 36492,
        Et = 2200,
        Pt = 2201,
        Rt = 2202,
        It = 2300,
        Dt = 2301,
        jt = 2302,
        Bt = 2400,
        Nt = 2401,
        zt = 2402,
        Ft = 2500,
        Gt = 2501,
        Ut = 0,
        Vt = 1,
        Wt = 2,
        Ht = 3e3,
        qt = 3001,
        Xt = 3200,
        Jt = 3201,
        Yt = 0,
        Zt = 1,
        Kt = "",
        Qt = "srgb",
        $t = "srgb-linear",
        en = 0,
        tn = 7680,
        nn = 7681,
        rn = 7682,
        an = 7683,
        on = 34055,
        sn = 34056,
        un = 5386,
        ln = 512,
        cn = 513,
        hn = 514,
        dn = 515,
        fn = 516,
        pn = 517,
        mn = 518,
        vn = 519,
        gn = 35044,
        yn = 35048,
        bn = 35040,
        xn = 35045,
        _n = 35049,
        Mn = 35041,
        Sn = 35046,
        wn = 35050,
        Tn = 35042,
        An = "100",
        On = "300 es",
        Cn = 1035,
        Ln = (function () {
          function EventDispatcher() {
            Object(f.a)(this, EventDispatcher);
          }
          return (
            Object(p.a)(EventDispatcher, [
              {
                key: "addEventListener",
                value: function addEventListener(e, t) {
                  void 0 === this._listeners && (this._listeners = {});
                  var n = this._listeners;
                  void 0 === n[e] && (n[e] = []),
                    -1 === n[e].indexOf(t) && n[e].push(t);
                },
              },
              {
                key: "hasEventListener",
                value: function hasEventListener(e, t) {
                  if (void 0 === this._listeners) return !1;
                  var n = this._listeners;
                  return void 0 !== n[e] && -1 !== n[e].indexOf(t);
                },
              },
              {
                key: "removeEventListener",
                value: function removeEventListener(e, t) {
                  if (void 0 !== this._listeners) {
                    var n = this._listeners[e];
                    if (void 0 !== n) {
                      var r = n.indexOf(t);
                      -1 !== r && n.splice(r, 1);
                    }
                  }
                },
              },
              {
                key: "dispatchEvent",
                value: function dispatchEvent(e) {
                  if (void 0 !== this._listeners) {
                    var t = this._listeners[e.type];
                    if (void 0 !== t) {
                      e.target = this;
                      for (var n = t.slice(0), r = 0, i = n.length; r < i; r++)
                        n[r].call(this, e);
                      e.target = null;
                    }
                  }
                },
              },
            ]),
            EventDispatcher
          );
        })(),
        kn = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        En = 1234567,
        Pn = Math.PI / 180,
        Rn = 180 / Math.PI;
      function generateUUID() {
        var e = (4294967295 * Math.random()) | 0,
          t = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          r = (4294967295 * Math.random()) | 0;
        return (
          kn[255 & e] +
          kn[(e >> 8) & 255] +
          kn[(e >> 16) & 255] +
          kn[(e >> 24) & 255] +
          "-" +
          kn[255 & t] +
          kn[(t >> 8) & 255] +
          "-" +
          kn[((t >> 16) & 15) | 64] +
          kn[(t >> 24) & 255] +
          "-" +
          kn[(63 & n) | 128] +
          kn[(n >> 8) & 255] +
          "-" +
          kn[(n >> 16) & 255] +
          kn[(n >> 24) & 255] +
          kn[255 & r] +
          kn[(r >> 8) & 255] +
          kn[(r >> 16) & 255] +
          kn[(r >> 24) & 255]
        ).toLowerCase();
      }
      function clamp(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
      function euclideanModulo(e, t) {
        return ((e % t) + t) % t;
      }
      function lerp(e, t, n) {
        return (1 - n) * e + n * t;
      }
      function isPowerOfTwo(e) {
        return 0 === (e & (e - 1)) && 0 !== e;
      }
      function ceilPowerOfTwo(e) {
        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
      }
      function floorPowerOfTwo(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
      }
      var In = Object.freeze({
          __proto__: null,
          DEG2RAD: Pn,
          RAD2DEG: Rn,
          generateUUID: generateUUID,
          clamp: clamp,
          euclideanModulo: euclideanModulo,
          mapLinear: function mapLinear(e, t, n, r, i) {
            return r + ((e - t) * (i - r)) / (n - t);
          },
          inverseLerp: function inverseLerp(e, t, n) {
            return e !== t ? (n - e) / (t - e) : 0;
          },
          lerp: lerp,
          damp: function damp(e, t, n, r) {
            return lerp(e, t, 1 - Math.exp(-n * r));
          },
          pingpong: function pingpong(e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 1;
            return t - Math.abs(euclideanModulo(e, 2 * t) - t);
          },
          smoothstep: function smoothstep(e, t, n) {
            return e <= t
              ? 0
              : e >= n
              ? 1
              : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
          },
          smootherstep: function smootherstep(e, t, n) {
            return e <= t
              ? 0
              : e >= n
              ? 1
              : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
          },
          randInt: function randInt(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1));
          },
          randFloat: function randFloat(e, t) {
            return e + Math.random() * (t - e);
          },
          randFloatSpread: function randFloatSpread(e) {
            return e * (0.5 - Math.random());
          },
          seededRandom: function seededRandom(e) {
            void 0 !== e && (En = e);
            var t = (En += 1831565813);
            return (
              (t = Math.imul(t ^ (t >>> 15), 1 | t)),
              (((t ^= t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ (t >>> 14)) >>>
                0) /
                4294967296
            );
          },
          degToRad: function degToRad(e) {
            return e * Pn;
          },
          radToDeg: function radToDeg(e) {
            return e * Rn;
          },
          isPowerOfTwo: isPowerOfTwo,
          ceilPowerOfTwo: ceilPowerOfTwo,
          floorPowerOfTwo: floorPowerOfTwo,
          setQuaternionFromProperEuler: function setQuaternionFromProperEuler(
            e,
            t,
            n,
            r,
            i
          ) {
            var a = Math.cos,
              o = Math.sin,
              s = a(n / 2),
              u = o(n / 2),
              l = a((t + r) / 2),
              c = o((t + r) / 2),
              h = a((t - r) / 2),
              d = o((t - r) / 2),
              f = a((r - t) / 2),
              p = o((r - t) / 2);
            switch (i) {
              case "XYX":
                e.set(s * c, u * h, u * d, s * l);
                break;
              case "YZY":
                e.set(u * d, s * c, u * h, s * l);
                break;
              case "ZXZ":
                e.set(u * h, u * d, s * c, s * l);
                break;
              case "XZX":
                e.set(s * c, u * p, u * f, s * l);
                break;
              case "YXY":
                e.set(u * f, s * c, u * p, s * l);
                break;
              case "ZYZ":
                e.set(u * p, u * f, s * c, s * l);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    i
                );
            }
          },
          normalize: function normalize(e, t) {
            switch (t.constructor) {
              case Float32Array:
                return e;
              case Uint16Array:
                return Math.round(65535 * e);
              case Uint8Array:
                return Math.round(255 * e);
              case Int16Array:
                return Math.round(32767 * e);
              case Int8Array:
                return Math.round(127 * e);
              default:
                throw new Error("Invalid component type.");
            }
          },
          denormalize: function denormalize$1(e, t) {
            switch (t.constructor) {
              case Float32Array:
                return e;
              case Uint16Array:
                return e / 65535;
              case Uint8Array:
                return e / 255;
              case Int16Array:
                return Math.max(e / 32767, -1);
              case Int8Array:
                return Math.max(e / 127, -1);
              default:
                throw new Error("Invalid component type.");
            }
          },
        }),
        Dn = (function () {
          function Vector2() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            Object(f.a)(this, Vector2),
              (Vector2.prototype.isVector2 = !0),
              (this.x = e),
              (this.y = t);
          }
          return (
            Object(p.a)(Vector2, [
              {
                key: "set",
                value: function set(e, t) {
                  return (this.x = e), (this.y = t), this;
                },
              },
              {
                key: "setScalar",
                value: function setScalar(e) {
                  return (this.x = e), (this.y = e), this;
                },
              },
              {
                key: "setX",
                value: function setX(e) {
                  return (this.x = e), this;
                },
              },
              {
                key: "setY",
                value: function setY(e) {
                  return (this.y = e), this;
                },
              },
              {
                key: "setComponent",
                value: function setComponent(e, t) {
                  switch (e) {
                    case 0:
                      this.x = t;
                      break;
                    case 1:
                      this.y = t;
                      break;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                  return this;
                },
              },
              {
                key: "getComponent",
                value: function getComponent(e) {
                  switch (e) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(this.x, this.y);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (this.x = e.x), (this.y = e.y), this;
                },
              },
              {
                key: "add",
                value: function add(e) {
                  return (this.x += e.x), (this.y += e.y), this;
                },
              },
              {
                key: "addScalar",
                value: function addScalar(e) {
                  return (this.x += e), (this.y += e), this;
                },
              },
              {
                key: "addVectors",
                value: function addVectors(e, t) {
                  return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
                },
              },
              {
                key: "addScaledVector",
                value: function addScaledVector(e, t) {
                  return (this.x += e.x * t), (this.y += e.y * t), this;
                },
              },
              {
                key: "sub",
                value: function sub(e) {
                  return (this.x -= e.x), (this.y -= e.y), this;
                },
              },
              {
                key: "subScalar",
                value: function subScalar(e) {
                  return (this.x -= e), (this.y -= e), this;
                },
              },
              {
                key: "subVectors",
                value: function subVectors(e, t) {
                  return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
                },
              },
              {
                key: "multiply",
                value: function multiply(e) {
                  return (this.x *= e.x), (this.y *= e.y), this;
                },
              },
              {
                key: "multiplyScalar",
                value: function multiplyScalar(e) {
                  return (this.x *= e), (this.y *= e), this;
                },
              },
              {
                key: "divide",
                value: function divide(e) {
                  return (this.x /= e.x), (this.y /= e.y), this;
                },
              },
              {
                key: "divideScalar",
                value: function divideScalar(e) {
                  return this.multiplyScalar(1 / e);
                },
              },
              {
                key: "applyMatrix3",
                value: function applyMatrix3(e) {
                  var t = this.x,
                    n = this.y,
                    r = e.elements;
                  return (
                    (this.x = r[0] * t + r[3] * n + r[6]),
                    (this.y = r[1] * t + r[4] * n + r[7]),
                    this
                  );
                },
              },
              {
                key: "min",
                value: function min(e) {
                  return (
                    (this.x = Math.min(this.x, e.x)),
                    (this.y = Math.min(this.y, e.y)),
                    this
                  );
                },
              },
              {
                key: "max",
                value: function max(e) {
                  return (
                    (this.x = Math.max(this.x, e.x)),
                    (this.y = Math.max(this.y, e.y)),
                    this
                  );
                },
              },
              {
                key: "clamp",
                value: function clamp(e, t) {
                  return (
                    (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                    (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                    this
                  );
                },
              },
              {
                key: "clampScalar",
                value: function clampScalar(e, t) {
                  return (
                    (this.x = Math.max(e, Math.min(t, this.x))),
                    (this.y = Math.max(e, Math.min(t, this.y))),
                    this
                  );
                },
              },
              {
                key: "clampLength",
                value: function clampLength(e, t) {
                  var n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(e, Math.min(t, n))
                  );
                },
              },
              {
                key: "floor",
                value: function floor() {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    this
                  );
                },
              },
              {
                key: "ceil",
                value: function ceil() {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    this
                  );
                },
              },
              {
                key: "round",
                value: function round() {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    this
                  );
                },
              },
              {
                key: "roundToZero",
                value: function roundToZero() {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    this
                  );
                },
              },
              {
                key: "negate",
                value: function negate() {
                  return (this.x = -this.x), (this.y = -this.y), this;
                },
              },
              {
                key: "dot",
                value: function dot(e) {
                  return this.x * e.x + this.y * e.y;
                },
              },
              {
                key: "cross",
                value: function cross(e) {
                  return this.x * e.y - this.y * e.x;
                },
              },
              {
                key: "lengthSq",
                value: function lengthSq() {
                  return this.x * this.x + this.y * this.y;
                },
              },
              {
                key: "length",
                value: function length() {
                  return Math.sqrt(this.x * this.x + this.y * this.y);
                },
              },
              {
                key: "manhattanLength",
                value: function manhattanLength() {
                  return Math.abs(this.x) + Math.abs(this.y);
                },
              },
              {
                key: "normalize",
                value: function normalize() {
                  return this.divideScalar(this.length() || 1);
                },
              },
              {
                key: "angle",
                value: function angle() {
                  var angle = Math.atan2(-this.y, -this.x) + Math.PI;
                  return angle;
                },
              },
              {
                key: "distanceTo",
                value: function distanceTo(e) {
                  return Math.sqrt(this.distanceToSquared(e));
                },
              },
              {
                key: "distanceToSquared",
                value: function distanceToSquared(e) {
                  var t = this.x - e.x,
                    n = this.y - e.y;
                  return t * t + n * n;
                },
              },
              {
                key: "manhattanDistanceTo",
                value: function manhattanDistanceTo(e) {
                  return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
                },
              },
              {
                key: "setLength",
                value: function setLength(e) {
                  return this.normalize().multiplyScalar(e);
                },
              },
              {
                key: "lerp",
                value: function lerp(e, t) {
                  return (
                    (this.x += (e.x - this.x) * t),
                    (this.y += (e.y - this.y) * t),
                    this
                  );
                },
              },
              {
                key: "lerpVectors",
                value: function lerpVectors(e, t, n) {
                  return (
                    (this.x = e.x + (t.x - e.x) * n),
                    (this.y = e.y + (t.y - e.y) * n),
                    this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return e.x === this.x && e.y === this.y;
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return (this.x = e[t]), (this.y = e[t + 1]), this;
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                  return (e[t] = this.x), (e[t + 1] = this.y), e;
                },
              },
              {
                key: "fromBufferAttribute",
                value: function fromBufferAttribute(e, t) {
                  return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
                },
              },
              {
                key: "rotateAround",
                value: function rotateAround(e, t) {
                  var n = Math.cos(t),
                    r = Math.sin(t),
                    i = this.x - e.x,
                    a = this.y - e.y;
                  return (
                    (this.x = i * n - a * r + e.x),
                    (this.y = i * r + a * n + e.y),
                    this
                  );
                },
              },
              {
                key: "random",
                value: function random() {
                  return (
                    (this.x = Math.random()), (this.y = Math.random()), this
                  );
                },
              },
              {
                key: Symbol.iterator,
                value: d.a.mark(function value() {
                  return d.a.wrap(
                    function value$(e) {
                      for (;;)
                        switch ((e.prev = e.next)) {
                          case 0:
                            return (e.next = 2), this.x;
                          case 2:
                            return (e.next = 4), this.y;
                          case 4:
                          case "end":
                            return e.stop();
                        }
                    },
                    value,
                    this
                  );
                }),
              },
              {
                key: "width",
                get: function get() {
                  return this.x;
                },
                set: function set(e) {
                  this.x = e;
                },
              },
              {
                key: "height",
                get: function get() {
                  return this.y;
                },
                set: function set(e) {
                  this.y = e;
                },
              },
            ]),
            Vector2
          );
        })(),
        jn = (function () {
          function Matrix3() {
            Object(f.a)(this, Matrix3),
              (Matrix3.prototype.isMatrix3 = !0),
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
          }
          return (
            Object(p.a)(Matrix3, [
              {
                key: "set",
                value: function set(e, t, n, r, i, a, o, s, u) {
                  var l = this.elements;
                  return (
                    (l[0] = e),
                    (l[1] = r),
                    (l[2] = o),
                    (l[3] = t),
                    (l[4] = i),
                    (l[5] = s),
                    (l[6] = n),
                    (l[7] = a),
                    (l[8] = u),
                    this
                  );
                },
              },
              {
                key: "identity",
                value: function identity() {
                  return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  var t = this.elements,
                    n = e.elements;
                  return (
                    (t[0] = n[0]),
                    (t[1] = n[1]),
                    (t[2] = n[2]),
                    (t[3] = n[3]),
                    (t[4] = n[4]),
                    (t[5] = n[5]),
                    (t[6] = n[6]),
                    (t[7] = n[7]),
                    (t[8] = n[8]),
                    this
                  );
                },
              },
              {
                key: "extractBasis",
                value: function extractBasis(e, t, n) {
                  return (
                    e.setFromMatrix3Column(this, 0),
                    t.setFromMatrix3Column(this, 1),
                    n.setFromMatrix3Column(this, 2),
                    this
                  );
                },
              },
              {
                key: "setFromMatrix4",
                value: function setFromMatrix4(e) {
                  var t = e.elements;
                  return (
                    this.set(
                      t[0],
                      t[4],
                      t[8],
                      t[1],
                      t[5],
                      t[9],
                      t[2],
                      t[6],
                      t[10]
                    ),
                    this
                  );
                },
              },
              {
                key: "multiply",
                value: function multiply(e) {
                  return this.multiplyMatrices(this, e);
                },
              },
              {
                key: "premultiply",
                value: function premultiply(e) {
                  return this.multiplyMatrices(e, this);
                },
              },
              {
                key: "multiplyMatrices",
                value: function multiplyMatrices(e, t) {
                  var n = e.elements,
                    r = t.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[3],
                    s = n[6],
                    u = n[1],
                    l = n[4],
                    c = n[7],
                    h = n[2],
                    d = n[5],
                    f = n[8],
                    p = r[0],
                    m = r[3],
                    v = r[6],
                    g = r[1],
                    y = r[4],
                    b = r[7],
                    x = r[2],
                    _ = r[5],
                    M = r[8];
                  return (
                    (i[0] = a * p + o * g + s * x),
                    (i[3] = a * m + o * y + s * _),
                    (i[6] = a * v + o * b + s * M),
                    (i[1] = u * p + l * g + c * x),
                    (i[4] = u * m + l * y + c * _),
                    (i[7] = u * v + l * b + c * M),
                    (i[2] = h * p + d * g + f * x),
                    (i[5] = h * m + d * y + f * _),
                    (i[8] = h * v + d * b + f * M),
                    this
                  );
                },
              },
              {
                key: "multiplyScalar",
                value: function multiplyScalar(e) {
                  var t = this.elements;
                  return (
                    (t[0] *= e),
                    (t[3] *= e),
                    (t[6] *= e),
                    (t[1] *= e),
                    (t[4] *= e),
                    (t[7] *= e),
                    (t[2] *= e),
                    (t[5] *= e),
                    (t[8] *= e),
                    this
                  );
                },
              },
              {
                key: "determinant",
                value: function determinant() {
                  var e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    a = e[4],
                    o = e[5],
                    s = e[6],
                    u = e[7],
                    l = e[8];
                  return (
                    t * a * l -
                    t * o * u -
                    n * i * l +
                    n * o * s +
                    r * i * u -
                    r * a * s
                  );
                },
              },
              {
                key: "invert",
                value: function invert() {
                  var e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    a = e[4],
                    o = e[5],
                    s = e[6],
                    u = e[7],
                    l = e[8],
                    c = l * a - o * u,
                    h = o * s - l * i,
                    d = u * i - a * s,
                    f = t * c + n * h + r * d;
                  if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                  var p = 1 / f;
                  return (
                    (e[0] = c * p),
                    (e[1] = (r * u - l * n) * p),
                    (e[2] = (o * n - r * a) * p),
                    (e[3] = h * p),
                    (e[4] = (l * t - r * s) * p),
                    (e[5] = (r * i - o * t) * p),
                    (e[6] = d * p),
                    (e[7] = (n * s - u * t) * p),
                    (e[8] = (a * t - n * i) * p),
                    this
                  );
                },
              },
              {
                key: "transpose",
                value: function transpose() {
                  var e,
                    t = this.elements;
                  return (
                    (e = t[1]),
                    (t[1] = t[3]),
                    (t[3] = e),
                    (e = t[2]),
                    (t[2] = t[6]),
                    (t[6] = e),
                    (e = t[5]),
                    (t[5] = t[7]),
                    (t[7] = e),
                    this
                  );
                },
              },
              {
                key: "getNormalMatrix",
                value: function getNormalMatrix(e) {
                  return this.setFromMatrix4(e).invert().transpose();
                },
              },
              {
                key: "transposeIntoArray",
                value: function transposeIntoArray(e) {
                  var t = this.elements;
                  return (
                    (e[0] = t[0]),
                    (e[1] = t[3]),
                    (e[2] = t[6]),
                    (e[3] = t[1]),
                    (e[4] = t[4]),
                    (e[5] = t[7]),
                    (e[6] = t[2]),
                    (e[7] = t[5]),
                    (e[8] = t[8]),
                    this
                  );
                },
              },
              {
                key: "setUvTransform",
                value: function setUvTransform(e, t, n, r, i, a, o) {
                  var s = Math.cos(i),
                    u = Math.sin(i);
                  return (
                    this.set(
                      n * s,
                      n * u,
                      -n * (s * a + u * o) + a + e,
                      -r * u,
                      r * s,
                      -r * (-u * a + s * o) + o + t,
                      0,
                      0,
                      1
                    ),
                    this
                  );
                },
              },
              {
                key: "scale",
                value: function scale(e, t) {
                  var n = this.elements;
                  return (
                    (n[0] *= e),
                    (n[3] *= e),
                    (n[6] *= e),
                    (n[1] *= t),
                    (n[4] *= t),
                    (n[7] *= t),
                    this
                  );
                },
              },
              {
                key: "rotate",
                value: function rotate(e) {
                  var t = Math.cos(e),
                    n = Math.sin(e),
                    r = this.elements,
                    i = r[0],
                    a = r[3],
                    o = r[6],
                    s = r[1],
                    u = r[4],
                    l = r[7];
                  return (
                    (r[0] = t * i + n * s),
                    (r[3] = t * a + n * u),
                    (r[6] = t * o + n * l),
                    (r[1] = -n * i + t * s),
                    (r[4] = -n * a + t * u),
                    (r[7] = -n * o + t * l),
                    this
                  );
                },
              },
              {
                key: "translate",
                value: function translate(e, t) {
                  var n = this.elements;
                  return (
                    (n[0] += e * n[2]),
                    (n[3] += e * n[5]),
                    (n[6] += e * n[8]),
                    (n[1] += t * n[2]),
                    (n[4] += t * n[5]),
                    (n[7] += t * n[8]),
                    this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                    if (t[r] !== n[r]) return !1;
                  return !0;
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  for (
                    var t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 0,
                      n = 0;
                    n < 9;
                    n++
                  )
                    this.elements[n] = e[n + t];
                  return this;
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0,
                    n = this.elements;
                  return (
                    (e[t] = n[0]),
                    (e[t + 1] = n[1]),
                    (e[t + 2] = n[2]),
                    (e[t + 3] = n[3]),
                    (e[t + 4] = n[4]),
                    (e[t + 5] = n[5]),
                    (e[t + 6] = n[6]),
                    (e[t + 7] = n[7]),
                    (e[t + 8] = n[8]),
                    e
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().fromArray(this.elements);
                },
              },
            ]),
            Matrix3
          );
        })();
      function arrayNeedsUint32(e) {
        for (var t = e.length - 1; t >= 0; --t) if (e[t] > 65535) return !0;
        return !1;
      }
      var Bn = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
      };
      function getTypedArray(e, t) {
        return new Bn[e](t);
      }
      function createElementNS(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function SRGBToLinear(e) {
        return e < 0.04045
          ? 0.0773993808 * e
          : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      function LinearToSRGB(e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      var Nn =
          (_defineProperty((c = {}), Qt, _defineProperty({}, $t, SRGBToLinear)),
          _defineProperty(c, $t, _defineProperty({}, Qt, LinearToSRGB)),
          c),
        zn = {
          legacyMode: !0,
          get workingColorSpace() {
            return $t;
          },
          set workingColorSpace(e) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function convert(e, t, n) {
            if (this.legacyMode || t === n || !t || !n) return e;
            if (Nn[t] && void 0 !== Nn[t][n]) {
              var r = Nn[t][n];
              return (e.r = r(e.r)), (e.g = r(e.g)), (e.b = r(e.b)), e;
            }
            throw new Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function fromWorkingColorSpace(e, t) {
            return this.convert(e, this.workingColorSpace, t);
          },
          toWorkingColorSpace: function toWorkingColorSpace(e, t) {
            return this.convert(e, t, this.workingColorSpace);
          },
        },
        Fn = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Gn = { r: 0, g: 0, b: 0 },
        Un = { h: 0, s: 0, l: 0 },
        Vn = { h: 0, s: 0, l: 0 };
      function hue2rgb(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + 6 * (t - e) * (2 / 3 - n)
            : e
        );
      }
      function toComponents(e, t) {
        return (t.r = e.r), (t.g = e.g), (t.b = e.b), t;
      }
      var Wn,
        Hn = (function () {
          function Color(e, t, n) {
            return (
              Object(f.a)(this, Color),
              (this.isColor = !0),
              (this.r = 1),
              (this.g = 1),
              (this.b = 1),
              void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
            );
          }
          return (
            Object(p.a)(Color, [
              {
                key: "set",
                value: function set(e) {
                  return (
                    e && e.isColor
                      ? this.copy(e)
                      : "number" === typeof e
                      ? this.setHex(e)
                      : "string" === typeof e && this.setStyle(e),
                    this
                  );
                },
              },
              {
                key: "setScalar",
                value: function setScalar(e) {
                  return (this.r = e), (this.g = e), (this.b = e), this;
                },
              },
              {
                key: "setHex",
                value: function setHex(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : Qt;
                  return (
                    (e = Math.floor(e)),
                    (this.r = ((e >> 16) & 255) / 255),
                    (this.g = ((e >> 8) & 255) / 255),
                    (this.b = (255 & e) / 255),
                    zn.toWorkingColorSpace(this, t),
                    this
                  );
                },
              },
              {
                key: "setRGB",
                value: function setRGB(e, t, n) {
                  var r =
                    arguments.length > 3 && void 0 !== arguments[3]
                      ? arguments[3]
                      : $t;
                  return (
                    (this.r = e),
                    (this.g = t),
                    (this.b = n),
                    zn.toWorkingColorSpace(this, r),
                    this
                  );
                },
              },
              {
                key: "setHSL",
                value: function setHSL(e, t, n) {
                  var r =
                    arguments.length > 3 && void 0 !== arguments[3]
                      ? arguments[3]
                      : $t;
                  if (
                    ((e = euclideanModulo(e, 1)),
                    (t = clamp(t, 0, 1)),
                    (n = clamp(n, 0, 1)),
                    0 === t)
                  )
                    this.r = this.g = this.b = n;
                  else {
                    var i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
                      a = 2 * n - i;
                    (this.r = hue2rgb(a, i, e + 1 / 3)),
                      (this.g = hue2rgb(a, i, e)),
                      (this.b = hue2rgb(a, i, e - 1 / 3));
                  }
                  return zn.toWorkingColorSpace(this, r), this;
                },
              },
              {
                key: "setStyle",
                value: function setStyle(e) {
                  var t,
                    n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : Qt;
                  function handleAlpha(t) {
                    void 0 !== t &&
                      parseFloat(t) < 1 &&
                      console.warn(
                        "THREE.Color: Alpha component of " +
                          e +
                          " will be ignored."
                      );
                  }
                  if ((t = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
                    var r,
                      i = t[1],
                      a = t[2];
                    switch (i) {
                      case "rgb":
                      case "rgba":
                        if (
                          (r =
                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                              a
                            ))
                        )
                          return (
                            (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                            (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                            (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                            zn.toWorkingColorSpace(this, n),
                            handleAlpha(r[4]),
                            this
                          );
                        if (
                          (r =
                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                              a
                            ))
                        )
                          return (
                            (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                            (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                            (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                            zn.toWorkingColorSpace(this, n),
                            handleAlpha(r[4]),
                            this
                          );
                        break;
                      case "hsl":
                      case "hsla":
                        if (
                          (r =
                            /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                              a
                            ))
                        ) {
                          var o = parseFloat(r[1]) / 360,
                            s = parseInt(r[2], 10) / 100,
                            u = parseInt(r[3], 10) / 100;
                          return handleAlpha(r[4]), this.setHSL(o, s, u, n);
                        }
                    }
                  } else if ((t = /^\#([A-Fa-f\d]+)$/.exec(e))) {
                    var l = t[1],
                      c = l.length;
                    if (3 === c)
                      return (
                        (this.r =
                          parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
                        (this.g =
                          parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
                        (this.b =
                          parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
                        zn.toWorkingColorSpace(this, n),
                        this
                      );
                    if (6 === c)
                      return (
                        (this.r =
                          parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
                        (this.g =
                          parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
                        (this.b =
                          parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
                        zn.toWorkingColorSpace(this, n),
                        this
                      );
                  }
                  return e && e.length > 0 ? this.setColorName(e, n) : this;
                },
              },
              {
                key: "setColorName",
                value: function setColorName(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : Qt,
                    n = Fn[e.toLowerCase()];
                  return (
                    void 0 !== n
                      ? this.setHex(n, t)
                      : console.warn("THREE.Color: Unknown color " + e),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(this.r, this.g, this.b);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
                },
              },
              {
                key: "copySRGBToLinear",
                value: function copySRGBToLinear(e) {
                  return (
                    (this.r = SRGBToLinear(e.r)),
                    (this.g = SRGBToLinear(e.g)),
                    (this.b = SRGBToLinear(e.b)),
                    this
                  );
                },
              },
              {
                key: "copyLinearToSRGB",
                value: function copyLinearToSRGB(e) {
                  return (
                    (this.r = LinearToSRGB(e.r)),
                    (this.g = LinearToSRGB(e.g)),
                    (this.b = LinearToSRGB(e.b)),
                    this
                  );
                },
              },
              {
                key: "convertSRGBToLinear",
                value: function convertSRGBToLinear() {
                  return this.copySRGBToLinear(this), this;
                },
              },
              {
                key: "convertLinearToSRGB",
                value: function convertLinearToSRGB() {
                  return this.copyLinearToSRGB(this), this;
                },
              },
              {
                key: "getHex",
                value: function getHex() {
                  var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : Qt;
                  return (
                    zn.fromWorkingColorSpace(toComponents(this, Gn), e),
                    (clamp(255 * Gn.r, 0, 255) << 16) ^
                      (clamp(255 * Gn.g, 0, 255) << 8) ^
                      (clamp(255 * Gn.b, 0, 255) << 0)
                  );
                },
              },
              {
                key: "getHexString",
                value: function getHexString() {
                  var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : Qt;
                  return ("000000" + this.getHex(e).toString(16)).slice(-6);
                },
              },
              {
                key: "getHSL",
                value: function getHSL(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : $t;
                  zn.fromWorkingColorSpace(toComponents(this, Gn), t);
                  var n,
                    r,
                    i = Gn.r,
                    a = Gn.g,
                    o = Gn.b,
                    s = Math.max(i, a, o),
                    u = Math.min(i, a, o),
                    l = (u + s) / 2;
                  if (u === s) (n = 0), (r = 0);
                  else {
                    var c = s - u;
                    switch (
                      ((r = l <= 0.5 ? c / (s + u) : c / (2 - s - u)), s)
                    ) {
                      case i:
                        n = (a - o) / c + (a < o ? 6 : 0);
                        break;
                      case a:
                        n = (o - i) / c + 2;
                        break;
                      case o:
                        n = (i - a) / c + 4;
                    }
                    n /= 6;
                  }
                  return (e.h = n), (e.s = r), (e.l = l), e;
                },
              },
              {
                key: "getRGB",
                value: function getRGB(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : $t;
                  return (
                    zn.fromWorkingColorSpace(toComponents(this, Gn), t),
                    (e.r = Gn.r),
                    (e.g = Gn.g),
                    (e.b = Gn.b),
                    e
                  );
                },
              },
              {
                key: "getStyle",
                value: function getStyle() {
                  var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : Qt;
                  return (
                    zn.fromWorkingColorSpace(toComponents(this, Gn), e),
                    e !== Qt
                      ? "color("
                          .concat(e, " ")
                          .concat(Gn.r, " ")
                          .concat(Gn.g, " ")
                          .concat(Gn.b, ")")
                      : "rgb("
                          .concat((255 * Gn.r) | 0, ",")
                          .concat((255 * Gn.g) | 0, ",")
                          .concat((255 * Gn.b) | 0, ")")
                  );
                },
              },
              {
                key: "offsetHSL",
                value: function offsetHSL(e, t, n) {
                  return (
                    this.getHSL(Un),
                    (Un.h += e),
                    (Un.s += t),
                    (Un.l += n),
                    this.setHSL(Un.h, Un.s, Un.l),
                    this
                  );
                },
              },
              {
                key: "add",
                value: function add(e) {
                  return (
                    (this.r += e.r), (this.g += e.g), (this.b += e.b), this
                  );
                },
              },
              {
                key: "addColors",
                value: function addColors(e, t) {
                  return (
                    (this.r = e.r + t.r),
                    (this.g = e.g + t.g),
                    (this.b = e.b + t.b),
                    this
                  );
                },
              },
              {
                key: "addScalar",
                value: function addScalar(e) {
                  return (this.r += e), (this.g += e), (this.b += e), this;
                },
              },
              {
                key: "sub",
                value: function sub(e) {
                  return (
                    (this.r = Math.max(0, this.r - e.r)),
                    (this.g = Math.max(0, this.g - e.g)),
                    (this.b = Math.max(0, this.b - e.b)),
                    this
                  );
                },
              },
              {
                key: "multiply",
                value: function multiply(e) {
                  return (
                    (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this
                  );
                },
              },
              {
                key: "multiplyScalar",
                value: function multiplyScalar(e) {
                  return (this.r *= e), (this.g *= e), (this.b *= e), this;
                },
              },
              {
                key: "lerp",
                value: function lerp(e, t) {
                  return (
                    (this.r += (e.r - this.r) * t),
                    (this.g += (e.g - this.g) * t),
                    (this.b += (e.b - this.b) * t),
                    this
                  );
                },
              },
              {
                key: "lerpColors",
                value: function lerpColors(e, t, n) {
                  return (
                    (this.r = e.r + (t.r - e.r) * n),
                    (this.g = e.g + (t.g - e.g) * n),
                    (this.b = e.b + (t.b - e.b) * n),
                    this
                  );
                },
              },
              {
                key: "lerpHSL",
                value: function lerpHSL(e, t) {
                  this.getHSL(Un), e.getHSL(Vn);
                  var n = lerp(Un.h, Vn.h, t),
                    r = lerp(Un.s, Vn.s, t),
                    i = lerp(Un.l, Vn.l, t);
                  return this.setHSL(n, r, i), this;
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return e.r === this.r && e.g === this.g && e.b === this.b;
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return (
                    (this.r = e[t]),
                    (this.g = e[t + 1]),
                    (this.b = e[t + 2]),
                    this
                  );
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                  return (
                    (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e
                  );
                },
              },
              {
                key: "fromBufferAttribute",
                value: function fromBufferAttribute(e, t) {
                  return (
                    (this.r = e.getX(t)),
                    (this.g = e.getY(t)),
                    (this.b = e.getZ(t)),
                    !0 === e.normalized &&
                      ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  return this.getHex();
                },
              },
              {
                key: Symbol.iterator,
                value: d.a.mark(function value() {
                  return d.a.wrap(
                    function value$(e) {
                      for (;;)
                        switch ((e.prev = e.next)) {
                          case 0:
                            return (e.next = 2), this.r;
                          case 2:
                            return (e.next = 4), this.g;
                          case 4:
                            return (e.next = 6), this.b;
                          case 6:
                          case "end":
                            return e.stop();
                        }
                    },
                    value,
                    this
                  );
                }),
              },
            ]),
            Color
          );
        })();
      Hn.NAMES = Fn;
      var qn = (function () {
          function ImageUtils() {
            Object(f.a)(this, ImageUtils);
          }
          return (
            Object(p.a)(ImageUtils, null, [
              {
                key: "getDataURL",
                value: function getDataURL(e) {
                  if (/^data:/i.test(e.src)) return e.src;
                  if ("undefined" == typeof HTMLCanvasElement) return e.src;
                  var t;
                  if (e instanceof HTMLCanvasElement) t = e;
                  else {
                    void 0 === Wn && (Wn = createElementNS("canvas")),
                      (Wn.width = e.width),
                      (Wn.height = e.height);
                    var n = Wn.getContext("2d");
                    e instanceof ImageData
                      ? n.putImageData(e, 0, 0)
                      : n.drawImage(e, 0, 0, e.width, e.height),
                      (t = Wn);
                  }
                  return t.width > 2048 || t.height > 2048
                    ? (console.warn(
                        "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                        e
                      ),
                      t.toDataURL("image/jpeg", 0.6))
                    : t.toDataURL("image/png");
                },
              },
              {
                key: "sRGBToLinear",
                value: function sRGBToLinear(e) {
                  if (
                    ("undefined" !== typeof HTMLImageElement &&
                      e instanceof HTMLImageElement) ||
                    ("undefined" !== typeof HTMLCanvasElement &&
                      e instanceof HTMLCanvasElement) ||
                    ("undefined" !== typeof ImageBitmap &&
                      e instanceof ImageBitmap)
                  ) {
                    var t = createElementNS("canvas");
                    (t.width = e.width), (t.height = e.height);
                    var n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    for (
                      var r = n.getImageData(0, 0, e.width, e.height),
                        i = r.data,
                        a = 0;
                      a < i.length;
                      a++
                    )
                      i[a] = 255 * SRGBToLinear(i[a] / 255);
                    return n.putImageData(r, 0, 0), t;
                  }
                  if (e.data) {
                    for (var o = e.data.slice(0), s = 0; s < o.length; s++)
                      o instanceof Uint8Array || o instanceof Uint8ClampedArray
                        ? (o[s] = Math.floor(255 * SRGBToLinear(o[s] / 255)))
                        : (o[s] = SRGBToLinear(o[s]));
                    return { data: o, width: e.width, height: e.height };
                  }
                  return (
                    console.warn(
                      "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
                    ),
                    e
                  );
                },
              },
            ]),
            ImageUtils
          );
        })(),
        Xn = (function () {
          function Source() {
            var e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : null;
            Object(f.a)(this, Source),
              (this.isSource = !0),
              (this.uuid = generateUUID()),
              (this.data = e),
              (this.version = 0);
          }
          return (
            Object(p.a)(Source, [
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = void 0 === e || "string" === typeof e;
                  if (!t && void 0 !== e.images[this.uuid])
                    return e.images[this.uuid];
                  var n = { uuid: this.uuid, url: "" },
                    r = this.data;
                  if (null !== r) {
                    var i;
                    if (Array.isArray(r)) {
                      i = [];
                      for (var a = 0, o = r.length; a < o; a++)
                        r[a].isDataTexture
                          ? i.push(serializeImage(r[a].image))
                          : i.push(serializeImage(r[a]));
                    } else i = serializeImage(r);
                    n.url = i;
                  }
                  return t || (e.images[this.uuid] = n), n;
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  !0 === e && this.version++;
                },
              },
            ]),
            Source
          );
        })();
      function serializeImage(e) {
        return ("undefined" !== typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
          ("undefined" !== typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" !== typeof ImageBitmap && e instanceof ImageBitmap)
          ? qn.getDataURL(e)
          : e.data
          ? {
              data: Array.from(e.data),
              width: e.width,
              height: e.height,
              type: e.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      var Jn = 0,
        Yn = (function (e) {
          function Texture() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : Texture.DEFAULT_IMAGE,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : Texture.DEFAULT_MAPPING,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : we,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : we,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : Ee,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : Ie,
              c =
                arguments.length > 6 && void 0 !== arguments[6]
                  ? arguments[6]
                  : Ye,
              h =
                arguments.length > 7 && void 0 !== arguments[7]
                  ? arguments[7]
                  : je,
              d =
                arguments.length > 8 && void 0 !== arguments[8]
                  ? arguments[8]
                  : 1,
              p =
                arguments.length > 9 && void 0 !== arguments[9]
                  ? arguments[9]
                  : Ht;
            return (
              Object(f.a)(this, Texture),
              ((e = Object(s.a)(
                this,
                Object(r.a)(Texture).call(this)
              )).isTexture = !0),
              Object.defineProperty(Object(l.a)(Object(l.a)(e)), "id", {
                value: Jn++,
              }),
              (e.uuid = generateUUID()),
              (e.name = ""),
              (e.source = new Xn(t)),
              (e.mipmaps = []),
              (e.mapping = n),
              (e.wrapS = i),
              (e.wrapT = a),
              (e.magFilter = o),
              (e.minFilter = u),
              (e.anisotropy = d),
              (e.format = c),
              (e.internalFormat = null),
              (e.type = h),
              (e.offset = new Dn(0, 0)),
              (e.repeat = new Dn(1, 1)),
              (e.center = new Dn(0, 0)),
              (e.rotation = 0),
              (e.matrixAutoUpdate = !0),
              (e.matrix = new jn()),
              (e.generateMipmaps = !0),
              (e.premultiplyAlpha = !1),
              (e.flipY = !0),
              (e.unpackAlignment = 4),
              (e.encoding = p),
              (e.userData = {}),
              (e.version = 0),
              (e.onUpdate = null),
              (e.isRenderTargetTexture = !1),
              (e.needsPMREMUpdate = !1),
              e
            );
          }
          return (
            Object(u.a)(Texture, e),
            Object(p.a)(Texture, [
              {
                key: "updateMatrix",
                value: function updateMatrix() {
                  this.matrix.setUvTransform(
                    this.offset.x,
                    this.offset.y,
                    this.repeat.x,
                    this.repeat.y,
                    this.rotation,
                    this.center.x,
                    this.center.y
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.name = e.name),
                    (this.source = e.source),
                    (this.mipmaps = e.mipmaps.slice(0)),
                    (this.mapping = e.mapping),
                    (this.wrapS = e.wrapS),
                    (this.wrapT = e.wrapT),
                    (this.magFilter = e.magFilter),
                    (this.minFilter = e.minFilter),
                    (this.anisotropy = e.anisotropy),
                    (this.format = e.format),
                    (this.internalFormat = e.internalFormat),
                    (this.type = e.type),
                    this.offset.copy(e.offset),
                    this.repeat.copy(e.repeat),
                    this.center.copy(e.center),
                    (this.rotation = e.rotation),
                    (this.matrixAutoUpdate = e.matrixAutoUpdate),
                    this.matrix.copy(e.matrix),
                    (this.generateMipmaps = e.generateMipmaps),
                    (this.premultiplyAlpha = e.premultiplyAlpha),
                    (this.flipY = e.flipY),
                    (this.unpackAlignment = e.unpackAlignment),
                    (this.encoding = e.encoding),
                    (this.userData = JSON.parse(JSON.stringify(e.userData))),
                    (this.needsUpdate = !0),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = void 0 === e || "string" === typeof e;
                  if (!t && void 0 !== e.textures[this.uuid])
                    return e.textures[this.uuid];
                  var n = {
                    metadata: {
                      version: 4.5,
                      type: "Texture",
                      generator: "Texture.toJSON",
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment,
                  };
                  return (
                    "{}" !== JSON.stringify(this.userData) &&
                      (n.userData = this.userData),
                    t || (e.textures[this.uuid] = n),
                    n
                  );
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.dispatchEvent({ type: "dispose" });
                },
              },
              {
                key: "transformUv",
                value: function transformUv(e) {
                  if (this.mapping !== ge) return e;
                  if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
                    switch (this.wrapS) {
                      case Se:
                        e.x = e.x - Math.floor(e.x);
                        break;
                      case we:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                      case Te:
                        1 === Math.abs(Math.floor(e.x) % 2)
                          ? (e.x = Math.ceil(e.x) - e.x)
                          : (e.x = e.x - Math.floor(e.x));
                    }
                  if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                      case Se:
                        e.y = e.y - Math.floor(e.y);
                        break;
                      case we:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                      case Te:
                        1 === Math.abs(Math.floor(e.y) % 2)
                          ? (e.y = Math.ceil(e.y) - e.y)
                          : (e.y = e.y - Math.floor(e.y));
                    }
                  return this.flipY && (e.y = 1 - e.y), e;
                },
              },
              {
                key: "image",
                get: function get() {
                  return this.source.data;
                },
                set: function set(e) {
                  this.source.data = e;
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  !0 === e && (this.version++, (this.source.needsUpdate = !0));
                },
              },
            ]),
            Texture
          );
        })(Ln);
      (Yn.DEFAULT_IMAGE = null), (Yn.DEFAULT_MAPPING = ge);
      var Zn = (function () {
          function Vector4() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            Object(f.a)(this, Vector4),
              (Vector4.prototype.isVector4 = !0),
              (this.x = e),
              (this.y = t),
              (this.z = n),
              (this.w = r);
          }
          return (
            Object(p.a)(Vector4, [
              {
                key: "set",
                value: function set(e, t, n, r) {
                  return (
                    (this.x = e), (this.y = t), (this.z = n), (this.w = r), this
                  );
                },
              },
              {
                key: "setScalar",
                value: function setScalar(e) {
                  return (
                    (this.x = e), (this.y = e), (this.z = e), (this.w = e), this
                  );
                },
              },
              {
                key: "setX",
                value: function setX(e) {
                  return (this.x = e), this;
                },
              },
              {
                key: "setY",
                value: function setY(e) {
                  return (this.y = e), this;
                },
              },
              {
                key: "setZ",
                value: function setZ(e) {
                  return (this.z = e), this;
                },
              },
              {
                key: "setW",
                value: function setW(e) {
                  return (this.w = e), this;
                },
              },
              {
                key: "setComponent",
                value: function setComponent(e, t) {
                  switch (e) {
                    case 0:
                      this.x = t;
                      break;
                    case 1:
                      this.y = t;
                      break;
                    case 2:
                      this.z = t;
                      break;
                    case 3:
                      this.w = t;
                      break;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                  return this;
                },
              },
              {
                key: "getComponent",
                value: function getComponent(e) {
                  switch (e) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    case 2:
                      return this.z;
                    case 3:
                      return this.w;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(this.x, this.y, this.z, this.w);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.x = e.x),
                    (this.y = e.y),
                    (this.z = e.z),
                    (this.w = void 0 !== e.w ? e.w : 1),
                    this
                  );
                },
              },
              {
                key: "add",
                value: function add(e) {
                  return (
                    (this.x += e.x),
                    (this.y += e.y),
                    (this.z += e.z),
                    (this.w += e.w),
                    this
                  );
                },
              },
              {
                key: "addScalar",
                value: function addScalar(e) {
                  return (
                    (this.x += e),
                    (this.y += e),
                    (this.z += e),
                    (this.w += e),
                    this
                  );
                },
              },
              {
                key: "addVectors",
                value: function addVectors(e, t) {
                  return (
                    (this.x = e.x + t.x),
                    (this.y = e.y + t.y),
                    (this.z = e.z + t.z),
                    (this.w = e.w + t.w),
                    this
                  );
                },
              },
              {
                key: "addScaledVector",
                value: function addScaledVector(e, t) {
                  return (
                    (this.x += e.x * t),
                    (this.y += e.y * t),
                    (this.z += e.z * t),
                    (this.w += e.w * t),
                    this
                  );
                },
              },
              {
                key: "sub",
                value: function sub(e) {
                  return (
                    (this.x -= e.x),
                    (this.y -= e.y),
                    (this.z -= e.z),
                    (this.w -= e.w),
                    this
                  );
                },
              },
              {
                key: "subScalar",
                value: function subScalar(e) {
                  return (
                    (this.x -= e),
                    (this.y -= e),
                    (this.z -= e),
                    (this.w -= e),
                    this
                  );
                },
              },
              {
                key: "subVectors",
                value: function subVectors(e, t) {
                  return (
                    (this.x = e.x - t.x),
                    (this.y = e.y - t.y),
                    (this.z = e.z - t.z),
                    (this.w = e.w - t.w),
                    this
                  );
                },
              },
              {
                key: "multiply",
                value: function multiply(e) {
                  return (
                    (this.x *= e.x),
                    (this.y *= e.y),
                    (this.z *= e.z),
                    (this.w *= e.w),
                    this
                  );
                },
              },
              {
                key: "multiplyScalar",
                value: function multiplyScalar(e) {
                  return (
                    (this.x *= e),
                    (this.y *= e),
                    (this.z *= e),
                    (this.w *= e),
                    this
                  );
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    a = e.elements;
                  return (
                    (this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i),
                    (this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i),
                    (this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i),
                    (this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i),
                    this
                  );
                },
              },
              {
                key: "divideScalar",
                value: function divideScalar(e) {
                  return this.multiplyScalar(1 / e);
                },
              },
              {
                key: "setAxisAngleFromQuaternion",
                value: function setAxisAngleFromQuaternion(e) {
                  this.w = 2 * Math.acos(e.w);
                  var t = Math.sqrt(1 - e.w * e.w);
                  return (
                    t < 1e-4
                      ? ((this.x = 1), (this.y = 0), (this.z = 0))
                      : ((this.x = e.x / t),
                        (this.y = e.y / t),
                        (this.z = e.z / t)),
                    this
                  );
                },
              },
              {
                key: "setAxisAngleFromRotationMatrix",
                value: function setAxisAngleFromRotationMatrix(e) {
                  var t,
                    n,
                    r,
                    i,
                    a = e.elements,
                    o = a[0],
                    s = a[4],
                    u = a[8],
                    l = a[1],
                    c = a[5],
                    h = a[9],
                    d = a[2],
                    f = a[6],
                    p = a[10];
                  if (
                    Math.abs(s - l) < 0.01 &&
                    Math.abs(u - d) < 0.01 &&
                    Math.abs(h - f) < 0.01
                  ) {
                    if (
                      Math.abs(s + l) < 0.1 &&
                      Math.abs(u + d) < 0.1 &&
                      Math.abs(h + f) < 0.1 &&
                      Math.abs(o + c + p - 3) < 0.1
                    )
                      return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    var m = (o + 1) / 2,
                      v = (c + 1) / 2,
                      g = (p + 1) / 2,
                      y = (s + l) / 4,
                      b = (u + d) / 4,
                      x = (h + f) / 4;
                    return (
                      m > v && m > g
                        ? m < 0.01
                          ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                          : ((r = y / (n = Math.sqrt(m))), (i = b / n))
                        : v > g
                        ? v < 0.01
                          ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                          : ((n = y / (r = Math.sqrt(v))), (i = x / r))
                        : g < 0.01
                        ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                        : ((n = b / (i = Math.sqrt(g))), (r = x / i)),
                      this.set(n, r, i, t),
                      this
                    );
                  }
                  var _ = Math.sqrt(
                    (f - h) * (f - h) + (u - d) * (u - d) + (l - s) * (l - s)
                  );
                  return (
                    Math.abs(_) < 0.001 && (_ = 1),
                    (this.x = (f - h) / _),
                    (this.y = (u - d) / _),
                    (this.z = (l - s) / _),
                    (this.w = Math.acos((o + c + p - 1) / 2)),
                    this
                  );
                },
              },
              {
                key: "min",
                value: function min(e) {
                  return (
                    (this.x = Math.min(this.x, e.x)),
                    (this.y = Math.min(this.y, e.y)),
                    (this.z = Math.min(this.z, e.z)),
                    (this.w = Math.min(this.w, e.w)),
                    this
                  );
                },
              },
              {
                key: "max",
                value: function max(e) {
                  return (
                    (this.x = Math.max(this.x, e.x)),
                    (this.y = Math.max(this.y, e.y)),
                    (this.z = Math.max(this.z, e.z)),
                    (this.w = Math.max(this.w, e.w)),
                    this
                  );
                },
              },
              {
                key: "clamp",
                value: function clamp(e, t) {
                  return (
                    (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                    (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                    (this.z = Math.max(e.z, Math.min(t.z, this.z))),
                    (this.w = Math.max(e.w, Math.min(t.w, this.w))),
                    this
                  );
                },
              },
              {
                key: "clampScalar",
                value: function clampScalar(e, t) {
                  return (
                    (this.x = Math.max(e, Math.min(t, this.x))),
                    (this.y = Math.max(e, Math.min(t, this.y))),
                    (this.z = Math.max(e, Math.min(t, this.z))),
                    (this.w = Math.max(e, Math.min(t, this.w))),
                    this
                  );
                },
              },
              {
                key: "clampLength",
                value: function clampLength(e, t) {
                  var n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(e, Math.min(t, n))
                  );
                },
              },
              {
                key: "floor",
                value: function floor() {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    (this.z = Math.floor(this.z)),
                    (this.w = Math.floor(this.w)),
                    this
                  );
                },
              },
              {
                key: "ceil",
                value: function ceil() {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    (this.z = Math.ceil(this.z)),
                    (this.w = Math.ceil(this.w)),
                    this
                  );
                },
              },
              {
                key: "round",
                value: function round() {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    (this.z = Math.round(this.z)),
                    (this.w = Math.round(this.w)),
                    this
                  );
                },
              },
              {
                key: "roundToZero",
                value: function roundToZero() {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    (this.z =
                      this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                    (this.w =
                      this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
                    this
                  );
                },
              },
              {
                key: "negate",
                value: function negate() {
                  return (
                    (this.x = -this.x),
                    (this.y = -this.y),
                    (this.z = -this.z),
                    (this.w = -this.w),
                    this
                  );
                },
              },
              {
                key: "dot",
                value: function dot(e) {
                  return (
                    this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                  );
                },
              },
              {
                key: "lengthSq",
                value: function lengthSq() {
                  return (
                    this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                  );
                },
              },
              {
                key: "length",
                value: function length() {
                  return Math.sqrt(
                    this.x * this.x +
                      this.y * this.y +
                      this.z * this.z +
                      this.w * this.w
                  );
                },
              },
              {
                key: "manhattanLength",
                value: function manhattanLength() {
                  return (
                    Math.abs(this.x) +
                    Math.abs(this.y) +
                    Math.abs(this.z) +
                    Math.abs(this.w)
                  );
                },
              },
              {
                key: "normalize",
                value: function normalize() {
                  return this.divideScalar(this.length() || 1);
                },
              },
              {
                key: "setLength",
                value: function setLength(e) {
                  return this.normalize().multiplyScalar(e);
                },
              },
              {
                key: "lerp",
                value: function lerp(e, t) {
                  return (
                    (this.x += (e.x - this.x) * t),
                    (this.y += (e.y - this.y) * t),
                    (this.z += (e.z - this.z) * t),
                    (this.w += (e.w - this.w) * t),
                    this
                  );
                },
              },
              {
                key: "lerpVectors",
                value: function lerpVectors(e, t, n) {
                  return (
                    (this.x = e.x + (t.x - e.x) * n),
                    (this.y = e.y + (t.y - e.y) * n),
                    (this.z = e.z + (t.z - e.z) * n),
                    (this.w = e.w + (t.w - e.w) * n),
                    this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return (
                    e.x === this.x &&
                    e.y === this.y &&
                    e.z === this.z &&
                    e.w === this.w
                  );
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return (
                    (this.x = e[t]),
                    (this.y = e[t + 1]),
                    (this.z = e[t + 2]),
                    (this.w = e[t + 3]),
                    this
                  );
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                  return (
                    (e[t] = this.x),
                    (e[t + 1] = this.y),
                    (e[t + 2] = this.z),
                    (e[t + 3] = this.w),
                    e
                  );
                },
              },
              {
                key: "fromBufferAttribute",
                value: function fromBufferAttribute(e, t) {
                  return (
                    (this.x = e.getX(t)),
                    (this.y = e.getY(t)),
                    (this.z = e.getZ(t)),
                    (this.w = e.getW(t)),
                    this
                  );
                },
              },
              {
                key: "random",
                value: function random() {
                  return (
                    (this.x = Math.random()),
                    (this.y = Math.random()),
                    (this.z = Math.random()),
                    (this.w = Math.random()),
                    this
                  );
                },
              },
              {
                key: Symbol.iterator,
                value: d.a.mark(function value() {
                  return d.a.wrap(
                    function value$(e) {
                      for (;;)
                        switch ((e.prev = e.next)) {
                          case 0:
                            return (e.next = 2), this.x;
                          case 2:
                            return (e.next = 4), this.y;
                          case 4:
                            return (e.next = 6), this.z;
                          case 6:
                            return (e.next = 8), this.w;
                          case 8:
                          case "end":
                            return e.stop();
                        }
                    },
                    value,
                    this
                  );
                }),
              },
              {
                key: "width",
                get: function get() {
                  return this.z;
                },
                set: function set(e) {
                  this.z = e;
                },
              },
              {
                key: "height",
                get: function get() {
                  return this.w;
                },
                set: function set(e) {
                  this.w = e;
                },
              },
            ]),
            Vector4
          );
        })(),
        Kn = (function (e) {
          function WebGLRenderTarget(e, t) {
            var n,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {};
            Object(f.a)(this, WebGLRenderTarget),
              ((n = Object(s.a)(
                this,
                Object(r.a)(WebGLRenderTarget).call(this)
              )).isWebGLRenderTarget = !0),
              (n.width = e),
              (n.height = t),
              (n.depth = 1),
              (n.scissor = new Zn(0, 0, e, t)),
              (n.scissorTest = !1),
              (n.viewport = new Zn(0, 0, e, t));
            var a = { width: e, height: t, depth: 1 };
            return (
              (n.texture = new Yn(
                a,
                i.mapping,
                i.wrapS,
                i.wrapT,
                i.magFilter,
                i.minFilter,
                i.format,
                i.type,
                i.anisotropy,
                i.encoding
              )),
              (n.texture.isRenderTargetTexture = !0),
              (n.texture.flipY = !1),
              (n.texture.generateMipmaps =
                void 0 !== i.generateMipmaps && i.generateMipmaps),
              (n.texture.internalFormat =
                void 0 !== i.internalFormat ? i.internalFormat : null),
              (n.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Ee),
              (n.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
              (n.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
              (n.depthTexture =
                void 0 !== i.depthTexture ? i.depthTexture : null),
              (n.samples = void 0 !== i.samples ? i.samples : 0),
              n
            );
          }
          return (
            Object(u.a)(WebGLRenderTarget, e),
            Object(p.a)(WebGLRenderTarget, [
              {
                key: "setSize",
                value: function setSize(e, t) {
                  var n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : 1;
                  (this.width === e && this.height === t && this.depth === n) ||
                    ((this.width = e),
                    (this.height = t),
                    (this.depth = n),
                    (this.texture.image.width = e),
                    (this.texture.image.height = t),
                    (this.texture.image.depth = n),
                    this.dispose()),
                    this.viewport.set(0, 0, e, t),
                    this.scissor.set(0, 0, e, t);
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  (this.width = e.width),
                    (this.height = e.height),
                    (this.depth = e.depth),
                    this.viewport.copy(e.viewport),
                    (this.texture = e.texture.clone()),
                    (this.texture.isRenderTargetTexture = !0);
                  var t = Object.assign({}, e.texture.image);
                  return (
                    (this.texture.source = new Xn(t)),
                    (this.depthBuffer = e.depthBuffer),
                    (this.stencilBuffer = e.stencilBuffer),
                    null !== e.depthTexture &&
                      (this.depthTexture = e.depthTexture.clone()),
                    (this.samples = e.samples),
                    this
                  );
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.dispatchEvent({ type: "dispose" });
                },
              },
            ]),
            WebGLRenderTarget
          );
        })(Ln),
        Qn = (function (e) {
          function DataArrayTexture() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : null,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            return (
              Object(f.a)(this, DataArrayTexture),
              ((e = Object(s.a)(
                this,
                Object(r.a)(DataArrayTexture).call(this, null)
              )).isDataArrayTexture = !0),
              (e.image = { data: t, width: n, height: i, depth: a }),
              (e.magFilter = Ae),
              (e.minFilter = Ae),
              (e.wrapR = we),
              (e.generateMipmaps = !1),
              (e.flipY = !1),
              (e.unpackAlignment = 1),
              e
            );
          }
          return Object(u.a)(DataArrayTexture, e), DataArrayTexture;
        })(Yn),
        $n = (function (e) {
          function WebGLArrayRenderTarget(e, t, n) {
            var i;
            return (
              Object(f.a)(this, WebGLArrayRenderTarget),
              ((i = Object(s.a)(
                this,
                Object(r.a)(WebGLArrayRenderTarget).call(this, e, t)
              )).isWebGLArrayRenderTarget = !0),
              (i.depth = n),
              (i.texture = new Qn(null, e, t, n)),
              (i.texture.isRenderTargetTexture = !0),
              i
            );
          }
          return Object(u.a)(WebGLArrayRenderTarget, e), WebGLArrayRenderTarget;
        })(Kn),
        er = (function (e) {
          function Data3DTexture() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : null,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            return (
              Object(f.a)(this, Data3DTexture),
              ((e = Object(s.a)(
                this,
                Object(r.a)(Data3DTexture).call(this, null)
              )).isData3DTexture = !0),
              (e.image = { data: t, width: n, height: i, depth: a }),
              (e.magFilter = Ae),
              (e.minFilter = Ae),
              (e.wrapR = we),
              (e.generateMipmaps = !1),
              (e.flipY = !1),
              (e.unpackAlignment = 1),
              e
            );
          }
          return Object(u.a)(Data3DTexture, e), Data3DTexture;
        })(Yn),
        tr = (function (e) {
          function WebGL3DRenderTarget(e, t, n) {
            var i;
            return (
              Object(f.a)(this, WebGL3DRenderTarget),
              ((i = Object(s.a)(
                this,
                Object(r.a)(WebGL3DRenderTarget).call(this, e, t)
              )).isWebGL3DRenderTarget = !0),
              (i.depth = n),
              (i.texture = new er(null, e, t, n)),
              (i.texture.isRenderTargetTexture = !0),
              i
            );
          }
          return Object(u.a)(WebGL3DRenderTarget, e), WebGL3DRenderTarget;
        })(Kn),
        nr = (function (e) {
          function WebGLMultipleRenderTargets(e, t, n) {
            var i,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : {};
            Object(f.a)(this, WebGLMultipleRenderTargets),
              ((i = Object(s.a)(
                this,
                Object(r.a)(WebGLMultipleRenderTargets).call(this, e, t, a)
              )).isWebGLMultipleRenderTargets = !0);
            var o = i.texture;
            i.texture = [];
            for (var u = 0; u < n; u++)
              (i.texture[u] = o.clone()),
                (i.texture[u].isRenderTargetTexture = !0);
            return i;
          }
          return (
            Object(u.a)(WebGLMultipleRenderTargets, e),
            Object(p.a)(WebGLMultipleRenderTargets, [
              {
                key: "setSize",
                value: function setSize(e, t) {
                  var n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : 1;
                  if (
                    this.width !== e ||
                    this.height !== t ||
                    this.depth !== n
                  ) {
                    (this.width = e), (this.height = t), (this.depth = n);
                    for (var r = 0, i = this.texture.length; r < i; r++)
                      (this.texture[r].image.width = e),
                        (this.texture[r].image.height = t),
                        (this.texture[r].image.depth = n);
                    this.dispose();
                  }
                  return (
                    this.viewport.set(0, 0, e, t),
                    this.scissor.set(0, 0, e, t),
                    this
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  this.dispose(),
                    (this.width = e.width),
                    (this.height = e.height),
                    (this.depth = e.depth),
                    this.viewport.set(0, 0, this.width, this.height),
                    this.scissor.set(0, 0, this.width, this.height),
                    (this.depthBuffer = e.depthBuffer),
                    (this.stencilBuffer = e.stencilBuffer),
                    null !== e.depthTexture &&
                      (this.depthTexture = e.depthTexture.clone()),
                    (this.texture.length = 0);
                  for (var t = 0, n = e.texture.length; t < n; t++)
                    (this.texture[t] = e.texture[t].clone()),
                      (this.texture[t].isRenderTargetTexture = !0);
                  return this;
                },
              },
            ]),
            WebGLMultipleRenderTargets
          );
        })(Kn),
        rr = (function () {
          function Quaternion() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            Object(f.a)(this, Quaternion),
              (this.isQuaternion = !0),
              (this._x = e),
              (this._y = t),
              (this._z = n),
              (this._w = r);
          }
          return (
            Object(p.a)(
              Quaternion,
              [
                {
                  key: "set",
                  value: function set(e, t, n, r) {
                    return (
                      (this._x = e),
                      (this._y = t),
                      (this._z = n),
                      (this._w = r),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "clone",
                  value: function clone() {
                    return new this.constructor(
                      this._x,
                      this._y,
                      this._z,
                      this._w
                    );
                  },
                },
                {
                  key: "copy",
                  value: function copy(e) {
                    return (
                      (this._x = e.x),
                      (this._y = e.y),
                      (this._z = e.z),
                      (this._w = e.w),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "setFromEuler",
                  value: function setFromEuler(e, t) {
                    if (!e || !e.isEuler)
                      throw new Error(
                        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
                      );
                    var n = e._x,
                      r = e._y,
                      i = e._z,
                      a = e._order,
                      o = Math.cos,
                      s = Math.sin,
                      u = o(n / 2),
                      l = o(r / 2),
                      c = o(i / 2),
                      h = s(n / 2),
                      d = s(r / 2),
                      f = s(i / 2);
                    switch (a) {
                      case "XYZ":
                        (this._x = h * l * c + u * d * f),
                          (this._y = u * d * c - h * l * f),
                          (this._z = u * l * f + h * d * c),
                          (this._w = u * l * c - h * d * f);
                        break;
                      case "YXZ":
                        (this._x = h * l * c + u * d * f),
                          (this._y = u * d * c - h * l * f),
                          (this._z = u * l * f - h * d * c),
                          (this._w = u * l * c + h * d * f);
                        break;
                      case "ZXY":
                        (this._x = h * l * c - u * d * f),
                          (this._y = u * d * c + h * l * f),
                          (this._z = u * l * f + h * d * c),
                          (this._w = u * l * c - h * d * f);
                        break;
                      case "ZYX":
                        (this._x = h * l * c - u * d * f),
                          (this._y = u * d * c + h * l * f),
                          (this._z = u * l * f - h * d * c),
                          (this._w = u * l * c + h * d * f);
                        break;
                      case "YZX":
                        (this._x = h * l * c + u * d * f),
                          (this._y = u * d * c + h * l * f),
                          (this._z = u * l * f - h * d * c),
                          (this._w = u * l * c - h * d * f);
                        break;
                      case "XZY":
                        (this._x = h * l * c - u * d * f),
                          (this._y = u * d * c - h * l * f),
                          (this._z = u * l * f + h * d * c),
                          (this._w = u * l * c + h * d * f);
                        break;
                      default:
                        console.warn(
                          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                            a
                        );
                    }
                    return !1 !== t && this._onChangeCallback(), this;
                  },
                },
                {
                  key: "setFromAxisAngle",
                  value: function setFromAxisAngle(e, t) {
                    var n = t / 2,
                      r = Math.sin(n);
                    return (
                      (this._x = e.x * r),
                      (this._y = e.y * r),
                      (this._z = e.z * r),
                      (this._w = Math.cos(n)),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "setFromRotationMatrix",
                  value: function setFromRotationMatrix(e) {
                    var t = e.elements,
                      n = t[0],
                      r = t[4],
                      i = t[8],
                      a = t[1],
                      o = t[5],
                      s = t[9],
                      u = t[2],
                      l = t[6],
                      c = t[10],
                      h = n + o + c;
                    if (h > 0) {
                      var d = 0.5 / Math.sqrt(h + 1);
                      (this._w = 0.25 / d),
                        (this._x = (l - s) * d),
                        (this._y = (i - u) * d),
                        (this._z = (a - r) * d);
                    } else if (n > o && n > c) {
                      var f = 2 * Math.sqrt(1 + n - o - c);
                      (this._w = (l - s) / f),
                        (this._x = 0.25 * f),
                        (this._y = (r + a) / f),
                        (this._z = (i + u) / f);
                    } else if (o > c) {
                      var p = 2 * Math.sqrt(1 + o - n - c);
                      (this._w = (i - u) / p),
                        (this._x = (r + a) / p),
                        (this._y = 0.25 * p),
                        (this._z = (s + l) / p);
                    } else {
                      var m = 2 * Math.sqrt(1 + c - n - o);
                      (this._w = (a - r) / m),
                        (this._x = (i + u) / m),
                        (this._y = (s + l) / m),
                        (this._z = 0.25 * m);
                    }
                    return this._onChangeCallback(), this;
                  },
                },
                {
                  key: "setFromUnitVectors",
                  value: function setFromUnitVectors(e, t) {
                    var n = e.dot(t) + 1;
                    return (
                      n < Number.EPSILON
                        ? ((n = 0),
                          Math.abs(e.x) > Math.abs(e.z)
                            ? ((this._x = -e.y),
                              (this._y = e.x),
                              (this._z = 0),
                              (this._w = n))
                            : ((this._x = 0),
                              (this._y = -e.z),
                              (this._z = e.y),
                              (this._w = n)))
                        : ((this._x = e.y * t.z - e.z * t.y),
                          (this._y = e.z * t.x - e.x * t.z),
                          (this._z = e.x * t.y - e.y * t.x),
                          (this._w = n)),
                      this.normalize()
                    );
                  },
                },
                {
                  key: "angleTo",
                  value: function angleTo(e) {
                    return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)));
                  },
                },
                {
                  key: "rotateTowards",
                  value: function rotateTowards(e, t) {
                    var n = this.angleTo(e);
                    if (0 === n) return this;
                    var r = Math.min(1, t / n);
                    return this.slerp(e, r), this;
                  },
                },
                {
                  key: "identity",
                  value: function identity() {
                    return this.set(0, 0, 0, 1);
                  },
                },
                {
                  key: "invert",
                  value: function invert() {
                    return this.conjugate();
                  },
                },
                {
                  key: "conjugate",
                  value: function conjugate() {
                    return (
                      (this._x *= -1),
                      (this._y *= -1),
                      (this._z *= -1),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "dot",
                  value: function dot(e) {
                    return (
                      this._x * e._x +
                      this._y * e._y +
                      this._z * e._z +
                      this._w * e._w
                    );
                  },
                },
                {
                  key: "lengthSq",
                  value: function lengthSq() {
                    return (
                      this._x * this._x +
                      this._y * this._y +
                      this._z * this._z +
                      this._w * this._w
                    );
                  },
                },
                {
                  key: "length",
                  value: function length() {
                    return Math.sqrt(
                      this._x * this._x +
                        this._y * this._y +
                        this._z * this._z +
                        this._w * this._w
                    );
                  },
                },
                {
                  key: "normalize",
                  value: function normalize() {
                    var e = this.length();
                    return (
                      0 === e
                        ? ((this._x = 0),
                          (this._y = 0),
                          (this._z = 0),
                          (this._w = 1))
                        : ((e = 1 / e),
                          (this._x = this._x * e),
                          (this._y = this._y * e),
                          (this._z = this._z * e),
                          (this._w = this._w * e)),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "multiply",
                  value: function multiply(e) {
                    return this.multiplyQuaternions(this, e);
                  },
                },
                {
                  key: "premultiply",
                  value: function premultiply(e) {
                    return this.multiplyQuaternions(e, this);
                  },
                },
                {
                  key: "multiplyQuaternions",
                  value: function multiplyQuaternions(e, t) {
                    var n = e._x,
                      r = e._y,
                      i = e._z,
                      a = e._w,
                      o = t._x,
                      s = t._y,
                      u = t._z,
                      l = t._w;
                    return (
                      (this._x = n * l + a * o + r * u - i * s),
                      (this._y = r * l + a * s + i * o - n * u),
                      (this._z = i * l + a * u + n * s - r * o),
                      (this._w = a * l - n * o - r * s - i * u),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "slerp",
                  value: function slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                      r = this._y,
                      i = this._z,
                      a = this._w,
                      o = a * e._w + n * e._x + r * e._y + i * e._z;
                    if (
                      (o < 0
                        ? ((this._w = -e._w),
                          (this._x = -e._x),
                          (this._y = -e._y),
                          (this._z = -e._z),
                          (o = -o))
                        : this.copy(e),
                      o >= 1)
                    )
                      return (
                        (this._w = a),
                        (this._x = n),
                        (this._y = r),
                        (this._z = i),
                        this
                      );
                    var s = 1 - o * o;
                    if (s <= Number.EPSILON) {
                      var u = 1 - t;
                      return (
                        (this._w = u * a + t * this._w),
                        (this._x = u * n + t * this._x),
                        (this._y = u * r + t * this._y),
                        (this._z = u * i + t * this._z),
                        this.normalize(),
                        this._onChangeCallback(),
                        this
                      );
                    }
                    var l = Math.sqrt(s),
                      c = Math.atan2(l, o),
                      h = Math.sin((1 - t) * c) / l,
                      d = Math.sin(t * c) / l;
                    return (
                      (this._w = a * h + this._w * d),
                      (this._x = n * h + this._x * d),
                      (this._y = r * h + this._y * d),
                      (this._z = i * h + this._z * d),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "slerpQuaternions",
                  value: function slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n);
                  },
                },
                {
                  key: "random",
                  value: function random() {
                    var e = Math.random(),
                      t = Math.sqrt(1 - e),
                      n = Math.sqrt(e),
                      r = 2 * Math.PI * Math.random(),
                      i = 2 * Math.PI * Math.random();
                    return this.set(
                      t * Math.cos(r),
                      n * Math.sin(i),
                      n * Math.cos(i),
                      t * Math.sin(r)
                    );
                  },
                },
                {
                  key: "equals",
                  value: function equals(e) {
                    return (
                      e._x === this._x &&
                      e._y === this._y &&
                      e._z === this._z &&
                      e._w === this._w
                    );
                  },
                },
                {
                  key: "fromArray",
                  value: function fromArray(e) {
                    var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                    return (
                      (this._x = e[t]),
                      (this._y = e[t + 1]),
                      (this._z = e[t + 2]),
                      (this._w = e[t + 3]),
                      this._onChangeCallback(),
                      this
                    );
                  },
                },
                {
                  key: "toArray",
                  value: function toArray() {
                    var e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : [],
                      t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 0;
                    return (
                      (e[t] = this._x),
                      (e[t + 1] = this._y),
                      (e[t + 2] = this._z),
                      (e[t + 3] = this._w),
                      e
                    );
                  },
                },
                {
                  key: "fromBufferAttribute",
                  value: function fromBufferAttribute(e, t) {
                    return (
                      (this._x = e.getX(t)),
                      (this._y = e.getY(t)),
                      (this._z = e.getZ(t)),
                      (this._w = e.getW(t)),
                      this
                    );
                  },
                },
                {
                  key: "_onChange",
                  value: function _onChange(e) {
                    return (this._onChangeCallback = e), this;
                  },
                },
                {
                  key: "_onChangeCallback",
                  value: function _onChangeCallback() {},
                },
                {
                  key: Symbol.iterator,
                  value: d.a.mark(function value() {
                    return d.a.wrap(
                      function value$(e) {
                        for (;;)
                          switch ((e.prev = e.next)) {
                            case 0:
                              return (e.next = 2), this._x;
                            case 2:
                              return (e.next = 4), this._y;
                            case 4:
                              return (e.next = 6), this._z;
                            case 6:
                              return (e.next = 8), this._w;
                            case 8:
                            case "end":
                              return e.stop();
                          }
                      },
                      value,
                      this
                    );
                  }),
                },
                {
                  key: "x",
                  get: function get() {
                    return this._x;
                  },
                  set: function set(e) {
                    (this._x = e), this._onChangeCallback();
                  },
                },
                {
                  key: "y",
                  get: function get() {
                    return this._y;
                  },
                  set: function set(e) {
                    (this._y = e), this._onChangeCallback();
                  },
                },
                {
                  key: "z",
                  get: function get() {
                    return this._z;
                  },
                  set: function set(e) {
                    (this._z = e), this._onChangeCallback();
                  },
                },
                {
                  key: "w",
                  get: function get() {
                    return this._w;
                  },
                  set: function set(e) {
                    (this._w = e), this._onChangeCallback();
                  },
                },
              ],
              [
                {
                  key: "slerpFlat",
                  value: function slerpFlat(e, t, n, r, i, a, o) {
                    var s = n[r + 0],
                      u = n[r + 1],
                      l = n[r + 2],
                      c = n[r + 3],
                      h = i[a + 0],
                      d = i[a + 1],
                      f = i[a + 2],
                      p = i[a + 3];
                    if (0 === o)
                      return (
                        (e[t + 0] = s),
                        (e[t + 1] = u),
                        (e[t + 2] = l),
                        void (e[t + 3] = c)
                      );
                    if (1 === o)
                      return (
                        (e[t + 0] = h),
                        (e[t + 1] = d),
                        (e[t + 2] = f),
                        void (e[t + 3] = p)
                      );
                    if (c !== p || s !== h || u !== d || l !== f) {
                      var m = 1 - o,
                        v = s * h + u * d + l * f + c * p,
                        g = v >= 0 ? 1 : -1,
                        y = 1 - v * v;
                      if (y > Number.EPSILON) {
                        var b = Math.sqrt(y),
                          x = Math.atan2(b, v * g);
                        (m = Math.sin(m * x) / b), (o = Math.sin(o * x) / b);
                      }
                      var _ = o * g;
                      if (
                        ((s = s * m + h * _),
                        (u = u * m + d * _),
                        (l = l * m + f * _),
                        (c = c * m + p * _),
                        m === 1 - o)
                      ) {
                        var M = 1 / Math.sqrt(s * s + u * u + l * l + c * c);
                        (s *= M), (u *= M), (l *= M), (c *= M);
                      }
                    }
                    (e[t] = s), (e[t + 1] = u), (e[t + 2] = l), (e[t + 3] = c);
                  },
                },
                {
                  key: "multiplyQuaternionsFlat",
                  value: function multiplyQuaternionsFlat(e, t, n, r, i, a) {
                    var o = n[r],
                      s = n[r + 1],
                      u = n[r + 2],
                      l = n[r + 3],
                      c = i[a],
                      h = i[a + 1],
                      d = i[a + 2],
                      f = i[a + 3];
                    return (
                      (e[t] = o * f + l * c + s * d - u * h),
                      (e[t + 1] = s * f + l * h + u * c - o * d),
                      (e[t + 2] = u * f + l * d + o * h - s * c),
                      (e[t + 3] = l * f - o * c - s * h - u * d),
                      e
                    );
                  },
                },
              ]
            ),
            Quaternion
          );
        })(),
        ir = (function () {
          function Vector3() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0;
            Object(f.a)(this, Vector3),
              (Vector3.prototype.isVector3 = !0),
              (this.x = e),
              (this.y = t),
              (this.z = n);
          }
          return (
            Object(p.a)(Vector3, [
              {
                key: "set",
                value: function set(e, t, n) {
                  return (
                    void 0 === n && (n = this.z),
                    (this.x = e),
                    (this.y = t),
                    (this.z = n),
                    this
                  );
                },
              },
              {
                key: "setScalar",
                value: function setScalar(e) {
                  return (this.x = e), (this.y = e), (this.z = e), this;
                },
              },
              {
                key: "setX",
                value: function setX(e) {
                  return (this.x = e), this;
                },
              },
              {
                key: "setY",
                value: function setY(e) {
                  return (this.y = e), this;
                },
              },
              {
                key: "setZ",
                value: function setZ(e) {
                  return (this.z = e), this;
                },
              },
              {
                key: "setComponent",
                value: function setComponent(e, t) {
                  switch (e) {
                    case 0:
                      this.x = t;
                      break;
                    case 1:
                      this.y = t;
                      break;
                    case 2:
                      this.z = t;
                      break;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                  return this;
                },
              },
              {
                key: "getComponent",
                value: function getComponent(e) {
                  switch (e) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    case 2:
                      return this.z;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(this.x, this.y, this.z);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
                },
              },
              {
                key: "add",
                value: function add(e) {
                  return (
                    (this.x += e.x), (this.y += e.y), (this.z += e.z), this
                  );
                },
              },
              {
                key: "addScalar",
                value: function addScalar(e) {
                  return (this.x += e), (this.y += e), (this.z += e), this;
                },
              },
              {
                key: "addVectors",
                value: function addVectors(e, t) {
                  return (
                    (this.x = e.x + t.x),
                    (this.y = e.y + t.y),
                    (this.z = e.z + t.z),
                    this
                  );
                },
              },
              {
                key: "addScaledVector",
                value: function addScaledVector(e, t) {
                  return (
                    (this.x += e.x * t),
                    (this.y += e.y * t),
                    (this.z += e.z * t),
                    this
                  );
                },
              },
              {
                key: "sub",
                value: function sub(e) {
                  return (
                    (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this
                  );
                },
              },
              {
                key: "subScalar",
                value: function subScalar(e) {
                  return (this.x -= e), (this.y -= e), (this.z -= e), this;
                },
              },
              {
                key: "subVectors",
                value: function subVectors(e, t) {
                  return (
                    (this.x = e.x - t.x),
                    (this.y = e.y - t.y),
                    (this.z = e.z - t.z),
                    this
                  );
                },
              },
              {
                key: "multiply",
                value: function multiply(e) {
                  return (
                    (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this
                  );
                },
              },
              {
                key: "multiplyScalar",
                value: function multiplyScalar(e) {
                  return (this.x *= e), (this.y *= e), (this.z *= e), this;
                },
              },
              {
                key: "multiplyVectors",
                value: function multiplyVectors(e, t) {
                  return (
                    (this.x = e.x * t.x),
                    (this.y = e.y * t.y),
                    (this.z = e.z * t.z),
                    this
                  );
                },
              },
              {
                key: "applyEuler",
                value: function applyEuler(e) {
                  return this.applyQuaternion(or.setFromEuler(e));
                },
              },
              {
                key: "applyAxisAngle",
                value: function applyAxisAngle(e, t) {
                  return this.applyQuaternion(or.setFromAxisAngle(e, t));
                },
              },
              {
                key: "applyMatrix3",
                value: function applyMatrix3(e) {
                  var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements;
                  return (
                    (this.x = i[0] * t + i[3] * n + i[6] * r),
                    (this.y = i[1] * t + i[4] * n + i[7] * r),
                    (this.z = i[2] * t + i[5] * n + i[8] * r),
                    this
                  );
                },
              },
              {
                key: "applyNormalMatrix",
                value: function applyNormalMatrix(e) {
                  return this.applyMatrix3(e).normalize();
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements,
                    a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                  return (
                    (this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a),
                    (this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a),
                    (this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a),
                    this
                  );
                },
              },
              {
                key: "applyQuaternion",
                value: function applyQuaternion(e) {
                  var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.x,
                    a = e.y,
                    o = e.z,
                    s = e.w,
                    u = s * t + a * r - o * n,
                    l = s * n + o * t - i * r,
                    c = s * r + i * n - a * t,
                    h = -i * t - a * n - o * r;
                  return (
                    (this.x = u * s + h * -i + l * -o - c * -a),
                    (this.y = l * s + h * -a + c * -i - u * -o),
                    (this.z = c * s + h * -o + u * -a - l * -i),
                    this
                  );
                },
              },
              {
                key: "project",
                value: function project(e) {
                  return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
                    e.projectionMatrix
                  );
                },
              },
              {
                key: "unproject",
                value: function unproject(e) {
                  return this.applyMatrix4(
                    e.projectionMatrixInverse
                  ).applyMatrix4(e.matrixWorld);
                },
              },
              {
                key: "transformDirection",
                value: function transformDirection(e) {
                  var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements;
                  return (
                    (this.x = i[0] * t + i[4] * n + i[8] * r),
                    (this.y = i[1] * t + i[5] * n + i[9] * r),
                    (this.z = i[2] * t + i[6] * n + i[10] * r),
                    this.normalize()
                  );
                },
              },
              {
                key: "divide",
                value: function divide(e) {
                  return (
                    (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this
                  );
                },
              },
              {
                key: "divideScalar",
                value: function divideScalar(e) {
                  return this.multiplyScalar(1 / e);
                },
              },
              {
                key: "min",
                value: function min(e) {
                  return (
                    (this.x = Math.min(this.x, e.x)),
                    (this.y = Math.min(this.y, e.y)),
                    (this.z = Math.min(this.z, e.z)),
                    this
                  );
                },
              },
              {
                key: "max",
                value: function max(e) {
                  return (
                    (this.x = Math.max(this.x, e.x)),
                    (this.y = Math.max(this.y, e.y)),
                    (this.z = Math.max(this.z, e.z)),
                    this
                  );
                },
              },
              {
                key: "clamp",
                value: function clamp(e, t) {
                  return (
                    (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                    (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                    (this.z = Math.max(e.z, Math.min(t.z, this.z))),
                    this
                  );
                },
              },
              {
                key: "clampScalar",
                value: function clampScalar(e, t) {
                  return (
                    (this.x = Math.max(e, Math.min(t, this.x))),
                    (this.y = Math.max(e, Math.min(t, this.y))),
                    (this.z = Math.max(e, Math.min(t, this.z))),
                    this
                  );
                },
              },
              {
                key: "clampLength",
                value: function clampLength(e, t) {
                  var n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(e, Math.min(t, n))
                  );
                },
              },
              {
                key: "floor",
                value: function floor() {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    (this.z = Math.floor(this.z)),
                    this
                  );
                },
              },
              {
                key: "ceil",
                value: function ceil() {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    (this.z = Math.ceil(this.z)),
                    this
                  );
                },
              },
              {
                key: "round",
                value: function round() {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    (this.z = Math.round(this.z)),
                    this
                  );
                },
              },
              {
                key: "roundToZero",
                value: function roundToZero() {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    (this.z =
                      this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                    this
                  );
                },
              },
              {
                key: "negate",
                value: function negate() {
                  return (
                    (this.x = -this.x),
                    (this.y = -this.y),
                    (this.z = -this.z),
                    this
                  );
                },
              },
              {
                key: "dot",
                value: function dot(e) {
                  return this.x * e.x + this.y * e.y + this.z * e.z;
                },
              },
              {
                key: "lengthSq",
                value: function lengthSq() {
                  return this.x * this.x + this.y * this.y + this.z * this.z;
                },
              },
              {
                key: "length",
                value: function length() {
                  return Math.sqrt(
                    this.x * this.x + this.y * this.y + this.z * this.z
                  );
                },
              },
              {
                key: "manhattanLength",
                value: function manhattanLength() {
                  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                },
              },
              {
                key: "normalize",
                value: function normalize() {
                  return this.divideScalar(this.length() || 1);
                },
              },
              {
                key: "setLength",
                value: function setLength(e) {
                  return this.normalize().multiplyScalar(e);
                },
              },
              {
                key: "lerp",
                value: function lerp(e, t) {
                  return (
                    (this.x += (e.x - this.x) * t),
                    (this.y += (e.y - this.y) * t),
                    (this.z += (e.z - this.z) * t),
                    this
                  );
                },
              },
              {
                key: "lerpVectors",
                value: function lerpVectors(e, t, n) {
                  return (
                    (this.x = e.x + (t.x - e.x) * n),
                    (this.y = e.y + (t.y - e.y) * n),
                    (this.z = e.z + (t.z - e.z) * n),
                    this
                  );
                },
              },
              {
                key: "cross",
                value: function cross(e) {
                  return this.crossVectors(this, e);
                },
              },
              {
                key: "crossVectors",
                value: function crossVectors(e, t) {
                  var n = e.x,
                    r = e.y,
                    i = e.z,
                    a = t.x,
                    o = t.y,
                    s = t.z;
                  return (
                    (this.x = r * s - i * o),
                    (this.y = i * a - n * s),
                    (this.z = n * o - r * a),
                    this
                  );
                },
              },
              {
                key: "projectOnVector",
                value: function projectOnVector(e) {
                  var t = e.lengthSq();
                  if (0 === t) return this.set(0, 0, 0);
                  var n = e.dot(this) / t;
                  return this.copy(e).multiplyScalar(n);
                },
              },
              {
                key: "projectOnPlane",
                value: function projectOnPlane(e) {
                  return ar.copy(this).projectOnVector(e), this.sub(ar);
                },
              },
              {
                key: "reflect",
                value: function reflect(e) {
                  return this.sub(ar.copy(e).multiplyScalar(2 * this.dot(e)));
                },
              },
              {
                key: "angleTo",
                value: function angleTo(e) {
                  var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                  if (0 === t) return Math.PI / 2;
                  var n = this.dot(e) / t;
                  return Math.acos(clamp(n, -1, 1));
                },
              },
              {
                key: "distanceTo",
                value: function distanceTo(e) {
                  return Math.sqrt(this.distanceToSquared(e));
                },
              },
              {
                key: "distanceToSquared",
                value: function distanceToSquared(e) {
                  var t = this.x - e.x,
                    n = this.y - e.y,
                    r = this.z - e.z;
                  return t * t + n * n + r * r;
                },
              },
              {
                key: "manhattanDistanceTo",
                value: function manhattanDistanceTo(e) {
                  return (
                    Math.abs(this.x - e.x) +
                    Math.abs(this.y - e.y) +
                    Math.abs(this.z - e.z)
                  );
                },
              },
              {
                key: "setFromSpherical",
                value: function setFromSpherical(e) {
                  return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
                },
              },
              {
                key: "setFromSphericalCoords",
                value: function setFromSphericalCoords(e, t, n) {
                  var r = Math.sin(t) * e;
                  return (
                    (this.x = r * Math.sin(n)),
                    (this.y = Math.cos(t) * e),
                    (this.z = r * Math.cos(n)),
                    this
                  );
                },
              },
              {
                key: "setFromCylindrical",
                value: function setFromCylindrical(e) {
                  return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
                },
              },
              {
                key: "setFromCylindricalCoords",
                value: function setFromCylindricalCoords(e, t, n) {
                  return (
                    (this.x = e * Math.sin(t)),
                    (this.y = n),
                    (this.z = e * Math.cos(t)),
                    this
                  );
                },
              },
              {
                key: "setFromMatrixPosition",
                value: function setFromMatrixPosition(e) {
                  var t = e.elements;
                  return (
                    (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this
                  );
                },
              },
              {
                key: "setFromMatrixScale",
                value: function setFromMatrixScale(e) {
                  var t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    r = this.setFromMatrixColumn(e, 2).length();
                  return (this.x = t), (this.y = n), (this.z = r), this;
                },
              },
              {
                key: "setFromMatrixColumn",
                value: function setFromMatrixColumn(e, t) {
                  return this.fromArray(e.elements, 4 * t);
                },
              },
              {
                key: "setFromMatrix3Column",
                value: function setFromMatrix3Column(e, t) {
                  return this.fromArray(e.elements, 3 * t);
                },
              },
              {
                key: "setFromEuler",
                value: function setFromEuler(e) {
                  return (
                    (this.x = e._x), (this.y = e._y), (this.z = e._z), this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return e.x === this.x && e.y === this.y && e.z === this.z;
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return (
                    (this.x = e[t]),
                    (this.y = e[t + 1]),
                    (this.z = e[t + 2]),
                    this
                  );
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                  return (
                    (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e
                  );
                },
              },
              {
                key: "fromBufferAttribute",
                value: function fromBufferAttribute(e, t) {
                  return (
                    (this.x = e.getX(t)),
                    (this.y = e.getY(t)),
                    (this.z = e.getZ(t)),
                    this
                  );
                },
              },
              {
                key: "random",
                value: function random() {
                  return (
                    (this.x = Math.random()),
                    (this.y = Math.random()),
                    (this.z = Math.random()),
                    this
                  );
                },
              },
              {
                key: "randomDirection",
                value: function randomDirection() {
                  var e = 2 * (Math.random() - 0.5),
                    t = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - Math.pow(e, 2));
                  return (
                    (this.x = n * Math.cos(t)),
                    (this.y = n * Math.sin(t)),
                    (this.z = e),
                    this
                  );
                },
              },
              {
                key: Symbol.iterator,
                value: d.a.mark(function value() {
                  return d.a.wrap(
                    function value$(e) {
                      for (;;)
                        switch ((e.prev = e.next)) {
                          case 0:
                            return (e.next = 2), this.x;
                          case 2:
                            return (e.next = 4), this.y;
                          case 4:
                            return (e.next = 6), this.z;
                          case 6:
                          case "end":
                            return e.stop();
                        }
                    },
                    value,
                    this
                  );
                }),
              },
            ]),
            Vector3
          );
        })(),
        ar = new ir(),
        or = new rr(),
        sr = (function () {
          function Box3() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(1 / 0, 1 / 0, 1 / 0),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir(-1 / 0, -1 / 0, -1 / 0);
            Object(f.a)(this, Box3),
              (this.isBox3 = !0),
              (this.min = e),
              (this.max = t);
          }
          return (
            Object(p.a)(Box3, [
              {
                key: "set",
                value: function set(e, t) {
                  return this.min.copy(e), this.max.copy(t), this;
                },
              },
              {
                key: "setFromArray",
                value: function setFromArray(e) {
                  for (
                    var t = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0,
                      s = 0,
                      u = e.length;
                    s < u;
                    s += 3
                  ) {
                    var l = e[s],
                      c = e[s + 1],
                      h = e[s + 2];
                    l < t && (t = l),
                      c < n && (n = c),
                      h < r && (r = h),
                      l > i && (i = l),
                      c > a && (a = c),
                      h > o && (o = h);
                  }
                  return this.min.set(t, n, r), this.max.set(i, a, o), this;
                },
              },
              {
                key: "setFromBufferAttribute",
                value: function setFromBufferAttribute(e) {
                  for (
                    var t = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0,
                      s = 0,
                      u = e.count;
                    s < u;
                    s++
                  ) {
                    var l = e.getX(s),
                      c = e.getY(s),
                      h = e.getZ(s);
                    l < t && (t = l),
                      c < n && (n = c),
                      h < r && (r = h),
                      l > i && (i = l),
                      c > a && (a = c),
                      h > o && (o = h);
                  }
                  return this.min.set(t, n, r), this.max.set(i, a, o), this;
                },
              },
              {
                key: "setFromPoints",
                value: function setFromPoints(e) {
                  this.makeEmpty();
                  for (var t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                  return this;
                },
              },
              {
                key: "setFromCenterAndSize",
                value: function setFromCenterAndSize(e, t) {
                  var n = lr.copy(t).multiplyScalar(0.5);
                  return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
                },
              },
              {
                key: "setFromObject",
                value: function setFromObject(e) {
                  var t =
                    arguments.length > 1 &&
                    void 0 !== arguments[1] &&
                    arguments[1];
                  return this.makeEmpty(), this.expandByObject(e, t);
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return this.min.copy(e.min), this.max.copy(e.max), this;
                },
              },
              {
                key: "makeEmpty",
                value: function makeEmpty() {
                  return (
                    (this.min.x = this.min.y = this.min.z = 1 / 0),
                    (this.max.x = this.max.y = this.max.z = -1 / 0),
                    this
                  );
                },
              },
              {
                key: "isEmpty",
                value: function isEmpty() {
                  return (
                    this.max.x < this.min.x ||
                    this.max.y < this.min.y ||
                    this.max.z < this.min.z
                  );
                },
              },
              {
                key: "getCenter",
                value: function getCenter(e) {
                  return this.isEmpty()
                    ? e.set(0, 0, 0)
                    : e.addVectors(this.min, this.max).multiplyScalar(0.5);
                },
              },
              {
                key: "getSize",
                value: function getSize(e) {
                  return this.isEmpty()
                    ? e.set(0, 0, 0)
                    : e.subVectors(this.max, this.min);
                },
              },
              {
                key: "expandByPoint",
                value: function expandByPoint(e) {
                  return this.min.min(e), this.max.max(e), this;
                },
              },
              {
                key: "expandByVector",
                value: function expandByVector(e) {
                  return this.min.sub(e), this.max.add(e), this;
                },
              },
              {
                key: "expandByScalar",
                value: function expandByScalar(e) {
                  return this.min.addScalar(-e), this.max.addScalar(e), this;
                },
              },
              {
                key: "expandByObject",
                value: function expandByObject(e) {
                  var t =
                    arguments.length > 1 &&
                    void 0 !== arguments[1] &&
                    arguments[1];
                  e.updateWorldMatrix(!1, !1);
                  var n = e.geometry;
                  if (void 0 !== n)
                    if (
                      t &&
                      void 0 != n.attributes &&
                      void 0 !== n.attributes.position
                    )
                      for (
                        var r = n.attributes.position, i = 0, a = r.count;
                        i < a;
                        i++
                      )
                        lr
                          .fromBufferAttribute(r, i)
                          .applyMatrix4(e.matrixWorld),
                          this.expandByPoint(lr);
                    else
                      null === n.boundingBox && n.computeBoundingBox(),
                        cr.copy(n.boundingBox),
                        cr.applyMatrix4(e.matrixWorld),
                        this.union(cr);
                  for (var o = e.children, s = 0, u = o.length; s < u; s++)
                    this.expandByObject(o[s], t);
                  return this;
                },
              },
              {
                key: "containsPoint",
                value: function containsPoint(e) {
                  return !(
                    e.x < this.min.x ||
                    e.x > this.max.x ||
                    e.y < this.min.y ||
                    e.y > this.max.y ||
                    e.z < this.min.z ||
                    e.z > this.max.z
                  );
                },
              },
              {
                key: "containsBox",
                value: function containsBox(e) {
                  return (
                    this.min.x <= e.min.x &&
                    e.max.x <= this.max.x &&
                    this.min.y <= e.min.y &&
                    e.max.y <= this.max.y &&
                    this.min.z <= e.min.z &&
                    e.max.z <= this.max.z
                  );
                },
              },
              {
                key: "getParameter",
                value: function getParameter(e, t) {
                  return t.set(
                    (e.x - this.min.x) / (this.max.x - this.min.x),
                    (e.y - this.min.y) / (this.max.y - this.min.y),
                    (e.z - this.min.z) / (this.max.z - this.min.z)
                  );
                },
              },
              {
                key: "intersectsBox",
                value: function intersectsBox(e) {
                  return !(
                    e.max.x < this.min.x ||
                    e.min.x > this.max.x ||
                    e.max.y < this.min.y ||
                    e.min.y > this.max.y ||
                    e.max.z < this.min.z ||
                    e.min.z > this.max.z
                  );
                },
              },
              {
                key: "intersectsSphere",
                value: function intersectsSphere(e) {
                  return (
                    this.clampPoint(e.center, lr),
                    lr.distanceToSquared(e.center) <= e.radius * e.radius
                  );
                },
              },
              {
                key: "intersectsPlane",
                value: function intersectsPlane(e) {
                  var t, n;
                  return (
                    e.normal.x > 0
                      ? ((t = e.normal.x * this.min.x),
                        (n = e.normal.x * this.max.x))
                      : ((t = e.normal.x * this.max.x),
                        (n = e.normal.x * this.min.x)),
                    e.normal.y > 0
                      ? ((t += e.normal.y * this.min.y),
                        (n += e.normal.y * this.max.y))
                      : ((t += e.normal.y * this.max.y),
                        (n += e.normal.y * this.min.y)),
                    e.normal.z > 0
                      ? ((t += e.normal.z * this.min.z),
                        (n += e.normal.z * this.max.z))
                      : ((t += e.normal.z * this.max.z),
                        (n += e.normal.z * this.min.z)),
                    t <= -e.constant && n >= -e.constant
                  );
                },
              },
              {
                key: "intersectsTriangle",
                value: function intersectsTriangle(e) {
                  if (this.isEmpty()) return !1;
                  this.getCenter(gr),
                    yr.subVectors(this.max, gr),
                    hr.subVectors(e.a, gr),
                    dr.subVectors(e.b, gr),
                    fr.subVectors(e.c, gr),
                    pr.subVectors(dr, hr),
                    mr.subVectors(fr, dr),
                    vr.subVectors(hr, fr);
                  var t = [
                    0,
                    -pr.z,
                    pr.y,
                    0,
                    -mr.z,
                    mr.y,
                    0,
                    -vr.z,
                    vr.y,
                    pr.z,
                    0,
                    -pr.x,
                    mr.z,
                    0,
                    -mr.x,
                    vr.z,
                    0,
                    -vr.x,
                    -pr.y,
                    pr.x,
                    0,
                    -mr.y,
                    mr.x,
                    0,
                    -vr.y,
                    vr.x,
                    0,
                  ];
                  return (
                    !!satForAxes(t, hr, dr, fr, yr) &&
                    !!satForAxes(
                      (t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                      hr,
                      dr,
                      fr,
                      yr
                    ) &&
                    (br.crossVectors(pr, mr),
                    satForAxes((t = [br.x, br.y, br.z]), hr, dr, fr, yr))
                  );
                },
              },
              {
                key: "clampPoint",
                value: function clampPoint(e, t) {
                  return t.copy(e).clamp(this.min, this.max);
                },
              },
              {
                key: "distanceToPoint",
                value: function distanceToPoint(e) {
                  return lr.copy(e).clamp(this.min, this.max).sub(e).length();
                },
              },
              {
                key: "getBoundingSphere",
                value: function getBoundingSphere(e) {
                  return (
                    this.getCenter(e.center),
                    (e.radius = 0.5 * this.getSize(lr).length()),
                    e
                  );
                },
              },
              {
                key: "intersect",
                value: function intersect(e) {
                  return (
                    this.min.max(e.min),
                    this.max.min(e.max),
                    this.isEmpty() && this.makeEmpty(),
                    this
                  );
                },
              },
              {
                key: "union",
                value: function union(e) {
                  return this.min.min(e.min), this.max.max(e.max), this;
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  return this.isEmpty()
                    ? this
                    : (ur[0]
                        .set(this.min.x, this.min.y, this.min.z)
                        .applyMatrix4(e),
                      ur[1]
                        .set(this.min.x, this.min.y, this.max.z)
                        .applyMatrix4(e),
                      ur[2]
                        .set(this.min.x, this.max.y, this.min.z)
                        .applyMatrix4(e),
                      ur[3]
                        .set(this.min.x, this.max.y, this.max.z)
                        .applyMatrix4(e),
                      ur[4]
                        .set(this.max.x, this.min.y, this.min.z)
                        .applyMatrix4(e),
                      ur[5]
                        .set(this.max.x, this.min.y, this.max.z)
                        .applyMatrix4(e),
                      ur[6]
                        .set(this.max.x, this.max.y, this.min.z)
                        .applyMatrix4(e),
                      ur[7]
                        .set(this.max.x, this.max.y, this.max.z)
                        .applyMatrix4(e),
                      this.setFromPoints(ur),
                      this);
                },
              },
              {
                key: "translate",
                value: function translate(e) {
                  return this.min.add(e), this.max.add(e), this;
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return e.min.equals(this.min) && e.max.equals(this.max);
                },
              },
            ]),
            Box3
          );
        })(),
        ur = [
          new ir(),
          new ir(),
          new ir(),
          new ir(),
          new ir(),
          new ir(),
          new ir(),
          new ir(),
        ],
        lr = new ir(),
        cr = new sr(),
        hr = new ir(),
        dr = new ir(),
        fr = new ir(),
        pr = new ir(),
        mr = new ir(),
        vr = new ir(),
        gr = new ir(),
        yr = new ir(),
        br = new ir(),
        xr = new ir();
      function satForAxes(e, t, n, r, i) {
        for (var a = 0, o = e.length - 3; a <= o; a += 3) {
          xr.fromArray(e, a);
          var s =
              i.x * Math.abs(xr.x) +
              i.y * Math.abs(xr.y) +
              i.z * Math.abs(xr.z),
            u = t.dot(xr),
            l = n.dot(xr),
            c = r.dot(xr);
          if (Math.max(-Math.max(u, l, c), Math.min(u, l, c)) > s) return !1;
        }
        return !0;
      }
      var _r = new sr(),
        Mr = new ir(),
        Sr = new ir(),
        wr = new ir(),
        Tr = (function () {
          function Sphere() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : -1;
            Object(f.a)(this, Sphere), (this.center = e), (this.radius = t);
          }
          return (
            Object(p.a)(Sphere, [
              {
                key: "set",
                value: function set(e, t) {
                  return this.center.copy(e), (this.radius = t), this;
                },
              },
              {
                key: "setFromPoints",
                value: function setFromPoints(e, t) {
                  var n = this.center;
                  void 0 !== t ? n.copy(t) : _r.setFromPoints(e).getCenter(n);
                  for (var r = 0, i = 0, a = e.length; i < a; i++)
                    r = Math.max(r, n.distanceToSquared(e[i]));
                  return (this.radius = Math.sqrt(r)), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    this.center.copy(e.center), (this.radius = e.radius), this
                  );
                },
              },
              {
                key: "isEmpty",
                value: function isEmpty() {
                  return this.radius < 0;
                },
              },
              {
                key: "makeEmpty",
                value: function makeEmpty() {
                  return this.center.set(0, 0, 0), (this.radius = -1), this;
                },
              },
              {
                key: "containsPoint",
                value: function containsPoint(e) {
                  return (
                    e.distanceToSquared(this.center) <=
                    this.radius * this.radius
                  );
                },
              },
              {
                key: "distanceToPoint",
                value: function distanceToPoint(e) {
                  return e.distanceTo(this.center) - this.radius;
                },
              },
              {
                key: "intersectsSphere",
                value: function intersectsSphere(e) {
                  var t = this.radius + e.radius;
                  return e.center.distanceToSquared(this.center) <= t * t;
                },
              },
              {
                key: "intersectsBox",
                value: function intersectsBox(e) {
                  return e.intersectsSphere(this);
                },
              },
              {
                key: "intersectsPlane",
                value: function intersectsPlane(e) {
                  return (
                    Math.abs(e.distanceToPoint(this.center)) <= this.radius
                  );
                },
              },
              {
                key: "clampPoint",
                value: function clampPoint(e, t) {
                  var n = this.center.distanceToSquared(e);
                  return (
                    t.copy(e),
                    n > this.radius * this.radius &&
                      (t.sub(this.center).normalize(),
                      t.multiplyScalar(this.radius).add(this.center)),
                    t
                  );
                },
              },
              {
                key: "getBoundingBox",
                value: function getBoundingBox(e) {
                  return this.isEmpty()
                    ? (e.makeEmpty(), e)
                    : (e.set(this.center, this.center),
                      e.expandByScalar(this.radius),
                      e);
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  return (
                    this.center.applyMatrix4(e),
                    (this.radius = this.radius * e.getMaxScaleOnAxis()),
                    this
                  );
                },
              },
              {
                key: "translate",
                value: function translate(e) {
                  return this.center.add(e), this;
                },
              },
              {
                key: "expandByPoint",
                value: function expandByPoint(e) {
                  wr.subVectors(e, this.center);
                  var t = wr.lengthSq();
                  if (t > this.radius * this.radius) {
                    var n = Math.sqrt(t),
                      r = 0.5 * (n - this.radius);
                    this.center.add(wr.multiplyScalar(r / n)),
                      (this.radius += r);
                  }
                  return this;
                },
              },
              {
                key: "union",
                value: function union(e) {
                  return (
                    !0 === this.center.equals(e.center)
                      ? Sr.set(0, 0, 1).multiplyScalar(e.radius)
                      : Sr.subVectors(e.center, this.center)
                          .normalize()
                          .multiplyScalar(e.radius),
                    this.expandByPoint(Mr.copy(e.center).add(Sr)),
                    this.expandByPoint(Mr.copy(e.center).sub(Sr)),
                    this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return (
                    e.center.equals(this.center) && e.radius === this.radius
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Sphere
          );
        })(),
        Ar = new ir(),
        Or = new ir(),
        Cr = new ir(),
        Lr = new ir(),
        kr = new ir(),
        Er = new ir(),
        Pr = new ir(),
        Rr = (function () {
          function Ray() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir(0, 0, -1);
            Object(f.a)(this, Ray), (this.origin = e), (this.direction = t);
          }
          return (
            Object(p.a)(Ray, [
              {
                key: "set",
                value: function set(e, t) {
                  return this.origin.copy(e), this.direction.copy(t), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    this.origin.copy(e.origin),
                    this.direction.copy(e.direction),
                    this
                  );
                },
              },
              {
                key: "at",
                value: function at(e, t) {
                  return t
                    .copy(this.direction)
                    .multiplyScalar(e)
                    .add(this.origin);
                },
              },
              {
                key: "lookAt",
                value: function lookAt(e) {
                  return (
                    this.direction.copy(e).sub(this.origin).normalize(), this
                  );
                },
              },
              {
                key: "recast",
                value: function recast(e) {
                  return this.origin.copy(this.at(e, Ar)), this;
                },
              },
              {
                key: "closestPointToPoint",
                value: function closestPointToPoint(e, t) {
                  t.subVectors(e, this.origin);
                  var n = t.dot(this.direction);
                  return n < 0
                    ? t.copy(this.origin)
                    : t.copy(this.direction).multiplyScalar(n).add(this.origin);
                },
              },
              {
                key: "distanceToPoint",
                value: function distanceToPoint(e) {
                  return Math.sqrt(this.distanceSqToPoint(e));
                },
              },
              {
                key: "distanceSqToPoint",
                value: function distanceSqToPoint(e) {
                  var t = Ar.subVectors(e, this.origin).dot(this.direction);
                  return t < 0
                    ? this.origin.distanceToSquared(e)
                    : (Ar.copy(this.direction)
                        .multiplyScalar(t)
                        .add(this.origin),
                      Ar.distanceToSquared(e));
                },
              },
              {
                key: "distanceSqToSegment",
                value: function distanceSqToSegment(e, t, n, r) {
                  Or.copy(e).add(t).multiplyScalar(0.5),
                    Cr.copy(t).sub(e).normalize(),
                    Lr.copy(this.origin).sub(Or);
                  var i,
                    a,
                    o,
                    s,
                    u = 0.5 * e.distanceTo(t),
                    l = -this.direction.dot(Cr),
                    c = Lr.dot(this.direction),
                    h = -Lr.dot(Cr),
                    d = Lr.lengthSq(),
                    f = Math.abs(1 - l * l);
                  if (f > 0)
                    if (((a = l * c - h), (s = u * f), (i = l * h - c) >= 0))
                      if (a >= -s)
                        if (a <= s) {
                          var p = 1 / f;
                          o =
                            (i *= p) * (i + l * (a *= p) + 2 * c) +
                            a * (l * i + a + 2 * h) +
                            d;
                        } else
                          (a = u),
                            (o =
                              -(i = Math.max(0, -(l * a + c))) * i +
                              a * (a + 2 * h) +
                              d);
                      else
                        (a = -u),
                          (o =
                            -(i = Math.max(0, -(l * a + c))) * i +
                            a * (a + 2 * h) +
                            d);
                    else
                      a <= -s
                        ? (o =
                            -(i = Math.max(0, -(-l * u + c))) * i +
                            (a = i > 0 ? -u : Math.min(Math.max(-u, -h), u)) *
                              (a + 2 * h) +
                            d)
                        : a <= s
                        ? ((i = 0),
                          (o =
                            (a = Math.min(Math.max(-u, -h), u)) * (a + 2 * h) +
                            d))
                        : (o =
                            -(i = Math.max(0, -(l * u + c))) * i +
                            (a = i > 0 ? u : Math.min(Math.max(-u, -h), u)) *
                              (a + 2 * h) +
                            d);
                  else
                    (a = l > 0 ? -u : u),
                      (o =
                        -(i = Math.max(0, -(l * a + c))) * i +
                        a * (a + 2 * h) +
                        d);
                  return (
                    n &&
                      n.copy(this.direction).multiplyScalar(i).add(this.origin),
                    r && r.copy(Cr).multiplyScalar(a).add(Or),
                    o
                  );
                },
              },
              {
                key: "intersectSphere",
                value: function intersectSphere(e, t) {
                  Ar.subVectors(e.center, this.origin);
                  var n = Ar.dot(this.direction),
                    r = Ar.dot(Ar) - n * n,
                    i = e.radius * e.radius;
                  if (r > i) return null;
                  var a = Math.sqrt(i - r),
                    o = n - a,
                    s = n + a;
                  return o < 0 && s < 0
                    ? null
                    : o < 0
                    ? this.at(s, t)
                    : this.at(o, t);
                },
              },
              {
                key: "intersectsSphere",
                value: function intersectsSphere(e) {
                  return (
                    this.distanceSqToPoint(e.center) <= e.radius * e.radius
                  );
                },
              },
              {
                key: "distanceToPlane",
                value: function distanceToPlane(e) {
                  var t = e.normal.dot(this.direction);
                  if (0 === t)
                    return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                  var n = -(this.origin.dot(e.normal) + e.constant) / t;
                  return n >= 0 ? n : null;
                },
              },
              {
                key: "intersectPlane",
                value: function intersectPlane(e, t) {
                  var n = this.distanceToPlane(e);
                  return null === n ? null : this.at(n, t);
                },
              },
              {
                key: "intersectsPlane",
                value: function intersectsPlane(e) {
                  var t = e.distanceToPoint(this.origin);
                  return 0 === t || e.normal.dot(this.direction) * t < 0;
                },
              },
              {
                key: "intersectBox",
                value: function intersectBox(e, t) {
                  var n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    u = 1 / this.direction.x,
                    l = 1 / this.direction.y,
                    c = 1 / this.direction.z,
                    h = this.origin;
                  return (
                    u >= 0
                      ? ((n = (e.min.x - h.x) * u), (r = (e.max.x - h.x) * u))
                      : ((n = (e.max.x - h.x) * u), (r = (e.min.x - h.x) * u)),
                    l >= 0
                      ? ((i = (e.min.y - h.y) * l), (a = (e.max.y - h.y) * l))
                      : ((i = (e.max.y - h.y) * l), (a = (e.min.y - h.y) * l)),
                    n > a || i > r
                      ? null
                      : ((i > n || n !== n) && (n = i),
                        (a < r || r !== r) && (r = a),
                        c >= 0
                          ? ((o = (e.min.z - h.z) * c),
                            (s = (e.max.z - h.z) * c))
                          : ((o = (e.max.z - h.z) * c),
                            (s = (e.min.z - h.z) * c)),
                        n > s || o > r
                          ? null
                          : ((o > n || n !== n) && (n = o),
                            (s < r || r !== r) && (r = s),
                            r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                  );
                },
              },
              {
                key: "intersectsBox",
                value: function intersectsBox(e) {
                  return null !== this.intersectBox(e, Ar);
                },
              },
              {
                key: "intersectTriangle",
                value: function intersectTriangle(e, t, n, r, i) {
                  kr.subVectors(t, e),
                    Er.subVectors(n, e),
                    Pr.crossVectors(kr, Er);
                  var a,
                    o = this.direction.dot(Pr);
                  if (o > 0) {
                    if (r) return null;
                    a = 1;
                  } else {
                    if (!(o < 0)) return null;
                    (a = -1), (o = -o);
                  }
                  Lr.subVectors(this.origin, e);
                  var s = a * this.direction.dot(Er.crossVectors(Lr, Er));
                  if (s < 0) return null;
                  var u = a * this.direction.dot(kr.cross(Lr));
                  if (u < 0) return null;
                  if (s + u > o) return null;
                  var l = -a * Lr.dot(Pr);
                  return l < 0 ? null : this.at(l / o, i);
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  return (
                    this.origin.applyMatrix4(e),
                    this.direction.transformDirection(e),
                    this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return (
                    e.origin.equals(this.origin) &&
                    e.direction.equals(this.direction)
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Ray
          );
        })(),
        Ir = (function () {
          function Matrix4() {
            Object(f.a)(this, Matrix4),
              (Matrix4.prototype.isMatrix4 = !0),
              (this.elements = [
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]);
          }
          return (
            Object(p.a)(Matrix4, [
              {
                key: "set",
                value: function set(
                  e,
                  t,
                  n,
                  r,
                  i,
                  a,
                  o,
                  s,
                  u,
                  l,
                  c,
                  h,
                  d,
                  f,
                  p,
                  m
                ) {
                  var v = this.elements;
                  return (
                    (v[0] = e),
                    (v[4] = t),
                    (v[8] = n),
                    (v[12] = r),
                    (v[1] = i),
                    (v[5] = a),
                    (v[9] = o),
                    (v[13] = s),
                    (v[2] = u),
                    (v[6] = l),
                    (v[10] = c),
                    (v[14] = h),
                    (v[3] = d),
                    (v[7] = f),
                    (v[11] = p),
                    (v[15] = m),
                    this
                  );
                },
              },
              {
                key: "identity",
                value: function identity() {
                  return (
                    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new Matrix4().fromArray(this.elements);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  var t = this.elements,
                    n = e.elements;
                  return (
                    (t[0] = n[0]),
                    (t[1] = n[1]),
                    (t[2] = n[2]),
                    (t[3] = n[3]),
                    (t[4] = n[4]),
                    (t[5] = n[5]),
                    (t[6] = n[6]),
                    (t[7] = n[7]),
                    (t[8] = n[8]),
                    (t[9] = n[9]),
                    (t[10] = n[10]),
                    (t[11] = n[11]),
                    (t[12] = n[12]),
                    (t[13] = n[13]),
                    (t[14] = n[14]),
                    (t[15] = n[15]),
                    this
                  );
                },
              },
              {
                key: "copyPosition",
                value: function copyPosition(e) {
                  var t = this.elements,
                    n = e.elements;
                  return (
                    (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this
                  );
                },
              },
              {
                key: "setFromMatrix3",
                value: function setFromMatrix3(e) {
                  var t = e.elements;
                  return (
                    this.set(
                      t[0],
                      t[3],
                      t[6],
                      0,
                      t[1],
                      t[4],
                      t[7],
                      0,
                      t[2],
                      t[5],
                      t[8],
                      0,
                      0,
                      0,
                      0,
                      1
                    ),
                    this
                  );
                },
              },
              {
                key: "extractBasis",
                value: function extractBasis(e, t, n) {
                  return (
                    e.setFromMatrixColumn(this, 0),
                    t.setFromMatrixColumn(this, 1),
                    n.setFromMatrixColumn(this, 2),
                    this
                  );
                },
              },
              {
                key: "makeBasis",
                value: function makeBasis(e, t, n) {
                  return (
                    this.set(
                      e.x,
                      t.x,
                      n.x,
                      0,
                      e.y,
                      t.y,
                      n.y,
                      0,
                      e.z,
                      t.z,
                      n.z,
                      0,
                      0,
                      0,
                      0,
                      1
                    ),
                    this
                  );
                },
              },
              {
                key: "extractRotation",
                value: function extractRotation(e) {
                  var t = this.elements,
                    n = e.elements,
                    r = 1 / Dr.setFromMatrixColumn(e, 0).length(),
                    i = 1 / Dr.setFromMatrixColumn(e, 1).length(),
                    a = 1 / Dr.setFromMatrixColumn(e, 2).length();
                  return (
                    (t[0] = n[0] * r),
                    (t[1] = n[1] * r),
                    (t[2] = n[2] * r),
                    (t[3] = 0),
                    (t[4] = n[4] * i),
                    (t[5] = n[5] * i),
                    (t[6] = n[6] * i),
                    (t[7] = 0),
                    (t[8] = n[8] * a),
                    (t[9] = n[9] * a),
                    (t[10] = n[10] * a),
                    (t[11] = 0),
                    (t[12] = 0),
                    (t[13] = 0),
                    (t[14] = 0),
                    (t[15] = 1),
                    this
                  );
                },
              },
              {
                key: "makeRotationFromEuler",
                value: function makeRotationFromEuler(e) {
                  var t = this.elements,
                    n = e.x,
                    r = e.y,
                    i = e.z,
                    a = Math.cos(n),
                    o = Math.sin(n),
                    s = Math.cos(r),
                    u = Math.sin(r),
                    l = Math.cos(i),
                    c = Math.sin(i);
                  if ("XYZ" === e.order) {
                    var h = a * l,
                      d = a * c,
                      f = o * l,
                      p = o * c;
                    (t[0] = s * l),
                      (t[4] = -s * c),
                      (t[8] = u),
                      (t[1] = d + f * u),
                      (t[5] = h - p * u),
                      (t[9] = -o * s),
                      (t[2] = p - h * u),
                      (t[6] = f + d * u),
                      (t[10] = a * s);
                  } else if ("YXZ" === e.order) {
                    var m = s * l,
                      v = s * c,
                      g = u * l,
                      y = u * c;
                    (t[0] = m + y * o),
                      (t[4] = g * o - v),
                      (t[8] = a * u),
                      (t[1] = a * c),
                      (t[5] = a * l),
                      (t[9] = -o),
                      (t[2] = v * o - g),
                      (t[6] = y + m * o),
                      (t[10] = a * s);
                  } else if ("ZXY" === e.order) {
                    var b = s * l,
                      x = s * c,
                      _ = u * l,
                      M = u * c;
                    (t[0] = b - M * o),
                      (t[4] = -a * c),
                      (t[8] = _ + x * o),
                      (t[1] = x + _ * o),
                      (t[5] = a * l),
                      (t[9] = M - b * o),
                      (t[2] = -a * u),
                      (t[6] = o),
                      (t[10] = a * s);
                  } else if ("ZYX" === e.order) {
                    var S = a * l,
                      w = a * c,
                      T = o * l,
                      A = o * c;
                    (t[0] = s * l),
                      (t[4] = T * u - w),
                      (t[8] = S * u + A),
                      (t[1] = s * c),
                      (t[5] = A * u + S),
                      (t[9] = w * u - T),
                      (t[2] = -u),
                      (t[6] = o * s),
                      (t[10] = a * s);
                  } else if ("YZX" === e.order) {
                    var O = a * s,
                      C = a * u,
                      L = o * s,
                      k = o * u;
                    (t[0] = s * l),
                      (t[4] = k - O * c),
                      (t[8] = L * c + C),
                      (t[1] = c),
                      (t[5] = a * l),
                      (t[9] = -o * l),
                      (t[2] = -u * l),
                      (t[6] = C * c + L),
                      (t[10] = O - k * c);
                  } else if ("XZY" === e.order) {
                    var E = a * s,
                      P = a * u,
                      R = o * s,
                      I = o * u;
                    (t[0] = s * l),
                      (t[4] = -c),
                      (t[8] = u * l),
                      (t[1] = E * c + I),
                      (t[5] = a * l),
                      (t[9] = P * c - R),
                      (t[2] = R * c - P),
                      (t[6] = o * l),
                      (t[10] = I * c + E);
                  }
                  return (
                    (t[3] = 0),
                    (t[7] = 0),
                    (t[11] = 0),
                    (t[12] = 0),
                    (t[13] = 0),
                    (t[14] = 0),
                    (t[15] = 1),
                    this
                  );
                },
              },
              {
                key: "makeRotationFromQuaternion",
                value: function makeRotationFromQuaternion(e) {
                  return this.compose(Br, e, Nr);
                },
              },
              {
                key: "lookAt",
                value: function lookAt(e, t, n) {
                  var r = this.elements;
                  return (
                    Gr.subVectors(e, t),
                    0 === Gr.lengthSq() && (Gr.z = 1),
                    Gr.normalize(),
                    zr.crossVectors(n, Gr),
                    0 === zr.lengthSq() &&
                      (1 === Math.abs(n.z) ? (Gr.x += 1e-4) : (Gr.z += 1e-4),
                      Gr.normalize(),
                      zr.crossVectors(n, Gr)),
                    zr.normalize(),
                    Fr.crossVectors(Gr, zr),
                    (r[0] = zr.x),
                    (r[4] = Fr.x),
                    (r[8] = Gr.x),
                    (r[1] = zr.y),
                    (r[5] = Fr.y),
                    (r[9] = Gr.y),
                    (r[2] = zr.z),
                    (r[6] = Fr.z),
                    (r[10] = Gr.z),
                    this
                  );
                },
              },
              {
                key: "multiply",
                value: function multiply(e) {
                  return this.multiplyMatrices(this, e);
                },
              },
              {
                key: "premultiply",
                value: function premultiply(e) {
                  return this.multiplyMatrices(e, this);
                },
              },
              {
                key: "multiplyMatrices",
                value: function multiplyMatrices(e, t) {
                  var n = e.elements,
                    r = t.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[4],
                    s = n[8],
                    u = n[12],
                    l = n[1],
                    c = n[5],
                    h = n[9],
                    d = n[13],
                    f = n[2],
                    p = n[6],
                    m = n[10],
                    v = n[14],
                    g = n[3],
                    y = n[7],
                    b = n[11],
                    x = n[15],
                    _ = r[0],
                    M = r[4],
                    S = r[8],
                    w = r[12],
                    T = r[1],
                    A = r[5],
                    O = r[9],
                    C = r[13],
                    L = r[2],
                    k = r[6],
                    E = r[10],
                    P = r[14],
                    R = r[3],
                    I = r[7],
                    D = r[11],
                    j = r[15];
                  return (
                    (i[0] = a * _ + o * T + s * L + u * R),
                    (i[4] = a * M + o * A + s * k + u * I),
                    (i[8] = a * S + o * O + s * E + u * D),
                    (i[12] = a * w + o * C + s * P + u * j),
                    (i[1] = l * _ + c * T + h * L + d * R),
                    (i[5] = l * M + c * A + h * k + d * I),
                    (i[9] = l * S + c * O + h * E + d * D),
                    (i[13] = l * w + c * C + h * P + d * j),
                    (i[2] = f * _ + p * T + m * L + v * R),
                    (i[6] = f * M + p * A + m * k + v * I),
                    (i[10] = f * S + p * O + m * E + v * D),
                    (i[14] = f * w + p * C + m * P + v * j),
                    (i[3] = g * _ + y * T + b * L + x * R),
                    (i[7] = g * M + y * A + b * k + x * I),
                    (i[11] = g * S + y * O + b * E + x * D),
                    (i[15] = g * w + y * C + b * P + x * j),
                    this
                  );
                },
              },
              {
                key: "multiplyScalar",
                value: function multiplyScalar(e) {
                  var t = this.elements;
                  return (
                    (t[0] *= e),
                    (t[4] *= e),
                    (t[8] *= e),
                    (t[12] *= e),
                    (t[1] *= e),
                    (t[5] *= e),
                    (t[9] *= e),
                    (t[13] *= e),
                    (t[2] *= e),
                    (t[6] *= e),
                    (t[10] *= e),
                    (t[14] *= e),
                    (t[3] *= e),
                    (t[7] *= e),
                    (t[11] *= e),
                    (t[15] *= e),
                    this
                  );
                },
              },
              {
                key: "determinant",
                value: function determinant() {
                  var e = this.elements,
                    t = e[0],
                    n = e[4],
                    r = e[8],
                    i = e[12],
                    a = e[1],
                    o = e[5],
                    s = e[9],
                    u = e[13],
                    l = e[2],
                    c = e[6],
                    h = e[10],
                    d = e[14];
                  return (
                    e[3] *
                      (+i * s * c -
                        r * u * c -
                        i * o * h +
                        n * u * h +
                        r * o * d -
                        n * s * d) +
                    e[7] *
                      (+t * s * d -
                        t * u * h +
                        i * a * h -
                        r * a * d +
                        r * u * l -
                        i * s * l) +
                    e[11] *
                      (+t * u * c -
                        t * o * d -
                        i * a * c +
                        n * a * d +
                        i * o * l -
                        n * u * l) +
                    e[15] *
                      (-r * o * l -
                        t * s * c +
                        t * o * h +
                        r * a * c -
                        n * a * h +
                        n * s * l)
                  );
                },
              },
              {
                key: "transpose",
                value: function transpose() {
                  var e,
                    t = this.elements;
                  return (
                    (e = t[1]),
                    (t[1] = t[4]),
                    (t[4] = e),
                    (e = t[2]),
                    (t[2] = t[8]),
                    (t[8] = e),
                    (e = t[6]),
                    (t[6] = t[9]),
                    (t[9] = e),
                    (e = t[3]),
                    (t[3] = t[12]),
                    (t[12] = e),
                    (e = t[7]),
                    (t[7] = t[13]),
                    (t[13] = e),
                    (e = t[11]),
                    (t[11] = t[14]),
                    (t[14] = e),
                    this
                  );
                },
              },
              {
                key: "setPosition",
                value: function setPosition(e, t, n) {
                  var r = this.elements;
                  return (
                    e.isVector3
                      ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
                      : ((r[12] = e), (r[13] = t), (r[14] = n)),
                    this
                  );
                },
              },
              {
                key: "invert",
                value: function invert() {
                  var e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    a = e[4],
                    o = e[5],
                    s = e[6],
                    u = e[7],
                    l = e[8],
                    c = e[9],
                    h = e[10],
                    d = e[11],
                    f = e[12],
                    p = e[13],
                    m = e[14],
                    v = e[15],
                    g =
                      c * m * u -
                      p * h * u +
                      p * s * d -
                      o * m * d -
                      c * s * v +
                      o * h * v,
                    y =
                      f * h * u -
                      l * m * u -
                      f * s * d +
                      a * m * d +
                      l * s * v -
                      a * h * v,
                    b =
                      l * p * u -
                      f * c * u +
                      f * o * d -
                      a * p * d -
                      l * o * v +
                      a * c * v,
                    x =
                      f * c * s -
                      l * p * s -
                      f * o * h +
                      a * p * h +
                      l * o * m -
                      a * c * m,
                    _ = t * g + n * y + r * b + i * x;
                  if (0 === _)
                    return this.set(
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                    );
                  var M = 1 / _;
                  return (
                    (e[0] = g * M),
                    (e[1] =
                      (p * h * i -
                        c * m * i -
                        p * r * d +
                        n * m * d +
                        c * r * v -
                        n * h * v) *
                      M),
                    (e[2] =
                      (o * m * i -
                        p * s * i +
                        p * r * u -
                        n * m * u -
                        o * r * v +
                        n * s * v) *
                      M),
                    (e[3] =
                      (c * s * i -
                        o * h * i -
                        c * r * u +
                        n * h * u +
                        o * r * d -
                        n * s * d) *
                      M),
                    (e[4] = y * M),
                    (e[5] =
                      (l * m * i -
                        f * h * i +
                        f * r * d -
                        t * m * d -
                        l * r * v +
                        t * h * v) *
                      M),
                    (e[6] =
                      (f * s * i -
                        a * m * i -
                        f * r * u +
                        t * m * u +
                        a * r * v -
                        t * s * v) *
                      M),
                    (e[7] =
                      (a * h * i -
                        l * s * i +
                        l * r * u -
                        t * h * u -
                        a * r * d +
                        t * s * d) *
                      M),
                    (e[8] = b * M),
                    (e[9] =
                      (f * c * i -
                        l * p * i -
                        f * n * d +
                        t * p * d +
                        l * n * v -
                        t * c * v) *
                      M),
                    (e[10] =
                      (a * p * i -
                        f * o * i +
                        f * n * u -
                        t * p * u -
                        a * n * v +
                        t * o * v) *
                      M),
                    (e[11] =
                      (l * o * i -
                        a * c * i -
                        l * n * u +
                        t * c * u +
                        a * n * d -
                        t * o * d) *
                      M),
                    (e[12] = x * M),
                    (e[13] =
                      (l * p * r -
                        f * c * r +
                        f * n * h -
                        t * p * h -
                        l * n * m +
                        t * c * m) *
                      M),
                    (e[14] =
                      (f * o * r -
                        a * p * r -
                        f * n * s +
                        t * p * s +
                        a * n * m -
                        t * o * m) *
                      M),
                    (e[15] =
                      (a * c * r -
                        l * o * r +
                        l * n * s -
                        t * c * s -
                        a * n * h +
                        t * o * h) *
                      M),
                    this
                  );
                },
              },
              {
                key: "scale",
                value: function scale(e) {
                  var t = this.elements,
                    n = e.x,
                    r = e.y,
                    i = e.z;
                  return (
                    (t[0] *= n),
                    (t[4] *= r),
                    (t[8] *= i),
                    (t[1] *= n),
                    (t[5] *= r),
                    (t[9] *= i),
                    (t[2] *= n),
                    (t[6] *= r),
                    (t[10] *= i),
                    (t[3] *= n),
                    (t[7] *= r),
                    (t[11] *= i),
                    this
                  );
                },
              },
              {
                key: "getMaxScaleOnAxis",
                value: function getMaxScaleOnAxis() {
                  var e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                  return Math.sqrt(Math.max(t, n, r));
                },
              },
              {
                key: "makeTranslation",
                value: function makeTranslation(e, t, n) {
                  return (
                    this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "makeRotationX",
                value: function makeRotationX(e) {
                  var t = Math.cos(e),
                    n = Math.sin(e);
                  return (
                    this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "makeRotationY",
                value: function makeRotationY(e) {
                  var t = Math.cos(e),
                    n = Math.sin(e);
                  return (
                    this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "makeRotationZ",
                value: function makeRotationZ(e) {
                  var t = Math.cos(e),
                    n = Math.sin(e);
                  return (
                    this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "makeRotationAxis",
                value: function makeRotationAxis(e, t) {
                  var n = Math.cos(t),
                    r = Math.sin(t),
                    i = 1 - n,
                    a = e.x,
                    o = e.y,
                    s = e.z,
                    u = i * a,
                    l = i * o;
                  return (
                    this.set(
                      u * a + n,
                      u * o - r * s,
                      u * s + r * o,
                      0,
                      u * o + r * s,
                      l * o + n,
                      l * s - r * a,
                      0,
                      u * s - r * o,
                      l * s + r * a,
                      i * s * s + n,
                      0,
                      0,
                      0,
                      0,
                      1
                    ),
                    this
                  );
                },
              },
              {
                key: "makeScale",
                value: function makeScale(e, t, n) {
                  return (
                    this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "makeShear",
                value: function makeShear(e, t, n, r, i, a) {
                  return (
                    this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1),
                    this
                  );
                },
              },
              {
                key: "compose",
                value: function compose(e, t, n) {
                  var r = this.elements,
                    i = t._x,
                    a = t._y,
                    o = t._z,
                    s = t._w,
                    u = i + i,
                    l = a + a,
                    c = o + o,
                    h = i * u,
                    d = i * l,
                    f = i * c,
                    p = a * l,
                    m = a * c,
                    v = o * c,
                    g = s * u,
                    y = s * l,
                    b = s * c,
                    x = n.x,
                    _ = n.y,
                    M = n.z;
                  return (
                    (r[0] = (1 - (p + v)) * x),
                    (r[1] = (d + b) * x),
                    (r[2] = (f - y) * x),
                    (r[3] = 0),
                    (r[4] = (d - b) * _),
                    (r[5] = (1 - (h + v)) * _),
                    (r[6] = (m + g) * _),
                    (r[7] = 0),
                    (r[8] = (f + y) * M),
                    (r[9] = (m - g) * M),
                    (r[10] = (1 - (h + p)) * M),
                    (r[11] = 0),
                    (r[12] = e.x),
                    (r[13] = e.y),
                    (r[14] = e.z),
                    (r[15] = 1),
                    this
                  );
                },
              },
              {
                key: "decompose",
                value: function decompose(e, t, n) {
                  var r = this.elements,
                    i = Dr.set(r[0], r[1], r[2]).length(),
                    a = Dr.set(r[4], r[5], r[6]).length(),
                    o = Dr.set(r[8], r[9], r[10]).length();
                  this.determinant() < 0 && (i = -i),
                    (e.x = r[12]),
                    (e.y = r[13]),
                    (e.z = r[14]),
                    jr.copy(this);
                  var s = 1 / i,
                    u = 1 / a,
                    l = 1 / o;
                  return (
                    (jr.elements[0] *= s),
                    (jr.elements[1] *= s),
                    (jr.elements[2] *= s),
                    (jr.elements[4] *= u),
                    (jr.elements[5] *= u),
                    (jr.elements[6] *= u),
                    (jr.elements[8] *= l),
                    (jr.elements[9] *= l),
                    (jr.elements[10] *= l),
                    t.setFromRotationMatrix(jr),
                    (n.x = i),
                    (n.y = a),
                    (n.z = o),
                    this
                  );
                },
              },
              {
                key: "makePerspective",
                value: function makePerspective(e, t, n, r, i, a) {
                  var o = this.elements,
                    s = (2 * i) / (t - e),
                    u = (2 * i) / (n - r),
                    l = (t + e) / (t - e),
                    c = (n + r) / (n - r),
                    h = -(a + i) / (a - i),
                    d = (-2 * a * i) / (a - i);
                  return (
                    (o[0] = s),
                    (o[4] = 0),
                    (o[8] = l),
                    (o[12] = 0),
                    (o[1] = 0),
                    (o[5] = u),
                    (o[9] = c),
                    (o[13] = 0),
                    (o[2] = 0),
                    (o[6] = 0),
                    (o[10] = h),
                    (o[14] = d),
                    (o[3] = 0),
                    (o[7] = 0),
                    (o[11] = -1),
                    (o[15] = 0),
                    this
                  );
                },
              },
              {
                key: "makeOrthographic",
                value: function makeOrthographic(e, t, n, r, i, a) {
                  var o = this.elements,
                    s = 1 / (t - e),
                    u = 1 / (n - r),
                    l = 1 / (a - i),
                    c = (t + e) * s,
                    h = (n + r) * u,
                    d = (a + i) * l;
                  return (
                    (o[0] = 2 * s),
                    (o[4] = 0),
                    (o[8] = 0),
                    (o[12] = -c),
                    (o[1] = 0),
                    (o[5] = 2 * u),
                    (o[9] = 0),
                    (o[13] = -h),
                    (o[2] = 0),
                    (o[6] = 0),
                    (o[10] = -2 * l),
                    (o[14] = -d),
                    (o[3] = 0),
                    (o[7] = 0),
                    (o[11] = 0),
                    (o[15] = 1),
                    this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  for (
                    var t = this.elements, n = e.elements, r = 0;
                    r < 16;
                    r++
                  )
                    if (t[r] !== n[r]) return !1;
                  return !0;
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  for (
                    var t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 0,
                      n = 0;
                    n < 16;
                    n++
                  )
                    this.elements[n] = e[n + t];
                  return this;
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0,
                    n = this.elements;
                  return (
                    (e[t] = n[0]),
                    (e[t + 1] = n[1]),
                    (e[t + 2] = n[2]),
                    (e[t + 3] = n[3]),
                    (e[t + 4] = n[4]),
                    (e[t + 5] = n[5]),
                    (e[t + 6] = n[6]),
                    (e[t + 7] = n[7]),
                    (e[t + 8] = n[8]),
                    (e[t + 9] = n[9]),
                    (e[t + 10] = n[10]),
                    (e[t + 11] = n[11]),
                    (e[t + 12] = n[12]),
                    (e[t + 13] = n[13]),
                    (e[t + 14] = n[14]),
                    (e[t + 15] = n[15]),
                    e
                  );
                },
              },
            ]),
            Matrix4
          );
        })(),
        Dr = new ir(),
        jr = new Ir(),
        Br = new ir(0, 0, 0),
        Nr = new ir(1, 1, 1),
        zr = new ir(),
        Fr = new ir(),
        Gr = new ir(),
        Ur = new Ir(),
        Vr = new rr(),
        Wr = (function () {
          function Euler() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : Euler.DefaultOrder;
            Object(f.a)(this, Euler),
              (this.isEuler = !0),
              (this._x = e),
              (this._y = t),
              (this._z = n),
              (this._order = r);
          }
          return (
            Object(p.a)(Euler, [
              {
                key: "set",
                value: function set(e, t, n) {
                  var r =
                    arguments.length > 3 && void 0 !== arguments[3]
                      ? arguments[3]
                      : this._order;
                  return (
                    (this._x = e),
                    (this._y = t),
                    (this._z = n),
                    (this._order = r),
                    this._onChangeCallback(),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(
                    this._x,
                    this._y,
                    this._z,
                    this._order
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this._x = e._x),
                    (this._y = e._y),
                    (this._z = e._z),
                    (this._order = e._order),
                    this._onChangeCallback(),
                    this
                  );
                },
              },
              {
                key: "setFromRotationMatrix",
                value: function setFromRotationMatrix(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : this._order,
                    n =
                      !(arguments.length > 2 && void 0 !== arguments[2]) ||
                      arguments[2],
                    r = e.elements,
                    i = r[0],
                    a = r[4],
                    o = r[8],
                    s = r[1],
                    u = r[5],
                    l = r[9],
                    c = r[2],
                    h = r[6],
                    d = r[10];
                  switch (t) {
                    case "XYZ":
                      (this._y = Math.asin(clamp(o, -1, 1))),
                        Math.abs(o) < 0.9999999
                          ? ((this._x = Math.atan2(-l, d)),
                            (this._z = Math.atan2(-a, i)))
                          : ((this._x = Math.atan2(h, u)), (this._z = 0));
                      break;
                    case "YXZ":
                      (this._x = Math.asin(-clamp(l, -1, 1))),
                        Math.abs(l) < 0.9999999
                          ? ((this._y = Math.atan2(o, d)),
                            (this._z = Math.atan2(s, u)))
                          : ((this._y = Math.atan2(-c, i)), (this._z = 0));
                      break;
                    case "ZXY":
                      (this._x = Math.asin(clamp(h, -1, 1))),
                        Math.abs(h) < 0.9999999
                          ? ((this._y = Math.atan2(-c, d)),
                            (this._z = Math.atan2(-a, u)))
                          : ((this._y = 0), (this._z = Math.atan2(s, i)));
                      break;
                    case "ZYX":
                      (this._y = Math.asin(-clamp(c, -1, 1))),
                        Math.abs(c) < 0.9999999
                          ? ((this._x = Math.atan2(h, d)),
                            (this._z = Math.atan2(s, i)))
                          : ((this._x = 0), (this._z = Math.atan2(-a, u)));
                      break;
                    case "YZX":
                      (this._z = Math.asin(clamp(s, -1, 1))),
                        Math.abs(s) < 0.9999999
                          ? ((this._x = Math.atan2(-l, u)),
                            (this._y = Math.atan2(-c, i)))
                          : ((this._x = 0), (this._y = Math.atan2(o, d)));
                      break;
                    case "XZY":
                      (this._z = Math.asin(-clamp(a, -1, 1))),
                        Math.abs(a) < 0.9999999
                          ? ((this._x = Math.atan2(h, u)),
                            (this._y = Math.atan2(o, i)))
                          : ((this._x = Math.atan2(-l, d)), (this._y = 0));
                      break;
                    default:
                      console.warn(
                        "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                          t
                      );
                  }
                  return (
                    (this._order = t),
                    !0 === n && this._onChangeCallback(),
                    this
                  );
                },
              },
              {
                key: "setFromQuaternion",
                value: function setFromQuaternion(e, t, n) {
                  return (
                    Ur.makeRotationFromQuaternion(e),
                    this.setFromRotationMatrix(Ur, t, n)
                  );
                },
              },
              {
                key: "setFromVector3",
                value: function setFromVector3(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this._order;
                  return this.set(e.x, e.y, e.z, t);
                },
              },
              {
                key: "reorder",
                value: function reorder(e) {
                  return Vr.setFromEuler(this), this.setFromQuaternion(Vr, e);
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return (
                    e._x === this._x &&
                    e._y === this._y &&
                    e._z === this._z &&
                    e._order === this._order
                  );
                },
              },
              {
                key: "fromArray",
                value: function fromArray(e) {
                  return (
                    (this._x = e[0]),
                    (this._y = e[1]),
                    (this._z = e[2]),
                    void 0 !== e[3] && (this._order = e[3]),
                    this._onChangeCallback(),
                    this
                  );
                },
              },
              {
                key: "toArray",
                value: function toArray() {
                  var e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : [],
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                  return (
                    (e[t] = this._x),
                    (e[t + 1] = this._y),
                    (e[t + 2] = this._z),
                    (e[t + 3] = this._order),
                    e
                  );
                },
              },
              {
                key: "_onChange",
                value: function _onChange(e) {
                  return (this._onChangeCallback = e), this;
                },
              },
              {
                key: "_onChangeCallback",
                value: function _onChangeCallback() {},
              },
              {
                key: Symbol.iterator,
                value: d.a.mark(function value() {
                  return d.a.wrap(
                    function value$(e) {
                      for (;;)
                        switch ((e.prev = e.next)) {
                          case 0:
                            return (e.next = 2), this._x;
                          case 2:
                            return (e.next = 4), this._y;
                          case 4:
                            return (e.next = 6), this._z;
                          case 6:
                            return (e.next = 8), this._order;
                          case 8:
                          case "end":
                            return e.stop();
                        }
                    },
                    value,
                    this
                  );
                }),
              },
              {
                key: "toVector3",
                value: function toVector3() {
                  console.error(
                    "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
                  );
                },
              },
              {
                key: "x",
                get: function get() {
                  return this._x;
                },
                set: function set(e) {
                  (this._x = e), this._onChangeCallback();
                },
              },
              {
                key: "y",
                get: function get() {
                  return this._y;
                },
                set: function set(e) {
                  (this._y = e), this._onChangeCallback();
                },
              },
              {
                key: "z",
                get: function get() {
                  return this._z;
                },
                set: function set(e) {
                  (this._z = e), this._onChangeCallback();
                },
              },
              {
                key: "order",
                get: function get() {
                  return this._order;
                },
                set: function set(e) {
                  (this._order = e), this._onChangeCallback();
                },
              },
            ]),
            Euler
          );
        })();
      (Wr.DefaultOrder = "XYZ"),
        (Wr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
      var Hr = (function () {
          function Layers() {
            Object(f.a)(this, Layers), (this.mask = 1);
          }
          return (
            Object(p.a)(Layers, [
              {
                key: "set",
                value: function set(e) {
                  this.mask = ((1 << e) | 0) >>> 0;
                },
              },
              {
                key: "enable",
                value: function enable(e) {
                  this.mask |= (1 << e) | 0;
                },
              },
              {
                key: "enableAll",
                value: function enableAll() {
                  this.mask = -1;
                },
              },
              {
                key: "toggle",
                value: function toggle(e) {
                  this.mask ^= (1 << e) | 0;
                },
              },
              {
                key: "disable",
                value: function disable(e) {
                  this.mask &= ~((1 << e) | 0);
                },
              },
              {
                key: "disableAll",
                value: function disableAll() {
                  this.mask = 0;
                },
              },
              {
                key: "test",
                value: function test(e) {
                  return 0 !== (this.mask & e.mask);
                },
              },
              {
                key: "isEnabled",
                value: function isEnabled(e) {
                  return 0 !== (this.mask & ((1 << e) | 0));
                },
              },
            ]),
            Layers
          );
        })(),
        qr = 0,
        Xr = new ir(),
        Jr = new rr(),
        Yr = new Ir(),
        Zr = new ir(),
        Kr = new ir(),
        Qr = new ir(),
        $r = new rr(),
        ei = new ir(1, 0, 0),
        ti = new ir(0, 1, 0),
        ni = new ir(0, 0, 1),
        ri = { type: "added" },
        ii = { type: "removed" },
        ai = (function (e) {
          function Object3D() {
            var e;
            Object(f.a)(this, Object3D),
              ((e = Object(s.a)(
                this,
                Object(r.a)(Object3D).call(this)
              )).isObject3D = !0),
              Object.defineProperty(Object(l.a)(Object(l.a)(e)), "id", {
                value: qr++,
              }),
              (e.uuid = generateUUID()),
              (e.name = ""),
              (e.type = "Object3D"),
              (e.parent = null),
              (e.children = []),
              (e.up = Object3D.DefaultUp.clone());
            var t = new ir(),
              n = new Wr(),
              i = new rr(),
              a = new ir(1, 1, 1);
            return (
              n._onChange(function onRotationChange() {
                i.setFromEuler(n, !1);
              }),
              i._onChange(function onQuaternionChange() {
                n.setFromQuaternion(i, void 0, !1);
              }),
              Object.defineProperties(Object(l.a)(Object(l.a)(e)), {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: n },
                quaternion: { configurable: !0, enumerable: !0, value: i },
                scale: { configurable: !0, enumerable: !0, value: a },
                modelViewMatrix: { value: new Ir() },
                normalMatrix: { value: new jn() },
              }),
              (e.matrix = new Ir()),
              (e.matrixWorld = new Ir()),
              (e.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate),
              (e.matrixWorldNeedsUpdate = !1),
              (e.layers = new Hr()),
              (e.visible = !0),
              (e.castShadow = !1),
              (e.receiveShadow = !1),
              (e.frustumCulled = !0),
              (e.renderOrder = 0),
              (e.animations = []),
              (e.userData = {}),
              e
            );
          }
          return (
            Object(u.a)(Object3D, e),
            Object(p.a)(Object3D, [
              { key: "onBeforeRender", value: function onBeforeRender() {} },
              { key: "onAfterRender", value: function onAfterRender() {} },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  this.matrixAutoUpdate && this.updateMatrix(),
                    this.matrix.premultiply(e),
                    this.matrix.decompose(
                      this.position,
                      this.quaternion,
                      this.scale
                    );
                },
              },
              {
                key: "applyQuaternion",
                value: function applyQuaternion(e) {
                  return this.quaternion.premultiply(e), this;
                },
              },
              {
                key: "setRotationFromAxisAngle",
                value: function setRotationFromAxisAngle(e, t) {
                  this.quaternion.setFromAxisAngle(e, t);
                },
              },
              {
                key: "setRotationFromEuler",
                value: function setRotationFromEuler(e) {
                  this.quaternion.setFromEuler(e, !0);
                },
              },
              {
                key: "setRotationFromMatrix",
                value: function setRotationFromMatrix(e) {
                  this.quaternion.setFromRotationMatrix(e);
                },
              },
              {
                key: "setRotationFromQuaternion",
                value: function setRotationFromQuaternion(e) {
                  this.quaternion.copy(e);
                },
              },
              {
                key: "rotateOnAxis",
                value: function rotateOnAxis(e, t) {
                  return (
                    Jr.setFromAxisAngle(e, t),
                    this.quaternion.multiply(Jr),
                    this
                  );
                },
              },
              {
                key: "rotateOnWorldAxis",
                value: function rotateOnWorldAxis(e, t) {
                  return (
                    Jr.setFromAxisAngle(e, t),
                    this.quaternion.premultiply(Jr),
                    this
                  );
                },
              },
              {
                key: "rotateX",
                value: function rotateX(e) {
                  return this.rotateOnAxis(ei, e);
                },
              },
              {
                key: "rotateY",
                value: function rotateY(e) {
                  return this.rotateOnAxis(ti, e);
                },
              },
              {
                key: "rotateZ",
                value: function rotateZ(e) {
                  return this.rotateOnAxis(ni, e);
                },
              },
              {
                key: "translateOnAxis",
                value: function translateOnAxis(e, t) {
                  return (
                    Xr.copy(e).applyQuaternion(this.quaternion),
                    this.position.add(Xr.multiplyScalar(t)),
                    this
                  );
                },
              },
              {
                key: "translateX",
                value: function translateX(e) {
                  return this.translateOnAxis(ei, e);
                },
              },
              {
                key: "translateY",
                value: function translateY(e) {
                  return this.translateOnAxis(ti, e);
                },
              },
              {
                key: "translateZ",
                value: function translateZ(e) {
                  return this.translateOnAxis(ni, e);
                },
              },
              {
                key: "localToWorld",
                value: function localToWorld(e) {
                  return e.applyMatrix4(this.matrixWorld);
                },
              },
              {
                key: "worldToLocal",
                value: function worldToLocal(e) {
                  return e.applyMatrix4(Yr.copy(this.matrixWorld).invert());
                },
              },
              {
                key: "lookAt",
                value: function lookAt(e, t, n) {
                  e.isVector3 ? Zr.copy(e) : Zr.set(e, t, n);
                  var r = this.parent;
                  this.updateWorldMatrix(!0, !1),
                    Kr.setFromMatrixPosition(this.matrixWorld),
                    this.isCamera || this.isLight
                      ? Yr.lookAt(Kr, Zr, this.up)
                      : Yr.lookAt(Zr, Kr, this.up),
                    this.quaternion.setFromRotationMatrix(Yr),
                    r &&
                      (Yr.extractRotation(r.matrixWorld),
                      Jr.setFromRotationMatrix(Yr),
                      this.quaternion.premultiply(Jr.invert()));
                },
              },
              {
                key: "add",
                value: function add(e) {
                  if (arguments.length > 1) {
                    for (var t = 0; t < arguments.length; t++)
                      this.add(arguments[t]);
                    return this;
                  }
                  return e === this
                    ? (console.error(
                        "THREE.Object3D.add: object can't be added as a child of itself.",
                        e
                      ),
                      this)
                    : (e && e.isObject3D
                        ? (null !== e.parent && e.parent.remove(e),
                          (e.parent = this),
                          this.children.push(e),
                          e.dispatchEvent(ri))
                        : console.error(
                            "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                            e
                          ),
                      this);
                },
              },
              {
                key: "remove",
                value: function remove(e) {
                  if (arguments.length > 1) {
                    for (var t = 0; t < arguments.length; t++)
                      this.remove(arguments[t]);
                    return this;
                  }
                  var n = this.children.indexOf(e);
                  return (
                    -1 !== n &&
                      ((e.parent = null),
                      this.children.splice(n, 1),
                      e.dispatchEvent(ii)),
                    this
                  );
                },
              },
              {
                key: "removeFromParent",
                value: function removeFromParent() {
                  var e = this.parent;
                  return null !== e && e.remove(this), this;
                },
              },
              {
                key: "clear",
                value: function clear() {
                  for (var e = 0; e < this.children.length; e++) {
                    var t = this.children[e];
                    (t.parent = null), t.dispatchEvent(ii);
                  }
                  return (this.children.length = 0), this;
                },
              },
              {
                key: "attach",
                value: function attach(e) {
                  return (
                    this.updateWorldMatrix(!0, !1),
                    Yr.copy(this.matrixWorld).invert(),
                    null !== e.parent &&
                      (e.parent.updateWorldMatrix(!0, !1),
                      Yr.multiply(e.parent.matrixWorld)),
                    e.applyMatrix4(Yr),
                    this.add(e),
                    e.updateWorldMatrix(!1, !0),
                    this
                  );
                },
              },
              {
                key: "getObjectById",
                value: function getObjectById(e) {
                  return this.getObjectByProperty("id", e);
                },
              },
              {
                key: "getObjectByName",
                value: function getObjectByName(e) {
                  return this.getObjectByProperty("name", e);
                },
              },
              {
                key: "getObjectByProperty",
                value: function getObjectByProperty(e, t) {
                  if (this[e] === t) return this;
                  for (var n = 0, r = this.children.length; n < r; n++) {
                    var i = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== i) return i;
                  }
                },
              },
              {
                key: "getWorldPosition",
                value: function getWorldPosition(e) {
                  return (
                    this.updateWorldMatrix(!0, !1),
                    e.setFromMatrixPosition(this.matrixWorld)
                  );
                },
              },
              {
                key: "getWorldQuaternion",
                value: function getWorldQuaternion(e) {
                  return (
                    this.updateWorldMatrix(!0, !1),
                    this.matrixWorld.decompose(Kr, e, Qr),
                    e
                  );
                },
              },
              {
                key: "getWorldScale",
                value: function getWorldScale(e) {
                  return (
                    this.updateWorldMatrix(!0, !1),
                    this.matrixWorld.decompose(Kr, $r, e),
                    e
                  );
                },
              },
              {
                key: "getWorldDirection",
                value: function getWorldDirection(e) {
                  this.updateWorldMatrix(!0, !1);
                  var t = this.matrixWorld.elements;
                  return e.set(t[8], t[9], t[10]).normalize();
                },
              },
              { key: "raycast", value: function raycast() {} },
              {
                key: "traverse",
                value: function traverse(e) {
                  e(this);
                  for (var t = this.children, n = 0, r = t.length; n < r; n++)
                    t[n].traverse(e);
                },
              },
              {
                key: "traverseVisible",
                value: function traverseVisible(e) {
                  if (!1 !== this.visible) {
                    e(this);
                    for (var t = this.children, n = 0, r = t.length; n < r; n++)
                      t[n].traverseVisible(e);
                  }
                },
              },
              {
                key: "traverseAncestors",
                value: function traverseAncestors(e) {
                  var t = this.parent;
                  null !== t && (e(t), t.traverseAncestors(e));
                },
              },
              {
                key: "updateMatrix",
                value: function updateMatrix() {
                  this.matrix.compose(
                    this.position,
                    this.quaternion,
                    this.scale
                  ),
                    (this.matrixWorldNeedsUpdate = !0);
                },
              },
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  this.matrixAutoUpdate && this.updateMatrix(),
                    (this.matrixWorldNeedsUpdate || e) &&
                      (null === this.parent
                        ? this.matrixWorld.copy(this.matrix)
                        : this.matrixWorld.multiplyMatrices(
                            this.parent.matrixWorld,
                            this.matrix
                          ),
                      (this.matrixWorldNeedsUpdate = !1),
                      (e = !0));
                  for (var t = this.children, n = 0, r = t.length; n < r; n++)
                    t[n].updateMatrixWorld(e);
                },
              },
              {
                key: "updateWorldMatrix",
                value: function updateWorldMatrix(e, t) {
                  var n = this.parent;
                  if (
                    (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                    this.matrixAutoUpdate && this.updateMatrix(),
                    null === this.parent
                      ? this.matrixWorld.copy(this.matrix)
                      : this.matrixWorld.multiplyMatrices(
                          this.parent.matrixWorld,
                          this.matrix
                        ),
                    !0 === t)
                  )
                    for (var r = this.children, i = 0, a = r.length; i < a; i++)
                      r[i].updateWorldMatrix(!1, !0);
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = void 0 === e || "string" === typeof e,
                    n = {};
                  t &&
                    ((e = {
                      geometries: {},
                      materials: {},
                      textures: {},
                      images: {},
                      shapes: {},
                      skeletons: {},
                      animations: {},
                      nodes: {},
                    }),
                    (n.metadata = {
                      version: 4.5,
                      type: "Object",
                      generator: "Object3D.toJSON",
                    }));
                  var r = {};
                  function serialize(t, n) {
                    return (
                      void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    );
                  }
                  if (
                    ((r.uuid = this.uuid),
                    (r.type = this.type),
                    "" !== this.name && (r.name = this.name),
                    !0 === this.castShadow && (r.castShadow = !0),
                    !0 === this.receiveShadow && (r.receiveShadow = !0),
                    !1 === this.visible && (r.visible = !1),
                    !1 === this.frustumCulled && (r.frustumCulled = !1),
                    0 !== this.renderOrder &&
                      (r.renderOrder = this.renderOrder),
                    "{}" !== JSON.stringify(this.userData) &&
                      (r.userData = this.userData),
                    (r.layers = this.layers.mask),
                    (r.matrix = this.matrix.toArray()),
                    !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                    this.isInstancedMesh &&
                      ((r.type = "InstancedMesh"),
                      (r.count = this.count),
                      (r.instanceMatrix = this.instanceMatrix.toJSON()),
                      null !== this.instanceColor &&
                        (r.instanceColor = this.instanceColor.toJSON())),
                    this.isScene)
                  )
                    this.background &&
                      (this.background.isColor
                        ? (r.background = this.background.toJSON())
                        : this.background.isTexture &&
                          (r.background = this.background.toJSON(e).uuid)),
                      this.environment &&
                        this.environment.isTexture &&
                        !0 !== this.environment.isRenderTargetTexture &&
                        (r.environment = this.environment.toJSON(e).uuid);
                  else if (this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = serialize(e.geometries, this.geometry);
                    var i = this.geometry.parameters;
                    if (void 0 !== i && void 0 !== i.shapes) {
                      var a = i.shapes;
                      if (Array.isArray(a))
                        for (var o = 0, s = a.length; o < s; o++) {
                          var u = a[o];
                          serialize(e.shapes, u);
                        }
                      else serialize(e.shapes, a);
                    }
                  }
                  if (
                    (this.isSkinnedMesh &&
                      ((r.bindMode = this.bindMode),
                      (r.bindMatrix = this.bindMatrix.toArray()),
                      void 0 !== this.skeleton &&
                        (serialize(e.skeletons, this.skeleton),
                        (r.skeleton = this.skeleton.uuid))),
                    void 0 !== this.material)
                  )
                    if (Array.isArray(this.material)) {
                      for (
                        var l = [], c = 0, h = this.material.length;
                        c < h;
                        c++
                      )
                        l.push(serialize(e.materials, this.material[c]));
                      r.material = l;
                    } else r.material = serialize(e.materials, this.material);
                  if (this.children.length > 0) {
                    r.children = [];
                    for (var d = 0; d < this.children.length; d++)
                      r.children.push(this.children[d].toJSON(e).object);
                  }
                  if (this.animations.length > 0) {
                    r.animations = [];
                    for (var f = 0; f < this.animations.length; f++) {
                      var p = this.animations[f];
                      r.animations.push(serialize(e.animations, p));
                    }
                  }
                  if (t) {
                    var m = extractFromCache(e.geometries),
                      v = extractFromCache(e.materials),
                      g = extractFromCache(e.textures),
                      y = extractFromCache(e.images),
                      b = extractFromCache(e.shapes),
                      x = extractFromCache(e.skeletons),
                      _ = extractFromCache(e.animations),
                      M = extractFromCache(e.nodes);
                    m.length > 0 && (n.geometries = m),
                      v.length > 0 && (n.materials = v),
                      g.length > 0 && (n.textures = g),
                      y.length > 0 && (n.images = y),
                      b.length > 0 && (n.shapes = b),
                      x.length > 0 && (n.skeletons = x),
                      _.length > 0 && (n.animations = _),
                      M.length > 0 && (n.nodes = M);
                  }
                  return (n.object = r), n;
                  function extractFromCache(e) {
                    var t = [];
                    for (var n in e) {
                      var r = e[n];
                      delete r.metadata, t.push(r);
                    }
                    return t;
                  }
                },
              },
              {
                key: "clone",
                value: function clone(e) {
                  return new this.constructor().copy(this, e);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  var t =
                    !(arguments.length > 1 && void 0 !== arguments[1]) ||
                    arguments[1];
                  if (
                    ((this.name = e.name),
                    this.up.copy(e.up),
                    this.position.copy(e.position),
                    (this.rotation.order = e.rotation.order),
                    this.quaternion.copy(e.quaternion),
                    this.scale.copy(e.scale),
                    this.matrix.copy(e.matrix),
                    this.matrixWorld.copy(e.matrixWorld),
                    (this.matrixAutoUpdate = e.matrixAutoUpdate),
                    (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
                    (this.layers.mask = e.layers.mask),
                    (this.visible = e.visible),
                    (this.castShadow = e.castShadow),
                    (this.receiveShadow = e.receiveShadow),
                    (this.frustumCulled = e.frustumCulled),
                    (this.renderOrder = e.renderOrder),
                    (this.userData = JSON.parse(JSON.stringify(e.userData))),
                    !0 === t)
                  )
                    for (var n = 0; n < e.children.length; n++) {
                      var r = e.children[n];
                      this.add(r.clone());
                    }
                  return this;
                },
              },
            ]),
            Object3D
          );
        })(Ln);
      (ai.DefaultUp = new ir(0, 1, 0)), (ai.DefaultMatrixAutoUpdate = !0);
      var oi = new ir(),
        si = new ir(),
        ui = new ir(),
        li = new ir(),
        ci = new ir(),
        hi = new ir(),
        di = new ir(),
        fi = new ir(),
        pi = new ir(),
        mi = new ir(),
        vi = (function () {
          function Triangle() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir(),
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : new ir();
            Object(f.a)(this, Triangle),
              (this.a = e),
              (this.b = t),
              (this.c = n);
          }
          return (
            Object(p.a)(
              Triangle,
              [
                {
                  key: "set",
                  value: function set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
                  },
                },
                {
                  key: "setFromPointsAndIndices",
                  value: function setFromPointsAndIndices(e, t, n, r) {
                    return (
                      this.a.copy(e[t]),
                      this.b.copy(e[n]),
                      this.c.copy(e[r]),
                      this
                    );
                  },
                },
                {
                  key: "setFromAttributeAndIndices",
                  value: function setFromAttributeAndIndices(e, t, n, r) {
                    return (
                      this.a.fromBufferAttribute(e, t),
                      this.b.fromBufferAttribute(e, n),
                      this.c.fromBufferAttribute(e, r),
                      this
                    );
                  },
                },
                {
                  key: "clone",
                  value: function clone() {
                    return new this.constructor().copy(this);
                  },
                },
                {
                  key: "copy",
                  value: function copy(e) {
                    return (
                      this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                    );
                  },
                },
                {
                  key: "getArea",
                  value: function getArea() {
                    return (
                      oi.subVectors(this.c, this.b),
                      si.subVectors(this.a, this.b),
                      0.5 * oi.cross(si).length()
                    );
                  },
                },
                {
                  key: "getMidpoint",
                  value: function getMidpoint(e) {
                    return e
                      .addVectors(this.a, this.b)
                      .add(this.c)
                      .multiplyScalar(1 / 3);
                  },
                },
                {
                  key: "getNormal",
                  value: function getNormal(e) {
                    return Triangle.getNormal(this.a, this.b, this.c, e);
                  },
                },
                {
                  key: "getPlane",
                  value: function getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c);
                  },
                },
                {
                  key: "getBarycoord",
                  value: function getBarycoord(e, t) {
                    return Triangle.getBarycoord(e, this.a, this.b, this.c, t);
                  },
                },
                {
                  key: "getUV",
                  value: function getUV(e, t, n, r, i) {
                    return Triangle.getUV(
                      e,
                      this.a,
                      this.b,
                      this.c,
                      t,
                      n,
                      r,
                      i
                    );
                  },
                },
                {
                  key: "containsPoint",
                  value: function containsPoint(e) {
                    return Triangle.containsPoint(e, this.a, this.b, this.c);
                  },
                },
                {
                  key: "isFrontFacing",
                  value: function isFrontFacing(e) {
                    return Triangle.isFrontFacing(this.a, this.b, this.c, e);
                  },
                },
                {
                  key: "intersectsBox",
                  value: function intersectsBox(e) {
                    return e.intersectsTriangle(this);
                  },
                },
                {
                  key: "closestPointToPoint",
                  value: function closestPointToPoint(e, t) {
                    var n,
                      r,
                      i = this.a,
                      a = this.b,
                      o = this.c;
                    ci.subVectors(a, i),
                      hi.subVectors(o, i),
                      fi.subVectors(e, i);
                    var s = ci.dot(fi),
                      u = hi.dot(fi);
                    if (s <= 0 && u <= 0) return t.copy(i);
                    pi.subVectors(e, a);
                    var l = ci.dot(pi),
                      c = hi.dot(pi);
                    if (l >= 0 && c <= l) return t.copy(a);
                    var h = s * c - l * u;
                    if (h <= 0 && s >= 0 && l <= 0)
                      return (
                        (n = s / (s - l)), t.copy(i).addScaledVector(ci, n)
                      );
                    mi.subVectors(e, o);
                    var d = ci.dot(mi),
                      f = hi.dot(mi);
                    if (f >= 0 && d <= f) return t.copy(o);
                    var p = d * u - s * f;
                    if (p <= 0 && u >= 0 && f <= 0)
                      return (
                        (r = u / (u - f)), t.copy(i).addScaledVector(hi, r)
                      );
                    var m = l * f - d * c;
                    if (m <= 0 && c - l >= 0 && d - f >= 0)
                      return (
                        di.subVectors(o, a),
                        (r = (c - l) / (c - l + (d - f))),
                        t.copy(a).addScaledVector(di, r)
                      );
                    var v = 1 / (m + p + h);
                    return (
                      (n = p * v),
                      (r = h * v),
                      t.copy(i).addScaledVector(ci, n).addScaledVector(hi, r)
                    );
                  },
                },
                {
                  key: "equals",
                  value: function equals(e) {
                    return (
                      e.a.equals(this.a) &&
                      e.b.equals(this.b) &&
                      e.c.equals(this.c)
                    );
                  },
                },
              ],
              [
                {
                  key: "getNormal",
                  value: function getNormal(e, t, n, r) {
                    r.subVectors(n, t), oi.subVectors(e, t), r.cross(oi);
                    var i = r.lengthSq();
                    return i > 0
                      ? r.multiplyScalar(1 / Math.sqrt(i))
                      : r.set(0, 0, 0);
                  },
                },
                {
                  key: "getBarycoord",
                  value: function getBarycoord(e, t, n, r, i) {
                    oi.subVectors(r, t),
                      si.subVectors(n, t),
                      ui.subVectors(e, t);
                    var a = oi.dot(oi),
                      o = oi.dot(si),
                      s = oi.dot(ui),
                      u = si.dot(si),
                      l = si.dot(ui),
                      c = a * u - o * o;
                    if (0 === c) return i.set(-2, -1, -1);
                    var h = 1 / c,
                      d = (u * s - o * l) * h,
                      f = (a * l - o * s) * h;
                    return i.set(1 - d - f, f, d);
                  },
                },
                {
                  key: "containsPoint",
                  value: function containsPoint(e, t, n, r) {
                    return (
                      this.getBarycoord(e, t, n, r, li),
                      li.x >= 0 && li.y >= 0 && li.x + li.y <= 1
                    );
                  },
                },
                {
                  key: "getUV",
                  value: function getUV(e, t, n, r, i, a, o, s) {
                    return (
                      this.getBarycoord(e, t, n, r, li),
                      s.set(0, 0),
                      s.addScaledVector(i, li.x),
                      s.addScaledVector(a, li.y),
                      s.addScaledVector(o, li.z),
                      s
                    );
                  },
                },
                {
                  key: "isFrontFacing",
                  value: function isFrontFacing(e, t, n, r) {
                    return (
                      oi.subVectors(n, t),
                      si.subVectors(e, t),
                      oi.cross(si).dot(r) < 0
                    );
                  },
                },
              ]
            ),
            Triangle
          );
        })(),
        gi = 0,
        yi = (function (e) {
          function Material() {
            var e;
            return (
              Object(f.a)(this, Material),
              ((e = Object(s.a)(
                this,
                Object(r.a)(Material).call(this)
              )).isMaterial = !0),
              Object.defineProperty(Object(l.a)(Object(l.a)(e)), "id", {
                value: gi++,
              }),
              (e.uuid = generateUUID()),
              (e.name = ""),
              (e.type = "Material"),
              (e.blending = R),
              (e.side = O),
              (e.vertexColors = !1),
              (e.opacity = 1),
              (e.transparent = !1),
              (e.blendSrc = X),
              (e.blendDst = J),
              (e.blendEquation = N),
              (e.blendSrcAlpha = null),
              (e.blendDstAlpha = null),
              (e.blendEquationAlpha = null),
              (e.depthFunc = re),
              (e.depthTest = !0),
              (e.depthWrite = !0),
              (e.stencilWriteMask = 255),
              (e.stencilFunc = vn),
              (e.stencilRef = 0),
              (e.stencilFuncMask = 255),
              (e.stencilFail = tn),
              (e.stencilZFail = tn),
              (e.stencilZPass = tn),
              (e.stencilWrite = !1),
              (e.clippingPlanes = null),
              (e.clipIntersection = !1),
              (e.clipShadows = !1),
              (e.shadowSide = null),
              (e.colorWrite = !0),
              (e.precision = null),
              (e.polygonOffset = !1),
              (e.polygonOffsetFactor = 0),
              (e.polygonOffsetUnits = 0),
              (e.dithering = !1),
              (e.alphaToCoverage = !1),
              (e.premultipliedAlpha = !1),
              (e.visible = !0),
              (e.toneMapped = !0),
              (e.userData = {}),
              (e.version = 0),
              (e._alphaTest = 0),
              e
            );
          }
          return (
            Object(u.a)(Material, e),
            Object(p.a)(Material, [
              { key: "onBuild", value: function onBuild() {} },
              { key: "onBeforeRender", value: function onBeforeRender() {} },
              { key: "onBeforeCompile", value: function onBeforeCompile() {} },
              {
                key: "customProgramCacheKey",
                value: function customProgramCacheKey() {
                  return this.onBeforeCompile.toString();
                },
              },
              {
                key: "setValues",
                value: function setValues(e) {
                  if (void 0 !== e)
                    for (var t in e) {
                      var n = e[t];
                      if (void 0 !== n)
                        if ("shading" !== t) {
                          var r = this[t];
                          void 0 !== r
                            ? r && r.isColor
                              ? r.set(n)
                              : r && r.isVector3 && n && n.isVector3
                              ? r.copy(n)
                              : (this[t] = n)
                            : console.warn(
                                "THREE." +
                                  this.type +
                                  ": '" +
                                  t +
                                  "' is not a property of this material."
                              );
                        } else
                          console.warn(
                            "THREE." +
                              this.type +
                              ": .shading has been removed. Use the boolean .flatShading instead."
                          ),
                            (this.flatShading = n === k);
                      else
                        console.warn(
                          "THREE.Material: '" + t + "' parameter is undefined."
                        );
                    }
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = void 0 === e || "string" === typeof e;
                  t && (e = { textures: {}, images: {} });
                  var n = {
                    metadata: {
                      version: 4.5,
                      type: "Material",
                      generator: "Material.toJSON",
                    },
                  };
                  function extractFromCache(e) {
                    var t = [];
                    for (var n in e) {
                      var r = e[n];
                      delete r.metadata, t.push(r);
                    }
                    return t;
                  }
                  if (
                    ((n.uuid = this.uuid),
                    (n.type = this.type),
                    "" !== this.name && (n.name = this.name),
                    this.color &&
                      this.color.isColor &&
                      (n.color = this.color.getHex()),
                    void 0 !== this.roughness && (n.roughness = this.roughness),
                    void 0 !== this.metalness && (n.metalness = this.metalness),
                    void 0 !== this.sheen && (n.sheen = this.sheen),
                    this.sheenColor &&
                      this.sheenColor.isColor &&
                      (n.sheenColor = this.sheenColor.getHex()),
                    void 0 !== this.sheenRoughness &&
                      (n.sheenRoughness = this.sheenRoughness),
                    this.emissive &&
                      this.emissive.isColor &&
                      (n.emissive = this.emissive.getHex()),
                    this.emissiveIntensity &&
                      1 !== this.emissiveIntensity &&
                      (n.emissiveIntensity = this.emissiveIntensity),
                    this.specular &&
                      this.specular.isColor &&
                      (n.specular = this.specular.getHex()),
                    void 0 !== this.specularIntensity &&
                      (n.specularIntensity = this.specularIntensity),
                    this.specularColor &&
                      this.specularColor.isColor &&
                      (n.specularColor = this.specularColor.getHex()),
                    void 0 !== this.shininess && (n.shininess = this.shininess),
                    void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                    void 0 !== this.clearcoatRoughness &&
                      (n.clearcoatRoughness = this.clearcoatRoughness),
                    this.clearcoatMap &&
                      this.clearcoatMap.isTexture &&
                      (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                    this.clearcoatRoughnessMap &&
                      this.clearcoatRoughnessMap.isTexture &&
                      (n.clearcoatRoughnessMap =
                        this.clearcoatRoughnessMap.toJSON(e).uuid),
                    this.clearcoatNormalMap &&
                      this.clearcoatNormalMap.isTexture &&
                      ((n.clearcoatNormalMap =
                        this.clearcoatNormalMap.toJSON(e).uuid),
                      (n.clearcoatNormalScale =
                        this.clearcoatNormalScale.toArray())),
                    void 0 !== this.iridescence &&
                      (n.iridescence = this.iridescence),
                    void 0 !== this.iridescenceIOR &&
                      (n.iridescenceIOR = this.iridescenceIOR),
                    void 0 !== this.iridescenceThicknessRange &&
                      (n.iridescenceThicknessRange =
                        this.iridescenceThicknessRange),
                    this.iridescenceMap &&
                      this.iridescenceMap.isTexture &&
                      (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                    this.iridescenceThicknessMap &&
                      this.iridescenceThicknessMap.isTexture &&
                      (n.iridescenceThicknessMap =
                        this.iridescenceThicknessMap.toJSON(e).uuid),
                    this.map &&
                      this.map.isTexture &&
                      (n.map = this.map.toJSON(e).uuid),
                    this.matcap &&
                      this.matcap.isTexture &&
                      (n.matcap = this.matcap.toJSON(e).uuid),
                    this.alphaMap &&
                      this.alphaMap.isTexture &&
                      (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                    this.lightMap &&
                      this.lightMap.isTexture &&
                      ((n.lightMap = this.lightMap.toJSON(e).uuid),
                      (n.lightMapIntensity = this.lightMapIntensity)),
                    this.aoMap &&
                      this.aoMap.isTexture &&
                      ((n.aoMap = this.aoMap.toJSON(e).uuid),
                      (n.aoMapIntensity = this.aoMapIntensity)),
                    this.bumpMap &&
                      this.bumpMap.isTexture &&
                      ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
                      (n.bumpScale = this.bumpScale)),
                    this.normalMap &&
                      this.normalMap.isTexture &&
                      ((n.normalMap = this.normalMap.toJSON(e).uuid),
                      (n.normalMapType = this.normalMapType),
                      (n.normalScale = this.normalScale.toArray())),
                    this.displacementMap &&
                      this.displacementMap.isTexture &&
                      ((n.displacementMap =
                        this.displacementMap.toJSON(e).uuid),
                      (n.displacementScale = this.displacementScale),
                      (n.displacementBias = this.displacementBias)),
                    this.roughnessMap &&
                      this.roughnessMap.isTexture &&
                      (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                    this.metalnessMap &&
                      this.metalnessMap.isTexture &&
                      (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                    this.emissiveMap &&
                      this.emissiveMap.isTexture &&
                      (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                    this.specularMap &&
                      this.specularMap.isTexture &&
                      (n.specularMap = this.specularMap.toJSON(e).uuid),
                    this.specularIntensityMap &&
                      this.specularIntensityMap.isTexture &&
                      (n.specularIntensityMap =
                        this.specularIntensityMap.toJSON(e).uuid),
                    this.specularColorMap &&
                      this.specularColorMap.isTexture &&
                      (n.specularColorMap =
                        this.specularColorMap.toJSON(e).uuid),
                    this.envMap &&
                      this.envMap.isTexture &&
                      ((n.envMap = this.envMap.toJSON(e).uuid),
                      void 0 !== this.combine && (n.combine = this.combine)),
                    void 0 !== this.envMapIntensity &&
                      (n.envMapIntensity = this.envMapIntensity),
                    void 0 !== this.reflectivity &&
                      (n.reflectivity = this.reflectivity),
                    void 0 !== this.refractionRatio &&
                      (n.refractionRatio = this.refractionRatio),
                    this.gradientMap &&
                      this.gradientMap.isTexture &&
                      (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                    void 0 !== this.transmission &&
                      (n.transmission = this.transmission),
                    this.transmissionMap &&
                      this.transmissionMap.isTexture &&
                      (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                    void 0 !== this.thickness && (n.thickness = this.thickness),
                    this.thicknessMap &&
                      this.thicknessMap.isTexture &&
                      (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                    void 0 !== this.attenuationDistance &&
                      (n.attenuationDistance = this.attenuationDistance),
                    void 0 !== this.attenuationColor &&
                      (n.attenuationColor = this.attenuationColor.getHex()),
                    void 0 !== this.size && (n.size = this.size),
                    null !== this.shadowSide &&
                      (n.shadowSide = this.shadowSide),
                    void 0 !== this.sizeAttenuation &&
                      (n.sizeAttenuation = this.sizeAttenuation),
                    this.blending !== R && (n.blending = this.blending),
                    this.side !== O && (n.side = this.side),
                    this.vertexColors && (n.vertexColors = !0),
                    this.opacity < 1 && (n.opacity = this.opacity),
                    !0 === this.transparent &&
                      (n.transparent = this.transparent),
                    (n.depthFunc = this.depthFunc),
                    (n.depthTest = this.depthTest),
                    (n.depthWrite = this.depthWrite),
                    (n.colorWrite = this.colorWrite),
                    (n.stencilWrite = this.stencilWrite),
                    (n.stencilWriteMask = this.stencilWriteMask),
                    (n.stencilFunc = this.stencilFunc),
                    (n.stencilRef = this.stencilRef),
                    (n.stencilFuncMask = this.stencilFuncMask),
                    (n.stencilFail = this.stencilFail),
                    (n.stencilZFail = this.stencilZFail),
                    (n.stencilZPass = this.stencilZPass),
                    void 0 !== this.rotation &&
                      0 !== this.rotation &&
                      (n.rotation = this.rotation),
                    !0 === this.polygonOffset && (n.polygonOffset = !0),
                    0 !== this.polygonOffsetFactor &&
                      (n.polygonOffsetFactor = this.polygonOffsetFactor),
                    0 !== this.polygonOffsetUnits &&
                      (n.polygonOffsetUnits = this.polygonOffsetUnits),
                    void 0 !== this.linewidth &&
                      1 !== this.linewidth &&
                      (n.linewidth = this.linewidth),
                    void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                    void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                    void 0 !== this.scale && (n.scale = this.scale),
                    !0 === this.dithering && (n.dithering = !0),
                    this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                    !0 === this.alphaToCoverage &&
                      (n.alphaToCoverage = this.alphaToCoverage),
                    !0 === this.premultipliedAlpha &&
                      (n.premultipliedAlpha = this.premultipliedAlpha),
                    !0 === this.wireframe && (n.wireframe = this.wireframe),
                    this.wireframeLinewidth > 1 &&
                      (n.wireframeLinewidth = this.wireframeLinewidth),
                    "round" !== this.wireframeLinecap &&
                      (n.wireframeLinecap = this.wireframeLinecap),
                    "round" !== this.wireframeLinejoin &&
                      (n.wireframeLinejoin = this.wireframeLinejoin),
                    !0 === this.flatShading &&
                      (n.flatShading = this.flatShading),
                    !1 === this.visible && (n.visible = !1),
                    !1 === this.toneMapped && (n.toneMapped = !1),
                    !1 === this.fog && (n.fog = !1),
                    "{}" !== JSON.stringify(this.userData) &&
                      (n.userData = this.userData),
                    t)
                  ) {
                    var r = extractFromCache(e.textures),
                      i = extractFromCache(e.images);
                    r.length > 0 && (n.textures = r),
                      i.length > 0 && (n.images = i);
                  }
                  return n;
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  (this.name = e.name),
                    (this.blending = e.blending),
                    (this.side = e.side),
                    (this.vertexColors = e.vertexColors),
                    (this.opacity = e.opacity),
                    (this.transparent = e.transparent),
                    (this.blendSrc = e.blendSrc),
                    (this.blendDst = e.blendDst),
                    (this.blendEquation = e.blendEquation),
                    (this.blendSrcAlpha = e.blendSrcAlpha),
                    (this.blendDstAlpha = e.blendDstAlpha),
                    (this.blendEquationAlpha = e.blendEquationAlpha),
                    (this.depthFunc = e.depthFunc),
                    (this.depthTest = e.depthTest),
                    (this.depthWrite = e.depthWrite),
                    (this.stencilWriteMask = e.stencilWriteMask),
                    (this.stencilFunc = e.stencilFunc),
                    (this.stencilRef = e.stencilRef),
                    (this.stencilFuncMask = e.stencilFuncMask),
                    (this.stencilFail = e.stencilFail),
                    (this.stencilZFail = e.stencilZFail),
                    (this.stencilZPass = e.stencilZPass),
                    (this.stencilWrite = e.stencilWrite);
                  var t = e.clippingPlanes,
                    n = null;
                  if (null !== t) {
                    var r = t.length;
                    n = new Array(r);
                    for (var i = 0; i !== r; ++i) n[i] = t[i].clone();
                  }
                  return (
                    (this.clippingPlanes = n),
                    (this.clipIntersection = e.clipIntersection),
                    (this.clipShadows = e.clipShadows),
                    (this.shadowSide = e.shadowSide),
                    (this.colorWrite = e.colorWrite),
                    (this.precision = e.precision),
                    (this.polygonOffset = e.polygonOffset),
                    (this.polygonOffsetFactor = e.polygonOffsetFactor),
                    (this.polygonOffsetUnits = e.polygonOffsetUnits),
                    (this.dithering = e.dithering),
                    (this.alphaTest = e.alphaTest),
                    (this.alphaToCoverage = e.alphaToCoverage),
                    (this.premultipliedAlpha = e.premultipliedAlpha),
                    (this.visible = e.visible),
                    (this.toneMapped = e.toneMapped),
                    (this.userData = JSON.parse(JSON.stringify(e.userData))),
                    this
                  );
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.dispatchEvent({ type: "dispose" });
                },
              },
              {
                key: "alphaTest",
                get: function get() {
                  return this._alphaTest;
                },
                set: function set(e) {
                  this._alphaTest > 0 !== e > 0 && this.version++,
                    (this._alphaTest = e);
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  !0 === e && this.version++;
                },
              },
            ]),
            Material
          );
        })(Ln),
        bi = (function (e) {
          function MeshBasicMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshBasicMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshBasicMaterial).call(this)
              )).isMeshBasicMaterial = !0),
              (t.type = "MeshBasicMaterial"),
              (t.color = new Hn(16777215)),
              (t.map = null),
              (t.lightMap = null),
              (t.lightMapIntensity = 1),
              (t.aoMap = null),
              (t.aoMapIntensity = 1),
              (t.specularMap = null),
              (t.alphaMap = null),
              (t.envMap = null),
              (t.combine = ue),
              (t.reflectivity = 1),
              (t.refractionRatio = 0.98),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.wireframeLinecap = "round"),
              (t.wireframeLinejoin = "round"),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshBasicMaterial, e),
            Object(p.a)(MeshBasicMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshBasicMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    (this.specularMap = e.specularMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.combine = e.combine),
                    (this.reflectivity = e.reflectivity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            MeshBasicMaterial
          );
        })(yi),
        xi = new ir(),
        _i = new Dn(),
        Mi = (function () {
          function BufferAttribute(e, t, n) {
            if ((Object(f.a)(this, BufferAttribute), Array.isArray(e)))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            (this.isBufferAttribute = !0),
              (this.name = ""),
              (this.array = e),
              (this.itemSize = t),
              (this.count = void 0 !== e ? e.length / t : 0),
              (this.normalized = !0 === n),
              (this.usage = gn),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0);
          }
          return (
            Object(p.a)(BufferAttribute, [
              {
                key: "onUploadCallback",
                value: function onUploadCallback() {},
              },
              {
                key: "setUsage",
                value: function setUsage(e) {
                  return (this.usage = e), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.name = e.name),
                    (this.array = new e.array.constructor(e.array)),
                    (this.itemSize = e.itemSize),
                    (this.count = e.count),
                    (this.normalized = e.normalized),
                    (this.usage = e.usage),
                    this
                  );
                },
              },
              {
                key: "copyAt",
                value: function copyAt(e, t, n) {
                  (e *= this.itemSize), (n *= t.itemSize);
                  for (var r = 0, i = this.itemSize; r < i; r++)
                    this.array[e + r] = t.array[n + r];
                  return this;
                },
              },
              {
                key: "copyArray",
                value: function copyArray(e) {
                  return this.array.set(e), this;
                },
              },
              {
                key: "copyColorsArray",
                value: function copyColorsArray(e) {
                  for (
                    var t = this.array, n = 0, r = 0, i = e.length;
                    r < i;
                    r++
                  ) {
                    var a = e[r];
                    void 0 === a &&
                      (console.warn(
                        "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                        r
                      ),
                      (a = new Hn())),
                      (t[n++] = a.r),
                      (t[n++] = a.g),
                      (t[n++] = a.b);
                  }
                  return this;
                },
              },
              {
                key: "copyVector2sArray",
                value: function copyVector2sArray(e) {
                  for (
                    var t = this.array, n = 0, r = 0, i = e.length;
                    r < i;
                    r++
                  ) {
                    var a = e[r];
                    void 0 === a &&
                      (console.warn(
                        "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                        r
                      ),
                      (a = new Dn())),
                      (t[n++] = a.x),
                      (t[n++] = a.y);
                  }
                  return this;
                },
              },
              {
                key: "copyVector3sArray",
                value: function copyVector3sArray(e) {
                  for (
                    var t = this.array, n = 0, r = 0, i = e.length;
                    r < i;
                    r++
                  ) {
                    var a = e[r];
                    void 0 === a &&
                      (console.warn(
                        "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                        r
                      ),
                      (a = new ir())),
                      (t[n++] = a.x),
                      (t[n++] = a.y),
                      (t[n++] = a.z);
                  }
                  return this;
                },
              },
              {
                key: "copyVector4sArray",
                value: function copyVector4sArray(e) {
                  for (
                    var t = this.array, n = 0, r = 0, i = e.length;
                    r < i;
                    r++
                  ) {
                    var a = e[r];
                    void 0 === a &&
                      (console.warn(
                        "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                        r
                      ),
                      (a = new Zn())),
                      (t[n++] = a.x),
                      (t[n++] = a.y),
                      (t[n++] = a.z),
                      (t[n++] = a.w);
                  }
                  return this;
                },
              },
              {
                key: "applyMatrix3",
                value: function applyMatrix3(e) {
                  if (2 === this.itemSize)
                    for (var t = 0, n = this.count; t < n; t++)
                      _i.fromBufferAttribute(this, t),
                        _i.applyMatrix3(e),
                        this.setXY(t, _i.x, _i.y);
                  else if (3 === this.itemSize)
                    for (var r = 0, i = this.count; r < i; r++)
                      xi.fromBufferAttribute(this, r),
                        xi.applyMatrix3(e),
                        this.setXYZ(r, xi.x, xi.y, xi.z);
                  return this;
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  for (var t = 0, n = this.count; t < n; t++)
                    xi.fromBufferAttribute(this, t),
                      xi.applyMatrix4(e),
                      this.setXYZ(t, xi.x, xi.y, xi.z);
                  return this;
                },
              },
              {
                key: "applyNormalMatrix",
                value: function applyNormalMatrix(e) {
                  for (var t = 0, n = this.count; t < n; t++)
                    xi.fromBufferAttribute(this, t),
                      xi.applyNormalMatrix(e),
                      this.setXYZ(t, xi.x, xi.y, xi.z);
                  return this;
                },
              },
              {
                key: "transformDirection",
                value: function transformDirection(e) {
                  for (var t = 0, n = this.count; t < n; t++)
                    xi.fromBufferAttribute(this, t),
                      xi.transformDirection(e),
                      this.setXYZ(t, xi.x, xi.y, xi.z);
                  return this;
                },
              },
              {
                key: "set",
                value: function set(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return this.array.set(e, t), this;
                },
              },
              {
                key: "getX",
                value: function getX(e) {
                  return this.array[e * this.itemSize];
                },
              },
              {
                key: "setX",
                value: function setX(e, t) {
                  return (this.array[e * this.itemSize] = t), this;
                },
              },
              {
                key: "getY",
                value: function getY(e) {
                  return this.array[e * this.itemSize + 1];
                },
              },
              {
                key: "setY",
                value: function setY(e, t) {
                  return (this.array[e * this.itemSize + 1] = t), this;
                },
              },
              {
                key: "getZ",
                value: function getZ(e) {
                  return this.array[e * this.itemSize + 2];
                },
              },
              {
                key: "setZ",
                value: function setZ(e, t) {
                  return (this.array[e * this.itemSize + 2] = t), this;
                },
              },
              {
                key: "getW",
                value: function getW(e) {
                  return this.array[e * this.itemSize + 3];
                },
              },
              {
                key: "setW",
                value: function setW(e, t) {
                  return (this.array[e * this.itemSize + 3] = t), this;
                },
              },
              {
                key: "setXY",
                value: function setXY(e, t, n) {
                  return (
                    (e *= this.itemSize),
                    (this.array[e + 0] = t),
                    (this.array[e + 1] = n),
                    this
                  );
                },
              },
              {
                key: "setXYZ",
                value: function setXYZ(e, t, n, r) {
                  return (
                    (e *= this.itemSize),
                    (this.array[e + 0] = t),
                    (this.array[e + 1] = n),
                    (this.array[e + 2] = r),
                    this
                  );
                },
              },
              {
                key: "setXYZW",
                value: function setXYZW(e, t, n, r, i) {
                  return (
                    (e *= this.itemSize),
                    (this.array[e + 0] = t),
                    (this.array[e + 1] = n),
                    (this.array[e + 2] = r),
                    (this.array[e + 3] = i),
                    this
                  );
                },
              },
              {
                key: "onUpload",
                value: function onUpload(e) {
                  return (this.onUploadCallback = e), this;
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(this.array, this.itemSize).copy(
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized,
                  };
                  return (
                    "" !== this.name && (e.name = this.name),
                    this.usage !== gn && (e.usage = this.usage),
                    (0 === this.updateRange.offset &&
                      -1 === this.updateRange.count) ||
                      (e.updateRange = this.updateRange),
                    e
                  );
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  !0 === e && this.version++;
                },
              },
            ]),
            BufferAttribute
          );
        })(),
        Si = (function (e) {
          function Int8BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Int8BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Int8BufferAttribute).call(
                  this,
                  new Int8Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Int8BufferAttribute, e), Int8BufferAttribute;
        })(Mi),
        wi = (function (e) {
          function Uint8BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Uint8BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Uint8BufferAttribute).call(
                  this,
                  new Uint8Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Uint8BufferAttribute, e), Uint8BufferAttribute;
        })(Mi),
        Ti = (function (e) {
          function Uint8ClampedBufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Uint8ClampedBufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Uint8ClampedBufferAttribute).call(
                  this,
                  new Uint8ClampedArray(e),
                  t,
                  n
                )
              )
            );
          }
          return (
            Object(u.a)(Uint8ClampedBufferAttribute, e),
            Uint8ClampedBufferAttribute
          );
        })(Mi),
        Ai = (function (e) {
          function Int16BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Int16BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Int16BufferAttribute).call(
                  this,
                  new Int16Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Int16BufferAttribute, e), Int16BufferAttribute;
        })(Mi),
        Oi = (function (e) {
          function Uint16BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Uint16BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Uint16BufferAttribute).call(
                  this,
                  new Uint16Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Uint16BufferAttribute, e), Uint16BufferAttribute;
        })(Mi),
        Ci = (function (e) {
          function Int32BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Int32BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Int32BufferAttribute).call(
                  this,
                  new Int32Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Int32BufferAttribute, e), Int32BufferAttribute;
        })(Mi),
        Li = (function (e) {
          function Uint32BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Uint32BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Uint32BufferAttribute).call(
                  this,
                  new Uint32Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Uint32BufferAttribute, e), Uint32BufferAttribute;
        })(Mi),
        ki = (function (e) {
          function Float16BufferAttribute(e, t, n) {
            var i;
            return (
              Object(f.a)(this, Float16BufferAttribute),
              ((i = Object(s.a)(
                this,
                Object(r.a)(Float16BufferAttribute).call(
                  this,
                  new Uint16Array(e),
                  t,
                  n
                )
              )).isFloat16BufferAttribute = !0),
              i
            );
          }
          return Object(u.a)(Float16BufferAttribute, e), Float16BufferAttribute;
        })(Mi),
        Ei = (function (e) {
          function Float32BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Float32BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Float32BufferAttribute).call(
                  this,
                  new Float32Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Float32BufferAttribute, e), Float32BufferAttribute;
        })(Mi),
        Pi = (function (e) {
          function Float64BufferAttribute(e, t, n) {
            return (
              Object(f.a)(this, Float64BufferAttribute),
              Object(s.a)(
                this,
                Object(r.a)(Float64BufferAttribute).call(
                  this,
                  new Float64Array(e),
                  t,
                  n
                )
              )
            );
          }
          return Object(u.a)(Float64BufferAttribute, e), Float64BufferAttribute;
        })(Mi),
        Ri = 0,
        Ii = new Ir(),
        Di = new ai(),
        ji = new ir(),
        Bi = new sr(),
        Ni = new sr(),
        zi = new ir(),
        Fi = (function (e) {
          function BufferGeometry() {
            var e;
            return (
              Object(f.a)(this, BufferGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(BufferGeometry).call(this)
              )).isBufferGeometry = !0),
              Object.defineProperty(Object(l.a)(Object(l.a)(e)), "id", {
                value: Ri++,
              }),
              (e.uuid = generateUUID()),
              (e.name = ""),
              (e.type = "BufferGeometry"),
              (e.index = null),
              (e.attributes = {}),
              (e.morphAttributes = {}),
              (e.morphTargetsRelative = !1),
              (e.groups = []),
              (e.boundingBox = null),
              (e.boundingSphere = null),
              (e.drawRange = { start: 0, count: 1 / 0 }),
              (e.userData = {}),
              e
            );
          }
          return (
            Object(u.a)(BufferGeometry, e),
            Object(p.a)(BufferGeometry, [
              {
                key: "getIndex",
                value: function getIndex() {
                  return this.index;
                },
              },
              {
                key: "setIndex",
                value: function setIndex(e) {
                  return (
                    Array.isArray(e)
                      ? (this.index = new (arrayNeedsUint32(e) ? Li : Oi)(e, 1))
                      : (this.index = e),
                    this
                  );
                },
              },
              {
                key: "getAttribute",
                value: function getAttribute(e) {
                  return this.attributes[e];
                },
              },
              {
                key: "setAttribute",
                value: function setAttribute(e, t) {
                  return (this.attributes[e] = t), this;
                },
              },
              {
                key: "deleteAttribute",
                value: function deleteAttribute(e) {
                  return delete this.attributes[e], this;
                },
              },
              {
                key: "hasAttribute",
                value: function hasAttribute(e) {
                  return void 0 !== this.attributes[e];
                },
              },
              {
                key: "addGroup",
                value: function addGroup(e, t) {
                  var n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : 0;
                  this.groups.push({ start: e, count: t, materialIndex: n });
                },
              },
              {
                key: "clearGroups",
                value: function clearGroups() {
                  this.groups = [];
                },
              },
              {
                key: "setDrawRange",
                value: function setDrawRange(e, t) {
                  (this.drawRange.start = e), (this.drawRange.count = t);
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  var t = this.attributes.position;
                  void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
                  var n = this.attributes.normal;
                  if (void 0 !== n) {
                    var r = new jn().getNormalMatrix(e);
                    n.applyNormalMatrix(r), (n.needsUpdate = !0);
                  }
                  var i = this.attributes.tangent;
                  return (
                    void 0 !== i &&
                      (i.transformDirection(e), (i.needsUpdate = !0)),
                    null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere &&
                      this.computeBoundingSphere(),
                    this
                  );
                },
              },
              {
                key: "applyQuaternion",
                value: function applyQuaternion(e) {
                  return (
                    Ii.makeRotationFromQuaternion(e),
                    this.applyMatrix4(Ii),
                    this
                  );
                },
              },
              {
                key: "rotateX",
                value: function rotateX(e) {
                  return Ii.makeRotationX(e), this.applyMatrix4(Ii), this;
                },
              },
              {
                key: "rotateY",
                value: function rotateY(e) {
                  return Ii.makeRotationY(e), this.applyMatrix4(Ii), this;
                },
              },
              {
                key: "rotateZ",
                value: function rotateZ(e) {
                  return Ii.makeRotationZ(e), this.applyMatrix4(Ii), this;
                },
              },
              {
                key: "translate",
                value: function translate(e, t, n) {
                  return (
                    Ii.makeTranslation(e, t, n), this.applyMatrix4(Ii), this
                  );
                },
              },
              {
                key: "scale",
                value: function scale(e, t, n) {
                  return Ii.makeScale(e, t, n), this.applyMatrix4(Ii), this;
                },
              },
              {
                key: "lookAt",
                value: function lookAt(e) {
                  return (
                    Di.lookAt(e),
                    Di.updateMatrix(),
                    this.applyMatrix4(Di.matrix),
                    this
                  );
                },
              },
              {
                key: "center",
                value: function center() {
                  return (
                    this.computeBoundingBox(),
                    this.boundingBox.getCenter(ji).negate(),
                    this.translate(ji.x, ji.y, ji.z),
                    this
                  );
                },
              },
              {
                key: "setFromPoints",
                value: function setFromPoints(e) {
                  for (var t = [], n = 0, r = e.length; n < r; n++) {
                    var i = e[n];
                    t.push(i.x, i.y, i.z || 0);
                  }
                  return this.setAttribute("position", new Ei(t, 3)), this;
                },
              },
              {
                key: "computeBoundingBox",
                value: function computeBoundingBox() {
                  null === this.boundingBox && (this.boundingBox = new sr());
                  var e = this.attributes.position,
                    t = this.morphAttributes.position;
                  if (e && e.isGLBufferAttribute)
                    return (
                      console.error(
                        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                        this
                      ),
                      void this.boundingBox.set(
                        new ir(-1 / 0, -1 / 0, -1 / 0),
                        new ir(1 / 0, 1 / 0, 1 / 0)
                      )
                    );
                  if (void 0 !== e) {
                    if ((this.boundingBox.setFromBufferAttribute(e), t))
                      for (var n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        Bi.setFromBufferAttribute(i),
                          this.morphTargetsRelative
                            ? (zi.addVectors(this.boundingBox.min, Bi.min),
                              this.boundingBox.expandByPoint(zi),
                              zi.addVectors(this.boundingBox.max, Bi.max),
                              this.boundingBox.expandByPoint(zi))
                            : (this.boundingBox.expandByPoint(Bi.min),
                              this.boundingBox.expandByPoint(Bi.max));
                      }
                  } else this.boundingBox.makeEmpty();
                  (isNaN(this.boundingBox.min.x) ||
                    isNaN(this.boundingBox.min.y) ||
                    isNaN(this.boundingBox.min.z)) &&
                    console.error(
                      'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                      this
                    );
                },
              },
              {
                key: "computeBoundingSphere",
                value: function computeBoundingSphere() {
                  null === this.boundingSphere &&
                    (this.boundingSphere = new Tr());
                  var e = this.attributes.position,
                    t = this.morphAttributes.position;
                  if (e && e.isGLBufferAttribute)
                    return (
                      console.error(
                        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                        this
                      ),
                      void this.boundingSphere.set(new ir(), 1 / 0)
                    );
                  if (e) {
                    var n = this.boundingSphere.center;
                    if ((Bi.setFromBufferAttribute(e), t))
                      for (var r = 0, i = t.length; r < i; r++) {
                        var a = t[r];
                        Ni.setFromBufferAttribute(a),
                          this.morphTargetsRelative
                            ? (zi.addVectors(Bi.min, Ni.min),
                              Bi.expandByPoint(zi),
                              zi.addVectors(Bi.max, Ni.max),
                              Bi.expandByPoint(zi))
                            : (Bi.expandByPoint(Ni.min),
                              Bi.expandByPoint(Ni.max));
                      }
                    Bi.getCenter(n);
                    for (var o = 0, s = 0, u = e.count; s < u; s++)
                      zi.fromBufferAttribute(e, s),
                        (o = Math.max(o, n.distanceToSquared(zi)));
                    if (t)
                      for (var l = 0, c = t.length; l < c; l++)
                        for (
                          var h = t[l],
                            d = this.morphTargetsRelative,
                            f = 0,
                            p = h.count;
                          f < p;
                          f++
                        )
                          zi.fromBufferAttribute(h, f),
                            d && (ji.fromBufferAttribute(e, f), zi.add(ji)),
                            (o = Math.max(o, n.distanceToSquared(zi)));
                    (this.boundingSphere.radius = Math.sqrt(o)),
                      isNaN(this.boundingSphere.radius) &&
                        console.error(
                          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                          this
                        );
                  }
                },
              },
              {
                key: "computeTangents",
                value: function computeTangents() {
                  var e = this.index,
                    t = this.attributes;
                  if (
                    null !== e &&
                    void 0 !== t.position &&
                    void 0 !== t.normal &&
                    void 0 !== t.uv
                  ) {
                    var n = e.array,
                      r = t.position.array,
                      i = t.normal.array,
                      a = t.uv.array,
                      o = r.length / 3;
                    !1 === this.hasAttribute("tangent") &&
                      this.setAttribute(
                        "tangent",
                        new Mi(new Float32Array(4 * o), 4)
                      );
                    for (
                      var s = this.getAttribute("tangent").array,
                        u = [],
                        l = [],
                        c = 0;
                      c < o;
                      c++
                    )
                      (u[c] = new ir()), (l[c] = new ir());
                    var h = new ir(),
                      d = new ir(),
                      f = new ir(),
                      p = new Dn(),
                      m = new Dn(),
                      v = new Dn(),
                      g = new ir(),
                      y = new ir(),
                      b = this.groups;
                    0 === b.length && (b = [{ start: 0, count: n.length }]);
                    for (var x = 0, _ = b.length; x < _; ++x)
                      for (
                        var M = b[x], S = M.start, w = S, T = S + M.count;
                        w < T;
                        w += 3
                      )
                        handleTriangle(n[w + 0], n[w + 1], n[w + 2]);
                    for (
                      var A = new ir(),
                        O = new ir(),
                        C = new ir(),
                        L = new ir(),
                        k = 0,
                        E = b.length;
                      k < E;
                      ++k
                    )
                      for (
                        var P = b[k], R = P.start, I = R, D = R + P.count;
                        I < D;
                        I += 3
                      )
                        handleVertex(n[I + 0]),
                          handleVertex(n[I + 1]),
                          handleVertex(n[I + 2]);
                  } else
                    console.error(
                      "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
                    );
                  function handleTriangle(e, t, n) {
                    h.fromArray(r, 3 * e),
                      d.fromArray(r, 3 * t),
                      f.fromArray(r, 3 * n),
                      p.fromArray(a, 2 * e),
                      m.fromArray(a, 2 * t),
                      v.fromArray(a, 2 * n),
                      d.sub(h),
                      f.sub(h),
                      m.sub(p),
                      v.sub(p);
                    var i = 1 / (m.x * v.y - v.x * m.y);
                    isFinite(i) &&
                      (g
                        .copy(d)
                        .multiplyScalar(v.y)
                        .addScaledVector(f, -m.y)
                        .multiplyScalar(i),
                      y
                        .copy(f)
                        .multiplyScalar(m.x)
                        .addScaledVector(d, -v.x)
                        .multiplyScalar(i),
                      u[e].add(g),
                      u[t].add(g),
                      u[n].add(g),
                      l[e].add(y),
                      l[t].add(y),
                      l[n].add(y));
                  }
                  function handleVertex(e) {
                    C.fromArray(i, 3 * e), L.copy(C);
                    var t = u[e];
                    A.copy(t),
                      A.sub(C.multiplyScalar(C.dot(t))).normalize(),
                      O.crossVectors(L, t);
                    var n = O.dot(l[e]) < 0 ? -1 : 1;
                    (s[4 * e] = A.x),
                      (s[4 * e + 1] = A.y),
                      (s[4 * e + 2] = A.z),
                      (s[4 * e + 3] = n);
                  }
                },
              },
              {
                key: "computeVertexNormals",
                value: function computeVertexNormals() {
                  var e = this.index,
                    t = this.getAttribute("position");
                  if (void 0 !== t) {
                    var n = this.getAttribute("normal");
                    if (void 0 === n)
                      (n = new Mi(new Float32Array(3 * t.count), 3)),
                        this.setAttribute("normal", n);
                    else
                      for (var r = 0, i = n.count; r < i; r++)
                        n.setXYZ(r, 0, 0, 0);
                    var a = new ir(),
                      o = new ir(),
                      s = new ir(),
                      u = new ir(),
                      l = new ir(),
                      c = new ir(),
                      h = new ir(),
                      d = new ir();
                    if (e)
                      for (var f = 0, p = e.count; f < p; f += 3) {
                        var m = e.getX(f + 0),
                          v = e.getX(f + 1),
                          g = e.getX(f + 2);
                        a.fromBufferAttribute(t, m),
                          o.fromBufferAttribute(t, v),
                          s.fromBufferAttribute(t, g),
                          h.subVectors(s, o),
                          d.subVectors(a, o),
                          h.cross(d),
                          u.fromBufferAttribute(n, m),
                          l.fromBufferAttribute(n, v),
                          c.fromBufferAttribute(n, g),
                          u.add(h),
                          l.add(h),
                          c.add(h),
                          n.setXYZ(m, u.x, u.y, u.z),
                          n.setXYZ(v, l.x, l.y, l.z),
                          n.setXYZ(g, c.x, c.y, c.z);
                      }
                    else
                      for (var y = 0, b = t.count; y < b; y += 3)
                        a.fromBufferAttribute(t, y + 0),
                          o.fromBufferAttribute(t, y + 1),
                          s.fromBufferAttribute(t, y + 2),
                          h.subVectors(s, o),
                          d.subVectors(a, o),
                          h.cross(d),
                          n.setXYZ(y + 0, h.x, h.y, h.z),
                          n.setXYZ(y + 1, h.x, h.y, h.z),
                          n.setXYZ(y + 2, h.x, h.y, h.z);
                    this.normalizeNormals(), (n.needsUpdate = !0);
                  }
                },
              },
              {
                key: "merge",
                value: function merge(e, t) {
                  if (e && e.isBufferGeometry) {
                    void 0 === t &&
                      ((t = 0),
                      console.warn(
                        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                      ));
                    var n = this.attributes;
                    for (var r in n)
                      if (void 0 !== e.attributes[r])
                        for (
                          var i = n[r].array,
                            a = e.attributes[r],
                            o = a.array,
                            s = a.itemSize * t,
                            u = Math.min(o.length, i.length - s),
                            l = 0,
                            c = s;
                          l < u;
                          l++, c++
                        )
                          i[c] = o[l];
                    return this;
                  }
                  console.error(
                    "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                    e
                  );
                },
              },
              {
                key: "normalizeNormals",
                value: function normalizeNormals() {
                  for (
                    var e = this.attributes.normal, t = 0, n = e.count;
                    t < n;
                    t++
                  )
                    zi.fromBufferAttribute(e, t),
                      zi.normalize(),
                      e.setXYZ(t, zi.x, zi.y, zi.z);
                },
              },
              {
                key: "toNonIndexed",
                value: function toNonIndexed() {
                  function convertBufferAttribute(e, t) {
                    for (
                      var n = e.array,
                        r = e.itemSize,
                        i = e.normalized,
                        a = new n.constructor(t.length * r),
                        o = 0,
                        s = 0,
                        u = 0,
                        l = t.length;
                      u < l;
                      u++
                    ) {
                      o = e.isInterleavedBufferAttribute
                        ? t[u] * e.data.stride + e.offset
                        : t[u] * r;
                      for (var c = 0; c < r; c++) a[s++] = n[o++];
                    }
                    return new Mi(a, r, i);
                  }
                  if (null === this.index)
                    return (
                      console.warn(
                        "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                      ),
                      this
                    );
                  var e = new BufferGeometry(),
                    t = this.index.array,
                    n = this.attributes;
                  for (var r in n) {
                    var i = convertBufferAttribute(n[r], t);
                    e.setAttribute(r, i);
                  }
                  var a = this.morphAttributes;
                  for (var o in a) {
                    for (
                      var s = [], u = a[o], l = 0, c = u.length;
                      l < c;
                      l++
                    ) {
                      var h = convertBufferAttribute(u[l], t);
                      s.push(h);
                    }
                    e.morphAttributes[o] = s;
                  }
                  e.morphTargetsRelative = this.morphTargetsRelative;
                  for (var d = this.groups, f = 0, p = d.length; f < p; f++) {
                    var m = d[f];
                    e.addGroup(m.start, m.count, m.materialIndex);
                  }
                  return e;
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = {
                    metadata: {
                      version: 4.5,
                      type: "BufferGeometry",
                      generator: "BufferGeometry.toJSON",
                    },
                  };
                  if (
                    ((e.uuid = this.uuid),
                    (e.type = this.type),
                    "" !== this.name && (e.name = this.name),
                    Object.keys(this.userData).length > 0 &&
                      (e.userData = this.userData),
                    void 0 !== this.parameters)
                  ) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e;
                  }
                  e.data = { attributes: {} };
                  var r = this.index;
                  null !== r &&
                    (e.data.index = {
                      type: r.array.constructor.name,
                      array: Array.prototype.slice.call(r.array),
                    });
                  var i = this.attributes;
                  for (var a in i) {
                    var o = i[a];
                    e.data.attributes[a] = o.toJSON(e.data);
                  }
                  var s = {},
                    u = !1;
                  for (var l in this.morphAttributes) {
                    for (
                      var c = this.morphAttributes[l],
                        h = [],
                        d = 0,
                        f = c.length;
                      d < f;
                      d++
                    ) {
                      var p = c[d];
                      h.push(p.toJSON(e.data));
                    }
                    h.length > 0 && ((s[l] = h), (u = !0));
                  }
                  u &&
                    ((e.data.morphAttributes = s),
                    (e.data.morphTargetsRelative = this.morphTargetsRelative));
                  var m = this.groups;
                  m.length > 0 &&
                    (e.data.groups = JSON.parse(JSON.stringify(m)));
                  var v = this.boundingSphere;
                  return (
                    null !== v &&
                      (e.data.boundingSphere = {
                        center: v.center.toArray(),
                        radius: v.radius,
                      }),
                    e
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  (this.index = null),
                    (this.attributes = {}),
                    (this.morphAttributes = {}),
                    (this.groups = []),
                    (this.boundingBox = null),
                    (this.boundingSphere = null);
                  var t = {};
                  this.name = e.name;
                  var n = e.index;
                  null !== n && this.setIndex(n.clone(t));
                  var r = e.attributes;
                  for (var i in r) {
                    var a = r[i];
                    this.setAttribute(i, a.clone(t));
                  }
                  var o = e.morphAttributes;
                  for (var s in o) {
                    for (var u = [], l = o[s], c = 0, h = l.length; c < h; c++)
                      u.push(l[c].clone(t));
                    this.morphAttributes[s] = u;
                  }
                  this.morphTargetsRelative = e.morphTargetsRelative;
                  for (var d = e.groups, f = 0, p = d.length; f < p; f++) {
                    var m = d[f];
                    this.addGroup(m.start, m.count, m.materialIndex);
                  }
                  var v = e.boundingBox;
                  null !== v && (this.boundingBox = v.clone());
                  var g = e.boundingSphere;
                  return (
                    null !== g && (this.boundingSphere = g.clone()),
                    (this.drawRange.start = e.drawRange.start),
                    (this.drawRange.count = e.drawRange.count),
                    (this.userData = e.userData),
                    void 0 !== e.parameters &&
                      (this.parameters = Object.assign({}, e.parameters)),
                    this
                  );
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.dispatchEvent({ type: "dispose" });
                },
              },
            ]),
            BufferGeometry
          );
        })(Ln),
        Gi = new Ir(),
        Ui = new Rr(),
        Vi = new Tr(),
        Wi = new ir(),
        Hi = new ir(),
        qi = new ir(),
        Xi = new ir(),
        Ji = new ir(),
        Yi = new ir(),
        Zi = new ir(),
        Ki = new ir(),
        Qi = new ir(),
        $i = new Dn(),
        ea = new Dn(),
        ta = new Dn(),
        na = new ir(),
        ra = new ir(),
        ia = (function (e) {
          function Mesh() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Fi(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new bi();
            return (
              Object(f.a)(this, Mesh),
              ((e = Object(s.a)(this, Object(r.a)(Mesh).call(this))).isMesh =
                !0),
              (e.type = "Mesh"),
              (e.geometry = t),
              (e.material = n),
              e.updateMorphTargets(),
              e
            );
          }
          return (
            Object(u.a)(Mesh, e),
            Object(p.a)(Mesh, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(Object(r.a)(Mesh.prototype), "copy", this).call(
                      this,
                      e,
                      t
                    ),
                    void 0 !== e.morphTargetInfluences &&
                      (this.morphTargetInfluences =
                        e.morphTargetInfluences.slice()),
                    void 0 !== e.morphTargetDictionary &&
                      (this.morphTargetDictionary = Object.assign(
                        {},
                        e.morphTargetDictionary
                      )),
                    (this.material = e.material),
                    (this.geometry = e.geometry),
                    this
                  );
                },
              },
              {
                key: "updateMorphTargets",
                value: function updateMorphTargets() {
                  var e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                  if (t.length > 0) {
                    var n = e[t[0]];
                    if (void 0 !== n) {
                      (this.morphTargetInfluences = []),
                        (this.morphTargetDictionary = {});
                      for (var r = 0, i = n.length; r < i; r++) {
                        var a = n[r].name || String(r);
                        this.morphTargetInfluences.push(0),
                          (this.morphTargetDictionary[a] = r);
                      }
                    }
                  }
                },
              },
              {
                key: "raycast",
                value: function raycast(e, t) {
                  var n = this.geometry,
                    r = this.material,
                    i = this.matrixWorld;
                  if (
                    void 0 !== r &&
                    (null === n.boundingSphere && n.computeBoundingSphere(),
                    Vi.copy(n.boundingSphere),
                    Vi.applyMatrix4(i),
                    !1 !== e.ray.intersectsSphere(Vi) &&
                      (Gi.copy(i).invert(),
                      Ui.copy(e.ray).applyMatrix4(Gi),
                      null === n.boundingBox ||
                        !1 !== Ui.intersectsBox(n.boundingBox)))
                  ) {
                    var a,
                      o = n.index,
                      s = n.attributes.position,
                      u = n.morphAttributes.position,
                      l = n.morphTargetsRelative,
                      c = n.attributes.uv,
                      h = n.attributes.uv2,
                      d = n.groups,
                      f = n.drawRange;
                    if (null !== o)
                      if (Array.isArray(r))
                        for (var p = 0, m = d.length; p < m; p++)
                          for (
                            var v = d[p],
                              g = r[v.materialIndex],
                              y = Math.max(v.start, f.start),
                              b = Math.min(
                                o.count,
                                Math.min(v.start + v.count, f.start + f.count)
                              );
                            y < b;
                            y += 3
                          ) {
                            var x = o.getX(y),
                              _ = o.getX(y + 1),
                              M = o.getX(y + 2);
                            (a = checkBufferGeometryIntersection(
                              this,
                              g,
                              e,
                              Ui,
                              s,
                              u,
                              l,
                              c,
                              h,
                              x,
                              _,
                              M
                            )) &&
                              ((a.faceIndex = Math.floor(y / 3)),
                              (a.face.materialIndex = v.materialIndex),
                              t.push(a));
                          }
                      else
                        for (
                          var S = Math.max(0, f.start),
                            w = Math.min(o.count, f.start + f.count);
                          S < w;
                          S += 3
                        ) {
                          var T = o.getX(S),
                            A = o.getX(S + 1),
                            O = o.getX(S + 2);
                          (a = checkBufferGeometryIntersection(
                            this,
                            r,
                            e,
                            Ui,
                            s,
                            u,
                            l,
                            c,
                            h,
                            T,
                            A,
                            O
                          )) && ((a.faceIndex = Math.floor(S / 3)), t.push(a));
                        }
                    else if (void 0 !== s)
                      if (Array.isArray(r))
                        for (var C = 0, L = d.length; C < L; C++)
                          for (
                            var k = d[C],
                              E = r[k.materialIndex],
                              P = Math.max(k.start, f.start),
                              R = Math.min(
                                s.count,
                                Math.min(k.start + k.count, f.start + f.count)
                              );
                            P < R;
                            P += 3
                          ) {
                            (a = checkBufferGeometryIntersection(
                              this,
                              E,
                              e,
                              Ui,
                              s,
                              u,
                              l,
                              c,
                              h,
                              P,
                              P + 1,
                              P + 2
                            )) &&
                              ((a.faceIndex = Math.floor(P / 3)),
                              (a.face.materialIndex = k.materialIndex),
                              t.push(a));
                          }
                      else
                        for (
                          var I = Math.max(0, f.start),
                            D = Math.min(s.count, f.start + f.count);
                          I < D;
                          I += 3
                        ) {
                          (a = checkBufferGeometryIntersection(
                            this,
                            r,
                            e,
                            Ui,
                            s,
                            u,
                            l,
                            c,
                            h,
                            I,
                            I + 1,
                            I + 2
                          )) && ((a.faceIndex = Math.floor(I / 3)), t.push(a));
                        }
                  }
                },
              },
            ]),
            Mesh
          );
        })(ai);
      function checkBufferGeometryIntersection(
        e,
        t,
        n,
        r,
        i,
        a,
        o,
        s,
        u,
        l,
        c,
        h
      ) {
        Wi.fromBufferAttribute(i, l),
          Hi.fromBufferAttribute(i, c),
          qi.fromBufferAttribute(i, h);
        var d = e.morphTargetInfluences;
        if (a && d) {
          Zi.set(0, 0, 0), Ki.set(0, 0, 0), Qi.set(0, 0, 0);
          for (var f = 0, p = a.length; f < p; f++) {
            var m = d[f],
              v = a[f];
            0 !== m &&
              (Xi.fromBufferAttribute(v, l),
              Ji.fromBufferAttribute(v, c),
              Yi.fromBufferAttribute(v, h),
              o
                ? (Zi.addScaledVector(Xi, m),
                  Ki.addScaledVector(Ji, m),
                  Qi.addScaledVector(Yi, m))
                : (Zi.addScaledVector(Xi.sub(Wi), m),
                  Ki.addScaledVector(Ji.sub(Hi), m),
                  Qi.addScaledVector(Yi.sub(qi), m)));
          }
          Wi.add(Zi), Hi.add(Ki), qi.add(Qi);
        }
        e.isSkinnedMesh &&
          (e.boneTransform(l, Wi),
          e.boneTransform(c, Hi),
          e.boneTransform(h, qi));
        var g = (function checkIntersection(e, t, n, r, i, a, o, s) {
          if (
            null ===
            (t.side === C
              ? r.intersectTriangle(o, a, i, !0, s)
              : r.intersectTriangle(i, a, o, t.side !== L, s))
          )
            return null;
          ra.copy(s), ra.applyMatrix4(e.matrixWorld);
          var u = n.ray.origin.distanceTo(ra);
          return u < n.near || u > n.far
            ? null
            : { distance: u, point: ra.clone(), object: e };
        })(e, t, n, r, Wi, Hi, qi, na);
        if (g) {
          s &&
            ($i.fromBufferAttribute(s, l),
            ea.fromBufferAttribute(s, c),
            ta.fromBufferAttribute(s, h),
            (g.uv = vi.getUV(na, Wi, Hi, qi, $i, ea, ta, new Dn()))),
            u &&
              ($i.fromBufferAttribute(u, l),
              ea.fromBufferAttribute(u, c),
              ta.fromBufferAttribute(u, h),
              (g.uv2 = vi.getUV(na, Wi, Hi, qi, $i, ea, ta, new Dn())));
          var y = { a: l, b: c, c: h, normal: new ir(), materialIndex: 0 };
          vi.getNormal(Wi, Hi, qi, y.normal), (g.face = y);
        }
        return g;
      }
      var aa = (function (e) {
        function BoxGeometry() {
          var e,
            t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 1,
            n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 1,
            i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 1,
            a =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : 1,
            o =
              arguments.length > 4 && void 0 !== arguments[4]
                ? arguments[4]
                : 1,
            u =
              arguments.length > 5 && void 0 !== arguments[5]
                ? arguments[5]
                : 1;
          Object(f.a)(this, BoxGeometry),
            ((e = Object(s.a)(this, Object(r.a)(BoxGeometry).call(this))).type =
              "BoxGeometry"),
            (e.parameters = {
              width: t,
              height: n,
              depth: i,
              widthSegments: a,
              heightSegments: o,
              depthSegments: u,
            });
          var c = Object(l.a)(Object(l.a)(e));
          (a = Math.floor(a)), (o = Math.floor(o)), (u = Math.floor(u));
          var h = [],
            d = [],
            p = [],
            m = [],
            v = 0,
            g = 0;
          function buildPlane(e, t, n, r, i, a, o, s, u, l, f) {
            for (
              var y = a / u,
                b = o / l,
                x = a / 2,
                _ = o / 2,
                M = s / 2,
                S = u + 1,
                w = l + 1,
                T = 0,
                A = 0,
                O = new ir(),
                C = 0;
              C < w;
              C++
            )
              for (var L = C * b - _, k = 0; k < S; k++) {
                var E = k * y - x;
                (O[e] = E * r),
                  (O[t] = L * i),
                  (O[n] = M),
                  d.push(O.x, O.y, O.z),
                  (O[e] = 0),
                  (O[t] = 0),
                  (O[n] = s > 0 ? 1 : -1),
                  p.push(O.x, O.y, O.z),
                  m.push(k / u),
                  m.push(1 - C / l),
                  (T += 1);
              }
            for (var P = 0; P < l; P++)
              for (var R = 0; R < u; R++) {
                var I = v + R + S * P,
                  D = v + R + S * (P + 1),
                  j = v + (R + 1) + S * (P + 1),
                  B = v + (R + 1) + S * P;
                h.push(I, D, B), h.push(D, j, B), (A += 6);
              }
            c.addGroup(g, A, f), (g += A), (v += T);
          }
          return (
            buildPlane("z", "y", "x", -1, -1, i, n, t, u, o, 0),
            buildPlane("z", "y", "x", 1, -1, i, n, -t, u, o, 1),
            buildPlane("x", "z", "y", 1, 1, t, i, n, a, u, 2),
            buildPlane("x", "z", "y", 1, -1, t, i, -n, a, u, 3),
            buildPlane("x", "y", "z", 1, -1, t, n, i, a, o, 4),
            buildPlane("x", "y", "z", -1, -1, t, n, -i, a, o, 5),
            e.setIndex(h),
            e.setAttribute("position", new Ei(d, 3)),
            e.setAttribute("normal", new Ei(p, 3)),
            e.setAttribute("uv", new Ei(m, 2)),
            e
          );
        }
        return (
          Object(u.a)(BoxGeometry, e),
          Object(p.a)(BoxGeometry, null, [
            {
              key: "fromJSON",
              value: function fromJSON(e) {
                return new BoxGeometry(
                  e.width,
                  e.height,
                  e.depth,
                  e.widthSegments,
                  e.heightSegments,
                  e.depthSegments
                );
              },
            },
          ]),
          BoxGeometry
        );
      })(Fi);
      function cloneUniforms(e) {
        var t = {};
        for (var n in e)
          for (var r in ((t[n] = {}), e[n])) {
            var i = e[n][r];
            i &&
            (i.isColor ||
              i.isMatrix3 ||
              i.isMatrix4 ||
              i.isVector2 ||
              i.isVector3 ||
              i.isVector4 ||
              i.isTexture ||
              i.isQuaternion)
              ? (t[n][r] = i.clone())
              : Array.isArray(i)
              ? (t[n][r] = i.slice())
              : (t[n][r] = i);
          }
        return t;
      }
      function mergeUniforms(e) {
        for (var t = {}, n = 0; n < e.length; n++) {
          var r = cloneUniforms(e[n]);
          for (var i in r) t[i] = r[i];
        }
        return t;
      }
      var oa = { clone: cloneUniforms, merge: mergeUniforms },
        sa =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        ua = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        la = (function (e) {
          function ShaderMaterial(e) {
            var t;
            return (
              Object(f.a)(this, ShaderMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(ShaderMaterial).call(this)
              )).isShaderMaterial = !0),
              (t.type = "ShaderMaterial"),
              (t.defines = {}),
              (t.uniforms = {}),
              (t.uniformsGroups = []),
              (t.vertexShader = sa),
              (t.fragmentShader = ua),
              (t.linewidth = 1),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.fog = !1),
              (t.lights = !1),
              (t.clipping = !1),
              (t.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (t.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0],
              }),
              (t.index0AttributeName = void 0),
              (t.uniformsNeedUpdate = !1),
              (t.glslVersion = null),
              void 0 !== e &&
                (void 0 !== e.attributes &&
                  console.error(
                    "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                  ),
                t.setValues(e)),
              t
            );
          }
          return (
            Object(u.a)(ShaderMaterial, e),
            Object(p.a)(ShaderMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(ShaderMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.fragmentShader = e.fragmentShader),
                    (this.vertexShader = e.vertexShader),
                    (this.uniforms = cloneUniforms(e.uniforms)),
                    (this.uniformsGroups = (function cloneUniformsGroups(e) {
                      for (var t = [], n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                      return t;
                    })(e.uniformsGroups)),
                    (this.defines = Object.assign({}, e.defines)),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.fog = e.fog),
                    (this.lights = e.lights),
                    (this.clipping = e.clipping),
                    (this.extensions = Object.assign({}, e.extensions)),
                    (this.glslVersion = e.glslVersion),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(ShaderMaterial.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  for (var n in ((t.glslVersion = this.glslVersion),
                  (t.uniforms = {}),
                  this.uniforms)) {
                    var i = this.uniforms[n].value;
                    i && i.isTexture
                      ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
                      : i && i.isColor
                      ? (t.uniforms[n] = { type: "c", value: i.getHex() })
                      : i && i.isVector2
                      ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
                      : i && i.isVector3
                      ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
                      : i && i.isVector4
                      ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
                      : i && i.isMatrix3
                      ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
                      : i && i.isMatrix4
                      ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
                      : (t.uniforms[n] = { value: i });
                  }
                  Object.keys(this.defines).length > 0 &&
                    (t.defines = this.defines),
                    (t.vertexShader = this.vertexShader),
                    (t.fragmentShader = this.fragmentShader);
                  var a = {};
                  for (var s in this.extensions)
                    !0 === this.extensions[s] && (a[s] = !0);
                  return Object.keys(a).length > 0 && (t.extensions = a), t;
                },
              },
            ]),
            ShaderMaterial
          );
        })(yi),
        ca = (function (e) {
          function Camera() {
            var e;
            return (
              Object(f.a)(this, Camera),
              ((e = Object(s.a)(
                this,
                Object(r.a)(Camera).call(this)
              )).isCamera = !0),
              (e.type = "Camera"),
              (e.matrixWorldInverse = new Ir()),
              (e.projectionMatrix = new Ir()),
              (e.projectionMatrixInverse = new Ir()),
              e
            );
          }
          return (
            Object(u.a)(Camera, e),
            Object(p.a)(Camera, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(Camera.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    this.matrixWorldInverse.copy(e.matrixWorldInverse),
                    this.projectionMatrix.copy(e.projectionMatrix),
                    this.projectionMatrixInverse.copy(
                      e.projectionMatrixInverse
                    ),
                    this
                  );
                },
              },
              {
                key: "getWorldDirection",
                value: function getWorldDirection(e) {
                  this.updateWorldMatrix(!0, !1);
                  var t = this.matrixWorld.elements;
                  return e.set(-t[8], -t[9], -t[10]).normalize();
                },
              },
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  Object(o.a)(
                    Object(r.a)(Camera.prototype),
                    "updateMatrixWorld",
                    this
                  ).call(this, e),
                    this.matrixWorldInverse.copy(this.matrixWorld).invert();
                },
              },
              {
                key: "updateWorldMatrix",
                value: function updateWorldMatrix(e, t) {
                  Object(o.a)(
                    Object(r.a)(Camera.prototype),
                    "updateWorldMatrix",
                    this
                  ).call(this, e, t),
                    this.matrixWorldInverse.copy(this.matrixWorld).invert();
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Camera
          );
        })(ai),
        ha = (function (e) {
          function PerspectiveCamera() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 50,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0.1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 2e3;
            return (
              Object(f.a)(this, PerspectiveCamera),
              ((e = Object(s.a)(
                this,
                Object(r.a)(PerspectiveCamera).call(this)
              )).isPerspectiveCamera = !0),
              (e.type = "PerspectiveCamera"),
              (e.fov = t),
              (e.zoom = 1),
              (e.near = i),
              (e.far = a),
              (e.focus = 10),
              (e.aspect = n),
              (e.view = null),
              (e.filmGauge = 35),
              (e.filmOffset = 0),
              e.updateProjectionMatrix(),
              e
            );
          }
          return (
            Object(u.a)(PerspectiveCamera, e),
            Object(p.a)(PerspectiveCamera, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(PerspectiveCamera.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.fov = e.fov),
                    (this.zoom = e.zoom),
                    (this.near = e.near),
                    (this.far = e.far),
                    (this.focus = e.focus),
                    (this.aspect = e.aspect),
                    (this.view =
                      null === e.view ? null : Object.assign({}, e.view)),
                    (this.filmGauge = e.filmGauge),
                    (this.filmOffset = e.filmOffset),
                    this
                  );
                },
              },
              {
                key: "setFocalLength",
                value: function setFocalLength(e) {
                  var t = (0.5 * this.getFilmHeight()) / e;
                  (this.fov = 2 * Rn * Math.atan(t)),
                    this.updateProjectionMatrix();
                },
              },
              {
                key: "getFocalLength",
                value: function getFocalLength() {
                  var e = Math.tan(0.5 * Pn * this.fov);
                  return (0.5 * this.getFilmHeight()) / e;
                },
              },
              {
                key: "getEffectiveFOV",
                value: function getEffectiveFOV() {
                  return (
                    2 *
                    Rn *
                    Math.atan(Math.tan(0.5 * Pn * this.fov) / this.zoom)
                  );
                },
              },
              {
                key: "getFilmWidth",
                value: function getFilmWidth() {
                  return this.filmGauge * Math.min(this.aspect, 1);
                },
              },
              {
                key: "getFilmHeight",
                value: function getFilmHeight() {
                  return this.filmGauge / Math.max(this.aspect, 1);
                },
              },
              {
                key: "setViewOffset",
                value: function setViewOffset(e, t, n, r, i, a) {
                  (this.aspect = e / t),
                    null === this.view &&
                      (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1,
                      }),
                    (this.view.enabled = !0),
                    (this.view.fullWidth = e),
                    (this.view.fullHeight = t),
                    (this.view.offsetX = n),
                    (this.view.offsetY = r),
                    (this.view.width = i),
                    (this.view.height = a),
                    this.updateProjectionMatrix();
                },
              },
              {
                key: "clearViewOffset",
                value: function clearViewOffset() {
                  null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix();
                },
              },
              {
                key: "updateProjectionMatrix",
                value: function updateProjectionMatrix() {
                  var e = this.near,
                    t = (e * Math.tan(0.5 * Pn * this.fov)) / this.zoom,
                    n = 2 * t,
                    r = this.aspect * n,
                    i = -0.5 * r,
                    a = this.view;
                  if (null !== this.view && this.view.enabled) {
                    var o = a.fullWidth,
                      s = a.fullHeight;
                    (i += (a.offsetX * r) / o),
                      (t -= (a.offsetY * n) / s),
                      (r *= a.width / o),
                      (n *= a.height / s);
                  }
                  var u = this.filmOffset;
                  0 !== u && (i += (e * u) / this.getFilmWidth()),
                    this.projectionMatrix.makePerspective(
                      i,
                      i + r,
                      t,
                      t - n,
                      e,
                      this.far
                    ),
                    this.projectionMatrixInverse
                      .copy(this.projectionMatrix)
                      .invert();
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(PerspectiveCamera.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (
                    (t.object.fov = this.fov),
                    (t.object.zoom = this.zoom),
                    (t.object.near = this.near),
                    (t.object.far = this.far),
                    (t.object.focus = this.focus),
                    (t.object.aspect = this.aspect),
                    null !== this.view &&
                      (t.object.view = Object.assign({}, this.view)),
                    (t.object.filmGauge = this.filmGauge),
                    (t.object.filmOffset = this.filmOffset),
                    t
                  );
                },
              },
            ]),
            PerspectiveCamera
          );
        })(ca),
        da = 90,
        fa = 1,
        pa = (function (e) {
          function CubeCamera(e, t, n) {
            var i;
            if (
              (Object(f.a)(this, CubeCamera),
              ((i = Object(s.a)(
                this,
                Object(r.a)(CubeCamera).call(this)
              )).type = "CubeCamera"),
              !0 !== n.isWebGLCubeRenderTarget)
            )
              return (
                console.error(
                  "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
                ),
                Object(s.a)(i)
              );
            i.renderTarget = n;
            var a = new ha(da, fa, e, t);
            (a.layers = i.layers),
              a.up.set(0, -1, 0),
              a.lookAt(new ir(1, 0, 0)),
              i.add(a);
            var o = new ha(da, fa, e, t);
            (o.layers = i.layers),
              o.up.set(0, -1, 0),
              o.lookAt(new ir(-1, 0, 0)),
              i.add(o);
            var u = new ha(da, fa, e, t);
            (u.layers = i.layers),
              u.up.set(0, 0, 1),
              u.lookAt(new ir(0, 1, 0)),
              i.add(u);
            var l = new ha(da, fa, e, t);
            (l.layers = i.layers),
              l.up.set(0, 0, -1),
              l.lookAt(new ir(0, -1, 0)),
              i.add(l);
            var c = new ha(da, fa, e, t);
            (c.layers = i.layers),
              c.up.set(0, -1, 0),
              c.lookAt(new ir(0, 0, 1)),
              i.add(c);
            var h = new ha(da, fa, e, t);
            return (
              (h.layers = i.layers),
              h.up.set(0, -1, 0),
              h.lookAt(new ir(0, 0, -1)),
              i.add(h),
              i
            );
          }
          return (
            Object(u.a)(CubeCamera, e),
            Object(p.a)(CubeCamera, [
              {
                key: "update",
                value: function update(e, t) {
                  null === this.parent && this.updateMatrixWorld();
                  var n = this.renderTarget,
                    r = Object(a.a)(this.children, 6),
                    i = r[0],
                    o = r[1],
                    s = r[2],
                    u = r[3],
                    l = r[4],
                    c = r[5],
                    h = e.getRenderTarget(),
                    d = e.toneMapping,
                    f = e.xr.enabled;
                  (e.toneMapping = he), (e.xr.enabled = !1);
                  var p = n.texture.generateMipmaps;
                  (n.texture.generateMipmaps = !1),
                    e.setRenderTarget(n, 0),
                    e.render(t, i),
                    e.setRenderTarget(n, 1),
                    e.render(t, o),
                    e.setRenderTarget(n, 2),
                    e.render(t, s),
                    e.setRenderTarget(n, 3),
                    e.render(t, u),
                    e.setRenderTarget(n, 4),
                    e.render(t, l),
                    (n.texture.generateMipmaps = p),
                    e.setRenderTarget(n, 5),
                    e.render(t, c),
                    e.setRenderTarget(h),
                    (e.toneMapping = d),
                    (e.xr.enabled = f),
                    (n.texture.needsPMREMUpdate = !0);
                },
              },
            ]),
            CubeCamera
          );
        })(ai),
        ma = (function (e) {
          function CubeTexture(e, t, n, i, a, o, u, l, c, h) {
            var d;
            return (
              Object(f.a)(this, CubeTexture),
              (e = void 0 !== e ? e : []),
              (t = void 0 !== t ? t : ye),
              ((d = Object(s.a)(
                this,
                Object(r.a)(CubeTexture).call(
                  this,
                  e,
                  t,
                  n,
                  i,
                  a,
                  o,
                  u,
                  l,
                  c,
                  h
                )
              )).isCubeTexture = !0),
              (d.flipY = !1),
              d
            );
          }
          return (
            Object(u.a)(CubeTexture, e),
            Object(p.a)(CubeTexture, [
              {
                key: "images",
                get: function get() {
                  return this.image;
                },
                set: function set(e) {
                  this.image = e;
                },
              },
            ]),
            CubeTexture
          );
        })(Yn),
        va = (function (e) {
          function WebGLCubeRenderTarget(e) {
            var t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
            Object(f.a)(this, WebGLCubeRenderTarget),
              ((t = Object(s.a)(
                this,
                Object(r.a)(WebGLCubeRenderTarget).call(this, e, e, n)
              )).isWebGLCubeRenderTarget = !0);
            var i = { width: e, height: e, depth: 1 },
              a = [i, i, i, i, i, i];
            return (
              (t.texture = new ma(
                a,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding
              )),
              (t.texture.isRenderTargetTexture = !0),
              (t.texture.generateMipmaps =
                void 0 !== n.generateMipmaps && n.generateMipmaps),
              (t.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Ee),
              t
            );
          }
          return (
            Object(u.a)(WebGLCubeRenderTarget, e),
            Object(p.a)(WebGLCubeRenderTarget, [
              {
                key: "fromEquirectangularTexture",
                value: function fromEquirectangularTexture(e, t) {
                  (this.texture.type = t.type),
                    (this.texture.encoding = t.encoding),
                    (this.texture.generateMipmaps = t.generateMipmaps),
                    (this.texture.minFilter = t.minFilter),
                    (this.texture.magFilter = t.magFilter);
                  var n = { tEquirect: { value: null } },
                    r =
                      "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    i =
                      "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                    a = new aa(5, 5, 5),
                    o = new la({
                      name: "CubemapFromEquirect",
                      uniforms: cloneUniforms(n),
                      vertexShader: r,
                      fragmentShader: i,
                      side: C,
                      blending: P,
                    });
                  o.uniforms.tEquirect.value = t;
                  var s = new ia(a, o),
                    u = t.minFilter;
                  return (
                    t.minFilter === Ie && (t.minFilter = Ee),
                    new pa(1, 10, this).update(e, s),
                    (t.minFilter = u),
                    s.geometry.dispose(),
                    s.material.dispose(),
                    this
                  );
                },
              },
              {
                key: "clear",
                value: function clear(e, t, n, r) {
                  for (var i = e.getRenderTarget(), a = 0; a < 6; a++)
                    e.setRenderTarget(this, a), e.clear(t, n, r);
                  e.setRenderTarget(i);
                },
              },
            ]),
            WebGLCubeRenderTarget
          );
        })(Kn),
        ga = new ir(),
        ya = new ir(),
        ba = new jn(),
        xa = (function () {
          function Plane() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(1, 0, 0),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            Object(f.a)(this, Plane),
              (this.isPlane = !0),
              (this.normal = e),
              (this.constant = t);
          }
          return (
            Object(p.a)(Plane, [
              {
                key: "set",
                value: function set(e, t) {
                  return this.normal.copy(e), (this.constant = t), this;
                },
              },
              {
                key: "setComponents",
                value: function setComponents(e, t, n, r) {
                  return this.normal.set(e, t, n), (this.constant = r), this;
                },
              },
              {
                key: "setFromNormalAndCoplanarPoint",
                value: function setFromNormalAndCoplanarPoint(e, t) {
                  return (
                    this.normal.copy(e),
                    (this.constant = -t.dot(this.normal)),
                    this
                  );
                },
              },
              {
                key: "setFromCoplanarPoints",
                value: function setFromCoplanarPoints(e, t, n) {
                  var r = ga
                    .subVectors(n, t)
                    .cross(ya.subVectors(e, t))
                    .normalize();
                  return this.setFromNormalAndCoplanarPoint(r, e), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    this.normal.copy(e.normal),
                    (this.constant = e.constant),
                    this
                  );
                },
              },
              {
                key: "normalize",
                value: function normalize() {
                  var e = 1 / this.normal.length();
                  return (
                    this.normal.multiplyScalar(e), (this.constant *= e), this
                  );
                },
              },
              {
                key: "negate",
                value: function negate() {
                  return (this.constant *= -1), this.normal.negate(), this;
                },
              },
              {
                key: "distanceToPoint",
                value: function distanceToPoint(e) {
                  return this.normal.dot(e) + this.constant;
                },
              },
              {
                key: "distanceToSphere",
                value: function distanceToSphere(e) {
                  return this.distanceToPoint(e.center) - e.radius;
                },
              },
              {
                key: "projectPoint",
                value: function projectPoint(e, t) {
                  return t
                    .copy(this.normal)
                    .multiplyScalar(-this.distanceToPoint(e))
                    .add(e);
                },
              },
              {
                key: "intersectLine",
                value: function intersectLine(e, t) {
                  var n = e.delta(ga),
                    r = this.normal.dot(n);
                  if (0 === r)
                    return 0 === this.distanceToPoint(e.start)
                      ? t.copy(e.start)
                      : null;
                  var i = -(e.start.dot(this.normal) + this.constant) / r;
                  return i < 0 || i > 1
                    ? null
                    : t.copy(n).multiplyScalar(i).add(e.start);
                },
              },
              {
                key: "intersectsLine",
                value: function intersectsLine(e) {
                  var t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                  return (t < 0 && n > 0) || (n < 0 && t > 0);
                },
              },
              {
                key: "intersectsBox",
                value: function intersectsBox(e) {
                  return e.intersectsPlane(this);
                },
              },
              {
                key: "intersectsSphere",
                value: function intersectsSphere(e) {
                  return e.intersectsPlane(this);
                },
              },
              {
                key: "coplanarPoint",
                value: function coplanarPoint(e) {
                  return e.copy(this.normal).multiplyScalar(-this.constant);
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e, t) {
                  var n = t || ba.getNormalMatrix(e),
                    r = this.coplanarPoint(ga).applyMatrix4(e),
                    i = this.normal.applyMatrix3(n).normalize();
                  return (this.constant = -r.dot(i)), this;
                },
              },
              {
                key: "translate",
                value: function translate(e) {
                  return (this.constant -= e.dot(this.normal)), this;
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return (
                    e.normal.equals(this.normal) && e.constant === this.constant
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Plane
          );
        })(),
        _a = new Tr(),
        Ma = new ir(),
        Sa = (function () {
          function Frustum() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new xa(),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new xa(),
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : new xa(),
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : new xa(),
              i =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : new xa(),
              a =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : new xa();
            Object(f.a)(this, Frustum), (this.planes = [e, t, n, r, i, a]);
          }
          return (
            Object(p.a)(Frustum, [
              {
                key: "set",
                value: function set(e, t, n, r, i, a) {
                  var o = this.planes;
                  return (
                    o[0].copy(e),
                    o[1].copy(t),
                    o[2].copy(n),
                    o[3].copy(r),
                    o[4].copy(i),
                    o[5].copy(a),
                    this
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  for (var t = this.planes, n = 0; n < 6; n++)
                    t[n].copy(e.planes[n]);
                  return this;
                },
              },
              {
                key: "setFromProjectionMatrix",
                value: function setFromProjectionMatrix(e) {
                  var t = this.planes,
                    n = e.elements,
                    r = n[0],
                    i = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    u = n[5],
                    l = n[6],
                    c = n[7],
                    h = n[8],
                    d = n[9],
                    f = n[10],
                    p = n[11],
                    m = n[12],
                    v = n[13],
                    g = n[14],
                    y = n[15];
                  return (
                    t[0].setComponents(o - r, c - s, p - h, y - m).normalize(),
                    t[1].setComponents(o + r, c + s, p + h, y + m).normalize(),
                    t[2].setComponents(o + i, c + u, p + d, y + v).normalize(),
                    t[3].setComponents(o - i, c - u, p - d, y - v).normalize(),
                    t[4].setComponents(o - a, c - l, p - f, y - g).normalize(),
                    t[5].setComponents(o + a, c + l, p + f, y + g).normalize(),
                    this
                  );
                },
              },
              {
                key: "intersectsObject",
                value: function intersectsObject(e) {
                  var t = e.geometry;
                  return (
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    _a.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
                    this.intersectsSphere(_a)
                  );
                },
              },
              {
                key: "intersectsSprite",
                value: function intersectsSprite(e) {
                  return (
                    _a.center.set(0, 0, 0),
                    (_a.radius = 0.7071067811865476),
                    _a.applyMatrix4(e.matrixWorld),
                    this.intersectsSphere(_a)
                  );
                },
              },
              {
                key: "intersectsSphere",
                value: function intersectsSphere(e) {
                  for (
                    var t = this.planes, n = e.center, r = -e.radius, i = 0;
                    i < 6;
                    i++
                  ) {
                    if (t[i].distanceToPoint(n) < r) return !1;
                  }
                  return !0;
                },
              },
              {
                key: "intersectsBox",
                value: function intersectsBox(e) {
                  for (var t = this.planes, n = 0; n < 6; n++) {
                    var r = t[n];
                    if (
                      ((Ma.x = r.normal.x > 0 ? e.max.x : e.min.x),
                      (Ma.y = r.normal.y > 0 ? e.max.y : e.min.y),
                      (Ma.z = r.normal.z > 0 ? e.max.z : e.min.z),
                      r.distanceToPoint(Ma) < 0)
                    )
                      return !1;
                  }
                  return !0;
                },
              },
              {
                key: "containsPoint",
                value: function containsPoint(e) {
                  for (var t = this.planes, n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                  return !0;
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Frustum
          );
        })();
      function WebGLAnimation() {
        var e = null,
          t = !1,
          n = null,
          r = null;
        function onAnimationFrame(t, i) {
          n(t, i), (r = e.requestAnimationFrame(onAnimationFrame));
        }
        return {
          start: function start() {
            !0 !== t &&
              null !== n &&
              ((r = e.requestAnimationFrame(onAnimationFrame)), (t = !0));
          },
          stop: function stop() {
            e.cancelAnimationFrame(r), (t = !1);
          },
          setAnimationLoop: function setAnimationLoop(e) {
            n = e;
          },
          setContext: function setContext(t) {
            e = t;
          },
        };
      }
      function WebGLAttributes(e, t) {
        var n = t.isWebGL2,
          r = new WeakMap();
        return {
          get: function get(e) {
            return e.isInterleavedBufferAttribute && (e = e.data), r.get(e);
          },
          remove: function remove(t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            var n = r.get(t);
            n && (e.deleteBuffer(n.buffer), r.delete(t));
          },
          update: function update(t, i) {
            if (t.isGLBufferAttribute) {
              var a = r.get(t);
              (!a || a.version < t.version) &&
                r.set(t, {
                  buffer: t.buffer,
                  type: t.type,
                  bytesPerElement: t.elementSize,
                  version: t.version,
                });
            } else {
              t.isInterleavedBufferAttribute && (t = t.data);
              var o = r.get(t);
              void 0 === o
                ? r.set(
                    t,
                    (function createBuffer(t, r) {
                      var i,
                        a = t.array,
                        o = t.usage,
                        s = e.createBuffer();
                      if (
                        (e.bindBuffer(r, s),
                        e.bufferData(r, a, o),
                        t.onUploadCallback(),
                        a instanceof Float32Array)
                      )
                        i = 5126;
                      else if (a instanceof Uint16Array)
                        if (t.isFloat16BufferAttribute) {
                          if (!n)
                            throw new Error(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                            );
                          i = 5131;
                        } else i = 5123;
                      else if (a instanceof Int16Array) i = 5122;
                      else if (a instanceof Uint32Array) i = 5125;
                      else if (a instanceof Int32Array) i = 5124;
                      else if (a instanceof Int8Array) i = 5120;
                      else if (a instanceof Uint8Array) i = 5121;
                      else {
                        if (!(a instanceof Uint8ClampedArray))
                          throw new Error(
                            "THREE.WebGLAttributes: Unsupported buffer data format: " +
                              a
                          );
                        i = 5121;
                      }
                      return {
                        buffer: s,
                        type: i,
                        bytesPerElement: a.BYTES_PER_ELEMENT,
                        version: t.version,
                      };
                    })(t, i)
                  )
                : o.version < t.version &&
                  ((function updateBuffer(t, r, i) {
                    var a = r.array,
                      o = r.updateRange;
                    e.bindBuffer(i, t),
                      -1 === o.count
                        ? e.bufferSubData(i, 0, a)
                        : (n
                            ? e.bufferSubData(
                                i,
                                o.offset * a.BYTES_PER_ELEMENT,
                                a,
                                o.offset,
                                o.count
                              )
                            : e.bufferSubData(
                                i,
                                o.offset * a.BYTES_PER_ELEMENT,
                                a.subarray(o.offset, o.offset + o.count)
                              ),
                          (o.count = -1));
                  })(o.buffer, t, i),
                  (o.version = t.version));
            }
          },
        };
      }
      var wa = (function (e) {
          function PlaneGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            Object(f.a)(this, PlaneGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(PlaneGeometry).call(this)
              )).type = "PlaneGeometry"),
              (e.parameters = {
                width: t,
                height: n,
                widthSegments: i,
                heightSegments: a,
              });
            for (
              var o = t / 2,
                u = n / 2,
                l = Math.floor(i),
                c = Math.floor(a),
                h = l + 1,
                d = c + 1,
                p = t / l,
                m = n / c,
                v = [],
                g = [],
                y = [],
                b = [],
                x = 0;
              x < d;
              x++
            )
              for (var _ = x * m - u, M = 0; M < h; M++) {
                var S = M * p - o;
                g.push(S, -_, 0),
                  y.push(0, 0, 1),
                  b.push(M / l),
                  b.push(1 - x / c);
              }
            for (var w = 0; w < c; w++)
              for (var T = 0; T < l; T++) {
                var A = T + h * w,
                  O = T + h * (w + 1),
                  C = T + 1 + h * (w + 1),
                  L = T + 1 + h * w;
                v.push(A, O, L), v.push(O, C, L);
              }
            return (
              e.setIndex(v),
              e.setAttribute("position", new Ei(g, 3)),
              e.setAttribute("normal", new Ei(y, 3)),
              e.setAttribute("uv", new Ei(b, 2)),
              e
            );
          }
          return (
            Object(u.a)(PlaneGeometry, e),
            Object(p.a)(PlaneGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new PlaneGeometry(
                    e.width,
                    e.height,
                    e.widthSegments,
                    e.heightSegments
                  );
                },
              },
            ]),
            PlaneGeometry
          );
        })(Fi),
        Ta = {
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment:
            "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex:
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          output_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
          uv_pars_fragment:
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex:
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex:
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex:
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        },
        Aa = {
          common: {
            diffuse: { value: new Hn(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new jn() },
            uv2Transform: { value: new jn() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new Dn(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Hn(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Hn(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new jn() },
          },
          sprite: {
            diffuse: { value: new Hn(16777215) },
            opacity: { value: 1 },
            center: { value: new Dn(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new jn() },
          },
        },
        Oa = {
          basic: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.specularmap,
              Aa.envmap,
              Aa.aomap,
              Aa.lightmap,
              Aa.fog,
            ]),
            vertexShader: Ta.meshbasic_vert,
            fragmentShader: Ta.meshbasic_frag,
          },
          lambert: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.specularmap,
              Aa.envmap,
              Aa.aomap,
              Aa.lightmap,
              Aa.emissivemap,
              Aa.fog,
              Aa.lights,
              { emissive: { value: new Hn(0) } },
            ]),
            vertexShader: Ta.meshlambert_vert,
            fragmentShader: Ta.meshlambert_frag,
          },
          phong: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.specularmap,
              Aa.envmap,
              Aa.aomap,
              Aa.lightmap,
              Aa.emissivemap,
              Aa.bumpmap,
              Aa.normalmap,
              Aa.displacementmap,
              Aa.fog,
              Aa.lights,
              {
                emissive: { value: new Hn(0) },
                specular: { value: new Hn(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Ta.meshphong_vert,
            fragmentShader: Ta.meshphong_frag,
          },
          standard: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.envmap,
              Aa.aomap,
              Aa.lightmap,
              Aa.emissivemap,
              Aa.bumpmap,
              Aa.normalmap,
              Aa.displacementmap,
              Aa.roughnessmap,
              Aa.metalnessmap,
              Aa.fog,
              Aa.lights,
              {
                emissive: { value: new Hn(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Ta.meshphysical_vert,
            fragmentShader: Ta.meshphysical_frag,
          },
          toon: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.aomap,
              Aa.lightmap,
              Aa.emissivemap,
              Aa.bumpmap,
              Aa.normalmap,
              Aa.displacementmap,
              Aa.gradientmap,
              Aa.fog,
              Aa.lights,
              { emissive: { value: new Hn(0) } },
            ]),
            vertexShader: Ta.meshtoon_vert,
            fragmentShader: Ta.meshtoon_frag,
          },
          matcap: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.bumpmap,
              Aa.normalmap,
              Aa.displacementmap,
              Aa.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Ta.meshmatcap_vert,
            fragmentShader: Ta.meshmatcap_frag,
          },
          points: {
            uniforms: mergeUniforms([Aa.points, Aa.fog]),
            vertexShader: Ta.points_vert,
            fragmentShader: Ta.points_frag,
          },
          dashed: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Ta.linedashed_vert,
            fragmentShader: Ta.linedashed_frag,
          },
          depth: {
            uniforms: mergeUniforms([Aa.common, Aa.displacementmap]),
            vertexShader: Ta.depth_vert,
            fragmentShader: Ta.depth_frag,
          },
          normal: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.bumpmap,
              Aa.normalmap,
              Aa.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Ta.meshnormal_vert,
            fragmentShader: Ta.meshnormal_frag,
          },
          sprite: {
            uniforms: mergeUniforms([Aa.sprite, Aa.fog]),
            vertexShader: Ta.sprite_vert,
            fragmentShader: Ta.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new jn() },
              t2D: { value: null },
            },
            vertexShader: Ta.background_vert,
            fragmentShader: Ta.background_frag,
          },
          cube: {
            uniforms: mergeUniforms([Aa.envmap, { opacity: { value: 1 } }]),
            vertexShader: Ta.cube_vert,
            fragmentShader: Ta.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Ta.equirect_vert,
            fragmentShader: Ta.equirect_frag,
          },
          distanceRGBA: {
            uniforms: mergeUniforms([
              Aa.common,
              Aa.displacementmap,
              {
                referencePosition: { value: new ir() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Ta.distanceRGBA_vert,
            fragmentShader: Ta.distanceRGBA_frag,
          },
          shadow: {
            uniforms: mergeUniforms([
              Aa.lights,
              Aa.fog,
              { color: { value: new Hn(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Ta.shadow_vert,
            fragmentShader: Ta.shadow_frag,
          },
        };
      function WebGLBackground(e, t, n, r, i, a) {
        var o,
          s,
          u = new Hn(0),
          l = !0 === i ? 0 : 1,
          c = null,
          h = 0,
          d = null;
        function setClear(e, t) {
          n.buffers.color.setClear(e.r, e.g, e.b, t, a);
        }
        return {
          getClearColor: function getClearColor() {
            return u;
          },
          setClearColor: function setClearColor(e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 1;
            u.set(e), setClear(u, (l = t));
          },
          getClearAlpha: function getClearAlpha() {
            return l;
          },
          setClearAlpha: function setClearAlpha(e) {
            setClear(u, (l = e));
          },
          render: function render(n, i) {
            var a = !1,
              f = !0 === i.isScene ? i.background : null;
            f && f.isTexture && (f = t.get(f));
            var p = e.xr,
              m = p.getSession && p.getSession();
            m && "additive" === m.environmentBlendMode && (f = null),
              null === f
                ? setClear(u, l)
                : f && f.isColor && (setClear(f, 1), (a = !0)),
              (e.autoClear || a) &&
                e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
              f && (f.isCubeTexture || f.mapping === Me)
                ? (void 0 === s &&
                    ((s = new ia(
                      new aa(1, 1, 1),
                      new la({
                        name: "BackgroundCubeMaterial",
                        uniforms: cloneUniforms(Oa.cube.uniforms),
                        vertexShader: Oa.cube.vertexShader,
                        fragmentShader: Oa.cube.fragmentShader,
                        side: C,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )).geometry.deleteAttribute("normal"),
                    s.geometry.deleteAttribute("uv"),
                    (s.onBeforeRender = function (e, t, n) {
                      this.matrixWorld.copyPosition(n.matrixWorld);
                    }),
                    Object.defineProperty(s.material, "envMap", {
                      get: function get() {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    r.update(s)),
                  (s.material.uniforms.envMap.value = f),
                  (s.material.uniforms.flipEnvMap.value =
                    f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
                  (c === f && h === f.version && d === e.toneMapping) ||
                    ((s.material.needsUpdate = !0),
                    (c = f),
                    (h = f.version),
                    (d = e.toneMapping)),
                  s.layers.enableAll(),
                  n.unshift(s, s.geometry, s.material, 0, 0, null))
                : f &&
                  f.isTexture &&
                  (void 0 === o &&
                    ((o = new ia(
                      new wa(2, 2),
                      new la({
                        name: "BackgroundMaterial",
                        uniforms: cloneUniforms(Oa.background.uniforms),
                        vertexShader: Oa.background.vertexShader,
                        fragmentShader: Oa.background.fragmentShader,
                        side: O,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )).geometry.deleteAttribute("normal"),
                    Object.defineProperty(o.material, "map", {
                      get: function get() {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    r.update(o)),
                  (o.material.uniforms.t2D.value = f),
                  !0 === f.matrixAutoUpdate && f.updateMatrix(),
                  o.material.uniforms.uvTransform.value.copy(f.matrix),
                  (c === f && h === f.version && d === e.toneMapping) ||
                    ((o.material.needsUpdate = !0),
                    (c = f),
                    (h = f.version),
                    (d = e.toneMapping)),
                  o.layers.enableAll(),
                  n.unshift(o, o.geometry, o.material, 0, 0, null));
          },
        };
      }
      function WebGLBindingStates(e, t, n, r) {
        var i = e.getParameter(34921),
          a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
          o = r.isWebGL2 || null !== a,
          s = {},
          u = createBindingState(null),
          l = u,
          c = !1;
        function bindVertexArrayObject(t) {
          return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t);
        }
        function deleteVertexArrayObject(t) {
          return r.isWebGL2
            ? e.deleteVertexArray(t)
            : a.deleteVertexArrayOES(t);
        }
        function createBindingState(e) {
          for (var t = [], n = [], r = [], a = 0; a < i; a++)
            (t[a] = 0), (n[a] = 0), (r[a] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: n,
            attributeDivisors: r,
            object: e,
            attributes: {},
            index: null,
          };
        }
        function initAttributes() {
          for (var e = l.newAttributes, t = 0, n = e.length; t < n; t++)
            e[t] = 0;
        }
        function enableAttribute(e) {
          enableAttributeAndDivisor(e, 0);
        }
        function enableAttributeAndDivisor(n, i) {
          var a = l.newAttributes,
            o = l.enabledAttributes,
            s = l.attributeDivisors;
          ((a[n] = 1),
          0 === o[n] && (e.enableVertexAttribArray(n), (o[n] = 1)),
          s[n] !== i) &&
            ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
              r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
            ](n, i),
            (s[n] = i));
        }
        function disableUnusedAttributes() {
          for (
            var t = l.newAttributes,
              n = l.enabledAttributes,
              r = 0,
              i = n.length;
            r < i;
            r++
          )
            n[r] !== t[r] && (e.disableVertexAttribArray(r), (n[r] = 0));
        }
        function vertexAttribPointer(t, n, i, a, o, s) {
          !0 !== r.isWebGL2 || (5124 !== i && 5125 !== i)
            ? e.vertexAttribPointer(t, n, i, a, o, s)
            : e.vertexAttribIPointer(t, n, i, o, s);
        }
        function reset() {
          resetDefaultState(),
            (c = !0),
            l !== u && bindVertexArrayObject((l = u).object);
        }
        function resetDefaultState() {
          (u.geometry = null), (u.program = null), (u.wireframe = !1);
        }
        return {
          setup: function setup(i, u, h, d, f) {
            var p = !1;
            if (o) {
              var m = (function getBindingState(t, n, i) {
                var o = !0 === i.wireframe,
                  u = s[t.id];
                void 0 === u && ((u = {}), (s[t.id] = u));
                var l = u[n.id];
                void 0 === l && ((l = {}), (u[n.id] = l));
                var c = l[o];
                return (
                  void 0 === c &&
                    ((c = createBindingState(
                      (function createVertexArrayObject() {
                        return r.isWebGL2
                          ? e.createVertexArray()
                          : a.createVertexArrayOES();
                      })()
                    )),
                    (l[o] = c)),
                  c
                );
              })(d, h, u);
              l !== m && bindVertexArrayObject((l = m).object),
                (p = (function needsUpdate(e, t, n, r) {
                  var i = l.attributes,
                    a = t.attributes,
                    o = 0,
                    s = n.getAttributes();
                  for (var u in s) {
                    var c = s[u];
                    if (c.location >= 0) {
                      var h = i[u],
                        d = a[u];
                      if (
                        (void 0 === d &&
                          ("instanceMatrix" === u &&
                            e.instanceMatrix &&
                            (d = e.instanceMatrix),
                          "instanceColor" === u &&
                            e.instanceColor &&
                            (d = e.instanceColor)),
                        void 0 === h)
                      )
                        return !0;
                      if (h.attribute !== d) return !0;
                      if (d && h.data !== d.data) return !0;
                      o++;
                    }
                  }
                  return l.attributesNum !== o || l.index !== r;
                })(i, d, h, f)) &&
                  (function saveCache(e, t, n, r) {
                    var i = {},
                      a = t.attributes,
                      o = 0,
                      s = n.getAttributes();
                    for (var u in s) {
                      var c = s[u];
                      if (c.location >= 0) {
                        var h = a[u];
                        void 0 === h &&
                          ("instanceMatrix" === u &&
                            e.instanceMatrix &&
                            (h = e.instanceMatrix),
                          "instanceColor" === u &&
                            e.instanceColor &&
                            (h = e.instanceColor));
                        var d = {};
                        (d.attribute = h),
                          h && h.data && (d.data = h.data),
                          (i[u] = d),
                          o++;
                      }
                    }
                    (l.attributes = i), (l.attributesNum = o), (l.index = r);
                  })(i, d, h, f);
            } else {
              var v = !0 === u.wireframe;
              (l.geometry === d.id &&
                l.program === h.id &&
                l.wireframe === v) ||
                ((l.geometry = d.id),
                (l.program = h.id),
                (l.wireframe = v),
                (p = !0));
            }
            null !== f && n.update(f, 34963),
              (p || c) &&
                ((c = !1),
                (function setupVertexAttributes(i, a, o, s) {
                  if (
                    !1 !== r.isWebGL2 ||
                    (!i.isInstancedMesh && !s.isInstancedBufferGeometry) ||
                    null !== t.get("ANGLE_instanced_arrays")
                  ) {
                    initAttributes();
                    var u = s.attributes,
                      l = o.getAttributes(),
                      c = a.defaultAttributeValues;
                    for (var h in l) {
                      var d = l[h];
                      if (d.location >= 0) {
                        var f = u[h];
                        if (
                          (void 0 === f &&
                            ("instanceMatrix" === h &&
                              i.instanceMatrix &&
                              (f = i.instanceMatrix),
                            "instanceColor" === h &&
                              i.instanceColor &&
                              (f = i.instanceColor)),
                          void 0 !== f)
                        ) {
                          var p = f.normalized,
                            m = f.itemSize,
                            v = n.get(f);
                          if (void 0 === v) continue;
                          var g = v.buffer,
                            y = v.type,
                            b = v.bytesPerElement;
                          if (f.isInterleavedBufferAttribute) {
                            var x = f.data,
                              _ = x.stride,
                              M = f.offset;
                            if (x.isInstancedInterleavedBuffer) {
                              for (var S = 0; S < d.locationSize; S++)
                                enableAttributeAndDivisor(
                                  d.location + S,
                                  x.meshPerAttribute
                                );
                              !0 !== i.isInstancedMesh &&
                                void 0 === s._maxInstanceCount &&
                                (s._maxInstanceCount =
                                  x.meshPerAttribute * x.count);
                            } else
                              for (var w = 0; w < d.locationSize; w++)
                                enableAttribute(d.location + w);
                            e.bindBuffer(34962, g);
                            for (var T = 0; T < d.locationSize; T++)
                              vertexAttribPointer(
                                d.location + T,
                                m / d.locationSize,
                                y,
                                p,
                                _ * b,
                                (M + (m / d.locationSize) * T) * b
                              );
                          } else {
                            if (f.isInstancedBufferAttribute) {
                              for (var A = 0; A < d.locationSize; A++)
                                enableAttributeAndDivisor(
                                  d.location + A,
                                  f.meshPerAttribute
                                );
                              !0 !== i.isInstancedMesh &&
                                void 0 === s._maxInstanceCount &&
                                (s._maxInstanceCount =
                                  f.meshPerAttribute * f.count);
                            } else
                              for (var O = 0; O < d.locationSize; O++)
                                enableAttribute(d.location + O);
                            e.bindBuffer(34962, g);
                            for (var C = 0; C < d.locationSize; C++)
                              vertexAttribPointer(
                                d.location + C,
                                m / d.locationSize,
                                y,
                                p,
                                m * b,
                                (m / d.locationSize) * C * b
                              );
                          }
                        } else if (void 0 !== c) {
                          var L = c[h];
                          if (void 0 !== L)
                            switch (L.length) {
                              case 2:
                                e.vertexAttrib2fv(d.location, L);
                                break;
                              case 3:
                                e.vertexAttrib3fv(d.location, L);
                                break;
                              case 4:
                                e.vertexAttrib4fv(d.location, L);
                                break;
                              default:
                                e.vertexAttrib1fv(d.location, L);
                            }
                        }
                      }
                    }
                    disableUnusedAttributes();
                  }
                })(i, u, h, d),
                null !== f && e.bindBuffer(34963, n.get(f).buffer));
          },
          reset: reset,
          resetDefaultState: resetDefaultState,
          dispose: function dispose() {
            for (var e in (reset(), s)) {
              var t = s[e];
              for (var n in t) {
                var r = t[n];
                for (var i in r)
                  deleteVertexArrayObject(r[i].object), delete r[i];
                delete t[n];
              }
              delete s[e];
            }
          },
          releaseStatesOfGeometry: function releaseStatesOfGeometry(e) {
            if (void 0 !== s[e.id]) {
              var t = s[e.id];
              for (var n in t) {
                var r = t[n];
                for (var i in r)
                  deleteVertexArrayObject(r[i].object), delete r[i];
                delete t[n];
              }
              delete s[e.id];
            }
          },
          releaseStatesOfProgram: function releaseStatesOfProgram(e) {
            for (var t in s) {
              var n = s[t];
              if (void 0 !== n[e.id]) {
                var r = n[e.id];
                for (var i in r)
                  deleteVertexArrayObject(r[i].object), delete r[i];
                delete n[e.id];
              }
            }
          },
          initAttributes: initAttributes,
          enableAttribute: enableAttribute,
          disableUnusedAttributes: disableUnusedAttributes,
        };
      }
      function WebGLBufferRenderer(e, t, n, r) {
        var i,
          a = r.isWebGL2;
        (this.setMode = function setMode(e) {
          i = e;
        }),
          (this.render = function render(t, r) {
            e.drawArrays(i, t, r), n.update(r, i, 1);
          }),
          (this.renderInstances = function renderInstances(r, o, s) {
            if (0 !== s) {
              var u, l;
              if (a) (u = e), (l = "drawArraysInstanced");
              else if (
                ((l = "drawArraysInstancedANGLE"),
                null === (u = t.get("ANGLE_instanced_arrays")))
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              u[l](i, r, o, s), n.update(o, i, s);
            }
          });
      }
      function WebGLCapabilities(e, t, n) {
        var r;
        function getMaxPrecision(t) {
          if ("highp" === t) {
            if (
              e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              e.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            t = "mediump";
          }
          return "mediump" === t &&
            e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        var i =
            ("undefined" !== typeof WebGL2RenderingContext &&
              e instanceof WebGL2RenderingContext) ||
            ("undefined" !== typeof WebGL2ComputeRenderingContext &&
              e instanceof WebGL2ComputeRenderingContext),
          a = void 0 !== n.precision ? n.precision : "highp",
          o = getMaxPrecision(a);
        o !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            o,
            "instead."
          ),
          (a = o));
        var s = i || t.has("WEBGL_draw_buffers"),
          u = !0 === n.logarithmicDepthBuffer,
          l = e.getParameter(34930),
          c = e.getParameter(35660),
          h = e.getParameter(3379),
          d = e.getParameter(34076),
          f = e.getParameter(34921),
          p = e.getParameter(36347),
          m = e.getParameter(36348),
          v = e.getParameter(36349),
          g = c > 0,
          y = i || t.has("OES_texture_float");
        return {
          isWebGL2: i,
          drawBuffers: s,
          getMaxAnisotropy: function getMaxAnisotropy() {
            if (void 0 !== r) return r;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
              var n = t.get("EXT_texture_filter_anisotropic");
              r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else r = 0;
            return r;
          },
          getMaxPrecision: getMaxPrecision,
          precision: a,
          logarithmicDepthBuffer: u,
          maxTextures: l,
          maxVertexTextures: c,
          maxTextureSize: h,
          maxCubemapSize: d,
          maxAttributes: f,
          maxVertexUniforms: p,
          maxVaryings: m,
          maxFragmentUniforms: v,
          vertexTextures: g,
          floatFragmentTextures: y,
          floatVertexTextures: g && y,
          maxSamples: i ? e.getParameter(36183) : 0,
        };
      }
      function WebGLClipping(e) {
        var t = this,
          n = null,
          r = 0,
          i = !1,
          a = !1,
          o = new xa(),
          s = new jn(),
          u = { value: null, needsUpdate: !1 };
        function resetGlobalState() {
          u.value !== n && ((u.value = n), (u.needsUpdate = r > 0)),
            (t.numPlanes = r),
            (t.numIntersection = 0);
        }
        function projectPlanes(e, n, r, i) {
          var a = null !== e ? e.length : 0,
            l = null;
          if (0 !== a) {
            if (((l = u.value), !0 !== i || null === l)) {
              var c = r + 4 * a,
                h = n.matrixWorldInverse;
              s.getNormalMatrix(h),
                (null === l || l.length < c) && (l = new Float32Array(c));
              for (var d = 0, f = r; d !== a; ++d, f += 4)
                o.copy(e[d]).applyMatrix4(h, s),
                  o.normal.toArray(l, f),
                  (l[f + 3] = o.constant);
            }
            (u.value = l), (u.needsUpdate = !0);
          }
          return (t.numPlanes = a), (t.numIntersection = 0), l;
        }
        (this.uniform = u),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, t, a) {
            var o = 0 !== e.length || t || 0 !== r || i;
            return (i = t), (n = projectPlanes(e, a, 0)), (r = e.length), o;
          }),
          (this.beginShadows = function () {
            (a = !0), projectPlanes(null);
          }),
          (this.endShadows = function () {
            (a = !1), resetGlobalState();
          }),
          (this.setState = function (t, o, s) {
            var l = t.clippingPlanes,
              c = t.clipIntersection,
              h = t.clipShadows,
              d = e.get(t);
            if (!i || null === l || 0 === l.length || (a && !h))
              a ? projectPlanes(null) : resetGlobalState();
            else {
              var f = a ? 0 : r,
                p = 4 * f,
                m = d.clippingState || null;
              (u.value = m), (m = projectPlanes(l, o, p, s));
              for (var v = 0; v !== p; ++v) m[v] = n[v];
              (d.clippingState = m),
                (this.numIntersection = c ? this.numPlanes : 0),
                (this.numPlanes += f);
            }
          });
      }
      function WebGLCubeMaps(e) {
        var t = new WeakMap();
        function mapTextureMapping(e, t) {
          return t === xe ? (e.mapping = ye) : t === _e && (e.mapping = be), e;
        }
        function onTextureDispose(e) {
          var n = e.target;
          n.removeEventListener("dispose", onTextureDispose);
          var r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function get(n) {
            if (n && n.isTexture && !1 === n.isRenderTargetTexture) {
              var r = n.mapping;
              if (r === xe || r === _e) {
                if (t.has(n))
                  return mapTextureMapping(t.get(n).texture, n.mapping);
                var i = n.image;
                if (i && i.height > 0) {
                  var a = new va(i.height / 2);
                  return (
                    a.fromEquirectangularTexture(e, n),
                    t.set(n, a),
                    n.addEventListener("dispose", onTextureDispose),
                    mapTextureMapping(a.texture, n.mapping)
                  );
                }
                return null;
              }
            }
            return n;
          },
          dispose: function dispose() {
            t = new WeakMap();
          },
        };
      }
      Oa.physical = {
        uniforms: mergeUniforms([
          Oa.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Dn(1, 1) },
            clearcoatNormalMap: { value: null },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new Hn(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new Dn() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Hn(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new Hn(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: Ta.meshphysical_vert,
        fragmentShader: Ta.meshphysical_frag,
      };
      var Ca = (function (e) {
          function OrthographicCamera() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : -1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : -1,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 0.1,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 2e3;
            return (
              Object(f.a)(this, OrthographicCamera),
              ((e = Object(s.a)(
                this,
                Object(r.a)(OrthographicCamera).call(this)
              )).isOrthographicCamera = !0),
              (e.type = "OrthographicCamera"),
              (e.zoom = 1),
              (e.view = null),
              (e.left = t),
              (e.right = n),
              (e.top = i),
              (e.bottom = a),
              (e.near = o),
              (e.far = u),
              e.updateProjectionMatrix(),
              e
            );
          }
          return (
            Object(u.a)(OrthographicCamera, e),
            Object(p.a)(OrthographicCamera, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(OrthographicCamera.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.left = e.left),
                    (this.right = e.right),
                    (this.top = e.top),
                    (this.bottom = e.bottom),
                    (this.near = e.near),
                    (this.far = e.far),
                    (this.zoom = e.zoom),
                    (this.view =
                      null === e.view ? null : Object.assign({}, e.view)),
                    this
                  );
                },
              },
              {
                key: "setViewOffset",
                value: function setViewOffset(e, t, n, r, i, a) {
                  null === this.view &&
                    (this.view = {
                      enabled: !0,
                      fullWidth: 1,
                      fullHeight: 1,
                      offsetX: 0,
                      offsetY: 0,
                      width: 1,
                      height: 1,
                    }),
                    (this.view.enabled = !0),
                    (this.view.fullWidth = e),
                    (this.view.fullHeight = t),
                    (this.view.offsetX = n),
                    (this.view.offsetY = r),
                    (this.view.width = i),
                    (this.view.height = a),
                    this.updateProjectionMatrix();
                },
              },
              {
                key: "clearViewOffset",
                value: function clearViewOffset() {
                  null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix();
                },
              },
              {
                key: "updateProjectionMatrix",
                value: function updateProjectionMatrix() {
                  var e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2,
                    i = n - e,
                    a = n + e,
                    o = r + t,
                    s = r - t;
                  if (null !== this.view && this.view.enabled) {
                    var u =
                        (this.right - this.left) /
                        this.view.fullWidth /
                        this.zoom,
                      l =
                        (this.top - this.bottom) /
                        this.view.fullHeight /
                        this.zoom;
                    (a = (i += u * this.view.offsetX) + u * this.view.width),
                      (s = (o -= l * this.view.offsetY) - l * this.view.height);
                  }
                  this.projectionMatrix.makeOrthographic(
                    i,
                    a,
                    o,
                    s,
                    this.near,
                    this.far
                  ),
                    this.projectionMatrixInverse
                      .copy(this.projectionMatrix)
                      .invert();
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(OrthographicCamera.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (
                    (t.object.zoom = this.zoom),
                    (t.object.left = this.left),
                    (t.object.right = this.right),
                    (t.object.top = this.top),
                    (t.object.bottom = this.bottom),
                    (t.object.near = this.near),
                    (t.object.far = this.far),
                    null !== this.view &&
                      (t.object.view = Object.assign({}, this.view)),
                    t
                  );
                },
              },
            ]),
            OrthographicCamera
          );
        })(ca),
        La = 4,
        ka = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Ea = 20,
        Pa = new Ca(),
        Ra = new Hn(),
        Ia = null,
        Da = (1 + Math.sqrt(5)) / 2,
        ja = 1 / Da,
        Ba = [
          new ir(1, 1, 1),
          new ir(-1, 1, 1),
          new ir(1, 1, -1),
          new ir(-1, 1, -1),
          new ir(0, Da, ja),
          new ir(0, Da, -ja),
          new ir(ja, 0, Da),
          new ir(-ja, 0, Da),
          new ir(Da, ja, 0),
          new ir(-Da, ja, 0),
        ],
        Na = (function () {
          function PMREMGenerator(e) {
            Object(f.a)(this, PMREMGenerator),
              (this._renderer = e),
              (this._pingPongRenderTarget = null),
              (this._lodMax = 0),
              (this._cubeSize = 0),
              (this._lodPlanes = []),
              (this._sizeLods = []),
              (this._sigmas = []),
              (this._blurMaterial = null),
              (this._cubemapMaterial = null),
              (this._equirectMaterial = null),
              this._compileMaterial(this._blurMaterial);
          }
          return (
            Object(p.a)(PMREMGenerator, [
              {
                key: "fromScene",
                value: function fromScene(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0,
                    n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : 0.1,
                    r =
                      arguments.length > 3 && void 0 !== arguments[3]
                        ? arguments[3]
                        : 100;
                  (Ia = this._renderer.getRenderTarget()), this._setSize(256);
                  var i = this._allocateTargets();
                  return (
                    (i.depthBuffer = !0),
                    this._sceneToCubeUV(e, n, r, i),
                    t > 0 && this._blur(i, 0, 0, t),
                    this._applyPMREM(i),
                    this._cleanup(i),
                    i
                  );
                },
              },
              {
                key: "fromEquirectangular",
                value: function fromEquirectangular(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : null;
                  return this._fromTexture(e, t);
                },
              },
              {
                key: "fromCubemap",
                value: function fromCubemap(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : null;
                  return this._fromTexture(e, t);
                },
              },
              {
                key: "compileCubemapShader",
                value: function compileCubemapShader() {
                  null === this._cubemapMaterial &&
                    ((this._cubemapMaterial = _getCubemapMaterial()),
                    this._compileMaterial(this._cubemapMaterial));
                },
              },
              {
                key: "compileEquirectangularShader",
                value: function compileEquirectangularShader() {
                  null === this._equirectMaterial &&
                    ((this._equirectMaterial = _getEquirectMaterial()),
                    this._compileMaterial(this._equirectMaterial));
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this._dispose(),
                    null !== this._cubemapMaterial &&
                      this._cubemapMaterial.dispose(),
                    null !== this._equirectMaterial &&
                      this._equirectMaterial.dispose();
                },
              },
              {
                key: "_setSize",
                value: function _setSize(e) {
                  (this._lodMax = Math.floor(Math.log2(e))),
                    (this._cubeSize = Math.pow(2, this._lodMax));
                },
              },
              {
                key: "_dispose",
                value: function _dispose() {
                  null !== this._blurMaterial && this._blurMaterial.dispose(),
                    null !== this._pingPongRenderTarget &&
                      this._pingPongRenderTarget.dispose();
                  for (var e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose();
                },
              },
              {
                key: "_cleanup",
                value: function _cleanup(e) {
                  this._renderer.setRenderTarget(Ia),
                    (e.scissorTest = !1),
                    _setViewport(e, 0, 0, e.width, e.height);
                },
              },
              {
                key: "_fromTexture",
                value: function _fromTexture(e, t) {
                  e.mapping === ye || e.mapping === be
                    ? this._setSize(
                        0 === e.image.length
                          ? 16
                          : e.image[0].width || e.image[0].image.width
                      )
                    : this._setSize(e.image.width / 4),
                    (Ia = this._renderer.getRenderTarget());
                  var n = t || this._allocateTargets();
                  return (
                    this._textureToCubeUV(e, n),
                    this._applyPMREM(n),
                    this._cleanup(n),
                    n
                  );
                },
              },
              {
                key: "_allocateTargets",
                value: function _allocateTargets() {
                  var e = 3 * Math.max(this._cubeSize, 112),
                    t = 4 * this._cubeSize,
                    n = {
                      magFilter: Ee,
                      minFilter: Ee,
                      generateMipmaps: !1,
                      type: Ve,
                      format: Ye,
                      encoding: Ht,
                      depthBuffer: !1,
                    },
                    r = _createRenderTarget(e, t, n);
                  if (
                    null === this._pingPongRenderTarget ||
                    this._pingPongRenderTarget.width !== e
                  ) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                      (this._pingPongRenderTarget = _createRenderTarget(
                        e,
                        t,
                        n
                      ));
                    var i = this._lodMax,
                      a = (function _createPlanes(e) {
                        for (
                          var t = [],
                            n = [],
                            r = [],
                            i = e,
                            a = e - La + 1 + ka.length,
                            o = 0;
                          o < a;
                          o++
                        ) {
                          var s = Math.pow(2, i);
                          n.push(s);
                          var u = 1 / s;
                          o > e - La
                            ? (u = ka[o - e + La - 1])
                            : 0 === o && (u = 0),
                            r.push(u);
                          for (
                            var l = 1 / (s - 2),
                              c = -l,
                              h = 1 + l,
                              d = [c, c, h, c, h, h, c, c, h, h, c, h],
                              f = new Float32Array(108),
                              p = new Float32Array(72),
                              m = new Float32Array(36),
                              v = 0;
                            v < 6;
                            v++
                          ) {
                            var g = ((v % 3) * 2) / 3 - 1,
                              y = v > 2 ? 0 : -1,
                              b = [
                                g,
                                y,
                                0,
                                g + 2 / 3,
                                y,
                                0,
                                g + 2 / 3,
                                y + 1,
                                0,
                                g,
                                y,
                                0,
                                g + 2 / 3,
                                y + 1,
                                0,
                                g,
                                y + 1,
                                0,
                              ];
                            f.set(b, 18 * v), p.set(d, 12 * v);
                            var x = [v, v, v, v, v, v];
                            m.set(x, 6 * v);
                          }
                          var _ = new Fi();
                          _.setAttribute("position", new Mi(f, 3)),
                            _.setAttribute("uv", new Mi(p, 2)),
                            _.setAttribute("faceIndex", new Mi(m, 1)),
                            t.push(_),
                            i > La && i--;
                        }
                        return { lodPlanes: t, sizeLods: n, sigmas: r };
                      })(i);
                    (this._sizeLods = a.sizeLods),
                      (this._lodPlanes = a.lodPlanes),
                      (this._sigmas = a.sigmas),
                      (this._blurMaterial = (function _getBlurShader(e, t, n) {
                        var r = new Float32Array(Ea),
                          i = new ir(0, 1, 0);
                        return new la({
                          name: "SphericalGaussianBlur",
                          defines: {
                            n: Ea,
                            CUBEUV_TEXEL_WIDTH: 1 / t,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: "".concat(e, ".0"),
                          },
                          uniforms: {
                            envMap: { value: null },
                            samples: { value: 1 },
                            weights: { value: r },
                            latitudinal: { value: !1 },
                            dTheta: { value: 0 },
                            mipInt: { value: 0 },
                            poleAxis: { value: i },
                          },
                          vertexShader:
                            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                          fragmentShader:
                            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                          blending: P,
                          depthTest: !1,
                          depthWrite: !1,
                        });
                      })(i, e, t));
                  }
                  return r;
                },
              },
              {
                key: "_compileMaterial",
                value: function _compileMaterial(e) {
                  var t = new ia(this._lodPlanes[0], e);
                  this._renderer.compile(t, Pa);
                },
              },
              {
                key: "_sceneToCubeUV",
                value: function _sceneToCubeUV(e, t, n, r) {
                  var i = new ha(90, 1, t, n),
                    a = [1, -1, 1, 1, 1, 1],
                    o = [1, 1, 1, -1, -1, -1],
                    s = this._renderer,
                    u = s.autoClear,
                    l = s.toneMapping;
                  s.getClearColor(Ra), (s.toneMapping = he), (s.autoClear = !1);
                  var c = new bi({
                      name: "PMREM.Background",
                      side: C,
                      depthWrite: !1,
                      depthTest: !1,
                    }),
                    h = new ia(new aa(), c),
                    d = !1,
                    f = e.background;
                  f
                    ? f.isColor &&
                      (c.color.copy(f), (e.background = null), (d = !0))
                    : (c.color.copy(Ra), (d = !0));
                  for (var p = 0; p < 6; p++) {
                    var m = p % 3;
                    0 === m
                      ? (i.up.set(0, a[p], 0), i.lookAt(o[p], 0, 0))
                      : 1 === m
                      ? (i.up.set(0, 0, a[p]), i.lookAt(0, o[p], 0))
                      : (i.up.set(0, a[p], 0), i.lookAt(0, 0, o[p]));
                    var v = this._cubeSize;
                    _setViewport(r, m * v, p > 2 ? v : 0, v, v),
                      s.setRenderTarget(r),
                      d && s.render(h, i),
                      s.render(e, i);
                  }
                  h.geometry.dispose(),
                    h.material.dispose(),
                    (s.toneMapping = l),
                    (s.autoClear = u),
                    (e.background = f);
                },
              },
              {
                key: "_textureToCubeUV",
                value: function _textureToCubeUV(e, t) {
                  var n = this._renderer,
                    r = e.mapping === ye || e.mapping === be;
                  r
                    ? (null === this._cubemapMaterial &&
                        (this._cubemapMaterial = _getCubemapMaterial()),
                      (this._cubemapMaterial.uniforms.flipEnvMap.value =
                        !1 === e.isRenderTargetTexture ? -1 : 1))
                    : null === this._equirectMaterial &&
                      (this._equirectMaterial = _getEquirectMaterial());
                  var i = r ? this._cubemapMaterial : this._equirectMaterial,
                    a = new ia(this._lodPlanes[0], i);
                  i.uniforms.envMap.value = e;
                  var o = this._cubeSize;
                  _setViewport(t, 0, 0, 3 * o, 2 * o),
                    n.setRenderTarget(t),
                    n.render(a, Pa);
                },
              },
              {
                key: "_applyPMREM",
                value: function _applyPMREM(e) {
                  var t = this._renderer,
                    n = t.autoClear;
                  t.autoClear = !1;
                  for (var r = 1; r < this._lodPlanes.length; r++) {
                    var i = Math.sqrt(
                        this._sigmas[r] * this._sigmas[r] -
                          this._sigmas[r - 1] * this._sigmas[r - 1]
                      ),
                      a = Ba[(r - 1) % Ba.length];
                    this._blur(e, r - 1, r, i, a);
                  }
                  t.autoClear = n;
                },
              },
              {
                key: "_blur",
                value: function _blur(e, t, n, r, i) {
                  var a = this._pingPongRenderTarget;
                  this._halfBlur(e, a, t, n, r, "latitudinal", i),
                    this._halfBlur(a, e, n, n, r, "longitudinal", i);
                },
              },
              {
                key: "_halfBlur",
                value: function _halfBlur(e, t, n, r, i, a, o) {
                  var s = this._renderer,
                    u = this._blurMaterial;
                  "latitudinal" !== a &&
                    "longitudinal" !== a &&
                    console.error(
                      "blur direction must be either latitudinal or longitudinal!"
                    );
                  var l = new ia(this._lodPlanes[r], u),
                    c = u.uniforms,
                    h = this._sizeLods[n] - 1,
                    d = isFinite(i)
                      ? Math.PI / (2 * h)
                      : (2 * Math.PI) / (2 * Ea - 1),
                    f = i / d,
                    p = isFinite(i) ? 1 + Math.floor(3 * f) : Ea;
                  p > Ea &&
                    console.warn(
                      "sigmaRadians, "
                        .concat(
                          i,
                          ", is too large and will clip, as it requested "
                        )
                        .concat(p, " samples when the maximum is set to ")
                        .concat(Ea)
                    );
                  for (var m = [], v = 0, g = 0; g < Ea; ++g) {
                    var y = g / f,
                      b = Math.exp((-y * y) / 2);
                    m.push(b), 0 === g ? (v += b) : g < p && (v += 2 * b);
                  }
                  for (var x = 0; x < m.length; x++) m[x] = m[x] / v;
                  (c.envMap.value = e.texture),
                    (c.samples.value = p),
                    (c.weights.value = m),
                    (c.latitudinal.value = "latitudinal" === a),
                    o && (c.poleAxis.value = o);
                  var _ = this._lodMax;
                  (c.dTheta.value = d), (c.mipInt.value = _ - n);
                  var M = this._sizeLods[r];
                  _setViewport(
                    t,
                    3 * M * (r > _ - La ? r - _ + La : 0),
                    4 * (this._cubeSize - M),
                    3 * M,
                    2 * M
                  ),
                    s.setRenderTarget(t),
                    s.render(l, Pa);
                },
              },
            ]),
            PMREMGenerator
          );
        })();
      function _createRenderTarget(e, t, n) {
        var r = new Kn(e, t, n);
        return (
          (r.texture.mapping = Me),
          (r.texture.name = "PMREM.cubeUv"),
          (r.scissorTest = !0),
          r
        );
      }
      function _setViewport(e, t, n, r, i) {
        e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i);
      }
      function _getEquirectMaterial() {
        return new la({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: P,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function _getCubemapMaterial() {
        return new la({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: P,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function WebGLCubeUVMaps(e) {
        var t = new WeakMap(),
          n = null;
        function onTextureDispose(e) {
          var n = e.target;
          n.removeEventListener("dispose", onTextureDispose);
          var r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function get(r) {
            if (r && r.isTexture) {
              var i = r.mapping,
                a = i === xe || i === _e,
                o = i === ye || i === be;
              if (a || o) {
                if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                  r.needsPMREMUpdate = !1;
                  var s = t.get(r);
                  return (
                    null === n && (n = new Na(e)),
                    (s = a ? n.fromEquirectangular(r, s) : n.fromCubemap(r, s)),
                    t.set(r, s),
                    s.texture
                  );
                }
                if (t.has(r)) return t.get(r).texture;
                var u = r.image;
                if (
                  (a && u && u.height > 0) ||
                  (o &&
                    u &&
                    (function isCubeTextureComplete(e) {
                      for (var t = 0, n = 0; n < 6; n++) void 0 !== e[n] && t++;
                      return 6 === t;
                    })(u))
                ) {
                  null === n && (n = new Na(e));
                  var l = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                  return (
                    t.set(r, l),
                    r.addEventListener("dispose", onTextureDispose),
                    l.texture
                  );
                }
                return null;
              }
            }
            return r;
          },
          dispose: function dispose() {
            (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
          },
        };
      }
      function WebGLExtensions(e) {
        var t = {};
        function getExtension(n) {
          if (void 0 !== t[n]) return t[n];
          var r;
          switch (n) {
            case "WEBGL_depth_texture":
              r =
                e.getExtension("WEBGL_depth_texture") ||
                e.getExtension("MOZ_WEBGL_depth_texture") ||
                e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r =
                e.getExtension("EXT_texture_filter_anisotropic") ||
                e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r =
                e.getExtension("WEBGL_compressed_texture_s3tc") ||
                e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r =
                e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = e.getExtension(n);
          }
          return (t[n] = r), r;
        }
        return {
          has: function has(e) {
            return null !== getExtension(e);
          },
          init: function init(e) {
            e.isWebGL2
              ? getExtension("EXT_color_buffer_float")
              : (getExtension("WEBGL_depth_texture"),
                getExtension("OES_texture_float"),
                getExtension("OES_texture_half_float"),
                getExtension("OES_texture_half_float_linear"),
                getExtension("OES_standard_derivatives"),
                getExtension("OES_element_index_uint"),
                getExtension("OES_vertex_array_object"),
                getExtension("ANGLE_instanced_arrays")),
              getExtension("OES_texture_float_linear"),
              getExtension("EXT_color_buffer_half_float"),
              getExtension("WEBGL_multisampled_render_to_texture");
          },
          get: function get(e) {
            var t = getExtension(e);
            return (
              null === t &&
                console.warn(
                  "THREE.WebGLRenderer: " + e + " extension not supported."
                ),
              t
            );
          },
        };
      }
      function WebGLGeometries(e, t, n, r) {
        var i = {},
          a = new WeakMap();
        function onGeometryDispose(e) {
          var o = e.target;
          for (var s in (null !== o.index && t.remove(o.index), o.attributes))
            t.remove(o.attributes[s]);
          o.removeEventListener("dispose", onGeometryDispose), delete i[o.id];
          var u = a.get(o);
          u && (t.remove(u), a.delete(o)),
            r.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            n.memory.geometries--;
        }
        function updateWireframeAttribute(e) {
          var n = [],
            r = e.index,
            i = e.attributes.position,
            o = 0;
          if (null !== r) {
            var s = r.array;
            o = r.version;
            for (var u = 0, l = s.length; u < l; u += 3) {
              var c = s[u + 0],
                h = s[u + 1],
                d = s[u + 2];
              n.push(c, h, h, d, d, c);
            }
          } else {
            var f = i.array;
            o = i.version;
            for (var p = 0, m = f.length / 3 - 1; p < m; p += 3) {
              var v = p + 0,
                g = p + 1,
                y = p + 2;
              n.push(v, g, g, y, y, v);
            }
          }
          var b = new (arrayNeedsUint32(n) ? Li : Oi)(n, 1);
          b.version = o;
          var x = a.get(e);
          x && t.remove(x), a.set(e, b);
        }
        return {
          get: function get(e, t) {
            return !0 === i[t.id]
              ? t
              : (t.addEventListener("dispose", onGeometryDispose),
                (i[t.id] = !0),
                n.memory.geometries++,
                t);
          },
          update: function update(e) {
            var n = e.attributes;
            for (var r in n) t.update(n[r], 34962);
            var i = e.morphAttributes;
            for (var a in i)
              for (var o = i[a], s = 0, u = o.length; s < u; s++)
                t.update(o[s], 34962);
          },
          getWireframeAttribute: function getWireframeAttribute(e) {
            var t = a.get(e);
            if (t) {
              var n = e.index;
              null !== n &&
                t.version < n.version &&
                updateWireframeAttribute(e);
            } else updateWireframeAttribute(e);
            return a.get(e);
          },
        };
      }
      function WebGLIndexedBufferRenderer(e, t, n, r) {
        var i,
          a,
          o,
          s = r.isWebGL2;
        (this.setMode = function setMode(e) {
          i = e;
        }),
          (this.setIndex = function setIndex(e) {
            (a = e.type), (o = e.bytesPerElement);
          }),
          (this.render = function render(t, r) {
            e.drawElements(i, r, a, t * o), n.update(r, i, 1);
          }),
          (this.renderInstances = function renderInstances(r, u, l) {
            if (0 !== l) {
              var c, h;
              if (s) (c = e), (h = "drawElementsInstanced");
              else if (
                ((h = "drawElementsInstancedANGLE"),
                null === (c = t.get("ANGLE_instanced_arrays")))
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              c[h](i, u, a, r * o, l), n.update(u, i, l);
            }
          });
      }
      function WebGLInfo(e) {
        var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function reset() {
            t.frame++,
              (t.calls = 0),
              (t.triangles = 0),
              (t.points = 0),
              (t.lines = 0);
          },
          update: function update(e, n, r) {
            switch ((t.calls++, n)) {
              case 4:
                t.triangles += r * (e / 3);
                break;
              case 1:
                t.lines += r * (e / 2);
                break;
              case 3:
                t.lines += r * (e - 1);
                break;
              case 2:
                t.lines += r * e;
                break;
              case 0:
                t.points += r * e;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", n);
            }
          },
        };
      }
      function numericalSort(e, t) {
        return e[0] - t[0];
      }
      function absNumericalSort(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function denormalize(e, t) {
        var n = 1,
          r = t.isInterleavedBufferAttribute ? t.data.array : t.array;
        r instanceof Int8Array
          ? (n = 127)
          : r instanceof Uint8Array
          ? (n = 255)
          : r instanceof Uint16Array
          ? (n = 65535)
          : r instanceof Int16Array
          ? (n = 32767)
          : r instanceof Int32Array
          ? (n = 2147483647)
          : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              r
            ),
          e.divideScalar(n);
      }
      function WebGLMorphtargets(e, t, n) {
        for (
          var r = {},
            i = new Float32Array(8),
            a = new WeakMap(),
            o = new Zn(),
            s = [],
            u = 0;
          u < 8;
          u++
        )
          s[u] = [u, 0];
        return {
          update: function update(u, l, c, h) {
            var d = u.morphTargetInfluences;
            if (!0 === t.isWebGL2) {
              var f =
                  l.morphAttributes.position ||
                  l.morphAttributes.normal ||
                  l.morphAttributes.color,
                p = void 0 !== f ? f.length : 0,
                m = a.get(l);
              if (void 0 === m || m.count !== p) {
                void 0 !== m && m.texture.dispose();
                var v = void 0 !== l.morphAttributes.position,
                  g = void 0 !== l.morphAttributes.normal,
                  y = void 0 !== l.morphAttributes.color,
                  b = l.morphAttributes.position || [],
                  x = l.morphAttributes.normal || [],
                  _ = l.morphAttributes.color || [],
                  M = 0;
                !0 === v && (M = 1), !0 === g && (M = 2), !0 === y && (M = 3);
                var S = l.attributes.position.count * M,
                  w = 1;
                S > t.maxTextureSize &&
                  ((w = Math.ceil(S / t.maxTextureSize)),
                  (S = t.maxTextureSize));
                var T = new Float32Array(S * w * 4 * p),
                  A = new Qn(T, S, w, p);
                (A.type = Ue), (A.needsUpdate = !0);
                for (var O = 4 * M, C = 0; C < p; C++)
                  for (
                    var L = b[C], k = x[C], E = _[C], P = S * w * 4 * C, R = 0;
                    R < L.count;
                    R++
                  ) {
                    var I = R * O;
                    !0 === v &&
                      (o.fromBufferAttribute(L, R),
                      !0 === L.normalized && denormalize(o, L),
                      (T[P + I + 0] = o.x),
                      (T[P + I + 1] = o.y),
                      (T[P + I + 2] = o.z),
                      (T[P + I + 3] = 0)),
                      !0 === g &&
                        (o.fromBufferAttribute(k, R),
                        !0 === k.normalized && denormalize(o, k),
                        (T[P + I + 4] = o.x),
                        (T[P + I + 5] = o.y),
                        (T[P + I + 6] = o.z),
                        (T[P + I + 7] = 0)),
                      !0 === y &&
                        (o.fromBufferAttribute(E, R),
                        !0 === E.normalized && denormalize(o, E),
                        (T[P + I + 8] = o.x),
                        (T[P + I + 9] = o.y),
                        (T[P + I + 10] = o.z),
                        (T[P + I + 11] = 4 === E.itemSize ? o.w : 1));
                  }
                (m = { count: p, texture: A, size: new Dn(S, w) }),
                  a.set(l, m),
                  l.addEventListener("dispose", function disposeTexture() {
                    A.dispose(),
                      a.delete(l),
                      l.removeEventListener("dispose", disposeTexture);
                  });
              }
              for (var D = 0, j = 0; j < d.length; j++) D += d[j];
              var B = l.morphTargetsRelative ? 1 : 1 - D;
              h.getUniforms().setValue(e, "morphTargetBaseInfluence", B),
                h.getUniforms().setValue(e, "morphTargetInfluences", d),
                h
                  .getUniforms()
                  .setValue(e, "morphTargetsTexture", m.texture, n),
                h.getUniforms().setValue(e, "morphTargetsTextureSize", m.size);
            } else {
              var N = void 0 === d ? 0 : d.length,
                z = r[l.id];
              if (void 0 === z || z.length !== N) {
                z = [];
                for (var F = 0; F < N; F++) z[F] = [F, 0];
                r[l.id] = z;
              }
              for (var G = 0; G < N; G++) {
                var U = z[G];
                (U[0] = G), (U[1] = d[G]);
              }
              z.sort(absNumericalSort);
              for (var V = 0; V < 8; V++)
                V < N && z[V][1]
                  ? ((s[V][0] = z[V][0]), (s[V][1] = z[V][1]))
                  : ((s[V][0] = Number.MAX_SAFE_INTEGER), (s[V][1] = 0));
              s.sort(numericalSort);
              for (
                var W = l.morphAttributes.position,
                  H = l.morphAttributes.normal,
                  q = 0,
                  X = 0;
                X < 8;
                X++
              ) {
                var J = s[X],
                  Y = J[0],
                  Z = J[1];
                Y !== Number.MAX_SAFE_INTEGER && Z
                  ? (W &&
                      l.getAttribute("morphTarget" + X) !== W[Y] &&
                      l.setAttribute("morphTarget" + X, W[Y]),
                    H &&
                      l.getAttribute("morphNormal" + X) !== H[Y] &&
                      l.setAttribute("morphNormal" + X, H[Y]),
                    (i[X] = Z),
                    (q += Z))
                  : (W &&
                      !0 === l.hasAttribute("morphTarget" + X) &&
                      l.deleteAttribute("morphTarget" + X),
                    H &&
                      !0 === l.hasAttribute("morphNormal" + X) &&
                      l.deleteAttribute("morphNormal" + X),
                    (i[X] = 0));
              }
              var K = l.morphTargetsRelative ? 1 : 1 - q;
              h.getUniforms().setValue(e, "morphTargetBaseInfluence", K),
                h.getUniforms().setValue(e, "morphTargetInfluences", i);
            }
          },
        };
      }
      function WebGLObjects(e, t, n, r) {
        var i = new WeakMap();
        function onInstancedMeshDispose(e) {
          var t = e.target;
          t.removeEventListener("dispose", onInstancedMeshDispose),
            n.remove(t.instanceMatrix),
            null !== t.instanceColor && n.remove(t.instanceColor);
        }
        return {
          update: function update(e) {
            var a = r.render.frame,
              o = e.geometry,
              s = t.get(e, o);
            return (
              i.get(s) !== a && (t.update(s), i.set(s, a)),
              e.isInstancedMesh &&
                (!1 === e.hasEventListener("dispose", onInstancedMeshDispose) &&
                  e.addEventListener("dispose", onInstancedMeshDispose),
                n.update(e.instanceMatrix, 34962),
                null !== e.instanceColor && n.update(e.instanceColor, 34962)),
              s
            );
          },
          dispose: function dispose() {
            i = new WeakMap();
          },
        };
      }
      var za = new Yn(),
        Fa = new Qn(),
        Ga = new er(),
        Ua = new ma(),
        Va = [],
        Wa = [],
        Ha = new Float32Array(16),
        qa = new Float32Array(9),
        Xa = new Float32Array(4);
      function flatten(e, t, n) {
        var r = e[0];
        if (r <= 0 || r > 0) return e;
        var i = t * n,
          a = Va[i];
        if (
          (void 0 === a && ((a = new Float32Array(i)), (Va[i] = a)), 0 !== t)
        ) {
          r.toArray(a, 0);
          for (var o = 1, s = 0; o !== t; ++o) (s += n), e[o].toArray(a, s);
        }
        return a;
      }
      function arraysEqual(e, t) {
        if (e.length !== t.length) return !1;
        for (var n = 0, r = e.length; n < r; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function copyArray(e, t) {
        for (var n = 0, r = t.length; n < r; n++) e[n] = t[n];
      }
      function allocTexUnits(e, t) {
        var n = Wa[t];
        void 0 === n && ((n = new Int32Array(t)), (Wa[t] = n));
        for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
        return n;
      }
      function setValueV1f(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
      }
      function setValueV2f(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (arraysEqual(n, t)) return;
          e.uniform2fv(this.addr, t), copyArray(n, t);
        }
      }
      function setValueV3f(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else if (void 0 !== t.r)
          (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b),
            (n[0] = t.r),
            (n[1] = t.g),
            (n[2] = t.b));
        else {
          if (arraysEqual(n, t)) return;
          e.uniform3fv(this.addr, t), copyArray(n, t);
        }
      }
      function setValueV4f(e, t) {
        var n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (arraysEqual(n, t)) return;
          e.uniform4fv(this.addr, t), copyArray(n, t);
        }
      }
      function setValueM2(e, t) {
        var n = this.cache,
          r = t.elements;
        if (void 0 === r) {
          if (arraysEqual(n, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), copyArray(n, t);
        } else {
          if (arraysEqual(n, r)) return;
          Xa.set(r), e.uniformMatrix2fv(this.addr, !1, Xa), copyArray(n, r);
        }
      }
      function setValueM3(e, t) {
        var n = this.cache,
          r = t.elements;
        if (void 0 === r) {
          if (arraysEqual(n, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), copyArray(n, t);
        } else {
          if (arraysEqual(n, r)) return;
          qa.set(r), e.uniformMatrix3fv(this.addr, !1, qa), copyArray(n, r);
        }
      }
      function setValueM4(e, t) {
        var n = this.cache,
          r = t.elements;
        if (void 0 === r) {
          if (arraysEqual(n, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), copyArray(n, t);
        } else {
          if (arraysEqual(n, r)) return;
          Ha.set(r), e.uniformMatrix4fv(this.addr, !1, Ha), copyArray(n, r);
        }
      }
      function setValueV1i(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
      }
      function setValueV2i(e, t) {
        var n = this.cache;
        arraysEqual(n, t) || (e.uniform2iv(this.addr, t), copyArray(n, t));
      }
      function setValueV3i(e, t) {
        var n = this.cache;
        arraysEqual(n, t) || (e.uniform3iv(this.addr, t), copyArray(n, t));
      }
      function setValueV4i(e, t) {
        var n = this.cache;
        arraysEqual(n, t) || (e.uniform4iv(this.addr, t), copyArray(n, t));
      }
      function setValueV1ui(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
      }
      function setValueV2ui(e, t) {
        var n = this.cache;
        arraysEqual(n, t) || (e.uniform2uiv(this.addr, t), copyArray(n, t));
      }
      function setValueV3ui(e, t) {
        var n = this.cache;
        arraysEqual(n, t) || (e.uniform3uiv(this.addr, t), copyArray(n, t));
      }
      function setValueV4ui(e, t) {
        var n = this.cache;
        arraysEqual(n, t) || (e.uniform4uiv(this.addr, t), copyArray(n, t));
      }
      function setValueT1(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.setTexture2D(t || za, i);
      }
      function setValueT3D1(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.setTexture3D(t || Ga, i);
      }
      function setValueT6(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.setTextureCube(t || Ua, i);
      }
      function setValueT2DArray1(e, t, n) {
        var r = this.cache,
          i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
          n.setTexture2DArray(t || Fa, i);
      }
      function setValueV1fArray(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function setValueV2fArray(e, t) {
        var n = flatten(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function setValueV3fArray(e, t) {
        var n = flatten(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function setValueV4fArray(e, t) {
        var n = flatten(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function setValueM2Array(e, t) {
        var n = flatten(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n);
      }
      function setValueM3Array(e, t) {
        var n = flatten(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n);
      }
      function setValueM4Array(e, t) {
        var n = flatten(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n);
      }
      function setValueV1iArray(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function setValueV2iArray(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function setValueV3iArray(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function setValueV4iArray(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function setValueV1uiArray(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function setValueV2uiArray(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function setValueV3uiArray(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function setValueV4uiArray(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function setValueT1Array(e, t, n) {
        var r = t.length,
          i = allocTexUnits(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.setTexture2D(t[a] || za, i[a]);
      }
      function setValueT3DArray(e, t, n) {
        var r = t.length,
          i = allocTexUnits(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.setTexture3D(t[a] || Ga, i[a]);
      }
      function setValueT6Array(e, t, n) {
        var r = t.length,
          i = allocTexUnits(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.setTextureCube(t[a] || Ua, i[a]);
      }
      function setValueT2DArrayArray(e, t, n) {
        var r = t.length,
          i = allocTexUnits(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.setTexture2DArray(t[a] || Fa, i[a]);
      }
      var Ja = function SingleUniform(e, t, n) {
          Object(f.a)(this, SingleUniform),
            (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function getSingularSetter(e) {
              switch (e) {
                case 5126:
                  return setValueV1f;
                case 35664:
                  return setValueV2f;
                case 35665:
                  return setValueV3f;
                case 35666:
                  return setValueV4f;
                case 35674:
                  return setValueM2;
                case 35675:
                  return setValueM3;
                case 35676:
                  return setValueM4;
                case 5124:
                case 35670:
                  return setValueV1i;
                case 35667:
                case 35671:
                  return setValueV2i;
                case 35668:
                case 35672:
                  return setValueV3i;
                case 35669:
                case 35673:
                  return setValueV4i;
                case 5125:
                  return setValueV1ui;
                case 36294:
                  return setValueV2ui;
                case 36295:
                  return setValueV3ui;
                case 36296:
                  return setValueV4ui;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return setValueT1;
                case 35679:
                case 36299:
                case 36307:
                  return setValueT3D1;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return setValueT6;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return setValueT2DArray1;
              }
            })(t.type));
        },
        Ya = function PureArrayUniform(e, t, n) {
          Object(f.a)(this, PureArrayUniform),
            (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.size = t.size),
            (this.setValue = (function getPureArraySetter(e) {
              switch (e) {
                case 5126:
                  return setValueV1fArray;
                case 35664:
                  return setValueV2fArray;
                case 35665:
                  return setValueV3fArray;
                case 35666:
                  return setValueV4fArray;
                case 35674:
                  return setValueM2Array;
                case 35675:
                  return setValueM3Array;
                case 35676:
                  return setValueM4Array;
                case 5124:
                case 35670:
                  return setValueV1iArray;
                case 35667:
                case 35671:
                  return setValueV2iArray;
                case 35668:
                case 35672:
                  return setValueV3iArray;
                case 35669:
                case 35673:
                  return setValueV4iArray;
                case 5125:
                  return setValueV1uiArray;
                case 36294:
                  return setValueV2uiArray;
                case 36295:
                  return setValueV3uiArray;
                case 36296:
                  return setValueV4uiArray;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return setValueT1Array;
                case 35679:
                case 36299:
                case 36307:
                  return setValueT3DArray;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return setValueT6Array;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return setValueT2DArrayArray;
              }
            })(t.type));
        },
        Za = (function () {
          function StructuredUniform(e) {
            Object(f.a)(this, StructuredUniform),
              (this.id = e),
              (this.seq = []),
              (this.map = {});
          }
          return (
            Object(p.a)(StructuredUniform, [
              {
                key: "setValue",
                value: function setValue(e, t, n) {
                  for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
                    var o = r[i];
                    o.setValue(e, t[o.id], n);
                  }
                },
              },
            ]),
            StructuredUniform
          );
        })(),
        Ka = /(\w+)(\])?(\[|\.)?/g;
      function addUniform(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function parseUniform(e, t, n) {
        var r = e.name,
          i = r.length;
        for (Ka.lastIndex = 0; ; ) {
          var a = Ka.exec(r),
            o = Ka.lastIndex,
            s = a[1],
            u = "]" === a[2],
            l = a[3];
          if ((u && (s |= 0), void 0 === l || ("[" === l && o + 2 === i))) {
            addUniform(n, void 0 === l ? new Ja(s, e, t) : new Ya(s, e, t));
            break;
          }
          var c = n.map[s];
          void 0 === c && addUniform(n, (c = new Za(s))), (n = c);
        }
      }
      var Qa = (function () {
        function WebGLUniforms(e, t) {
          Object(f.a)(this, WebGLUniforms), (this.seq = []), (this.map = {});
          for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
            var i = e.getActiveUniform(t, r);
            parseUniform(i, e.getUniformLocation(t, i.name), this);
          }
        }
        return (
          Object(p.a)(
            WebGLUniforms,
            [
              {
                key: "setValue",
                value: function setValue(e, t, n, r) {
                  var i = this.map[t];
                  void 0 !== i && i.setValue(e, n, r);
                },
              },
              {
                key: "setOptional",
                value: function setOptional(e, t, n) {
                  var r = t[n];
                  void 0 !== r && this.setValue(e, n, r);
                },
              },
            ],
            [
              {
                key: "upload",
                value: function upload(e, t, n, r) {
                  for (var i = 0, a = t.length; i !== a; ++i) {
                    var o = t[i],
                      s = n[o.id];
                    !1 !== s.needsUpdate && o.setValue(e, s.value, r);
                  }
                },
              },
              {
                key: "seqWithValue",
                value: function seqWithValue(e, t) {
                  for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                    var a = e[r];
                    a.id in t && n.push(a);
                  }
                  return n;
                },
              },
            ]
          ),
          WebGLUniforms
        );
      })();
      function WebGLShader(e, t, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, n), e.compileShader(r), r;
      }
      var $a = 0;
      function getShaderErrors(e, t, n) {
        var r = e.getShaderParameter(t, 35713),
          i = e.getShaderInfoLog(t).trim();
        if (r && "" === i) return "";
        var a = /ERROR: 0:(\d+)/.exec(i);
        if (a) {
          var o = parseInt(a[1]);
          return (
            n.toUpperCase() +
            "\n\n" +
            i +
            "\n\n" +
            (function handleSource(e, t) {
              for (
                var n = e.split("\n"),
                  r = [],
                  i = Math.max(t - 6, 0),
                  a = Math.min(t + 6, n.length),
                  o = i;
                o < a;
                o++
              ) {
                var s = o + 1;
                r.push(
                  ""
                    .concat(s === t ? ">" : " ", " ")
                    .concat(s, ": ")
                    .concat(n[o])
                );
              }
              return r.join("\n");
            })(e.getShaderSource(t), o)
          );
        }
        return i;
      }
      function getTexelEncodingFunction(e, t) {
        var n = (function getEncodingComponents(e) {
          switch (e) {
            case Ht:
              return ["Linear", "( value )"];
            case qt:
              return ["sRGB", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
                ["Linear", "( value )"]
              );
          }
        })(t);
        return (
          "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        );
      }
      function getToneMappingFunction(e, t) {
        var n;
        switch (t) {
          case de:
            n = "Linear";
            break;
          case fe:
            n = "Reinhard";
            break;
          case pe:
            n = "OptimizedCineon";
            break;
          case me:
            n = "ACESFilmic";
            break;
          case ve:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (n = "Linear");
        }
        return (
          "vec3 " +
          e +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function filterEmptyLine(e) {
        return "" !== e;
      }
      function replaceLightNums(e, t) {
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function replaceClippingPlaneNums(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      var eo = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function resolveIncludes(e) {
        return e.replace(eo, includeReplacer);
      }
      function includeReplacer(e, t) {
        var n = Ta[t];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + t + ">");
        return resolveIncludes(n);
      }
      var to =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        no =
          /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function unrollLoops(e) {
        return e.replace(no, loopReplacer).replace(to, deprecatedLoopReplacer);
      }
      function deprecatedLoopReplacer(e, t, n, r) {
        return (
          console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
          ),
          loopReplacer(e, t, n, r)
        );
      }
      function loopReplacer(e, t, n, r) {
        for (var i = "", a = parseInt(t); a < parseInt(n); a++)
          i += r
            .replace(/\[\s*i\s*\]/g, "[ " + a + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, a);
        return i;
      }
      function generatePrecision(e) {
        var t =
          "precision " +
          e.precision +
          " float;\nprecision " +
          e.precision +
          " int;";
        return (
          "highp" === e.precision
            ? (t += "\n#define HIGH_PRECISION")
            : "mediump" === e.precision
            ? (t += "\n#define MEDIUM_PRECISION")
            : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
          t
        );
      }
      function WebGLProgram(e, t, n, r) {
        var i,
          a,
          o = e.getContext(),
          s = n.defines,
          u = n.vertexShader,
          l = n.fragmentShader,
          c = (function generateShadowMapTypeDefine(e) {
            var t = "SHADOWMAP_TYPE_BASIC";
            return (
              e.shadowMapType === w
                ? (t = "SHADOWMAP_TYPE_PCF")
                : e.shadowMapType === T
                ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                : e.shadowMapType === A && (t = "SHADOWMAP_TYPE_VSM"),
              t
            );
          })(n),
          h = (function generateEnvMapTypeDefine(e) {
            var t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case ye:
                case be:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case Me:
                  t = "ENVMAP_TYPE_CUBE_UV";
              }
            return t;
          })(n),
          d = (function generateEnvMapModeDefine(e) {
            var t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap)
              switch (e.envMapMode) {
                case be:
                  t = "ENVMAP_MODE_REFRACTION";
              }
            return t;
          })(n),
          f = (function generateEnvMapBlendingDefine(e) {
            var t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case ue:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case le:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case ce:
                  t = "ENVMAP_BLENDING_ADD";
              }
            return t;
          })(n),
          p = (function generateCubeUVSize(e) {
            var t = e.envMapCubeUVHeight;
            if (null === t) return null;
            var n = Math.log2(t) - 2,
              r = 1 / t;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
              texelHeight: r,
              maxMip: n,
            };
          })(n),
          m = n.isWebGL2
            ? ""
            : (function generateExtensions(e) {
                return [
                  e.extensionDerivatives ||
                  e.envMapCubeUVHeight ||
                  e.bumpMap ||
                  e.tangentSpaceNormalMap ||
                  e.clearcoatNormalMap ||
                  e.flatShading ||
                  "physical" === e.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                  e.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
                  e.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(filterEmptyLine)
                  .join("\n");
              })(n),
          v = (function generateDefines(e) {
            var t = [];
            for (var n in e) {
              var r = e[n];
              !1 !== r && t.push("#define " + n + " " + r);
            }
            return t.join("\n");
          })(s),
          g = o.createProgram(),
          y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((i = [v].filter(filterEmptyLine).join("\n")).length > 0 &&
              (i += "\n"),
            (a = [m, v].filter(filterEmptyLine).join("\n")).length > 0 &&
              (a += "\n"))
          : ((i = [
              generatePrecision(n),
              "#define SHADER_NAME " + n.shaderName,
              v,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + d : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(filterEmptyLine)
              .join("\n")),
            (a = [
              m,
              generatePrecision(n),
              "#define SHADER_NAME " + n.shaderName,
              v,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + h : "",
              n.envMap ? "#define " + d : "",
              n.envMap ? "#define " + f : "",
              p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
              p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
              p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoat ? "#define USE_CLEARCOAT" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescence ? "#define USE_IRIDESCENCE" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaTest ? "#define USE_ALPHATEST" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + c : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              n.toneMapping !== he ? "#define TONE_MAPPING" : "",
              n.toneMapping !== he ? Ta.tonemapping_pars_fragment : "",
              n.toneMapping !== he
                ? getToneMappingFunction("toneMapping", n.toneMapping)
                : "",
              n.dithering ? "#define DITHERING" : "",
              n.opaque ? "#define OPAQUE" : "",
              Ta.encodings_pars_fragment,
              getTexelEncodingFunction("linearToOutputTexel", n.outputEncoding),
              n.useDepthPacking
                ? "#define DEPTH_PACKING " + n.depthPacking
                : "",
              "\n",
            ]
              .filter(filterEmptyLine)
              .join("\n"))),
          (u = replaceClippingPlaneNums(
            (u = replaceLightNums((u = resolveIncludes(u)), n)),
            n
          )),
          (l = replaceClippingPlaneNums(
            (l = replaceLightNums((l = resolveIncludes(l)), n)),
            n
          )),
          (u = unrollLoops(u)),
          (l = unrollLoops(l)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((y = "#version 300 es\n"),
            (i =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              i),
            (a =
              [
                "#define varying in",
                n.glslVersion === On
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                n.glslVersion === On ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              a));
        var b,
          x,
          _ = y + a + l,
          M = WebGLShader(o, 35633, y + i + u),
          S = WebGLShader(o, 35632, _);
        if (
          (o.attachShader(g, M),
          o.attachShader(g, S),
          void 0 !== n.index0AttributeName
            ? o.bindAttribLocation(g, 0, n.index0AttributeName)
            : !0 === n.morphTargets && o.bindAttribLocation(g, 0, "position"),
          o.linkProgram(g),
          e.debug.checkShaderErrors)
        ) {
          var O = o.getProgramInfoLog(g).trim(),
            C = o.getShaderInfoLog(M).trim(),
            L = o.getShaderInfoLog(S).trim(),
            k = !0,
            E = !0;
          if (!1 === o.getProgramParameter(g, 35714)) {
            k = !1;
            var P = getShaderErrors(o, M, "vertex"),
              R = getShaderErrors(o, S, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                o.getError() +
                " - VALIDATE_STATUS " +
                o.getProgramParameter(g, 35715) +
                "\n\nProgram Info Log: " +
                O +
                "\n" +
                P +
                "\n" +
                R
            );
          } else
            "" !== O
              ? console.warn("THREE.WebGLProgram: Program Info Log:", O)
              : ("" !== C && "" !== L) || (E = !1);
          E &&
            (this.diagnostics = {
              runnable: k,
              programLog: O,
              vertexShader: { log: C, prefix: i },
              fragmentShader: { log: L, prefix: a },
            });
        }
        return (
          o.deleteShader(M),
          o.deleteShader(S),
          (this.getUniforms = function () {
            return void 0 === b && (b = new Qa(o, g)), b;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === x &&
                (x = (function fetchAttributeLocations(e, t) {
                  for (
                    var n = {}, r = e.getProgramParameter(t, 35721), i = 0;
                    i < r;
                    i++
                  ) {
                    var a = e.getActiveAttrib(t, i),
                      o = a.name,
                      s = 1;
                    35674 === a.type && (s = 2),
                      35675 === a.type && (s = 3),
                      35676 === a.type && (s = 4),
                      (n[o] = {
                        type: a.type,
                        location: e.getAttribLocation(t, o),
                        locationSize: s,
                      });
                  }
                  return n;
                })(o, g)),
              x
            );
          }),
          (this.destroy = function () {
            r.releaseStatesOfProgram(this),
              o.deleteProgram(g),
              (this.program = void 0);
          }),
          (this.name = n.shaderName),
          (this.id = $a++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = g),
          (this.vertexShader = M),
          (this.fragmentShader = S),
          this
        );
      }
      var ro = 0,
        io = (function () {
          function WebGLShaderCache() {
            Object(f.a)(this, WebGLShaderCache),
              (this.shaderCache = new Map()),
              (this.materialCache = new Map());
          }
          return (
            Object(p.a)(WebGLShaderCache, [
              {
                key: "update",
                value: function update(e) {
                  var t = e.vertexShader,
                    n = e.fragmentShader,
                    r = this._getShaderStage(t),
                    i = this._getShaderStage(n),
                    a = this._getShaderCacheForMaterial(e);
                  return (
                    !1 === a.has(r) && (a.add(r), r.usedTimes++),
                    !1 === a.has(i) && (a.add(i), i.usedTimes++),
                    this
                  );
                },
              },
              {
                key: "remove",
                value: function remove(e) {
                  var t = this.materialCache.get(e),
                    n = !0,
                    r = !1,
                    i = void 0;
                  try {
                    for (
                      var a, o = t[Symbol.iterator]();
                      !(n = (a = o.next()).done);
                      n = !0
                    ) {
                      var s = a.value;
                      s.usedTimes--,
                        0 === s.usedTimes && this.shaderCache.delete(s.code);
                    }
                  } catch (u) {
                    (r = !0), (i = u);
                  } finally {
                    try {
                      n || null == o.return || o.return();
                    } finally {
                      if (r) throw i;
                    }
                  }
                  return this.materialCache.delete(e), this;
                },
              },
              {
                key: "getVertexShaderID",
                value: function getVertexShaderID(e) {
                  return this._getShaderStage(e.vertexShader).id;
                },
              },
              {
                key: "getFragmentShaderID",
                value: function getFragmentShaderID(e) {
                  return this._getShaderStage(e.fragmentShader).id;
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.shaderCache.clear(), this.materialCache.clear();
                },
              },
              {
                key: "_getShaderCacheForMaterial",
                value: function _getShaderCacheForMaterial(e) {
                  var t = this.materialCache;
                  return !1 === t.has(e) && t.set(e, new Set()), t.get(e);
                },
              },
              {
                key: "_getShaderStage",
                value: function _getShaderStage(e) {
                  var t = this.shaderCache;
                  if (!1 === t.has(e)) {
                    var n = new ao(e);
                    t.set(e, n);
                  }
                  return t.get(e);
                },
              },
            ]),
            WebGLShaderCache
          );
        })(),
        ao = function WebGLShaderStage(e) {
          Object(f.a)(this, WebGLShaderStage),
            (this.id = ro++),
            (this.code = e),
            (this.usedTimes = 0);
        };
      function WebGLPrograms(e, t, n, r, i, a, o) {
        var s = new Hr(),
          u = new io(),
          l = [],
          c = i.isWebGL2,
          h = i.logarithmicDepthBuffer,
          d = i.vertexTextures,
          f = i.precision,
          p = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          };
        return {
          getParameters: function getParameters(a, s, l, m, v) {
            var g = m.fog,
              y = v.geometry,
              b = a.isMeshStandardMaterial ? m.environment : null,
              x = (a.isMeshStandardMaterial ? n : t).get(a.envMap || b),
              _ = x && x.mapping === Me ? x.image.height : null,
              M = p[a.type];
            null !== a.precision &&
              (f = i.getMaxPrecision(a.precision)) !== a.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                a.precision,
                "not supported, using",
                f,
                "instead."
              );
            var S,
              w,
              T,
              A,
              O =
                y.morphAttributes.position ||
                y.morphAttributes.normal ||
                y.morphAttributes.color,
              k = void 0 !== O ? O.length : 0,
              E = 0;
            if (
              (void 0 !== y.morphAttributes.position && (E = 1),
              void 0 !== y.morphAttributes.normal && (E = 2),
              void 0 !== y.morphAttributes.color && (E = 3),
              M)
            ) {
              var P = Oa[M];
              (S = P.vertexShader), (w = P.fragmentShader);
            } else
              (S = a.vertexShader),
                (w = a.fragmentShader),
                u.update(a),
                (T = u.getVertexShaderID(a)),
                (A = u.getFragmentShaderID(a));
            var I = e.getRenderTarget(),
              D = a.alphaTest > 0,
              j = a.clearcoat > 0,
              B = a.iridescence > 0;
            return {
              isWebGL2: c,
              shaderID: M,
              shaderName: a.type,
              vertexShader: S,
              fragmentShader: w,
              defines: a.defines,
              customVertexShaderID: T,
              customFragmentShaderID: A,
              isRawShaderMaterial: !0 === a.isRawShaderMaterial,
              glslVersion: a.glslVersion,
              precision: f,
              instancing: !0 === v.isInstancedMesh,
              instancingColor:
                !0 === v.isInstancedMesh && null !== v.instanceColor,
              supportsVertexTextures: d,
              outputEncoding:
                null === I
                  ? e.outputEncoding
                  : !0 === I.isXRRenderTarget
                  ? I.texture.encoding
                  : Ht,
              map: !!a.map,
              matcap: !!a.matcap,
              envMap: !!x,
              envMapMode: x && x.mapping,
              envMapCubeUVHeight: _,
              lightMap: !!a.lightMap,
              aoMap: !!a.aoMap,
              emissiveMap: !!a.emissiveMap,
              bumpMap: !!a.bumpMap,
              normalMap: !!a.normalMap,
              objectSpaceNormalMap: a.normalMapType === Zt,
              tangentSpaceNormalMap: a.normalMapType === Yt,
              decodeVideoTexture:
                !!a.map && !0 === a.map.isVideoTexture && a.map.encoding === qt,
              clearcoat: j,
              clearcoatMap: j && !!a.clearcoatMap,
              clearcoatRoughnessMap: j && !!a.clearcoatRoughnessMap,
              clearcoatNormalMap: j && !!a.clearcoatNormalMap,
              iridescence: B,
              iridescenceMap: B && !!a.iridescenceMap,
              iridescenceThicknessMap: B && !!a.iridescenceThicknessMap,
              displacementMap: !!a.displacementMap,
              roughnessMap: !!a.roughnessMap,
              metalnessMap: !!a.metalnessMap,
              specularMap: !!a.specularMap,
              specularIntensityMap: !!a.specularIntensityMap,
              specularColorMap: !!a.specularColorMap,
              opaque: !1 === a.transparent && a.blending === R,
              alphaMap: !!a.alphaMap,
              alphaTest: D,
              gradientMap: !!a.gradientMap,
              sheen: a.sheen > 0,
              sheenColorMap: !!a.sheenColorMap,
              sheenRoughnessMap: !!a.sheenRoughnessMap,
              transmission: a.transmission > 0,
              transmissionMap: !!a.transmissionMap,
              thicknessMap: !!a.thicknessMap,
              combine: a.combine,
              vertexTangents: !!a.normalMap && !!y.attributes.tangent,
              vertexColors: a.vertexColors,
              vertexAlphas:
                !0 === a.vertexColors &&
                !!y.attributes.color &&
                4 === y.attributes.color.itemSize,
              vertexUvs:
                !!a.map ||
                !!a.bumpMap ||
                !!a.normalMap ||
                !!a.specularMap ||
                !!a.alphaMap ||
                !!a.emissiveMap ||
                !!a.roughnessMap ||
                !!a.metalnessMap ||
                !!a.clearcoatMap ||
                !!a.clearcoatRoughnessMap ||
                !!a.clearcoatNormalMap ||
                !!a.iridescenceMap ||
                !!a.iridescenceThicknessMap ||
                !!a.displacementMap ||
                !!a.transmissionMap ||
                !!a.thicknessMap ||
                !!a.specularIntensityMap ||
                !!a.specularColorMap ||
                !!a.sheenColorMap ||
                !!a.sheenRoughnessMap,
              uvsVertexOnly:
                !(
                  a.map ||
                  a.bumpMap ||
                  a.normalMap ||
                  a.specularMap ||
                  a.alphaMap ||
                  a.emissiveMap ||
                  a.roughnessMap ||
                  a.metalnessMap ||
                  a.clearcoatNormalMap ||
                  a.iridescenceMap ||
                  a.iridescenceThicknessMap ||
                  a.transmission > 0 ||
                  a.transmissionMap ||
                  a.thicknessMap ||
                  a.specularIntensityMap ||
                  a.specularColorMap ||
                  a.sheen > 0 ||
                  a.sheenColorMap ||
                  a.sheenRoughnessMap
                ) && !!a.displacementMap,
              fog: !!g,
              useFog: !0 === a.fog,
              fogExp2: g && g.isFogExp2,
              flatShading: !!a.flatShading,
              sizeAttenuation: a.sizeAttenuation,
              logarithmicDepthBuffer: h,
              skinning: !0 === v.isSkinnedMesh,
              morphTargets: void 0 !== y.morphAttributes.position,
              morphNormals: void 0 !== y.morphAttributes.normal,
              morphColors: void 0 !== y.morphAttributes.color,
              morphTargetsCount: k,
              morphTextureStride: E,
              numDirLights: s.directional.length,
              numPointLights: s.point.length,
              numSpotLights: s.spot.length,
              numRectAreaLights: s.rectArea.length,
              numHemiLights: s.hemi.length,
              numDirLightShadows: s.directionalShadowMap.length,
              numPointLightShadows: s.pointShadowMap.length,
              numSpotLightShadows: s.spotShadowMap.length,
              numClippingPlanes: o.numPlanes,
              numClipIntersection: o.numIntersection,
              dithering: a.dithering,
              shadowMapEnabled: e.shadowMap.enabled && l.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: a.toneMapped ? e.toneMapping : he,
              physicallyCorrectLights: e.physicallyCorrectLights,
              premultipliedAlpha: a.premultipliedAlpha,
              doubleSided: a.side === L,
              flipSided: a.side === C,
              useDepthPacking: !!a.depthPacking,
              depthPacking: a.depthPacking || 0,
              index0AttributeName: a.index0AttributeName,
              extensionDerivatives: a.extensions && a.extensions.derivatives,
              extensionFragDepth: a.extensions && a.extensions.fragDepth,
              extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
              extensionShaderTextureLOD:
                a.extensions && a.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: c || r.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                c || r.has("EXT_shader_texture_lod"),
              customProgramCacheKey: a.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function getProgramCacheKey(t) {
            var n = [];
            if (
              (t.shaderID
                ? n.push(t.shaderID)
                : (n.push(t.customVertexShaderID),
                  n.push(t.customFragmentShaderID)),
              void 0 !== t.defines)
            )
              for (var r in t.defines) n.push(r), n.push(t.defines[r]);
            return (
              !1 === t.isRawShaderMaterial &&
                ((function getProgramCacheKeyParameters(e, t) {
                  e.push(t.precision),
                    e.push(t.outputEncoding),
                    e.push(t.envMapMode),
                    e.push(t.envMapCubeUVHeight),
                    e.push(t.combine),
                    e.push(t.vertexUvs),
                    e.push(t.fogExp2),
                    e.push(t.sizeAttenuation),
                    e.push(t.morphTargetsCount),
                    e.push(t.morphAttributeCount),
                    e.push(t.numDirLights),
                    e.push(t.numPointLights),
                    e.push(t.numSpotLights),
                    e.push(t.numHemiLights),
                    e.push(t.numRectAreaLights),
                    e.push(t.numDirLightShadows),
                    e.push(t.numPointLightShadows),
                    e.push(t.numSpotLightShadows),
                    e.push(t.shadowMapType),
                    e.push(t.toneMapping),
                    e.push(t.numClippingPlanes),
                    e.push(t.numClipIntersection),
                    e.push(t.depthPacking);
                })(n, t),
                (function getProgramCacheKeyBooleans(e, t) {
                  s.disableAll(),
                    t.isWebGL2 && s.enable(0),
                    t.supportsVertexTextures && s.enable(1),
                    t.instancing && s.enable(2),
                    t.instancingColor && s.enable(3),
                    t.map && s.enable(4),
                    t.matcap && s.enable(5),
                    t.envMap && s.enable(6),
                    t.lightMap && s.enable(7),
                    t.aoMap && s.enable(8),
                    t.emissiveMap && s.enable(9),
                    t.bumpMap && s.enable(10),
                    t.normalMap && s.enable(11),
                    t.objectSpaceNormalMap && s.enable(12),
                    t.tangentSpaceNormalMap && s.enable(13),
                    t.clearcoat && s.enable(14),
                    t.clearcoatMap && s.enable(15),
                    t.clearcoatRoughnessMap && s.enable(16),
                    t.clearcoatNormalMap && s.enable(17),
                    t.iridescence && s.enable(18),
                    t.iridescenceMap && s.enable(19),
                    t.iridescenceThicknessMap && s.enable(20),
                    t.displacementMap && s.enable(21),
                    t.specularMap && s.enable(22),
                    t.roughnessMap && s.enable(23),
                    t.metalnessMap && s.enable(24),
                    t.gradientMap && s.enable(25),
                    t.alphaMap && s.enable(26),
                    t.alphaTest && s.enable(27),
                    t.vertexColors && s.enable(28),
                    t.vertexAlphas && s.enable(29),
                    t.vertexUvs && s.enable(30),
                    t.vertexTangents && s.enable(31),
                    t.uvsVertexOnly && s.enable(32),
                    t.fog && s.enable(33),
                    e.push(s.mask),
                    s.disableAll(),
                    t.useFog && s.enable(0),
                    t.flatShading && s.enable(1),
                    t.logarithmicDepthBuffer && s.enable(2),
                    t.skinning && s.enable(3),
                    t.morphTargets && s.enable(4),
                    t.morphNormals && s.enable(5),
                    t.morphColors && s.enable(6),
                    t.premultipliedAlpha && s.enable(7),
                    t.shadowMapEnabled && s.enable(8),
                    t.physicallyCorrectLights && s.enable(9),
                    t.doubleSided && s.enable(10),
                    t.flipSided && s.enable(11),
                    t.useDepthPacking && s.enable(12),
                    t.dithering && s.enable(13),
                    t.specularIntensityMap && s.enable(14),
                    t.specularColorMap && s.enable(15),
                    t.transmission && s.enable(16),
                    t.transmissionMap && s.enable(17),
                    t.thicknessMap && s.enable(18),
                    t.sheen && s.enable(19),
                    t.sheenColorMap && s.enable(20),
                    t.sheenRoughnessMap && s.enable(21),
                    t.decodeVideoTexture && s.enable(22),
                    t.opaque && s.enable(23),
                    e.push(s.mask);
                })(n, t),
                n.push(e.outputEncoding)),
              n.push(t.customProgramCacheKey),
              n.join()
            );
          },
          getUniforms: function getUniforms(e) {
            var t,
              n = p[e.type];
            if (n) {
              var r = Oa[n];
              t = oa.clone(r.uniforms);
            } else t = e.uniforms;
            return t;
          },
          acquireProgram: function acquireProgram(t, n) {
            for (var r, i = 0, o = l.length; i < o; i++) {
              var s = l[i];
              if (s.cacheKey === n) {
                ++(r = s).usedTimes;
                break;
              }
            }
            return (
              void 0 === r && ((r = new WebGLProgram(e, n, t, a)), l.push(r)), r
            );
          },
          releaseProgram: function releaseProgram(e) {
            if (0 === --e.usedTimes) {
              var t = l.indexOf(e);
              (l[t] = l[l.length - 1]), l.pop(), e.destroy();
            }
          },
          releaseShaderCache: function releaseShaderCache(e) {
            u.remove(e);
          },
          programs: l,
          dispose: function dispose() {
            u.dispose();
          },
        };
      }
      function WebGLProperties() {
        var e = new WeakMap();
        return {
          get: function get(t) {
            var n = e.get(t);
            return void 0 === n && ((n = {}), e.set(t, n)), n;
          },
          remove: function remove(t) {
            e.delete(t);
          },
          update: function update(t, n, r) {
            e.get(t)[n] = r;
          },
          dispose: function dispose() {
            e = new WeakMap();
          },
        };
      }
      function painterSortStable(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function reversePainterSortStable(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function WebGLRenderList() {
        var e = [],
          t = 0,
          n = [],
          r = [],
          i = [];
        function getNextRenderItem(n, r, i, a, o, s) {
          var u = e[t];
          return (
            void 0 === u
              ? ((u = {
                  id: n.id,
                  object: n,
                  geometry: r,
                  material: i,
                  groupOrder: a,
                  renderOrder: n.renderOrder,
                  z: o,
                  group: s,
                }),
                (e[t] = u))
              : ((u.id = n.id),
                (u.object = n),
                (u.geometry = r),
                (u.material = i),
                (u.groupOrder = a),
                (u.renderOrder = n.renderOrder),
                (u.z = o),
                (u.group = s)),
            t++,
            u
          );
        }
        return {
          opaque: n,
          transmissive: r,
          transparent: i,
          init: function init() {
            (t = 0), (n.length = 0), (r.length = 0), (i.length = 0);
          },
          push: function push(e, t, a, o, s, u) {
            var l = getNextRenderItem(e, t, a, o, s, u);
            a.transmission > 0
              ? r.push(l)
              : !0 === a.transparent
              ? i.push(l)
              : n.push(l);
          },
          unshift: function unshift(e, t, a, o, s, u) {
            var l = getNextRenderItem(e, t, a, o, s, u);
            a.transmission > 0
              ? r.unshift(l)
              : !0 === a.transparent
              ? i.unshift(l)
              : n.unshift(l);
          },
          finish: function finish() {
            for (var n = t, r = e.length; n < r; n++) {
              var i = e[n];
              if (null === i.id) break;
              (i.id = null),
                (i.object = null),
                (i.geometry = null),
                (i.material = null),
                (i.group = null);
            }
          },
          sort: function sort(e, t) {
            n.length > 1 && n.sort(e || painterSortStable),
              r.length > 1 && r.sort(t || reversePainterSortStable),
              i.length > 1 && i.sort(t || reversePainterSortStable);
          },
        };
      }
      function WebGLRenderLists() {
        var e = new WeakMap();
        return {
          get: function get(t, n) {
            var r;
            return (
              !1 === e.has(t)
                ? ((r = new WebGLRenderList()), e.set(t, [r]))
                : n >= e.get(t).length
                ? ((r = new WebGLRenderList()), e.get(t).push(r))
                : (r = e.get(t)[n]),
              r
            );
          },
          dispose: function dispose() {
            e = new WeakMap();
          },
        };
      }
      function UniformsCache() {
        var e = {};
        return {
          get: function get(t) {
            if (void 0 !== e[t.id]) return e[t.id];
            var n;
            switch (t.type) {
              case "DirectionalLight":
                n = { direction: new ir(), color: new Hn() };
                break;
              case "SpotLight":
                n = {
                  position: new ir(),
                  direction: new ir(),
                  color: new Hn(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new ir(),
                  color: new Hn(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new ir(),
                  skyColor: new Hn(),
                  groundColor: new Hn(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new Hn(),
                  position: new ir(),
                  halfWidth: new ir(),
                  halfHeight: new ir(),
                };
            }
            return (e[t.id] = n), n;
          },
        };
      }
      var oo = 0;
      function shadowCastingLightsFirst(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
      }
      function WebGLLights(e, t) {
        for (
          var n = new UniformsCache(),
            r = (function ShadowUniformsCache() {
              var e = {};
              return {
                get: function get(t) {
                  if (void 0 !== e[t.id]) return e[t.id];
                  var n;
                  switch (t.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Dn(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Dn(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (e[t.id] = n), n;
                },
              };
            })(),
            i = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            },
            a = 0;
          a < 9;
          a++
        )
          i.probe.push(new ir());
        var o = new ir(),
          s = new Ir(),
          u = new Ir();
        return {
          setup: function setup(a, o) {
            for (var s = 0, u = 0, l = 0, c = 0; c < 9; c++)
              i.probe[c].set(0, 0, 0);
            var h = 0,
              d = 0,
              f = 0,
              p = 0,
              m = 0,
              v = 0,
              g = 0,
              y = 0;
            a.sort(shadowCastingLightsFirst);
            for (
              var b = !0 !== o ? Math.PI : 1, x = 0, _ = a.length;
              x < _;
              x++
            ) {
              var M = a[x],
                S = M.color,
                w = M.intensity,
                T = M.distance,
                A = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
              if (M.isAmbientLight)
                (s += S.r * w * b), (u += S.g * w * b), (l += S.b * w * b);
              else if (M.isLightProbe)
                for (var O = 0; O < 9; O++)
                  i.probe[O].addScaledVector(M.sh.coefficients[O], w);
              else if (M.isDirectionalLight) {
                var C = n.get(M);
                if (
                  (C.color.copy(M.color).multiplyScalar(M.intensity * b),
                  M.castShadow)
                ) {
                  var L = M.shadow,
                    k = r.get(M);
                  (k.shadowBias = L.bias),
                    (k.shadowNormalBias = L.normalBias),
                    (k.shadowRadius = L.radius),
                    (k.shadowMapSize = L.mapSize),
                    (i.directionalShadow[h] = k),
                    (i.directionalShadowMap[h] = A),
                    (i.directionalShadowMatrix[h] = M.shadow.matrix),
                    v++;
                }
                (i.directional[h] = C), h++;
              } else if (M.isSpotLight) {
                var E = n.get(M);
                if (
                  (E.position.setFromMatrixPosition(M.matrixWorld),
                  E.color.copy(S).multiplyScalar(w * b),
                  (E.distance = T),
                  (E.coneCos = Math.cos(M.angle)),
                  (E.penumbraCos = Math.cos(M.angle * (1 - M.penumbra))),
                  (E.decay = M.decay),
                  M.castShadow)
                ) {
                  var P = M.shadow,
                    R = r.get(M);
                  (R.shadowBias = P.bias),
                    (R.shadowNormalBias = P.normalBias),
                    (R.shadowRadius = P.radius),
                    (R.shadowMapSize = P.mapSize),
                    (i.spotShadow[f] = R),
                    (i.spotShadowMap[f] = A),
                    (i.spotShadowMatrix[f] = M.shadow.matrix),
                    y++;
                }
                (i.spot[f] = E), f++;
              } else if (M.isRectAreaLight) {
                var I = n.get(M);
                I.color.copy(S).multiplyScalar(w),
                  I.halfWidth.set(0.5 * M.width, 0, 0),
                  I.halfHeight.set(0, 0.5 * M.height, 0),
                  (i.rectArea[p] = I),
                  p++;
              } else if (M.isPointLight) {
                var D = n.get(M);
                if (
                  (D.color.copy(M.color).multiplyScalar(M.intensity * b),
                  (D.distance = M.distance),
                  (D.decay = M.decay),
                  M.castShadow)
                ) {
                  var j = M.shadow,
                    B = r.get(M);
                  (B.shadowBias = j.bias),
                    (B.shadowNormalBias = j.normalBias),
                    (B.shadowRadius = j.radius),
                    (B.shadowMapSize = j.mapSize),
                    (B.shadowCameraNear = j.camera.near),
                    (B.shadowCameraFar = j.camera.far),
                    (i.pointShadow[d] = B),
                    (i.pointShadowMap[d] = A),
                    (i.pointShadowMatrix[d] = M.shadow.matrix),
                    g++;
                }
                (i.point[d] = D), d++;
              } else if (M.isHemisphereLight) {
                var N = n.get(M);
                N.skyColor.copy(M.color).multiplyScalar(w * b),
                  N.groundColor.copy(M.groundColor).multiplyScalar(w * b),
                  (i.hemi[m] = N),
                  m++;
              }
            }
            p > 0 &&
              (t.isWebGL2
                ? ((i.rectAreaLTC1 = Aa.LTC_FLOAT_1),
                  (i.rectAreaLTC2 = Aa.LTC_FLOAT_2))
                : !0 === e.has("OES_texture_float_linear")
                ? ((i.rectAreaLTC1 = Aa.LTC_FLOAT_1),
                  (i.rectAreaLTC2 = Aa.LTC_FLOAT_2))
                : !0 === e.has("OES_texture_half_float_linear")
                ? ((i.rectAreaLTC1 = Aa.LTC_HALF_1),
                  (i.rectAreaLTC2 = Aa.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (i.ambient[0] = s),
              (i.ambient[1] = u),
              (i.ambient[2] = l);
            var z = i.hash;
            (z.directionalLength === h &&
              z.pointLength === d &&
              z.spotLength === f &&
              z.rectAreaLength === p &&
              z.hemiLength === m &&
              z.numDirectionalShadows === v &&
              z.numPointShadows === g &&
              z.numSpotShadows === y) ||
              ((i.directional.length = h),
              (i.spot.length = f),
              (i.rectArea.length = p),
              (i.point.length = d),
              (i.hemi.length = m),
              (i.directionalShadow.length = v),
              (i.directionalShadowMap.length = v),
              (i.pointShadow.length = g),
              (i.pointShadowMap.length = g),
              (i.spotShadow.length = y),
              (i.spotShadowMap.length = y),
              (i.directionalShadowMatrix.length = v),
              (i.pointShadowMatrix.length = g),
              (i.spotShadowMatrix.length = y),
              (z.directionalLength = h),
              (z.pointLength = d),
              (z.spotLength = f),
              (z.rectAreaLength = p),
              (z.hemiLength = m),
              (z.numDirectionalShadows = v),
              (z.numPointShadows = g),
              (z.numSpotShadows = y),
              (i.version = oo++));
          },
          setupView: function setupView(e, t) {
            for (
              var n = 0,
                r = 0,
                a = 0,
                l = 0,
                c = 0,
                h = t.matrixWorldInverse,
                d = 0,
                f = e.length;
              d < f;
              d++
            ) {
              var p = e[d];
              if (p.isDirectionalLight) {
                var m = i.directional[n];
                m.direction.setFromMatrixPosition(p.matrixWorld),
                  o.setFromMatrixPosition(p.target.matrixWorld),
                  m.direction.sub(o),
                  m.direction.transformDirection(h),
                  n++;
              } else if (p.isSpotLight) {
                var v = i.spot[a];
                v.position.setFromMatrixPosition(p.matrixWorld),
                  v.position.applyMatrix4(h),
                  v.direction.setFromMatrixPosition(p.matrixWorld),
                  o.setFromMatrixPosition(p.target.matrixWorld),
                  v.direction.sub(o),
                  v.direction.transformDirection(h),
                  a++;
              } else if (p.isRectAreaLight) {
                var g = i.rectArea[l];
                g.position.setFromMatrixPosition(p.matrixWorld),
                  g.position.applyMatrix4(h),
                  u.identity(),
                  s.copy(p.matrixWorld),
                  s.premultiply(h),
                  u.extractRotation(s),
                  g.halfWidth.set(0.5 * p.width, 0, 0),
                  g.halfHeight.set(0, 0.5 * p.height, 0),
                  g.halfWidth.applyMatrix4(u),
                  g.halfHeight.applyMatrix4(u),
                  l++;
              } else if (p.isPointLight) {
                var y = i.point[r];
                y.position.setFromMatrixPosition(p.matrixWorld),
                  y.position.applyMatrix4(h),
                  r++;
              } else if (p.isHemisphereLight) {
                var b = i.hemi[c];
                b.direction.setFromMatrixPosition(p.matrixWorld),
                  b.direction.transformDirection(h),
                  c++;
              }
            }
          },
          state: i,
        };
      }
      function WebGLRenderState(e, t) {
        var n = new WebGLLights(e, t),
          r = [],
          i = [];
        return {
          init: function init() {
            (r.length = 0), (i.length = 0);
          },
          state: { lightsArray: r, shadowsArray: i, lights: n },
          setupLights: function setupLights(e) {
            n.setup(r, e);
          },
          setupLightsView: function setupLightsView(e) {
            n.setupView(r, e);
          },
          pushLight: function pushLight(e) {
            r.push(e);
          },
          pushShadow: function pushShadow(e) {
            i.push(e);
          },
        };
      }
      function WebGLRenderStates(e, t) {
        var n = new WeakMap();
        return {
          get: function get(r) {
            var i,
              a =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            return (
              !1 === n.has(r)
                ? ((i = new WebGLRenderState(e, t)), n.set(r, [i]))
                : a >= n.get(r).length
                ? ((i = new WebGLRenderState(e, t)), n.get(r).push(i))
                : (i = n.get(r)[a]),
              i
            );
          },
          dispose: function dispose() {
            n = new WeakMap();
          },
        };
      }
      var so = (function (e) {
          function MeshDepthMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshDepthMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshDepthMaterial).call(this)
              )).isMeshDepthMaterial = !0),
              (t.type = "MeshDepthMaterial"),
              (t.depthPacking = Xt),
              (t.map = null),
              (t.alphaMap = null),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshDepthMaterial, e),
            Object(p.a)(MeshDepthMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshDepthMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.depthPacking = e.depthPacking),
                    (this.map = e.map),
                    (this.alphaMap = e.alphaMap),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    this
                  );
                },
              },
            ]),
            MeshDepthMaterial
          );
        })(yi),
        uo = (function (e) {
          function MeshDistanceMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshDistanceMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshDistanceMaterial).call(this)
              )).isMeshDistanceMaterial = !0),
              (t.type = "MeshDistanceMaterial"),
              (t.referencePosition = new ir()),
              (t.nearDistance = 1),
              (t.farDistance = 1e3),
              (t.map = null),
              (t.alphaMap = null),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshDistanceMaterial, e),
            Object(p.a)(MeshDistanceMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshDistanceMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.referencePosition.copy(e.referencePosition),
                    (this.nearDistance = e.nearDistance),
                    (this.farDistance = e.farDistance),
                    (this.map = e.map),
                    (this.alphaMap = e.alphaMap),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    this
                  );
                },
              },
            ]),
            MeshDistanceMaterial
          );
        })(yi),
        lo = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        co =
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function WebGLShadowMap(e, t, n) {
        var r = new Sa(),
          i = new Dn(),
          a = new Dn(),
          o = new Zn(),
          s = new so({ depthPacking: Jt }),
          u = new uo(),
          l = {},
          c = n.maxTextureSize,
          h = { 0: C, 1: O, 2: L },
          d = new la({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Dn() },
              radius: { value: 4 },
            },
            vertexShader: lo,
            fragmentShader: co,
          }),
          f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        var p = new Fi();
        p.setAttribute(
          "position",
          new Mi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        var m = new ia(p, d),
          v = this;
        function VSMPass(n, r) {
          var a = t.update(m);
          d.defines.VSM_SAMPLES !== n.blurSamples &&
            ((d.defines.VSM_SAMPLES = n.blurSamples),
            (f.defines.VSM_SAMPLES = n.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            null === n.mapPass && (n.mapPass = new Kn(i.x, i.y)),
            (d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(r, null, a, d, m, null),
            (f.uniforms.shadow_pass.value = n.mapPass.texture),
            (f.uniforms.resolution.value = n.mapSize),
            (f.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(r, null, a, f, m, null);
        }
        function getDepthMaterial(t, n, r, i, a, o) {
          var c = null,
            d =
              !0 === r.isPointLight
                ? t.customDistanceMaterial
                : t.customDepthMaterial;
          if (
            ((c = void 0 !== d ? d : !0 === r.isPointLight ? u : s),
            (e.localClippingEnabled &&
              !0 === n.clipShadows &&
              Array.isArray(n.clippingPlanes) &&
              0 !== n.clippingPlanes.length) ||
              (n.displacementMap && 0 !== n.displacementScale) ||
              (n.alphaMap && n.alphaTest > 0))
          ) {
            var f = c.uuid,
              p = n.uuid,
              m = l[f];
            void 0 === m && ((m = {}), (l[f] = m));
            var v = m[p];
            void 0 === v && ((v = c.clone()), (m[p] = v)), (c = v);
          }
          return (
            (c.visible = n.visible),
            (c.wireframe = n.wireframe),
            (c.side =
              o === A
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : h[n.side]),
            (c.alphaMap = n.alphaMap),
            (c.alphaTest = n.alphaTest),
            (c.clipShadows = n.clipShadows),
            (c.clippingPlanes = n.clippingPlanes),
            (c.clipIntersection = n.clipIntersection),
            (c.displacementMap = n.displacementMap),
            (c.displacementScale = n.displacementScale),
            (c.displacementBias = n.displacementBias),
            (c.wireframeLinewidth = n.wireframeLinewidth),
            (c.linewidth = n.linewidth),
            !0 === r.isPointLight &&
              !0 === c.isMeshDistanceMaterial &&
              (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
              (c.nearDistance = i),
              (c.farDistance = a)),
            c
          );
        }
        function renderObject(n, i, a, o, s) {
          if (!1 !== n.visible) {
            if (
              n.layers.test(i.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && s === A)) &&
              (!n.frustumCulled || r.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                a.matrixWorldInverse,
                n.matrixWorld
              );
              var u = t.update(n),
                l = n.material;
              if (Array.isArray(l))
                for (var c = u.groups, h = 0, d = c.length; h < d; h++) {
                  var f = c[h],
                    p = l[f.materialIndex];
                  if (p && p.visible) {
                    var m = getDepthMaterial(n, p, o, a.near, a.far, s);
                    e.renderBufferDirect(a, null, u, m, n, f);
                  }
                }
              else if (l.visible) {
                var v = getDepthMaterial(n, l, o, a.near, a.far, s);
                e.renderBufferDirect(a, null, u, v, n, null);
              }
            }
            for (var g = n.children, y = 0, b = g.length; y < b; y++)
              renderObject(g[y], i, a, o, s);
          }
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = w),
          (this.render = function (t, n, s) {
            if (
              !1 !== v.enabled &&
              (!1 !== v.autoUpdate || !1 !== v.needsUpdate) &&
              0 !== t.length
            ) {
              var u = e.getRenderTarget(),
                l = e.getActiveCubeFace(),
                h = e.getActiveMipmapLevel(),
                d = e.state;
              d.setBlending(P),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
              for (var f = 0, p = t.length; f < p; f++) {
                var m = t[f],
                  g = m.shadow;
                if (void 0 !== g) {
                  if (!1 !== g.autoUpdate || !1 !== g.needsUpdate) {
                    i.copy(g.mapSize);
                    var y = g.getFrameExtents();
                    if (
                      (i.multiply(y),
                      a.copy(g.mapSize),
                      (i.x > c || i.y > c) &&
                        (i.x > c &&
                          ((a.x = Math.floor(c / y.x)),
                          (i.x = a.x * y.x),
                          (g.mapSize.x = a.x)),
                        i.y > c &&
                          ((a.y = Math.floor(c / y.y)),
                          (i.y = a.y * y.y),
                          (g.mapSize.y = a.y))),
                      null === g.map)
                    ) {
                      var b =
                        this.type !== A ? { minFilter: Ae, magFilter: Ae } : {};
                      (g.map = new Kn(i.x, i.y, b)),
                        (g.map.texture.name = m.name + ".shadowMap"),
                        g.camera.updateProjectionMatrix();
                    }
                    e.setRenderTarget(g.map), e.clear();
                    for (var x = g.getViewportCount(), _ = 0; _ < x; _++) {
                      var M = g.getViewport(_);
                      o.set(a.x * M.x, a.y * M.y, a.x * M.z, a.y * M.w),
                        d.viewport(o),
                        g.updateMatrices(m, _),
                        (r = g.getFrustum()),
                        renderObject(n, s, g.camera, m, this.type);
                    }
                    !0 !== g.isPointLightShadow &&
                      this.type === A &&
                      VSMPass(g, s),
                      (g.needsUpdate = !1);
                  }
                } else
                  console.warn("THREE.WebGLShadowMap:", m, "has no shadow.");
              }
              (v.needsUpdate = !1), e.setRenderTarget(u, l, h);
            }
          });
      }
      function WebGLState(e, t, n) {
        var r,
          i,
          a = n.isWebGL2;
        var o = new (function ColorBuffer() {
            var t = !1,
              n = new Zn(),
              r = null,
              i = new Zn(0, 0, 0, 0);
            return {
              setMask: function setMask(n) {
                r === n || t || (e.colorMask(n, n, n, n), (r = n));
              },
              setLocked: function setLocked(e) {
                t = e;
              },
              setClear: function setClear(t, r, a, o, s) {
                !0 === s && ((t *= o), (r *= o), (a *= o)),
                  n.set(t, r, a, o),
                  !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n));
              },
              reset: function reset() {
                (t = !1), (r = null), i.set(-1, 0, 0, 0);
              },
            };
          })(),
          s = new (function DepthBuffer() {
            var t = !1,
              n = null,
              r = null,
              i = null;
            return {
              setTest: function setTest(e) {
                e ? enable(2929) : disable(2929);
              },
              setMask: function setMask(r) {
                n === r || t || (e.depthMask(r), (n = r));
              },
              setFunc: function setFunc(t) {
                if (r !== t) {
                  if (t)
                    switch (t) {
                      case ee:
                        e.depthFunc(512);
                        break;
                      case te:
                        e.depthFunc(519);
                        break;
                      case ne:
                        e.depthFunc(513);
                        break;
                      case re:
                        e.depthFunc(515);
                        break;
                      case ie:
                        e.depthFunc(514);
                        break;
                      case ae:
                        e.depthFunc(518);
                        break;
                      case oe:
                        e.depthFunc(516);
                        break;
                      case se:
                        e.depthFunc(517);
                        break;
                      default:
                        e.depthFunc(515);
                    }
                  else e.depthFunc(515);
                  r = t;
                }
              },
              setLocked: function setLocked(e) {
                t = e;
              },
              setClear: function setClear(t) {
                i !== t && (e.clearDepth(t), (i = t));
              },
              reset: function reset() {
                (t = !1), (n = null), (r = null), (i = null);
              },
            };
          })(),
          u = new (function StencilBuffer() {
            var t = !1,
              n = null,
              r = null,
              i = null,
              a = null,
              o = null,
              s = null,
              u = null,
              l = null;
            return {
              setTest: function setTest(e) {
                t || (e ? enable(2960) : disable(2960));
              },
              setMask: function setMask(r) {
                n === r || t || (e.stencilMask(r), (n = r));
              },
              setFunc: function setFunc(t, n, o) {
                (r === t && i === n && a === o) ||
                  (e.stencilFunc(t, n, o), (r = t), (i = n), (a = o));
              },
              setOp: function setOp(t, n, r) {
                (o === t && s === n && u === r) ||
                  (e.stencilOp(t, n, r), (o = t), (s = n), (u = r));
              },
              setLocked: function setLocked(e) {
                t = e;
              },
              setClear: function setClear(t) {
                l !== t && (e.clearStencil(t), (l = t));
              },
              reset: function reset() {
                (t = !1),
                  (n = null),
                  (r = null),
                  (i = null),
                  (a = null),
                  (o = null),
                  (s = null),
                  (u = null),
                  (l = null);
              },
            };
          })(),
          l = new WeakMap(),
          c = new WeakMap(),
          h = {},
          d = {},
          f = new WeakMap(),
          p = [],
          m = null,
          v = !1,
          g = null,
          y = null,
          M = null,
          S = null,
          w = null,
          T = null,
          A = null,
          O = !1,
          k = null,
          E = null,
          ue = null,
          le = null,
          ce = null,
          he = e.getParameter(35661),
          de = !1,
          fe = 0,
          pe = e.getParameter(7938);
        -1 !== pe.indexOf("WebGL")
          ? ((fe = parseFloat(/^WebGL (\d)/.exec(pe)[1])), (de = fe >= 1))
          : -1 !== pe.indexOf("OpenGL ES") &&
            ((fe = parseFloat(/^OpenGL ES (\d)/.exec(pe)[1])), (de = fe >= 2));
        var me = null,
          ve = {},
          ge = e.getParameter(3088),
          ye = e.getParameter(2978),
          be = new Zn().fromArray(ge),
          xe = new Zn().fromArray(ye);
        function createTexture(t, n, r) {
          var i = new Uint8Array(4),
            a = e.createTexture();
          e.bindTexture(t, a),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
          for (var o = 0; o < r; o++)
            e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
          return a;
        }
        var _e = {};
        function enable(t) {
          !0 !== h[t] && (e.enable(t), (h[t] = !0));
        }
        function disable(t) {
          !1 !== h[t] && (e.disable(t), (h[t] = !1));
        }
        (_e[3553] = createTexture(3553, 3553, 1)),
          (_e[34067] = createTexture(34067, 34069, 6)),
          o.setClear(0, 0, 0, 1),
          s.setClear(1),
          u.setClear(0),
          enable(2929),
          s.setFunc(re),
          setFlipSided(!1),
          setCullFace(x),
          enable(2884),
          setBlending(P);
        var Me =
          (_defineProperty((r = {}), N, 32774),
          _defineProperty(r, z, 32778),
          _defineProperty(r, F, 32779),
          r);
        if (a) (Me[G] = 32775), (Me[U] = 32776);
        else {
          var Se = t.get("EXT_blend_minmax");
          null !== Se && ((Me[G] = Se.MIN_EXT), (Me[U] = Se.MAX_EXT));
        }
        var we =
          (_defineProperty((i = {}), V, 0),
          _defineProperty(i, W, 1),
          _defineProperty(i, H, 768),
          _defineProperty(i, X, 770),
          _defineProperty(i, $, 776),
          _defineProperty(i, K, 774),
          _defineProperty(i, Y, 772),
          _defineProperty(i, q, 769),
          _defineProperty(i, J, 771),
          _defineProperty(i, Q, 775),
          _defineProperty(i, Z, 773),
          i);
        function setBlending(t, n, r, i, a, o, s, u) {
          if (t !== P) {
            if ((!1 === v && (enable(3042), (v = !0)), t === B))
              (a = a || n),
                (o = o || r),
                (s = s || i),
                (n === y && a === w) ||
                  (e.blendEquationSeparate(Me[n], Me[a]), (y = n), (w = a)),
                (r === M && i === S && o === T && s === A) ||
                  (e.blendFuncSeparate(we[r], we[i], we[o], we[s]),
                  (M = r),
                  (S = i),
                  (T = o),
                  (A = s)),
                (g = t),
                (O = null);
            else if (t !== g || u !== O) {
              if (
                ((y === N && w === N) ||
                  (e.blendEquation(32774), (y = N), (w = N)),
                u)
              )
                switch (t) {
                  case R:
                    e.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case I:
                    e.blendFunc(1, 1);
                    break;
                  case D:
                    e.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case j:
                    e.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              else
                switch (t) {
                  case R:
                    e.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case I:
                    e.blendFunc(770, 1);
                    break;
                  case D:
                    e.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case j:
                    e.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              (M = null), (S = null), (T = null), (A = null), (g = t), (O = u);
            }
          } else !0 === v && (disable(3042), (v = !1));
        }
        function setFlipSided(t) {
          k !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (k = t));
        }
        function setCullFace(t) {
          t !== b
            ? (enable(2884),
              t !== E &&
                (t === x
                  ? e.cullFace(1029)
                  : t === _
                  ? e.cullFace(1028)
                  : e.cullFace(1032)))
            : disable(2884),
            (E = t);
        }
        function setPolygonOffset(t, n, r) {
          t
            ? (enable(32823),
              (le === n && ce === r) ||
                (e.polygonOffset(n, r), (le = n), (ce = r)))
            : disable(32823);
        }
        function activeTexture(t) {
          void 0 === t && (t = 33984 + he - 1),
            me !== t && (e.activeTexture(t), (me = t));
        }
        return {
          buffers: { color: o, depth: s, stencil: u },
          enable: enable,
          disable: disable,
          bindFramebuffer: function bindFramebuffer(t, n) {
            return (
              d[t] !== n &&
              (e.bindFramebuffer(t, n),
              (d[t] = n),
              a &&
                (36009 === t && (d[36160] = n), 36160 === t && (d[36009] = n)),
              !0)
            );
          },
          drawBuffers: function drawBuffers(r, i) {
            var a = p,
              o = !1;
            if (r)
              if (
                (void 0 === (a = f.get(i)) && ((a = []), f.set(i, a)),
                r.isWebGLMultipleRenderTargets)
              ) {
                var s = r.texture;
                if (a.length !== s.length || 36064 !== a[0]) {
                  for (var u = 0, l = s.length; u < l; u++) a[u] = 36064 + u;
                  (a.length = s.length), (o = !0);
                }
              } else 36064 !== a[0] && ((a[0] = 36064), (o = !0));
            else 1029 !== a[0] && ((a[0] = 1029), (o = !0));
            o &&
              (n.isWebGL2
                ? e.drawBuffers(a)
                : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a));
          },
          useProgram: function useProgram(t) {
            return m !== t && (e.useProgram(t), (m = t), !0);
          },
          setBlending: setBlending,
          setMaterial: function setMaterial(e, t) {
            e.side === L ? disable(2884) : enable(2884);
            var n = e.side === C;
            t && (n = !n),
              setFlipSided(n),
              e.blending === R && !1 === e.transparent
                ? setBlending(P)
                : setBlending(
                    e.blending,
                    e.blendEquation,
                    e.blendSrc,
                    e.blendDst,
                    e.blendEquationAlpha,
                    e.blendSrcAlpha,
                    e.blendDstAlpha,
                    e.premultipliedAlpha
                  ),
              s.setFunc(e.depthFunc),
              s.setTest(e.depthTest),
              s.setMask(e.depthWrite),
              o.setMask(e.colorWrite);
            var r = e.stencilWrite;
            u.setTest(r),
              r &&
                (u.setMask(e.stencilWriteMask),
                u.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                u.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
              setPolygonOffset(
                e.polygonOffset,
                e.polygonOffsetFactor,
                e.polygonOffsetUnits
              ),
              !0 === e.alphaToCoverage ? enable(32926) : disable(32926);
          },
          setFlipSided: setFlipSided,
          setCullFace: setCullFace,
          setLineWidth: function setLineWidth(t) {
            t !== ue && (de && e.lineWidth(t), (ue = t));
          },
          setPolygonOffset: setPolygonOffset,
          setScissorTest: function setScissorTest(e) {
            e ? enable(3089) : disable(3089);
          },
          activeTexture: activeTexture,
          bindTexture: function bindTexture(t, n) {
            null === me && activeTexture();
            var r = ve[me];
            void 0 === r &&
              ((r = { type: void 0, texture: void 0 }), (ve[me] = r)),
              (r.type === t && r.texture === n) ||
                (e.bindTexture(t, n || _e[t]), (r.type = t), (r.texture = n));
          },
          unbindTexture: function unbindTexture() {
            var t = ve[me];
            void 0 !== t &&
              void 0 !== t.type &&
              (e.bindTexture(t.type, null),
              (t.type = void 0),
              (t.texture = void 0));
          },
          compressedTexImage2D: function compressedTexImage2D() {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage2D: function texImage2D() {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage3D: function texImage3D() {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          updateUBOMapping: function updateUBOMapping(t, n) {
            var r = c.get(n);
            void 0 === r && ((r = new WeakMap()), c.set(n, r));
            var i = r.get(t);
            void 0 === i &&
              ((i = e.getUniformBlockIndex(n, t.name)), r.set(t, i));
          },
          uniformBlockBinding: function uniformBlockBinding(t, n) {
            var r = c.get(n).get(t);
            l.get(t) !== r &&
              (e.uniformBlockBinding(n, r, t.__bindingPointIndex), l.set(t, r));
          },
          texStorage2D: function texStorage2D() {
            try {
              e.texStorage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texStorage3D: function texStorage3D() {
            try {
              e.texStorage3D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texSubImage2D: function texSubImage2D() {
            try {
              e.texSubImage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texSubImage3D: function texSubImage3D() {
            try {
              e.texSubImage3D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          compressedTexSubImage2D: function compressedTexSubImage2D() {
            try {
              e.compressedTexSubImage2D.apply(e, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          scissor: function scissor(t) {
            !1 === be.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), be.copy(t));
          },
          viewport: function viewport(t) {
            !1 === xe.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), xe.copy(t));
          },
          reset: function reset() {
            e.disable(3042),
              e.disable(2884),
              e.disable(2929),
              e.disable(32823),
              e.disable(3089),
              e.disable(2960),
              e.disable(32926),
              e.blendEquation(32774),
              e.blendFunc(1, 0),
              e.blendFuncSeparate(1, 0, 1, 0),
              e.colorMask(!0, !0, !0, !0),
              e.clearColor(0, 0, 0, 0),
              e.depthMask(!0),
              e.depthFunc(513),
              e.clearDepth(1),
              e.stencilMask(4294967295),
              e.stencilFunc(519, 0, 4294967295),
              e.stencilOp(7680, 7680, 7680),
              e.clearStencil(0),
              e.cullFace(1029),
              e.frontFace(2305),
              e.polygonOffset(0, 0),
              e.activeTexture(33984),
              e.bindFramebuffer(36160, null),
              !0 === a &&
                (e.bindFramebuffer(36009, null),
                e.bindFramebuffer(36008, null)),
              e.useProgram(null),
              e.lineWidth(1),
              e.scissor(0, 0, e.canvas.width, e.canvas.height),
              e.viewport(0, 0, e.canvas.width, e.canvas.height),
              (h = {}),
              (me = null),
              (ve = {}),
              (d = {}),
              (f = new WeakMap()),
              (p = []),
              (m = null),
              (v = !1),
              (g = null),
              (y = null),
              (M = null),
              (S = null),
              (w = null),
              (T = null),
              (A = null),
              (O = !1),
              (k = null),
              (E = null),
              (ue = null),
              (le = null),
              (ce = null),
              be.set(0, 0, e.canvas.width, e.canvas.height),
              xe.set(0, 0, e.canvas.width, e.canvas.height),
              o.reset(),
              s.reset(),
              u.reset();
          },
        };
      }
      function WebGLTextures(e, t, n, r, i, a, o) {
        var s,
          u,
          l,
          c = i.isWebGL2,
          h = i.maxTextures,
          d = i.maxCubemapSize,
          f = i.maxTextureSize,
          p = i.maxSamples,
          m = t.has("WEBGL_multisampled_render_to_texture")
            ? t.get("WEBGL_multisampled_render_to_texture")
            : null,
          v = /OculusBrowser/g.test(navigator.userAgent),
          g = new WeakMap(),
          y = new WeakMap(),
          b = !1;
        try {
          b =
            "undefined" !== typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (S) {}
        function createCanvas(e, t) {
          return b ? new OffscreenCanvas(e, t) : createElementNS("canvas");
        }
        function resizeImage(e, t, n, r) {
          var i = 1;
          if (
            ((e.width > r || e.height > r) &&
              (i = r / Math.max(e.width, e.height)),
            i < 1 || !0 === t)
          ) {
            if (
              ("undefined" !== typeof HTMLImageElement &&
                e instanceof HTMLImageElement) ||
              ("undefined" !== typeof HTMLCanvasElement &&
                e instanceof HTMLCanvasElement) ||
              ("undefined" !== typeof ImageBitmap && e instanceof ImageBitmap)
            ) {
              var a = t ? floorPowerOfTwo : Math.floor,
                o = a(i * e.width),
                s = a(i * e.height);
              void 0 === l && (l = createCanvas(o, s));
              var u = n ? createCanvas(o, s) : l;
              return (
                (u.width = o),
                (u.height = s),
                u.getContext("2d").drawImage(e, 0, 0, o, s),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    e.width +
                    "x" +
                    e.height +
                    ") to (" +
                    o +
                    "x" +
                    s +
                    ")."
                ),
                u
              );
            }
            return (
              "data" in e &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    e.width +
                    "x" +
                    e.height +
                    ")."
                ),
              e
            );
          }
          return e;
        }
        function isPowerOfTwo$1(e) {
          return isPowerOfTwo(e.width) && isPowerOfTwo(e.height);
        }
        function textureNeedsGenerateMipmaps(e, t) {
          return (
            e.generateMipmaps && t && e.minFilter !== Ae && e.minFilter !== Ee
          );
        }
        function generateMipmap(t) {
          e.generateMipmap(t);
        }
        function getInternalFormat(n, r, i, a) {
          var o =
            arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          if (!1 === c) return r;
          if (null !== n) {
            if (void 0 !== e[n]) return e[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          var s = r;
          return (
            6403 === r &&
              (5126 === i && (s = 33326),
              5131 === i && (s = 33325),
              5121 === i && (s = 33321)),
            33319 === r &&
              (5126 === i && (s = 33328),
              5131 === i && (s = 33327),
              5121 === i && (s = 33323)),
            6408 === r &&
              (5126 === i && (s = 34836),
              5131 === i && (s = 34842),
              5121 === i && (s = a === qt && !1 === o ? 35907 : 32856),
              32819 === i && (s = 32854),
              32820 === i && (s = 32855)),
            (33325 !== s &&
              33326 !== s &&
              33327 !== s &&
              33328 !== s &&
              34842 !== s &&
              34836 !== s) ||
              t.get("EXT_color_buffer_float"),
            s
          );
        }
        function getMipLevels(e, t, n) {
          return !0 === textureNeedsGenerateMipmaps(e, n) ||
            (e.isFramebufferTexture && e.minFilter !== Ae && e.minFilter !== Ee)
            ? Math.log2(Math.max(t.width, t.height)) + 1
            : void 0 !== e.mipmaps && e.mipmaps.length > 0
            ? e.mipmaps.length
            : e.isCompressedTexture && Array.isArray(e.image)
            ? t.mipmaps.length
            : 1;
        }
        function filterFallback(e) {
          return e === Ae || e === Oe || e === Le ? 9728 : 9729;
        }
        function onTextureDispose(e) {
          var t = e.target;
          t.removeEventListener("dispose", onTextureDispose),
            (function deallocateTexture(e) {
              var t = r.get(e);
              if (void 0 === t.__webglInit) return;
              var n = e.source,
                i = y.get(n);
              if (i) {
                var a = i[t.__cacheKey];
                a.usedTimes--,
                  0 === a.usedTimes && deleteTexture(e),
                  0 === Object.keys(i).length && y.delete(n);
              }
              r.remove(e);
            })(t),
            t.isVideoTexture && g.delete(t);
        }
        function onRenderTargetDispose(t) {
          var n = t.target;
          n.removeEventListener("dispose", onRenderTargetDispose),
            (function deallocateRenderTarget(t) {
              var n = t.texture,
                i = r.get(t),
                a = r.get(n);
              void 0 !== a.__webglTexture &&
                (e.deleteTexture(a.__webglTexture), o.memory.textures--);
              t.depthTexture && t.depthTexture.dispose();
              if (t.isWebGLCubeRenderTarget)
                for (var s = 0; s < 6; s++)
                  e.deleteFramebuffer(i.__webglFramebuffer[s]),
                    i.__webglDepthbuffer &&
                      e.deleteRenderbuffer(i.__webglDepthbuffer[s]);
              else {
                if (
                  (e.deleteFramebuffer(i.__webglFramebuffer),
                  i.__webglDepthbuffer &&
                    e.deleteRenderbuffer(i.__webglDepthbuffer),
                  i.__webglMultisampledFramebuffer &&
                    e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                  i.__webglColorRenderbuffer)
                )
                  for (var u = 0; u < i.__webglColorRenderbuffer.length; u++)
                    i.__webglColorRenderbuffer[u] &&
                      e.deleteRenderbuffer(i.__webglColorRenderbuffer[u]);
                i.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
              }
              if (t.isWebGLMultipleRenderTargets)
                for (var l = 0, c = n.length; l < c; l++) {
                  var h = r.get(n[l]);
                  h.__webglTexture &&
                    (e.deleteTexture(h.__webglTexture), o.memory.textures--),
                    r.remove(n[l]);
                }
              r.remove(n), r.remove(t);
            })(n);
        }
        function deleteTexture(t) {
          var n = r.get(t);
          e.deleteTexture(n.__webglTexture);
          var i = t.source;
          delete y.get(i)[n.__cacheKey], o.memory.textures--;
        }
        var x = 0;
        function setTexture2D(e, t) {
          var i = r.get(e);
          if (
            (e.isVideoTexture &&
              (function updateVideoTexture(e) {
                var t = o.render.frame;
                g.get(e) !== t && (g.set(e, t), e.update());
              })(e),
            !1 === e.isRenderTargetTexture &&
              e.version > 0 &&
              i.__version !== e.version)
          ) {
            var a = e.image;
            if (null === a)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else {
              if (!1 !== a.complete) return void uploadTexture(i, e, t);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture);
        }
        var _ =
            (_defineProperty((s = {}), Se, 10497),
            _defineProperty(s, we, 33071),
            _defineProperty(s, Te, 33648),
            s),
          M =
            (_defineProperty((u = {}), Ae, 9728),
            _defineProperty(u, Oe, 9984),
            _defineProperty(u, Le, 9986),
            _defineProperty(u, Ee, 9729),
            _defineProperty(u, Pe, 9985),
            _defineProperty(u, Ie, 9987),
            u);
        function setTextureParameters(n, a, o) {
          if (
            (o
              ? (e.texParameteri(n, 10242, _[a.wrapS]),
                e.texParameteri(n, 10243, _[a.wrapT]),
                (32879 !== n && 35866 !== n) ||
                  e.texParameteri(n, 32882, _[a.wrapR]),
                e.texParameteri(n, 10240, M[a.magFilter]),
                e.texParameteri(n, 10241, M[a.minFilter]))
              : (e.texParameteri(n, 10242, 33071),
                e.texParameteri(n, 10243, 33071),
                (32879 !== n && 35866 !== n) ||
                  e.texParameteri(n, 32882, 33071),
                (a.wrapS === we && a.wrapT === we) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                e.texParameteri(n, 10240, filterFallback(a.magFilter)),
                e.texParameteri(n, 10241, filterFallback(a.minFilter)),
                a.minFilter !== Ae &&
                  a.minFilter !== Ee &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            !0 === t.has("EXT_texture_filter_anisotropic"))
          ) {
            var s = t.get("EXT_texture_filter_anisotropic");
            if (a.type === Ue && !1 === t.has("OES_texture_float_linear"))
              return;
            if (
              !1 === c &&
              a.type === Ve &&
              !1 === t.has("OES_texture_half_float_linear")
            )
              return;
            (a.anisotropy > 1 || r.get(a).__currentAnisotropy) &&
              (e.texParameterf(
                n,
                s.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(a.anisotropy, i.getMaxAnisotropy())
              ),
              (r.get(a).__currentAnisotropy = a.anisotropy));
          }
        }
        function initTexture(t, n) {
          var r = !1;
          void 0 === t.__webglInit &&
            ((t.__webglInit = !0),
            n.addEventListener("dispose", onTextureDispose));
          var i = n.source,
            a = y.get(i);
          void 0 === a && ((a = {}), y.set(i, a));
          var s = (function getTextureCacheKey(e) {
            var t = [];
            return (
              t.push(e.wrapS),
              t.push(e.wrapT),
              t.push(e.magFilter),
              t.push(e.minFilter),
              t.push(e.anisotropy),
              t.push(e.internalFormat),
              t.push(e.format),
              t.push(e.type),
              t.push(e.generateMipmaps),
              t.push(e.premultiplyAlpha),
              t.push(e.flipY),
              t.push(e.unpackAlignment),
              t.push(e.encoding),
              t.join()
            );
          })(n);
          if (s !== t.__cacheKey) {
            void 0 === a[s] &&
              ((a[s] = { texture: e.createTexture(), usedTimes: 0 }),
              o.memory.textures++,
              (r = !0)),
              a[s].usedTimes++;
            var u = a[t.__cacheKey];
            void 0 !== u &&
              (a[t.__cacheKey].usedTimes--,
              0 === u.usedTimes && deleteTexture(n)),
              (t.__cacheKey = s),
              (t.__webglTexture = a[s].texture);
          }
          return r;
        }
        function uploadTexture(t, r, i) {
          var o = 3553;
          r.isDataArrayTexture && (o = 35866), r.isData3DTexture && (o = 32879);
          var s = initTexture(t, r),
            u = r.source;
          if (
            (n.activeTexture(33984 + i),
            n.bindTexture(o, t.__webglTexture),
            u.version !== u.__currentVersion || !0 === s)
          ) {
            e.pixelStorei(37440, r.flipY),
              e.pixelStorei(37441, r.premultiplyAlpha),
              e.pixelStorei(3317, r.unpackAlignment),
              e.pixelStorei(37443, 0);
            var l,
              h =
                (function textureNeedsPowerOfTwo(e) {
                  return (
                    !c &&
                    (e.wrapS !== we ||
                      e.wrapT !== we ||
                      (e.minFilter !== Ae && e.minFilter !== Ee))
                  );
                })(r) && !1 === isPowerOfTwo$1(r.image),
              d = resizeImage(r.image, h, !1, f),
              p = isPowerOfTwo$1((d = verifyColorSpace(r, d))) || c,
              m = a.convert(r.format, r.encoding),
              v = a.convert(r.type),
              g = getInternalFormat(
                r.internalFormat,
                m,
                v,
                r.encoding,
                r.isVideoTexture
              );
            setTextureParameters(o, r, p);
            var y = r.mipmaps,
              b = c && !0 !== r.isVideoTexture,
              x = void 0 === u.__currentVersion || !0 === s,
              _ = getMipLevels(r, d, p);
            if (r.isDepthTexture)
              (g = 6402),
                c
                  ? (g =
                      r.type === Ue
                        ? 36012
                        : r.type === Ge
                        ? 33190
                        : r.type === qe
                        ? 35056
                        : 33189)
                  : r.type === Ue &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                r.format === Qe &&
                  6402 === g &&
                  r.type !== ze &&
                  r.type !== Ge &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (r.type = Ge),
                  (v = a.convert(r.type))),
                r.format === $e &&
                  6402 === g &&
                  ((g = 34041),
                  r.type !== qe &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (r.type = qe),
                    (v = a.convert(r.type)))),
                x &&
                  (b
                    ? n.texStorage2D(3553, 1, g, d.width, d.height)
                    : n.texImage2D(
                        3553,
                        0,
                        g,
                        d.width,
                        d.height,
                        0,
                        m,
                        v,
                        null
                      ));
            else if (r.isDataTexture)
              if (y.length > 0 && p) {
                b && x && n.texStorage2D(3553, _, g, y[0].width, y[0].height);
                for (var M = 0, S = y.length; M < S; M++)
                  (l = y[M]),
                    b
                      ? n.texSubImage2D(
                          3553,
                          M,
                          0,
                          0,
                          l.width,
                          l.height,
                          m,
                          v,
                          l.data
                        )
                      : n.texImage2D(
                          3553,
                          M,
                          g,
                          l.width,
                          l.height,
                          0,
                          m,
                          v,
                          l.data
                        );
                r.generateMipmaps = !1;
              } else
                b
                  ? (x && n.texStorage2D(3553, _, g, d.width, d.height),
                    n.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      d.width,
                      d.height,
                      m,
                      v,
                      d.data
                    ))
                  : n.texImage2D(
                      3553,
                      0,
                      g,
                      d.width,
                      d.height,
                      0,
                      m,
                      v,
                      d.data
                    );
            else if (r.isCompressedTexture) {
              b && x && n.texStorage2D(3553, _, g, y[0].width, y[0].height);
              for (var w = 0, T = y.length; w < T; w++)
                (l = y[w]),
                  r.format !== Ye
                    ? null !== m
                      ? b
                        ? n.compressedTexSubImage2D(
                            3553,
                            w,
                            0,
                            0,
                            l.width,
                            l.height,
                            m,
                            l.data
                          )
                        : n.compressedTexImage2D(
                            3553,
                            w,
                            g,
                            l.width,
                            l.height,
                            0,
                            l.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : b
                    ? n.texSubImage2D(
                        3553,
                        w,
                        0,
                        0,
                        l.width,
                        l.height,
                        m,
                        v,
                        l.data
                      )
                    : n.texImage2D(
                        3553,
                        w,
                        g,
                        l.width,
                        l.height,
                        0,
                        m,
                        v,
                        l.data
                      );
            } else if (r.isDataArrayTexture)
              b
                ? (x && n.texStorage3D(35866, _, g, d.width, d.height, d.depth),
                  n.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    d.width,
                    d.height,
                    d.depth,
                    m,
                    v,
                    d.data
                  ))
                : n.texImage3D(
                    35866,
                    0,
                    g,
                    d.width,
                    d.height,
                    d.depth,
                    0,
                    m,
                    v,
                    d.data
                  );
            else if (r.isData3DTexture)
              b
                ? (x && n.texStorage3D(32879, _, g, d.width, d.height, d.depth),
                  n.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    d.width,
                    d.height,
                    d.depth,
                    m,
                    v,
                    d.data
                  ))
                : n.texImage3D(
                    32879,
                    0,
                    g,
                    d.width,
                    d.height,
                    d.depth,
                    0,
                    m,
                    v,
                    d.data
                  );
            else if (r.isFramebufferTexture) {
              if (x)
                if (b) n.texStorage2D(3553, _, g, d.width, d.height);
                else
                  for (var A = d.width, O = d.height, C = 0; C < _; C++)
                    n.texImage2D(3553, C, g, A, O, 0, m, v, null),
                      (A >>= 1),
                      (O >>= 1);
            } else if (y.length > 0 && p) {
              b && x && n.texStorage2D(3553, _, g, y[0].width, y[0].height);
              for (var L = 0, k = y.length; L < k; L++)
                (l = y[L]),
                  b
                    ? n.texSubImage2D(3553, L, 0, 0, m, v, l)
                    : n.texImage2D(3553, L, g, m, v, l);
              r.generateMipmaps = !1;
            } else
              b
                ? (x && n.texStorage2D(3553, _, g, d.width, d.height),
                  n.texSubImage2D(3553, 0, 0, 0, m, v, d))
                : n.texImage2D(3553, 0, g, m, v, d);
            textureNeedsGenerateMipmaps(r, p) && generateMipmap(o),
              (u.__currentVersion = u.version),
              r.onUpdate && r.onUpdate(r);
          }
          t.__version = r.version;
        }
        function setupFrameBufferTexture(t, i, o, s, u) {
          var l = a.convert(o.format, o.encoding),
            c = a.convert(o.type),
            h = getInternalFormat(o.internalFormat, l, c, o.encoding);
          r.get(i).__hasExternalTextures ||
            (32879 === u || 35866 === u
              ? n.texImage3D(u, 0, h, i.width, i.height, i.depth, 0, l, c, null)
              : n.texImage2D(u, 0, h, i.width, i.height, 0, l, c, null)),
            n.bindFramebuffer(36160, t),
            useMultisampledRTT(i)
              ? m.framebufferTexture2DMultisampleEXT(
                  36160,
                  s,
                  u,
                  r.get(o).__webglTexture,
                  0,
                  getRenderTargetSamples(i)
                )
              : e.framebufferTexture2D(36160, s, u, r.get(o).__webglTexture, 0),
            n.bindFramebuffer(36160, null);
        }
        function setupRenderBufferStorage(t, n, r) {
          if (
            (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)
          ) {
            var i = 33189;
            if (r || useMultisampledRTT(n)) {
              var o = n.depthTexture;
              o &&
                o.isDepthTexture &&
                (o.type === Ue ? (i = 36012) : o.type === Ge && (i = 33190));
              var s = getRenderTargetSamples(n);
              useMultisampledRTT(n)
                ? m.renderbufferStorageMultisampleEXT(
                    36161,
                    s,
                    i,
                    n.width,
                    n.height
                  )
                : e.renderbufferStorageMultisample(
                    36161,
                    s,
                    i,
                    n.width,
                    n.height
                  );
            } else e.renderbufferStorage(36161, i, n.width, n.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (n.depthBuffer && n.stencilBuffer) {
            var u = getRenderTargetSamples(n);
            r && !1 === useMultisampledRTT(n)
              ? e.renderbufferStorageMultisample(
                  36161,
                  u,
                  35056,
                  n.width,
                  n.height
                )
              : useMultisampledRTT(n)
              ? m.renderbufferStorageMultisampleEXT(
                  36161,
                  u,
                  35056,
                  n.width,
                  n.height
                )
              : e.renderbufferStorage(36161, 34041, n.width, n.height),
              e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else
            for (
              var l =
                  !0 === n.isWebGLMultipleRenderTargets
                    ? n.texture
                    : [n.texture],
                c = 0;
              c < l.length;
              c++
            ) {
              var h = l[c],
                d = a.convert(h.format, h.encoding),
                f = a.convert(h.type),
                p = getInternalFormat(h.internalFormat, d, f, h.encoding),
                v = getRenderTargetSamples(n);
              r && !1 === useMultisampledRTT(n)
                ? e.renderbufferStorageMultisample(
                    36161,
                    v,
                    p,
                    n.width,
                    n.height
                  )
                : useMultisampledRTT(n)
                ? m.renderbufferStorageMultisampleEXT(
                    36161,
                    v,
                    p,
                    n.width,
                    n.height
                  )
                : e.renderbufferStorage(36161, p, n.width, n.height);
            }
          e.bindRenderbuffer(36161, null);
        }
        function setupDepthRenderbuffer(t) {
          var i = r.get(t),
            a = !0 === t.isWebGLCubeRenderTarget;
          if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
            if (a)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function setupDepthTexture(t, i) {
              if (i && i.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (n.bindFramebuffer(36160, t),
                !i.depthTexture || !i.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              (r.get(i.depthTexture).__webglTexture &&
                i.depthTexture.image.width === i.width &&
                i.depthTexture.image.height === i.height) ||
                ((i.depthTexture.image.width = i.width),
                (i.depthTexture.image.height = i.height),
                (i.depthTexture.needsUpdate = !0)),
                setTexture2D(i.depthTexture, 0);
              var a = r.get(i.depthTexture).__webglTexture,
                o = getRenderTargetSamples(i);
              if (i.depthTexture.format === Qe)
                useMultisampledRTT(i)
                  ? m.framebufferTexture2DMultisampleEXT(
                      36160,
                      36096,
                      3553,
                      a,
                      0,
                      o
                    )
                  : e.framebufferTexture2D(36160, 36096, 3553, a, 0);
              else {
                if (i.depthTexture.format !== $e)
                  throw new Error("Unknown depthTexture format");
                useMultisampledRTT(i)
                  ? m.framebufferTexture2DMultisampleEXT(
                      36160,
                      33306,
                      3553,
                      a,
                      0,
                      o
                    )
                  : e.framebufferTexture2D(36160, 33306, 3553, a, 0);
              }
            })(i.__webglFramebuffer, t);
          } else if (a) {
            i.__webglDepthbuffer = [];
            for (var o = 0; o < 6; o++)
              n.bindFramebuffer(36160, i.__webglFramebuffer[o]),
                (i.__webglDepthbuffer[o] = e.createRenderbuffer()),
                setupRenderBufferStorage(i.__webglDepthbuffer[o], t, !1);
          } else
            n.bindFramebuffer(36160, i.__webglFramebuffer),
              (i.__webglDepthbuffer = e.createRenderbuffer()),
              setupRenderBufferStorage(i.__webglDepthbuffer, t, !1);
          n.bindFramebuffer(36160, null);
        }
        function getRenderTargetSamples(e) {
          return Math.min(p, e.samples);
        }
        function useMultisampledRTT(e) {
          var n = r.get(e);
          return (
            c &&
            e.samples > 0 &&
            !0 === t.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== n.__useRenderToTexture
          );
        }
        function verifyColorSpace(e, n) {
          var r = e.encoding,
            i = e.format,
            a = e.type;
          return !0 === e.isCompressedTexture ||
            !0 === e.isVideoTexture ||
            e.format === Cn
            ? n
            : (r !== Ht &&
                (r === qt
                  ? !1 === c
                    ? !0 === t.has("EXT_sRGB") && i === Ye
                      ? ((e.format = Cn),
                        (e.minFilter = Ee),
                        (e.generateMipmaps = !1))
                      : (n = qn.sRGBToLinear(n))
                    : (i === Ye && a === je) ||
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      r
                    )),
              n);
        }
        (this.allocateTextureUnit = function allocateTextureUnit() {
          var e = x;
          return (
            e >= h &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  e +
                  " texture units while this GPU supports only " +
                  h
              ),
            (x += 1),
            e
          );
        }),
          (this.resetTextureUnits = function resetTextureUnits() {
            x = 0;
          }),
          (this.setTexture2D = setTexture2D),
          (this.setTexture2DArray = function setTexture2DArray(e, t) {
            var i = r.get(e);
            e.version > 0 && i.__version !== e.version
              ? uploadTexture(i, e, t)
              : (n.activeTexture(33984 + t),
                n.bindTexture(35866, i.__webglTexture));
          }),
          (this.setTexture3D = function setTexture3D(e, t) {
            var i = r.get(e);
            e.version > 0 && i.__version !== e.version
              ? uploadTexture(i, e, t)
              : (n.activeTexture(33984 + t),
                n.bindTexture(32879, i.__webglTexture));
          }),
          (this.setTextureCube = function setTextureCube(t, i) {
            var o = r.get(t);
            t.version > 0 && o.__version !== t.version
              ? (function uploadCubeTexture(t, r, i) {
                  if (6 === r.image.length) {
                    var o = initTexture(t, r),
                      s = r.source;
                    if (
                      (n.activeTexture(33984 + i),
                      n.bindTexture(34067, t.__webglTexture),
                      s.version !== s.__currentVersion || !0 === o)
                    ) {
                      e.pixelStorei(37440, r.flipY),
                        e.pixelStorei(37441, r.premultiplyAlpha),
                        e.pixelStorei(3317, r.unpackAlignment),
                        e.pixelStorei(37443, 0);
                      for (
                        var u =
                            r.isCompressedTexture ||
                            r.image[0].isCompressedTexture,
                          l = r.image[0] && r.image[0].isDataTexture,
                          h = [],
                          f = 0;
                        f < 6;
                        f++
                      )
                        (h[f] =
                          u || l
                            ? l
                              ? r.image[f].image
                              : r.image[f]
                            : resizeImage(r.image[f], !1, !0, d)),
                          (h[f] = verifyColorSpace(r, h[f]));
                      var p,
                        m = h[0],
                        v = isPowerOfTwo$1(m) || c,
                        g = a.convert(r.format, r.encoding),
                        y = a.convert(r.type),
                        b = getInternalFormat(
                          r.internalFormat,
                          g,
                          y,
                          r.encoding
                        ),
                        x = c && !0 !== r.isVideoTexture,
                        _ = void 0 === s.__currentVersion || !0 === o,
                        M = getMipLevels(r, m, v);
                      if ((setTextureParameters(34067, r, v), u)) {
                        x &&
                          _ &&
                          n.texStorage2D(34067, M, b, m.width, m.height);
                        for (var S = 0; S < 6; S++) {
                          p = h[S].mipmaps;
                          for (var w = 0; w < p.length; w++) {
                            var T = p[w];
                            r.format !== Ye
                              ? null !== g
                                ? x
                                  ? n.compressedTexSubImage2D(
                                      34069 + S,
                                      w,
                                      0,
                                      0,
                                      T.width,
                                      T.height,
                                      g,
                                      T.data
                                    )
                                  : n.compressedTexImage2D(
                                      34069 + S,
                                      w,
                                      b,
                                      T.width,
                                      T.height,
                                      0,
                                      T.data
                                    )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                  )
                              : x
                              ? n.texSubImage2D(
                                  34069 + S,
                                  w,
                                  0,
                                  0,
                                  T.width,
                                  T.height,
                                  g,
                                  y,
                                  T.data
                                )
                              : n.texImage2D(
                                  34069 + S,
                                  w,
                                  b,
                                  T.width,
                                  T.height,
                                  0,
                                  g,
                                  y,
                                  T.data
                                );
                          }
                        }
                      } else {
                        (p = r.mipmaps),
                          x &&
                            _ &&
                            (p.length > 0 && M++,
                            n.texStorage2D(
                              34067,
                              M,
                              b,
                              h[0].width,
                              h[0].height
                            ));
                        for (var A = 0; A < 6; A++)
                          if (l) {
                            x
                              ? n.texSubImage2D(
                                  34069 + A,
                                  0,
                                  0,
                                  0,
                                  h[A].width,
                                  h[A].height,
                                  g,
                                  y,
                                  h[A].data
                                )
                              : n.texImage2D(
                                  34069 + A,
                                  0,
                                  b,
                                  h[A].width,
                                  h[A].height,
                                  0,
                                  g,
                                  y,
                                  h[A].data
                                );
                            for (var O = 0; O < p.length; O++) {
                              var C = p[O],
                                L = C.image[A].image;
                              x
                                ? n.texSubImage2D(
                                    34069 + A,
                                    O + 1,
                                    0,
                                    0,
                                    L.width,
                                    L.height,
                                    g,
                                    y,
                                    L.data
                                  )
                                : n.texImage2D(
                                    34069 + A,
                                    O + 1,
                                    b,
                                    L.width,
                                    L.height,
                                    0,
                                    g,
                                    y,
                                    L.data
                                  );
                            }
                          } else {
                            x
                              ? n.texSubImage2D(34069 + A, 0, 0, 0, g, y, h[A])
                              : n.texImage2D(34069 + A, 0, b, g, y, h[A]);
                            for (var k = 0; k < p.length; k++) {
                              var E = p[k];
                              x
                                ? n.texSubImage2D(
                                    34069 + A,
                                    k + 1,
                                    0,
                                    0,
                                    g,
                                    y,
                                    E.image[A]
                                  )
                                : n.texImage2D(
                                    34069 + A,
                                    k + 1,
                                    b,
                                    g,
                                    y,
                                    E.image[A]
                                  );
                            }
                          }
                      }
                      textureNeedsGenerateMipmaps(r, v) &&
                        generateMipmap(34067),
                        (s.__currentVersion = s.version),
                        r.onUpdate && r.onUpdate(r);
                    }
                    t.__version = r.version;
                  }
                })(o, t, i)
              : (n.activeTexture(33984 + i),
                n.bindTexture(34067, o.__webglTexture));
          }),
          (this.rebindTextures = function rebindTextures(e, t, n) {
            var i = r.get(e);
            void 0 !== t &&
              setupFrameBufferTexture(
                i.__webglFramebuffer,
                e,
                e.texture,
                36064,
                3553
              ),
              void 0 !== n && setupDepthRenderbuffer(e);
          }),
          (this.setupRenderTarget = function setupRenderTarget(t) {
            var s = t.texture,
              u = r.get(t),
              l = r.get(s);
            t.addEventListener("dispose", onRenderTargetDispose),
              !0 !== t.isWebGLMultipleRenderTargets &&
                (void 0 === l.__webglTexture &&
                  (l.__webglTexture = e.createTexture()),
                (l.__version = s.version),
                o.memory.textures++);
            var h = !0 === t.isWebGLCubeRenderTarget,
              d = !0 === t.isWebGLMultipleRenderTargets,
              f = isPowerOfTwo$1(t) || c;
            if (h) {
              u.__webglFramebuffer = [];
              for (var p = 0; p < 6; p++)
                u.__webglFramebuffer[p] = e.createFramebuffer();
            } else {
              if (((u.__webglFramebuffer = e.createFramebuffer()), d))
                if (i.drawBuffers)
                  for (var m = t.texture, v = 0, g = m.length; v < g; v++) {
                    var y = r.get(m[v]);
                    void 0 === y.__webglTexture &&
                      ((y.__webglTexture = e.createTexture()),
                      o.memory.textures++);
                  }
                else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              if (c && t.samples > 0 && !1 === useMultisampledRTT(t)) {
                var b = d ? s : [s];
                (u.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (u.__webglColorRenderbuffer = []),
                  n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer);
                for (var x = 0; x < b.length; x++) {
                  var _ = b[x];
                  (u.__webglColorRenderbuffer[x] = e.createRenderbuffer()),
                    e.bindRenderbuffer(36161, u.__webglColorRenderbuffer[x]);
                  var M = a.convert(_.format, _.encoding),
                    S = a.convert(_.type),
                    w = getInternalFormat(_.internalFormat, M, S, _.encoding),
                    T = getRenderTargetSamples(t);
                  e.renderbufferStorageMultisample(
                    36161,
                    T,
                    w,
                    t.width,
                    t.height
                  ),
                    e.framebufferRenderbuffer(
                      36160,
                      36064 + x,
                      36161,
                      u.__webglColorRenderbuffer[x]
                    );
                }
                e.bindRenderbuffer(36161, null),
                  t.depthBuffer &&
                    ((u.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    setupRenderBufferStorage(
                      u.__webglDepthRenderbuffer,
                      t,
                      !0
                    )),
                  n.bindFramebuffer(36160, null);
              }
            }
            if (h) {
              n.bindTexture(34067, l.__webglTexture),
                setTextureParameters(34067, s, f);
              for (var A = 0; A < 6; A++)
                setupFrameBufferTexture(
                  u.__webglFramebuffer[A],
                  t,
                  s,
                  36064,
                  34069 + A
                );
              textureNeedsGenerateMipmaps(s, f) && generateMipmap(34067),
                n.unbindTexture();
            } else if (d) {
              for (var O = t.texture, C = 0, L = O.length; C < L; C++) {
                var k = O[C],
                  E = r.get(k);
                n.bindTexture(3553, E.__webglTexture),
                  setTextureParameters(3553, k, f),
                  setupFrameBufferTexture(
                    u.__webglFramebuffer,
                    t,
                    k,
                    36064 + C,
                    3553
                  ),
                  textureNeedsGenerateMipmaps(k, f) && generateMipmap(3553);
              }
              n.unbindTexture();
            } else {
              var P = 3553;
              (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
                (c
                  ? (P = t.isWebGL3DRenderTarget ? 32879 : 35866)
                  : console.error(
                      "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                    )),
                n.bindTexture(P, l.__webglTexture),
                setTextureParameters(P, s, f),
                setupFrameBufferTexture(u.__webglFramebuffer, t, s, 36064, P),
                textureNeedsGenerateMipmaps(s, f) && generateMipmap(P),
                n.unbindTexture();
            }
            t.depthBuffer && setupDepthRenderbuffer(t);
          }),
          (this.updateRenderTargetMipmap = function updateRenderTargetMipmap(
            e
          ) {
            for (
              var t = isPowerOfTwo$1(e) || c,
                i =
                  !0 === e.isWebGLMultipleRenderTargets
                    ? e.texture
                    : [e.texture],
                a = 0,
                o = i.length;
              a < o;
              a++
            ) {
              var s = i[a];
              if (textureNeedsGenerateMipmaps(s, t)) {
                var u = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                  l = r.get(s).__webglTexture;
                n.bindTexture(u, l), generateMipmap(u), n.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget =
            function updateMultisampleRenderTarget(t) {
              if (c && t.samples > 0 && !1 === useMultisampledRTT(t)) {
                var i = t.isWebGLMultipleRenderTargets
                    ? t.texture
                    : [t.texture],
                  a = t.width,
                  o = t.height,
                  s = 16384,
                  u = [],
                  l = t.stencilBuffer ? 33306 : 36096,
                  h = r.get(t),
                  d = !0 === t.isWebGLMultipleRenderTargets;
                if (d)
                  for (var f = 0; f < i.length; f++)
                    n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                      e.framebufferRenderbuffer(36160, 36064 + f, 36161, null),
                      n.bindFramebuffer(36160, h.__webglFramebuffer),
                      e.framebufferTexture2D(36009, 36064 + f, 3553, null, 0);
                n.bindFramebuffer(36008, h.__webglMultisampledFramebuffer),
                  n.bindFramebuffer(36009, h.__webglFramebuffer);
                for (var p = 0; p < i.length; p++) {
                  u.push(36064 + p), t.depthBuffer && u.push(l);
                  var m =
                    void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                  if (
                    (!1 === m &&
                      (t.depthBuffer && (s |= 256),
                      t.stencilBuffer && (s |= 1024)),
                    d &&
                      e.framebufferRenderbuffer(
                        36008,
                        36064,
                        36161,
                        h.__webglColorRenderbuffer[p]
                      ),
                    !0 === m &&
                      (e.invalidateFramebuffer(36008, [l]),
                      e.invalidateFramebuffer(36009, [l])),
                    d)
                  ) {
                    var g = r.get(i[p]).__webglTexture;
                    e.framebufferTexture2D(36009, 36064, 3553, g, 0);
                  }
                  e.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728),
                    v && e.invalidateFramebuffer(36008, u);
                }
                if (
                  (n.bindFramebuffer(36008, null),
                  n.bindFramebuffer(36009, null),
                  d)
                )
                  for (var y = 0; y < i.length; y++) {
                    n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                      e.framebufferRenderbuffer(
                        36160,
                        36064 + y,
                        36161,
                        h.__webglColorRenderbuffer[y]
                      );
                    var b = r.get(i[y]).__webglTexture;
                    n.bindFramebuffer(36160, h.__webglFramebuffer),
                      e.framebufferTexture2D(36009, 36064 + y, 3553, b, 0);
                  }
                n.bindFramebuffer(36009, h.__webglMultisampledFramebuffer);
              }
            }),
          (this.setupDepthRenderbuffer = setupDepthRenderbuffer),
          (this.setupFrameBufferTexture = setupFrameBufferTexture),
          (this.useMultisampledRTT = useMultisampledRTT);
      }
      function WebGLUtils(e, t, n) {
        var r = n.isWebGL2;
        return {
          convert: function convert(n) {
            var i,
              a =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : null;
            if (n === je) return 5121;
            if (n === We) return 32819;
            if (n === He) return 32820;
            if (n === Be) return 5120;
            if (n === Ne) return 5122;
            if (n === ze) return 5123;
            if (n === Fe) return 5124;
            if (n === Ge) return 5125;
            if (n === Ue) return 5126;
            if (n === Ve)
              return r
                ? 5131
                : null !== (i = t.get("OES_texture_half_float"))
                ? i.HALF_FLOAT_OES
                : null;
            if (n === Xe) return 6406;
            if (n === Ye) return 6408;
            if (n === Ze) return 6409;
            if (n === Ke) return 6410;
            if (n === Qe) return 6402;
            if (n === $e) return 34041;
            if (n === et) return 6403;
            if (n === Je)
              return (
                console.warn(
                  "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
                ),
                6408
              );
            if (n === Cn)
              return null !== (i = t.get("EXT_sRGB")) ? i.SRGB_ALPHA_EXT : null;
            if (n === tt) return 36244;
            if (n === nt) return 33319;
            if (n === rt) return 33320;
            if (n === it) return 36249;
            if (n === at || n === ot || n === st || n === ut)
              if (a === qt) {
                if (null === (i = t.get("WEBGL_compressed_texture_s3tc_srgb")))
                  return null;
                if (n === at) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === ot) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === st) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === ut) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (null === (i = t.get("WEBGL_compressed_texture_s3tc")))
                  return null;
                if (n === at) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === ot) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === st) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === ut) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (n === lt || n === ct || n === ht || n === dt) {
              if (null === (i = t.get("WEBGL_compressed_texture_pvrtc")))
                return null;
              if (n === lt) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (n === ct) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (n === ht) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (n === dt) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (n === ft)
              return null !== (i = t.get("WEBGL_compressed_texture_etc1"))
                ? i.COMPRESSED_RGB_ETC1_WEBGL
                : null;
            if (n === pt || n === mt) {
              if (null === (i = t.get("WEBGL_compressed_texture_etc")))
                return null;
              if (n === pt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ETC2
                  : i.COMPRESSED_RGB8_ETC2;
              if (n === mt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : i.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              n === vt ||
              n === gt ||
              n === yt ||
              n === bt ||
              n === xt ||
              n === _t ||
              n === Mt ||
              n === St ||
              n === wt ||
              n === Tt ||
              n === At ||
              n === Ot ||
              n === Ct ||
              n === Lt
            ) {
              if (null === (i = t.get("WEBGL_compressed_texture_astc")))
                return null;
              if (n === vt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (n === gt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (n === yt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (n === bt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (n === xt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (n === _t)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (n === Mt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (n === St)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (n === wt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (n === Tt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (n === At)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (n === Ot)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (n === Ct)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (n === Lt)
                return a === qt
                  ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : i.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (n === kt) {
              if (null === (i = t.get("EXT_texture_compression_bptc")))
                return null;
              if (n === kt)
                return a === qt
                  ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : i.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            return n === qe
              ? r
                ? 34042
                : null !== (i = t.get("WEBGL_depth_texture"))
                ? i.UNSIGNED_INT_24_8_WEBGL
                : null
              : void 0 !== e[n]
              ? e[n]
              : null;
          },
        };
      }
      var ho = (function (e) {
          function ArrayCamera() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [];
            return (
              Object(f.a)(this, ArrayCamera),
              ((e = Object(s.a)(
                this,
                Object(r.a)(ArrayCamera).call(this)
              )).isArrayCamera = !0),
              (e.cameras = t),
              e
            );
          }
          return Object(u.a)(ArrayCamera, e), ArrayCamera;
        })(ha),
        fo = (function (e) {
          function Group() {
            var e;
            return (
              Object(f.a)(this, Group),
              ((e = Object(s.a)(this, Object(r.a)(Group).call(this))).isGroup =
                !0),
              (e.type = "Group"),
              e
            );
          }
          return Object(u.a)(Group, e), Group;
        })(ai),
        po = { type: "move" },
        mo = (function () {
          function WebXRController() {
            Object(f.a)(this, WebXRController),
              (this._targetRay = null),
              (this._grip = null),
              (this._hand = null);
          }
          return (
            Object(p.a)(WebXRController, [
              {
                key: "getHandSpace",
                value: function getHandSpace() {
                  return (
                    null === this._hand &&
                      ((this._hand = new fo()),
                      (this._hand.matrixAutoUpdate = !1),
                      (this._hand.visible = !1),
                      (this._hand.joints = {}),
                      (this._hand.inputState = { pinching: !1 })),
                    this._hand
                  );
                },
              },
              {
                key: "getTargetRaySpace",
                value: function getTargetRaySpace() {
                  return (
                    null === this._targetRay &&
                      ((this._targetRay = new fo()),
                      (this._targetRay.matrixAutoUpdate = !1),
                      (this._targetRay.visible = !1),
                      (this._targetRay.hasLinearVelocity = !1),
                      (this._targetRay.linearVelocity = new ir()),
                      (this._targetRay.hasAngularVelocity = !1),
                      (this._targetRay.angularVelocity = new ir())),
                    this._targetRay
                  );
                },
              },
              {
                key: "getGripSpace",
                value: function getGripSpace() {
                  return (
                    null === this._grip &&
                      ((this._grip = new fo()),
                      (this._grip.matrixAutoUpdate = !1),
                      (this._grip.visible = !1),
                      (this._grip.hasLinearVelocity = !1),
                      (this._grip.linearVelocity = new ir()),
                      (this._grip.hasAngularVelocity = !1),
                      (this._grip.angularVelocity = new ir())),
                    this._grip
                  );
                },
              },
              {
                key: "dispatchEvent",
                value: function dispatchEvent(e) {
                  return (
                    null !== this._targetRay &&
                      this._targetRay.dispatchEvent(e),
                    null !== this._grip && this._grip.dispatchEvent(e),
                    null !== this._hand && this._hand.dispatchEvent(e),
                    this
                  );
                },
              },
              {
                key: "disconnect",
                value: function disconnect(e) {
                  return (
                    this.dispatchEvent({ type: "disconnected", data: e }),
                    null !== this._targetRay && (this._targetRay.visible = !1),
                    null !== this._grip && (this._grip.visible = !1),
                    null !== this._hand && (this._hand.visible = !1),
                    this
                  );
                },
              },
              {
                key: "update",
                value: function update(e, t, n) {
                  var r = null,
                    i = null,
                    a = null,
                    o = this._targetRay,
                    s = this._grip,
                    u = this._hand;
                  if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (u && e.hand) {
                      a = !0;
                      var l = !0,
                        c = !1,
                        h = void 0;
                      try {
                        for (
                          var d, f = e.hand.values()[Symbol.iterator]();
                          !(l = (d = f.next()).done);
                          l = !0
                        ) {
                          var p = d.value,
                            m = t.getJointPose(p, n);
                          if (void 0 === u.joints[p.jointName]) {
                            var v = new fo();
                            (v.matrixAutoUpdate = !1),
                              (v.visible = !1),
                              (u.joints[p.jointName] = v),
                              u.add(v);
                          }
                          var g = u.joints[p.jointName];
                          null !== m &&
                            (g.matrix.fromArray(m.transform.matrix),
                            g.matrix.decompose(g.position, g.rotation, g.scale),
                            (g.jointRadius = m.radius)),
                            (g.visible = null !== m);
                        }
                      } catch (_) {
                        (c = !0), (h = _);
                      } finally {
                        try {
                          l || null == f.return || f.return();
                        } finally {
                          if (c) throw h;
                        }
                      }
                      var y = u.joints["index-finger-tip"],
                        b = u.joints["thumb-tip"],
                        x = y.position.distanceTo(b.position);
                      u.inputState.pinching && x > 0.025
                        ? ((u.inputState.pinching = !1),
                          this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this,
                          }))
                        : !u.inputState.pinching &&
                          x <= 0.015 &&
                          ((u.inputState.pinching = !0),
                          this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this,
                          }));
                    } else
                      null !== s &&
                        e.gripSpace &&
                        null !== (i = t.getPose(e.gripSpace, n)) &&
                        (s.matrix.fromArray(i.transform.matrix),
                        s.matrix.decompose(s.position, s.rotation, s.scale),
                        i.linearVelocity
                          ? ((s.hasLinearVelocity = !0),
                            s.linearVelocity.copy(i.linearVelocity))
                          : (s.hasLinearVelocity = !1),
                        i.angularVelocity
                          ? ((s.hasAngularVelocity = !0),
                            s.angularVelocity.copy(i.angularVelocity))
                          : (s.hasAngularVelocity = !1));
                    null !== o &&
                      (null === (r = t.getPose(e.targetRaySpace, n)) &&
                        null !== i &&
                        (r = i),
                      null !== r &&
                        (o.matrix.fromArray(r.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        r.linearVelocity
                          ? ((o.hasLinearVelocity = !0),
                            o.linearVelocity.copy(r.linearVelocity))
                          : (o.hasLinearVelocity = !1),
                        r.angularVelocity
                          ? ((o.hasAngularVelocity = !0),
                            o.angularVelocity.copy(r.angularVelocity))
                          : (o.hasAngularVelocity = !1),
                        this.dispatchEvent(po)));
                  }
                  return (
                    null !== o && (o.visible = null !== r),
                    null !== s && (s.visible = null !== i),
                    null !== u && (u.visible = null !== a),
                    this
                  );
                },
              },
            ]),
            WebXRController
          );
        })(),
        vo = (function (e) {
          function DepthTexture(e, t, n, i, a, o, u, l, c, h) {
            var d;
            if (
              (Object(f.a)(this, DepthTexture),
              (h = void 0 !== h ? h : Qe) !== Qe && h !== $e)
            )
              throw new Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            return (
              void 0 === n && h === Qe && (n = Ge),
              void 0 === n && h === $e && (n = qe),
              ((d = Object(s.a)(
                this,
                Object(r.a)(DepthTexture).call(
                  this,
                  null,
                  i,
                  a,
                  o,
                  u,
                  l,
                  h,
                  n,
                  c
                )
              )).isDepthTexture = !0),
              (d.image = { width: e, height: t }),
              (d.magFilter = void 0 !== u ? u : Ae),
              (d.minFilter = void 0 !== l ? l : Ae),
              (d.flipY = !1),
              (d.generateMipmaps = !1),
              d
            );
          }
          return Object(u.a)(DepthTexture, e), DepthTexture;
        })(Yn),
        go = (function (e) {
          function WebXRManager(e, t) {
            var n;
            Object(f.a)(this, WebXRManager),
              (n = Object(s.a)(this, Object(r.a)(WebXRManager).call(this)));
            var i = Object(l.a)(Object(l.a)(n)),
              a = null,
              o = 1,
              u = null,
              c = "local-floor",
              h = null,
              p = null,
              m = null,
              v = null,
              g = null,
              y = null,
              b = t.getContextAttributes(),
              x = null,
              _ = null,
              M = [],
              S = [],
              w = new ha();
            w.layers.enable(1), (w.viewport = new Zn());
            var T = new ha();
            T.layers.enable(2), (T.viewport = new Zn());
            var A = [w, T],
              O = new ho();
            O.layers.enable(1), O.layers.enable(2);
            var C = null,
              L = null;
            function onSessionEvent(e) {
              var t = S.indexOf(e.inputSource);
              if (-1 !== t) {
                var n = M[t];
                void 0 !== n &&
                  n.dispatchEvent({ type: e.type, data: e.inputSource });
              }
            }
            function onSessionEnd() {
              a.removeEventListener("select", onSessionEvent),
                a.removeEventListener("selectstart", onSessionEvent),
                a.removeEventListener("selectend", onSessionEvent),
                a.removeEventListener("squeeze", onSessionEvent),
                a.removeEventListener("squeezestart", onSessionEvent),
                a.removeEventListener("squeezeend", onSessionEvent),
                a.removeEventListener("end", onSessionEnd),
                a.removeEventListener(
                  "inputsourceschange",
                  onInputSourcesChange
                );
              for (var t = 0; t < M.length; t++) {
                var n = S[t];
                null !== n && ((S[t] = null), M[t].disconnect(n));
              }
              (C = null),
                (L = null),
                e.setRenderTarget(x),
                (g = null),
                (v = null),
                (m = null),
                (a = null),
                (_ = null),
                R.stop(),
                (i.isPresenting = !1),
                i.dispatchEvent({ type: "sessionend" });
            }
            function onInputSourcesChange(e) {
              for (var t = 0; t < e.removed.length; t++) {
                var n = e.removed[t],
                  r = S.indexOf(n);
                r >= 0 &&
                  ((S[r] = null),
                  M[r].dispatchEvent({ type: "disconnected", data: n }));
              }
              for (var i = 0; i < e.added.length; i++) {
                var a = e.added[i],
                  o = S.indexOf(a);
                if (-1 === o) {
                  for (var s = 0; s < M.length; s++) {
                    if (s >= S.length) {
                      S.push(a), (o = s);
                      break;
                    }
                    if (null === S[s]) {
                      (S[s] = a), (o = s);
                      break;
                    }
                  }
                  if (-1 === o) break;
                }
                var u = M[o];
                u && u.dispatchEvent({ type: "connected", data: a });
              }
            }
            (n.cameraAutoUpdate = !0),
              (n.enabled = !1),
              (n.isPresenting = !1),
              (n.getController = function (e) {
                var t = M[e];
                return (
                  void 0 === t && ((t = new mo()), (M[e] = t)),
                  t.getTargetRaySpace()
                );
              }),
              (n.getControllerGrip = function (e) {
                var t = M[e];
                return (
                  void 0 === t && ((t = new mo()), (M[e] = t)), t.getGripSpace()
                );
              }),
              (n.getHand = function (e) {
                var t = M[e];
                return (
                  void 0 === t && ((t = new mo()), (M[e] = t)), t.getHandSpace()
                );
              }),
              (n.setFramebufferScaleFactor = function (e) {
                (o = e),
                  !0 === i.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (n.setReferenceSpaceType = function (e) {
                (c = e),
                  !0 === i.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (n.getReferenceSpace = function () {
                return h || u;
              }),
              (n.setReferenceSpace = function (e) {
                h = e;
              }),
              (n.getBaseLayer = function () {
                return null !== v ? v : g;
              }),
              (n.getBinding = function () {
                return m;
              }),
              (n.getFrame = function () {
                return y;
              }),
              (n.getSession = function () {
                return a;
              }),
              (n.setSession = (function () {
                var n = _asyncToGenerator(
                  d.a.mark(function _callee(n) {
                    var r, s, l, f, p;
                    return d.a.wrap(
                      function _callee$(d) {
                        for (;;)
                          switch ((d.prev = d.next)) {
                            case 0:
                              if (null === (a = n)) {
                                d.next = 25;
                                break;
                              }
                              if (
                                ((x = e.getRenderTarget()),
                                a.addEventListener("select", onSessionEvent),
                                a.addEventListener(
                                  "selectstart",
                                  onSessionEvent
                                ),
                                a.addEventListener("selectend", onSessionEvent),
                                a.addEventListener("squeeze", onSessionEvent),
                                a.addEventListener(
                                  "squeezestart",
                                  onSessionEvent
                                ),
                                a.addEventListener(
                                  "squeezeend",
                                  onSessionEvent
                                ),
                                a.addEventListener("end", onSessionEnd),
                                a.addEventListener(
                                  "inputsourceschange",
                                  onInputSourcesChange
                                ),
                                !0 === b.xrCompatible)
                              ) {
                                d.next = 14;
                                break;
                              }
                              return (d.next = 14), t.makeXRCompatible();
                            case 14:
                              return (
                                void 0 === a.renderState.layers ||
                                !1 === e.capabilities.isWebGL2
                                  ? ((r = {
                                      antialias:
                                        void 0 !== a.renderState.layers ||
                                        b.antialias,
                                      alpha: b.alpha,
                                      depth: b.depth,
                                      stencil: b.stencil,
                                      framebufferScaleFactor: o,
                                    }),
                                    (g = new XRWebGLLayer(a, t, r)),
                                    a.updateRenderState({ baseLayer: g }),
                                    (_ = new Kn(
                                      g.framebufferWidth,
                                      g.framebufferHeight,
                                      {
                                        format: Ye,
                                        type: je,
                                        encoding: e.outputEncoding,
                                      }
                                    )))
                                  : ((s = null),
                                    (l = null),
                                    (f = null),
                                    b.depth &&
                                      ((f = b.stencil ? 35056 : 33190),
                                      (s = b.stencil ? $e : Qe),
                                      (l = b.stencil ? qe : Ge)),
                                    (p = {
                                      colorFormat: 32856,
                                      depthFormat: f,
                                      scaleFactor: o,
                                    }),
                                    (m = new XRWebGLBinding(a, t)),
                                    (v = m.createProjectionLayer(p)),
                                    a.updateRenderState({ layers: [v] }),
                                    (_ = new Kn(
                                      v.textureWidth,
                                      v.textureHeight,
                                      {
                                        format: Ye,
                                        type: je,
                                        depthTexture: new vo(
                                          v.textureWidth,
                                          v.textureHeight,
                                          l,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          s
                                        ),
                                        stencilBuffer: b.stencil,
                                        encoding: e.outputEncoding,
                                        samples: b.antialias ? 4 : 0,
                                      }
                                    )),
                                    (e.properties.get(_).__ignoreDepthValues =
                                      v.ignoreDepthValues)),
                                (_.isXRRenderTarget = !0),
                                this.setFoveation(1),
                                (h = null),
                                (d.next = 20),
                                a.requestReferenceSpace(c)
                              );
                            case 20:
                              (u = d.sent),
                                R.setContext(a),
                                R.start(),
                                (i.isPresenting = !0),
                                i.dispatchEvent({ type: "sessionstart" });
                            case 25:
                            case "end":
                              return d.stop();
                          }
                      },
                      _callee,
                      this
                    );
                  })
                );
                return function (e) {
                  return n.apply(this, arguments);
                };
              })());
            var k = new ir(),
              E = new ir();
            function updateCamera(e, t) {
              null === t
                ? e.matrixWorld.copy(e.matrix)
                : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                e.matrixWorldInverse.copy(e.matrixWorld).invert();
            }
            (n.updateCamera = function (e) {
              if (null !== a) {
                (O.near = T.near = w.near = e.near),
                  (O.far = T.far = w.far = e.far),
                  (C === O.near && L === O.far) ||
                    (a.updateRenderState({
                      depthNear: O.near,
                      depthFar: O.far,
                    }),
                    (C = O.near),
                    (L = O.far));
                var t = e.parent,
                  n = O.cameras;
                updateCamera(O, t);
                for (var r = 0; r < n.length; r++) updateCamera(n[r], t);
                O.matrixWorld.decompose(O.position, O.quaternion, O.scale),
                  e.position.copy(O.position),
                  e.quaternion.copy(O.quaternion),
                  e.scale.copy(O.scale),
                  e.matrix.copy(O.matrix),
                  e.matrixWorld.copy(O.matrixWorld);
                for (var i = e.children, o = 0, s = i.length; o < s; o++)
                  i[o].updateMatrixWorld(!0);
                2 === n.length
                  ? (function setProjectionFromUnion(e, t, n) {
                      k.setFromMatrixPosition(t.matrixWorld),
                        E.setFromMatrixPosition(n.matrixWorld);
                      var r = k.distanceTo(E),
                        i = t.projectionMatrix.elements,
                        a = n.projectionMatrix.elements,
                        o = i[14] / (i[10] - 1),
                        s = i[14] / (i[10] + 1),
                        u = (i[9] + 1) / i[5],
                        l = (i[9] - 1) / i[5],
                        c = (i[8] - 1) / i[0],
                        h = (a[8] + 1) / a[0],
                        d = o * c,
                        f = o * h,
                        p = r / (-c + h),
                        m = p * -c;
                      t.matrixWorld.decompose(
                        e.position,
                        e.quaternion,
                        e.scale
                      ),
                        e.translateX(m),
                        e.translateZ(p),
                        e.matrixWorld.compose(
                          e.position,
                          e.quaternion,
                          e.scale
                        ),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert();
                      var v = o + p,
                        g = s + p,
                        y = d - m,
                        b = f + (r - m),
                        x = ((u * s) / g) * v,
                        _ = ((l * s) / g) * v;
                      e.projectionMatrix.makePerspective(y, b, x, _, v, g);
                    })(O, w, T)
                  : O.projectionMatrix.copy(w.projectionMatrix);
              }
            }),
              (n.getCamera = function () {
                return O;
              }),
              (n.getFoveation = function () {
                return null !== v
                  ? v.fixedFoveation
                  : null !== g
                  ? g.fixedFoveation
                  : void 0;
              }),
              (n.setFoveation = function (e) {
                null !== v && (v.fixedFoveation = e),
                  null !== g &&
                    void 0 !== g.fixedFoveation &&
                    (g.fixedFoveation = e);
              });
            var P = null;
            var R = new WebGLAnimation();
            return (
              R.setAnimationLoop(function onAnimationFrame(t, n) {
                if (((p = n.getViewerPose(h || u)), (y = n), null !== p)) {
                  var r = p.views;
                  null !== g &&
                    (e.setRenderTargetFramebuffer(_, g.framebuffer),
                    e.setRenderTarget(_));
                  var i = !1;
                  r.length !== O.cameras.length &&
                    ((O.cameras.length = 0), (i = !0));
                  for (var a = 0; a < r.length; a++) {
                    var o = r[a],
                      s = null;
                    if (null !== g) s = g.getViewport(o);
                    else {
                      var l = m.getViewSubImage(v, o);
                      (s = l.viewport),
                        0 === a &&
                          (e.setRenderTargetTextures(
                            _,
                            l.colorTexture,
                            v.ignoreDepthValues ? void 0 : l.depthStencilTexture
                          ),
                          e.setRenderTarget(_));
                    }
                    var c = A[a];
                    void 0 === c &&
                      ((c = new ha()).layers.enable(a),
                      (c.viewport = new Zn()),
                      (A[a] = c)),
                      c.matrix.fromArray(o.transform.matrix),
                      c.projectionMatrix.fromArray(o.projectionMatrix),
                      c.viewport.set(s.x, s.y, s.width, s.height),
                      0 === a && O.matrix.copy(c.matrix),
                      !0 === i && O.cameras.push(c);
                  }
                }
                for (var d = 0; d < M.length; d++) {
                  var f = S[d],
                    b = M[d];
                  null !== f && void 0 !== b && b.update(f, n, h || u);
                }
                P && P(t, n), (y = null);
              }),
              (n.setAnimationLoop = function (e) {
                P = e;
              }),
              (n.dispose = function () {}),
              n
            );
          }
          return Object(u.a)(WebXRManager, e), WebXRManager;
        })(Ln);
      function WebGLMaterials(e, t) {
        function refreshUniformsCommon(n, r) {
          (n.opacity.value = r.opacity),
            r.color && n.diffuse.value.copy(r.color),
            r.emissive &&
              n.emissive.value
                .copy(r.emissive)
                .multiplyScalar(r.emissiveIntensity),
            r.map && (n.map.value = r.map),
            r.alphaMap && (n.alphaMap.value = r.alphaMap),
            r.bumpMap &&
              ((n.bumpMap.value = r.bumpMap),
              (n.bumpScale.value = r.bumpScale),
              r.side === C && (n.bumpScale.value *= -1)),
            r.displacementMap &&
              ((n.displacementMap.value = r.displacementMap),
              (n.displacementScale.value = r.displacementScale),
              (n.displacementBias.value = r.displacementBias)),
            r.emissiveMap && (n.emissiveMap.value = r.emissiveMap),
            r.normalMap &&
              ((n.normalMap.value = r.normalMap),
              n.normalScale.value.copy(r.normalScale),
              r.side === C && n.normalScale.value.negate()),
            r.specularMap && (n.specularMap.value = r.specularMap),
            r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
          var i,
            a,
            o = t.get(r).envMap;
          if (
            (o &&
              ((n.envMap.value = o),
              (n.flipEnvMap.value =
                o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1),
              (n.reflectivity.value = r.reflectivity),
              (n.ior.value = r.ior),
              (n.refractionRatio.value = r.refractionRatio)),
            r.lightMap)
          ) {
            n.lightMap.value = r.lightMap;
            var s = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
            n.lightMapIntensity.value = r.lightMapIntensity * s;
          }
          r.aoMap &&
            ((n.aoMap.value = r.aoMap),
            (n.aoMapIntensity.value = r.aoMapIntensity)),
            r.map
              ? (i = r.map)
              : r.specularMap
              ? (i = r.specularMap)
              : r.displacementMap
              ? (i = r.displacementMap)
              : r.normalMap
              ? (i = r.normalMap)
              : r.bumpMap
              ? (i = r.bumpMap)
              : r.roughnessMap
              ? (i = r.roughnessMap)
              : r.metalnessMap
              ? (i = r.metalnessMap)
              : r.alphaMap
              ? (i = r.alphaMap)
              : r.emissiveMap
              ? (i = r.emissiveMap)
              : r.clearcoatMap
              ? (i = r.clearcoatMap)
              : r.clearcoatNormalMap
              ? (i = r.clearcoatNormalMap)
              : r.clearcoatRoughnessMap
              ? (i = r.clearcoatRoughnessMap)
              : r.iridescenceMap
              ? (i = r.iridescenceMap)
              : r.iridescenceThicknessMap
              ? (i = r.iridescenceThicknessMap)
              : r.specularIntensityMap
              ? (i = r.specularIntensityMap)
              : r.specularColorMap
              ? (i = r.specularColorMap)
              : r.transmissionMap
              ? (i = r.transmissionMap)
              : r.thicknessMap
              ? (i = r.thicknessMap)
              : r.sheenColorMap
              ? (i = r.sheenColorMap)
              : r.sheenRoughnessMap && (i = r.sheenRoughnessMap),
            void 0 !== i &&
              (i.isWebGLRenderTarget && (i = i.texture),
              !0 === i.matrixAutoUpdate && i.updateMatrix(),
              n.uvTransform.value.copy(i.matrix)),
            r.aoMap ? (a = r.aoMap) : r.lightMap && (a = r.lightMap),
            void 0 !== a &&
              (a.isWebGLRenderTarget && (a = a.texture),
              !0 === a.matrixAutoUpdate && a.updateMatrix(),
              n.uv2Transform.value.copy(a.matrix));
        }
        return {
          refreshFogUniforms: function refreshFogUniforms(e, t) {
            e.fogColor.value.copy(t.color),
              t.isFog
                ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
                : t.isFogExp2 && (e.fogDensity.value = t.density);
          },
          refreshMaterialUniforms: function refreshMaterialUniforms(
            e,
            n,
            r,
            i,
            a
          ) {
            n.isMeshBasicMaterial
              ? refreshUniformsCommon(e, n)
              : n.isMeshLambertMaterial
              ? refreshUniformsCommon(e, n)
              : n.isMeshToonMaterial
              ? (refreshUniformsCommon(e, n),
                (function refreshUniformsToon(e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap);
                })(e, n))
              : n.isMeshPhongMaterial
              ? (refreshUniformsCommon(e, n),
                (function refreshUniformsPhong(e, t) {
                  e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4));
                })(e, n))
              : n.isMeshStandardMaterial
              ? (refreshUniformsCommon(e, n),
                (function refreshUniformsStandard(e, n) {
                  (e.roughness.value = n.roughness),
                    (e.metalness.value = n.metalness),
                    n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                    n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                    t.get(n).envMap &&
                      (e.envMapIntensity.value = n.envMapIntensity);
                })(e, n),
                n.isMeshPhysicalMaterial &&
                  (function refreshUniformsPhysical(e, t, n) {
                    (e.ior.value = t.ior),
                      t.sheen > 0 &&
                        (e.sheenColor.value
                          .copy(t.sheenColor)
                          .multiplyScalar(t.sheen),
                        (e.sheenRoughness.value = t.sheenRoughness),
                        t.sheenColorMap &&
                          (e.sheenColorMap.value = t.sheenColorMap),
                        t.sheenRoughnessMap &&
                          (e.sheenRoughnessMap.value = t.sheenRoughnessMap)),
                      t.clearcoat > 0 &&
                        ((e.clearcoat.value = t.clearcoat),
                        (e.clearcoatRoughness.value = t.clearcoatRoughness),
                        t.clearcoatMap &&
                          (e.clearcoatMap.value = t.clearcoatMap),
                        t.clearcoatRoughnessMap &&
                          (e.clearcoatRoughnessMap.value =
                            t.clearcoatRoughnessMap),
                        t.clearcoatNormalMap &&
                          (e.clearcoatNormalScale.value.copy(
                            t.clearcoatNormalScale
                          ),
                          (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                          t.side === C &&
                            e.clearcoatNormalScale.value.negate())),
                      t.iridescence > 0 &&
                        ((e.iridescence.value = t.iridescence),
                        (e.iridescenceIOR.value = t.iridescenceIOR),
                        (e.iridescenceThicknessMinimum.value =
                          t.iridescenceThicknessRange[0]),
                        (e.iridescenceThicknessMaximum.value =
                          t.iridescenceThicknessRange[1]),
                        t.iridescenceMap &&
                          (e.iridescenceMap.value = t.iridescenceMap),
                        t.iridescenceThicknessMap &&
                          (e.iridescenceThicknessMap.value =
                            t.iridescenceThicknessMap)),
                      t.transmission > 0 &&
                        ((e.transmission.value = t.transmission),
                        (e.transmissionSamplerMap.value = n.texture),
                        e.transmissionSamplerSize.value.set(n.width, n.height),
                        t.transmissionMap &&
                          (e.transmissionMap.value = t.transmissionMap),
                        (e.thickness.value = t.thickness),
                        t.thicknessMap &&
                          (e.thicknessMap.value = t.thicknessMap),
                        (e.attenuationDistance.value = t.attenuationDistance),
                        e.attenuationColor.value.copy(t.attenuationColor)),
                      (e.specularIntensity.value = t.specularIntensity),
                      e.specularColor.value.copy(t.specularColor),
                      t.specularIntensityMap &&
                        (e.specularIntensityMap.value = t.specularIntensityMap),
                      t.specularColorMap &&
                        (e.specularColorMap.value = t.specularColorMap);
                  })(e, n, a))
              : n.isMeshMatcapMaterial
              ? (refreshUniformsCommon(e, n),
                (function refreshUniformsMatcap(e, t) {
                  t.matcap && (e.matcap.value = t.matcap);
                })(e, n))
              : n.isMeshDepthMaterial
              ? refreshUniformsCommon(e, n)
              : n.isMeshDistanceMaterial
              ? (refreshUniformsCommon(e, n),
                (function refreshUniformsDistance(e, t) {
                  e.referencePosition.value.copy(t.referencePosition),
                    (e.nearDistance.value = t.nearDistance),
                    (e.farDistance.value = t.farDistance);
                })(e, n))
              : n.isMeshNormalMaterial
              ? refreshUniformsCommon(e, n)
              : n.isLineBasicMaterial
              ? ((function refreshUniformsLine(e, t) {
                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
                })(e, n),
                n.isLineDashedMaterial &&
                  (function refreshUniformsDash(e, t) {
                    (e.dashSize.value = t.dashSize),
                      (e.totalSize.value = t.dashSize + t.gapSize),
                      (e.scale.value = t.scale);
                  })(e, n))
              : n.isPointsMaterial
              ? (function refreshUniformsPoints(e, t, n, r) {
                  var i;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.size.value = t.size * n),
                    (e.scale.value = 0.5 * r),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                    t.map ? (i = t.map) : t.alphaMap && (i = t.alphaMap),
                    void 0 !== i &&
                      (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                      e.uvTransform.value.copy(i.matrix));
                })(e, n, r, i)
              : n.isSpriteMaterial
              ? (function refreshUniformsSprites(e, t) {
                  var n;
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.rotation.value = t.rotation),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                    t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap),
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      e.uvTransform.value.copy(n.matrix));
                })(e, n)
              : n.isShadowMaterial
              ? (e.color.value.copy(n.color), (e.opacity.value = n.opacity))
              : n.isShaderMaterial && (n.uniformsNeedUpdate = !1);
          },
        };
      }
      function WebGLUniformsGroups(e, t, n, r) {
        var i = {},
          a = {},
          o = [],
          s = n.isWebGL2 ? e.getParameter(35375) : 0;
        function hasUniformChanged(e, t, n) {
          var r = e.value;
          if (void 0 === n[t])
            return (n[t] = "number" === typeof r ? r : r.clone()), !0;
          if ("number" === typeof r) {
            if (n[t] !== r) return (n[t] = r), !0;
          } else {
            var i = n[t];
            if (!1 === i.equals(r)) return i.copy(r), !0;
          }
          return !1;
        }
        function getUniformSize(e) {
          var t = e.value,
            n = { boundary: 0, storage: 0 };
          return (
            "number" === typeof t
              ? ((n.boundary = 4), (n.storage = 4))
              : t.isVector2
              ? ((n.boundary = 8), (n.storage = 8))
              : t.isVector3 || t.isColor
              ? ((n.boundary = 16), (n.storage = 12))
              : t.isVector4
              ? ((n.boundary = 16), (n.storage = 16))
              : t.isMatrix3
              ? ((n.boundary = 48), (n.storage = 48))
              : t.isMatrix4
              ? ((n.boundary = 64), (n.storage = 64))
              : t.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  t
                ),
            n
          );
        }
        function onUniformsGroupsDispose(t) {
          var n = t.target;
          n.removeEventListener("dispose", onUniformsGroupsDispose);
          var r = o.indexOf(n.__bindingPointIndex);
          o.splice(r, 1),
            e.deleteBuffer(i[n.id]),
            delete i[n.id],
            delete a[n.id];
        }
        return {
          bind: function bind(e, t) {
            var n = t.program;
            r.uniformBlockBinding(e, n);
          },
          update: function update(n, u) {
            var l = i[n.id];
            void 0 === l &&
              ((function prepareUniformsGroup(e) {
                for (
                  var t = e.uniforms, n = 0, r = 0, i = 0, a = t.length;
                  i < a;
                  i++
                ) {
                  var o = t[i],
                    s = getUniformSize(o);
                  if (
                    ((o.__data = new Float32Array(
                      s.storage / Float32Array.BYTES_PER_ELEMENT
                    )),
                    (o.__offset = n),
                    i > 0)
                  ) {
                    var u = 16 - (r = n % 16);
                    0 !== r &&
                      u - s.boundary < 0 &&
                      ((n += 16 - r), (o.__offset = n));
                  }
                  n += s.storage;
                }
                return (
                  (r = n % 16) > 0 && (n += 16 - r),
                  (e.__size = n),
                  (e.__cache = {}),
                  this
                );
              })(n),
              (l = (function createBuffer(t) {
                var n = (function allocateBindingPointIndex() {
                  for (var e = 0; e < s; e++)
                    if (-1 === o.indexOf(e)) return o.push(e), e;
                  return (
                    console.error(
                      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                    ),
                    0
                  );
                })();
                t.__bindingPointIndex = n;
                var r = e.createBuffer(),
                  i = t.__size,
                  a = t.usage;
                return (
                  e.bindBuffer(35345, r),
                  e.bufferData(35345, i, a),
                  e.bindBuffer(35345, null),
                  e.bindBufferBase(35345, n, r),
                  r
                );
              })(n)),
              (i[n.id] = l),
              n.addEventListener("dispose", onUniformsGroupsDispose));
            var c = u.program;
            r.updateUBOMapping(n, c);
            var h = t.render.frame;
            a[n.id] !== h &&
              ((function updateBufferData(t) {
                var n = i[t.id],
                  r = t.uniforms,
                  a = t.__cache;
                e.bindBuffer(35345, n);
                for (var o = 0, s = r.length; o < s; o++) {
                  var u = r[o];
                  if (!0 === hasUniformChanged(u, o, a)) {
                    var l = u.value,
                      c = u.__offset;
                    "number" === typeof l
                      ? ((u.__data[0] = l), e.bufferSubData(35345, c, u.__data))
                      : (u.value.isMatrix3
                          ? ((u.__data[0] = u.value.elements[0]),
                            (u.__data[1] = u.value.elements[1]),
                            (u.__data[2] = u.value.elements[2]),
                            (u.__data[3] = u.value.elements[0]),
                            (u.__data[4] = u.value.elements[3]),
                            (u.__data[5] = u.value.elements[4]),
                            (u.__data[6] = u.value.elements[5]),
                            (u.__data[7] = u.value.elements[0]),
                            (u.__data[8] = u.value.elements[6]),
                            (u.__data[9] = u.value.elements[7]),
                            (u.__data[10] = u.value.elements[8]),
                            (u.__data[11] = u.value.elements[0]))
                          : l.toArray(u.__data),
                        e.bufferSubData(35345, c, u.__data));
                  }
                }
                e.bindBuffer(35345, null);
              })(n),
              (a[n.id] = h));
          },
          dispose: function dispose() {
            for (var t in i) e.deleteBuffer(i[t]);
            (o = []), (i = {}), (a = {});
          },
        };
      }
      function WebGLRenderer() {
        var e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this.isWebGLRenderer = !0;
        var t,
          n =
            void 0 !== e.canvas
              ? e.canvas
              : (function createCanvasElement() {
                  var e = createElementNS("canvas");
                  return (e.style.display = "block"), e;
                })(),
          r = void 0 !== e.context ? e.context : null,
          i = void 0 === e.depth || e.depth,
          a = void 0 === e.stencil || e.stencil,
          o = void 0 !== e.antialias && e.antialias,
          s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
          u = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
          l = void 0 !== e.powerPreference ? e.powerPreference : "default",
          c =
            void 0 !== e.failIfMajorPerformanceCaveat &&
            e.failIfMajorPerformanceCaveat;
        t =
          null !== r
            ? r.getContextAttributes().alpha
            : void 0 !== e.alpha && e.alpha;
        var h = null,
          d = null,
          f = [],
          p = [];
        (this.domElement = n),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = Ht),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = he),
          (this.toneMappingExposure = 1),
          Object.defineProperties(this, {
            gammaFactor: {
              get: function get() {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaFactor has been removed."
                  ),
                  2
                );
              },
              set: function set() {
                console.warn(
                  "THREE.WebGLRenderer: .gammaFactor has been removed."
                );
              },
            },
          });
        var v = this,
          g = !1,
          y = 0,
          b = 0,
          x = null,
          _ = -1,
          M = null,
          S = new Zn(),
          w = new Zn(),
          T = null,
          A = n.width,
          k = n.height,
          E = 1,
          P = null,
          R = null,
          I = new Zn(0, 0, A, k),
          D = new Zn(0, 0, A, k),
          j = !1,
          B = new Sa(),
          N = !1,
          z = !1,
          F = null,
          G = new Ir(),
          U = new Dn(),
          V = new ir(),
          W = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function getTargetPixelRatio() {
          return null === x ? E : 1;
        }
        var H,
          q,
          X,
          J,
          Y,
          Z,
          K,
          Q,
          $,
          ee,
          te,
          ne,
          re,
          ie,
          ae,
          oe,
          se,
          ue,
          le,
          ce,
          de,
          fe,
          pe,
          me,
          ve = r;
        function getContext(e, t) {
          for (var r = 0; r < e.length; r++) {
            var i = e[r],
              a = n.getContext(i, t);
            if (null !== a) return a;
          }
          return null;
        }
        try {
          var ge = {
            alpha: !0,
            depth: i,
            stencil: a,
            antialias: o,
            premultipliedAlpha: s,
            preserveDrawingBuffer: u,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c,
          };
          if (
            ("setAttribute" in n &&
              n.setAttribute("data-engine", "three.js r".concat(m)),
            n.addEventListener("webglcontextlost", onContextLost, !1),
            n.addEventListener("webglcontextrestored", onContextRestore, !1),
            n.addEventListener(
              "webglcontextcreationerror",
              onContextCreationError,
              !1
            ),
            null === ve)
          ) {
            var ye = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === v.isWebGL1Renderer && ye.shift(),
              null === (ve = getContext(ye, ge)))
            )
              throw getContext(ye)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          void 0 === ve.getShaderPrecisionFormat &&
            (ve.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (Me) {
          throw (console.error("THREE.WebGLRenderer: " + Me.message), Me);
        }
        function initGLContext() {
          (H = new WebGLExtensions(ve)),
            (q = new WebGLCapabilities(ve, H, e)),
            H.init(q),
            (fe = new WebGLUtils(ve, H, q)),
            (X = new WebGLState(ve, H, q)),
            (J = new WebGLInfo()),
            (Y = new WebGLProperties()),
            (Z = new WebGLTextures(ve, H, X, Y, q, fe, J)),
            (K = new WebGLCubeMaps(v)),
            (Q = new WebGLCubeUVMaps(v)),
            ($ = new WebGLAttributes(ve, q)),
            (pe = new WebGLBindingStates(ve, H, $, q)),
            (ee = new WebGLGeometries(ve, $, J, pe)),
            (te = new WebGLObjects(ve, ee, $, J)),
            (le = new WebGLMorphtargets(ve, q, Z)),
            (oe = new WebGLClipping(Y)),
            (ne = new WebGLPrograms(v, K, Q, H, q, pe, oe)),
            (re = new WebGLMaterials(v, Y)),
            (ie = new WebGLRenderLists()),
            (ae = new WebGLRenderStates(H, q)),
            (ue = new WebGLBackground(v, K, X, te, t, s)),
            (se = new WebGLShadowMap(v, te, q)),
            (me = new WebGLUniformsGroups(ve, J, q, X)),
            (ce = new WebGLBufferRenderer(ve, H, J, q)),
            (de = new WebGLIndexedBufferRenderer(ve, H, J, q)),
            (J.programs = ne.programs),
            (v.capabilities = q),
            (v.extensions = H),
            (v.properties = Y),
            (v.renderLists = ie),
            (v.shadowMap = se),
            (v.state = X),
            (v.info = J);
        }
        initGLContext();
        var be = new go(v, ve);
        function onContextLost(e) {
          e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (g = !0);
        }
        function onContextRestore() {
          console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
          var e = J.autoReset,
            t = se.enabled,
            n = se.autoUpdate,
            r = se.needsUpdate,
            i = se.type;
          initGLContext(),
            (J.autoReset = e),
            (se.enabled = t),
            (se.autoUpdate = n),
            (se.needsUpdate = r),
            (se.type = i);
        }
        function onContextCreationError(e) {
          console.error(
            "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
            e.statusMessage
          );
        }
        function onMaterialDispose(e) {
          var t = e.target;
          t.removeEventListener("dispose", onMaterialDispose),
            (function deallocateMaterial(e) {
              (function releaseMaterialProgramReferences(e) {
                var t = Y.get(e).programs;
                void 0 !== t &&
                  (t.forEach(function (e) {
                    ne.releaseProgram(e);
                  }),
                  e.isShaderMaterial && ne.releaseShaderCache(e));
              })(e),
                Y.remove(e);
            })(t);
        }
        (this.xr = be),
          (this.getContext = function () {
            return ve;
          }),
          (this.getContextAttributes = function () {
            return ve.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            var e = H.get("WEBGL_lose_context");
            e && e.loseContext();
          }),
          (this.forceContextRestore = function () {
            var e = H.get("WEBGL_lose_context");
            e && e.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return E;
          }),
          (this.setPixelRatio = function (e) {
            void 0 !== e && ((E = e), this.setSize(A, k, !1));
          }),
          (this.getSize = function (e) {
            return e.set(A, k);
          }),
          (this.setSize = function (e, t, r) {
            be.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((A = e),
                (k = t),
                (n.width = Math.floor(e * E)),
                (n.height = Math.floor(t * E)),
                !1 !== r &&
                  ((n.style.width = e + "px"), (n.style.height = t + "px")),
                this.setViewport(0, 0, e, t));
          }),
          (this.getDrawingBufferSize = function (e) {
            return e.set(A * E, k * E).floor();
          }),
          (this.setDrawingBufferSize = function (e, t, r) {
            (A = e),
              (k = t),
              (E = r),
              (n.width = Math.floor(e * r)),
              (n.height = Math.floor(t * r)),
              this.setViewport(0, 0, e, t);
          }),
          (this.getCurrentViewport = function (e) {
            return e.copy(S);
          }),
          (this.getViewport = function (e) {
            return e.copy(I);
          }),
          (this.setViewport = function (e, t, n, r) {
            e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, n, r),
              X.viewport(S.copy(I).multiplyScalar(E).floor());
          }),
          (this.getScissor = function (e) {
            return e.copy(D);
          }),
          (this.setScissor = function (e, t, n, r) {
            e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r),
              X.scissor(w.copy(D).multiplyScalar(E).floor());
          }),
          (this.getScissorTest = function () {
            return j;
          }),
          (this.setScissorTest = function (e) {
            X.setScissorTest((j = e));
          }),
          (this.setOpaqueSort = function (e) {
            P = e;
          }),
          (this.setTransparentSort = function (e) {
            R = e;
          }),
          (this.getClearColor = function (e) {
            return e.copy(ue.getClearColor());
          }),
          (this.setClearColor = function () {
            ue.setClearColor.apply(ue, arguments);
          }),
          (this.getClearAlpha = function () {
            return ue.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            ue.setClearAlpha.apply(ue, arguments);
          }),
          (this.clear = function () {
            var e = 0;
            (!(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0]) &&
              (e |= 16384),
              (!(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1]) &&
                (e |= 256),
              (!(arguments.length > 2 && void 0 !== arguments[2]) ||
                arguments[2]) &&
                (e |= 1024),
              ve.clear(e);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            n.removeEventListener("webglcontextlost", onContextLost, !1),
              n.removeEventListener(
                "webglcontextrestored",
                onContextRestore,
                !1
              ),
              n.removeEventListener(
                "webglcontextcreationerror",
                onContextCreationError,
                !1
              ),
              ie.dispose(),
              ae.dispose(),
              Y.dispose(),
              K.dispose(),
              Q.dispose(),
              te.dispose(),
              pe.dispose(),
              me.dispose(),
              ne.dispose(),
              be.dispose(),
              be.removeEventListener("sessionstart", onXRSessionStart),
              be.removeEventListener("sessionend", onXRSessionEnd),
              F && (F.dispose(), (F = null)),
              _e.stop();
          }),
          (this.renderBufferDirect = function (e, t, n, r, i, a) {
            null === t && (t = W);
            var o = i.isMesh && i.matrixWorld.determinant() < 0,
              s = (function setProgram(e, t, n, r, i) {
                !0 !== t.isScene && (t = W);
                Z.resetTextureUnits();
                var a = t.fog,
                  o = r.isMeshStandardMaterial ? t.environment : null,
                  s =
                    null === x
                      ? v.outputEncoding
                      : !0 === x.isXRRenderTarget
                      ? x.texture.encoding
                      : Ht,
                  u = (r.isMeshStandardMaterial ? Q : K).get(r.envMap || o),
                  l =
                    !0 === r.vertexColors &&
                    !!n.attributes.color &&
                    4 === n.attributes.color.itemSize,
                  c = !!r.normalMap && !!n.attributes.tangent,
                  h = !!n.morphAttributes.position,
                  f = !!n.morphAttributes.normal,
                  p = !!n.morphAttributes.color,
                  m = r.toneMapped ? v.toneMapping : he,
                  g =
                    n.morphAttributes.position ||
                    n.morphAttributes.normal ||
                    n.morphAttributes.color,
                  y = void 0 !== g ? g.length : 0,
                  b = Y.get(r),
                  S = d.state.lights;
                if (!0 === N && (!0 === z || e !== M)) {
                  var w = e === M && r.id === _;
                  oe.setState(r, e, w);
                }
                var T = !1;
                r.version === b.__version
                  ? b.needsLights && b.lightsStateVersion !== S.state.version
                    ? (T = !0)
                    : b.outputEncoding !== s
                    ? (T = !0)
                    : i.isInstancedMesh && !1 === b.instancing
                    ? (T = !0)
                    : i.isInstancedMesh || !0 !== b.instancing
                    ? i.isSkinnedMesh && !1 === b.skinning
                      ? (T = !0)
                      : i.isSkinnedMesh || !0 !== b.skinning
                      ? b.envMap !== u
                        ? (T = !0)
                        : !0 === r.fog && b.fog !== a
                        ? (T = !0)
                        : void 0 === b.numClippingPlanes ||
                          (b.numClippingPlanes === oe.numPlanes &&
                            b.numIntersection === oe.numIntersection)
                        ? b.vertexAlphas !== l
                          ? (T = !0)
                          : b.vertexTangents !== c
                          ? (T = !0)
                          : b.morphTargets !== h
                          ? (T = !0)
                          : b.morphNormals !== f
                          ? (T = !0)
                          : b.morphColors !== p
                          ? (T = !0)
                          : b.toneMapping !== m
                          ? (T = !0)
                          : !0 === q.isWebGL2 &&
                            b.morphTargetsCount !== y &&
                            (T = !0)
                        : (T = !0)
                      : (T = !0)
                    : (T = !0)
                  : ((T = !0), (b.__version = r.version));
                var A = b.currentProgram;
                !0 === T && (A = getProgram(r, t, i));
                var O = !1,
                  C = !1,
                  L = !1,
                  P = A.getUniforms(),
                  R = b.uniforms;
                X.useProgram(A.program) && ((O = !0), (C = !0), (L = !0));
                r.id !== _ && ((_ = r.id), (C = !0));
                if (O || M !== e) {
                  if (
                    (P.setValue(ve, "projectionMatrix", e.projectionMatrix),
                    q.logarithmicDepthBuffer &&
                      P.setValue(
                        ve,
                        "logDepthBufFC",
                        2 / (Math.log(e.far + 1) / Math.LN2)
                      ),
                    M !== e && ((M = e), (C = !0), (L = !0)),
                    r.isShaderMaterial ||
                      r.isMeshPhongMaterial ||
                      r.isMeshToonMaterial ||
                      r.isMeshStandardMaterial ||
                      r.envMap)
                  ) {
                    var I = P.map.cameraPosition;
                    void 0 !== I &&
                      I.setValue(ve, V.setFromMatrixPosition(e.matrixWorld));
                  }
                  (r.isMeshPhongMaterial ||
                    r.isMeshToonMaterial ||
                    r.isMeshLambertMaterial ||
                    r.isMeshBasicMaterial ||
                    r.isMeshStandardMaterial ||
                    r.isShaderMaterial) &&
                    P.setValue(
                      ve,
                      "isOrthographic",
                      !0 === e.isOrthographicCamera
                    ),
                    (r.isMeshPhongMaterial ||
                      r.isMeshToonMaterial ||
                      r.isMeshLambertMaterial ||
                      r.isMeshBasicMaterial ||
                      r.isMeshStandardMaterial ||
                      r.isShaderMaterial ||
                      r.isShadowMaterial ||
                      i.isSkinnedMesh) &&
                      P.setValue(ve, "viewMatrix", e.matrixWorldInverse);
                }
                if (i.isSkinnedMesh) {
                  P.setOptional(ve, i, "bindMatrix"),
                    P.setOptional(ve, i, "bindMatrixInverse");
                  var D = i.skeleton;
                  D &&
                    (q.floatVertexTextures
                      ? (null === D.boneTexture && D.computeBoneTexture(),
                        P.setValue(ve, "boneTexture", D.boneTexture, Z),
                        P.setValue(ve, "boneTextureSize", D.boneTextureSize))
                      : console.warn(
                          "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                        ));
                }
                var j = n.morphAttributes;
                (void 0 !== j.position ||
                  void 0 !== j.normal ||
                  (void 0 !== j.color && !0 === q.isWebGL2)) &&
                  le.update(i, n, r, A);
                (C || b.receiveShadow !== i.receiveShadow) &&
                  ((b.receiveShadow = i.receiveShadow),
                  P.setValue(ve, "receiveShadow", i.receiveShadow));
                C &&
                  (P.setValue(ve, "toneMappingExposure", v.toneMappingExposure),
                  b.needsLights &&
                    (function markUniformsLightsNeedsUpdate(e, t) {
                      (e.ambientLightColor.needsUpdate = t),
                        (e.lightProbe.needsUpdate = t),
                        (e.directionalLights.needsUpdate = t),
                        (e.directionalLightShadows.needsUpdate = t),
                        (e.pointLights.needsUpdate = t),
                        (e.pointLightShadows.needsUpdate = t),
                        (e.spotLights.needsUpdate = t),
                        (e.spotLightShadows.needsUpdate = t),
                        (e.rectAreaLights.needsUpdate = t),
                        (e.hemisphereLights.needsUpdate = t);
                    })(R, L),
                  a && !0 === r.fog && re.refreshFogUniforms(R, a),
                  re.refreshMaterialUniforms(R, r, E, k, F),
                  Qa.upload(ve, b.uniformsList, R, Z));
                r.isShaderMaterial &&
                  !0 === r.uniformsNeedUpdate &&
                  (Qa.upload(ve, b.uniformsList, R, Z),
                  (r.uniformsNeedUpdate = !1));
                r.isSpriteMaterial && P.setValue(ve, "center", i.center);
                if (
                  (P.setValue(ve, "modelViewMatrix", i.modelViewMatrix),
                  P.setValue(ve, "normalMatrix", i.normalMatrix),
                  P.setValue(ve, "modelMatrix", i.matrixWorld),
                  r.isShaderMaterial || r.isRawShaderMaterial)
                )
                  for (
                    var B = r.uniformsGroups, G = 0, U = B.length;
                    G < U;
                    G++
                  )
                    if (q.isWebGL2) {
                      var H = B[G];
                      me.update(H, A), me.bind(H, A);
                    } else
                      console.warn(
                        "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                      );
                return A;
              })(e, t, n, r, i);
            X.setMaterial(r, o);
            var u = n.index,
              l = n.attributes.position;
            if (null === u) {
              if (void 0 === l || 0 === l.count) return;
            } else if (0 === u.count) return;
            var c,
              h = 1;
            !0 === r.wireframe && ((u = ee.getWireframeAttribute(n)), (h = 2)),
              pe.setup(i, r, s, n, u);
            var f = ce;
            null !== u && ((c = $.get(u)), (f = de).setIndex(c));
            var p = null !== u ? u.count : l.count,
              m = n.drawRange.start * h,
              g = n.drawRange.count * h,
              y = null !== a ? a.start * h : 0,
              b = null !== a ? a.count * h : 1 / 0,
              S = Math.max(m, y),
              w = Math.min(p, m + g, y + b) - 1,
              T = Math.max(0, w - S + 1);
            if (0 !== T) {
              if (i.isMesh)
                !0 === r.wireframe
                  ? (X.setLineWidth(
                      r.wireframeLinewidth * getTargetPixelRatio()
                    ),
                    f.setMode(1))
                  : f.setMode(4);
              else if (i.isLine) {
                var A = r.linewidth;
                void 0 === A && (A = 1),
                  X.setLineWidth(A * getTargetPixelRatio()),
                  i.isLineSegments
                    ? f.setMode(1)
                    : i.isLineLoop
                    ? f.setMode(2)
                    : f.setMode(3);
              } else i.isPoints ? f.setMode(0) : i.isSprite && f.setMode(4);
              if (i.isInstancedMesh) f.renderInstances(S, T, i.count);
              else if (n.isInstancedBufferGeometry) {
                var O = Math.min(n.instanceCount, n._maxInstanceCount);
                f.renderInstances(S, T, O);
              } else f.render(S, T);
            }
          }),
          (this.compile = function (e, t) {
            (d = ae.get(e)).init(),
              p.push(d),
              e.traverseVisible(function (e) {
                e.isLight &&
                  e.layers.test(t.layers) &&
                  (d.pushLight(e), e.castShadow && d.pushShadow(e));
              }),
              d.setupLights(v.physicallyCorrectLights),
              e.traverse(function (t) {
                var n = t.material;
                if (n)
                  if (Array.isArray(n))
                    for (var r = 0; r < n.length; r++) {
                      getProgram(n[r], e, t);
                    }
                  else getProgram(n, e, t);
              }),
              p.pop(),
              (d = null);
          });
        var xe = null;
        function onXRSessionStart() {
          _e.stop();
        }
        function onXRSessionEnd() {
          _e.start();
        }
        var _e = new WebGLAnimation();
        function renderScene(e, t, n, r) {
          var i = e.opaque,
            a = e.transmissive,
            s = e.transparent;
          d.setupLightsView(n),
            a.length > 0 &&
              (function renderTransmissionPass(e, t, n) {
                var r = q.isWebGL2;
                null === F &&
                  (F = new Kn(1, 1, {
                    generateMipmaps: !0,
                    type: H.has("EXT_color_buffer_half_float") ? Ve : je,
                    minFilter: Ie,
                    samples: r && !0 === o ? 4 : 0,
                  }));
                v.getDrawingBufferSize(U),
                  r
                    ? F.setSize(U.x, U.y)
                    : F.setSize(floorPowerOfTwo(U.x), floorPowerOfTwo(U.y));
                var i = v.getRenderTarget();
                v.setRenderTarget(F), v.clear();
                var a = v.toneMapping;
                (v.toneMapping = he),
                  renderObjects(e, t, n),
                  (v.toneMapping = a),
                  Z.updateMultisampleRenderTarget(F),
                  Z.updateRenderTargetMipmap(F),
                  v.setRenderTarget(i);
              })(i, t, n),
            r && X.viewport(S.copy(r)),
            i.length > 0 && renderObjects(i, t, n),
            a.length > 0 && renderObjects(a, t, n),
            s.length > 0 && renderObjects(s, t, n),
            X.buffers.depth.setTest(!0),
            X.buffers.depth.setMask(!0),
            X.buffers.color.setMask(!0),
            X.setPolygonOffset(!1);
        }
        function renderObjects(e, t, n) {
          for (
            var r = !0 === t.isScene ? t.overrideMaterial : null,
              i = 0,
              a = e.length;
            i < a;
            i++
          ) {
            var o = e[i],
              s = o.object,
              u = o.geometry,
              l = null === r ? o.material : r,
              c = o.group;
            s.layers.test(n.layers) && renderObject(s, t, n, u, l, c);
          }
        }
        function renderObject(e, t, n, r, i, a) {
          e.onBeforeRender(v, t, n, r, i, a),
            e.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              e.matrixWorld
            ),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            i.onBeforeRender(v, t, n, r, e, a),
            !0 === i.transparent && i.side === L
              ? ((i.side = C),
                (i.needsUpdate = !0),
                v.renderBufferDirect(n, t, r, i, e, a),
                (i.side = O),
                (i.needsUpdate = !0),
                v.renderBufferDirect(n, t, r, i, e, a),
                (i.side = L))
              : v.renderBufferDirect(n, t, r, i, e, a),
            e.onAfterRender(v, t, n, r, i, a);
        }
        function getProgram(e, t, n) {
          !0 !== t.isScene && (t = W);
          var r = Y.get(e),
            i = d.state.lights,
            a = d.state.shadowsArray,
            o = i.state.version,
            s = ne.getParameters(e, i.state, a, t, n),
            u = ne.getProgramCacheKey(s),
            l = r.programs;
          (r.environment = e.isMeshStandardMaterial ? t.environment : null),
            (r.fog = t.fog),
            (r.envMap = (e.isMeshStandardMaterial ? Q : K).get(
              e.envMap || r.environment
            )),
            void 0 === l &&
              (e.addEventListener("dispose", onMaterialDispose),
              (l = new Map()),
              (r.programs = l));
          var c = l.get(u);
          if (void 0 !== c) {
            if (r.currentProgram === c && r.lightsStateVersion === o)
              return updateCommonMaterialProperties(e, s), c;
          } else
            (s.uniforms = ne.getUniforms(e)),
              e.onBuild(n, s, v),
              e.onBeforeCompile(s, v),
              (c = ne.acquireProgram(s, u)),
              l.set(u, c),
              (r.uniforms = s.uniforms);
          var h = r.uniforms;
          ((e.isShaderMaterial || e.isRawShaderMaterial) &&
            !0 !== e.clipping) ||
            (h.clippingPlanes = oe.uniform),
            updateCommonMaterialProperties(e, s),
            (r.needsLights = (function materialNeedsLights(e) {
              return (
                e.isMeshLambertMaterial ||
                e.isMeshToonMaterial ||
                e.isMeshPhongMaterial ||
                e.isMeshStandardMaterial ||
                e.isShadowMaterial ||
                (e.isShaderMaterial && !0 === e.lights)
              );
            })(e)),
            (r.lightsStateVersion = o),
            r.needsLights &&
              ((h.ambientLightColor.value = i.state.ambient),
              (h.lightProbe.value = i.state.probe),
              (h.directionalLights.value = i.state.directional),
              (h.directionalLightShadows.value = i.state.directionalShadow),
              (h.spotLights.value = i.state.spot),
              (h.spotLightShadows.value = i.state.spotShadow),
              (h.rectAreaLights.value = i.state.rectArea),
              (h.ltc_1.value = i.state.rectAreaLTC1),
              (h.ltc_2.value = i.state.rectAreaLTC2),
              (h.pointLights.value = i.state.point),
              (h.pointLightShadows.value = i.state.pointShadow),
              (h.hemisphereLights.value = i.state.hemi),
              (h.directionalShadowMap.value = i.state.directionalShadowMap),
              (h.directionalShadowMatrix.value =
                i.state.directionalShadowMatrix),
              (h.spotShadowMap.value = i.state.spotShadowMap),
              (h.spotShadowMatrix.value = i.state.spotShadowMatrix),
              (h.pointShadowMap.value = i.state.pointShadowMap),
              (h.pointShadowMatrix.value = i.state.pointShadowMatrix));
          var f = c.getUniforms(),
            p = Qa.seqWithValue(f.seq, h);
          return (r.currentProgram = c), (r.uniformsList = p), c;
        }
        function updateCommonMaterialProperties(e, t) {
          var n = Y.get(e);
          (n.outputEncoding = t.outputEncoding),
            (n.instancing = t.instancing),
            (n.skinning = t.skinning),
            (n.morphTargets = t.morphTargets),
            (n.morphNormals = t.morphNormals),
            (n.morphColors = t.morphColors),
            (n.morphTargetsCount = t.morphTargetsCount),
            (n.numClippingPlanes = t.numClippingPlanes),
            (n.numIntersection = t.numClipIntersection),
            (n.vertexAlphas = t.vertexAlphas),
            (n.vertexTangents = t.vertexTangents),
            (n.toneMapping = t.toneMapping);
        }
        _e.setAnimationLoop(function onAnimationFrame(e) {
          xe && xe(e);
        }),
          "undefined" !== typeof self && _e.setContext(self),
          (this.setAnimationLoop = function (e) {
            (xe = e),
              be.setAnimationLoop(e),
              null === e ? _e.stop() : _e.start();
          }),
          be.addEventListener("sessionstart", onXRSessionStart),
          be.addEventListener("sessionend", onXRSessionEnd),
          (this.render = function (e, t) {
            if (void 0 === t || !0 === t.isCamera) {
              if (!0 !== g) {
                !0 === e.autoUpdate && e.updateMatrixWorld(),
                  null === t.parent && t.updateMatrixWorld(),
                  !0 === be.enabled &&
                    !0 === be.isPresenting &&
                    (!0 === be.cameraAutoUpdate && be.updateCamera(t),
                    (t = be.getCamera())),
                  !0 === e.isScene && e.onBeforeRender(v, e, t, x),
                  (d = ae.get(e, p.length)).init(),
                  p.push(d),
                  G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                  B.setFromProjectionMatrix(G),
                  (z = this.localClippingEnabled),
                  (N = oe.init(this.clippingPlanes, z, t)),
                  (h = ie.get(e, f.length)).init(),
                  f.push(h),
                  (function projectObject(e, t, n, r) {
                    if (!1 === e.visible) return;
                    var i = e.layers.test(t.layers);
                    if (i)
                      if (e.isGroup) n = e.renderOrder;
                      else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                      else if (e.isLight)
                        d.pushLight(e), e.castShadow && d.pushShadow(e);
                      else if (e.isSprite) {
                        if (!e.frustumCulled || B.intersectsSprite(e)) {
                          r &&
                            V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(
                              G
                            );
                          var a = te.update(e),
                            o = e.material;
                          o.visible && h.push(e, a, o, n, V.z, null);
                        }
                      } else if (
                        (e.isMesh || e.isLine || e.isPoints) &&
                        (e.isSkinnedMesh &&
                          e.skeleton.frame !== J.render.frame &&
                          (e.skeleton.update(),
                          (e.skeleton.frame = J.render.frame)),
                        !e.frustumCulled || B.intersectsObject(e))
                      ) {
                        r &&
                          V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(
                            G
                          );
                        var s = te.update(e),
                          u = e.material;
                        if (Array.isArray(u))
                          for (
                            var l = s.groups, c = 0, f = l.length;
                            c < f;
                            c++
                          ) {
                            var p = l[c],
                              m = u[p.materialIndex];
                            m && m.visible && h.push(e, s, m, n, V.z, p);
                          }
                        else u.visible && h.push(e, s, u, n, V.z, null);
                      }
                    var v = e.children;
                    for (var g = 0, y = v.length; g < y; g++)
                      projectObject(v[g], t, n, r);
                  })(e, t, 0, v.sortObjects),
                  h.finish(),
                  !0 === v.sortObjects && h.sort(P, R),
                  !0 === N && oe.beginShadows();
                var n = d.state.shadowsArray;
                if (
                  (se.render(n, e, t),
                  !0 === N && oe.endShadows(),
                  !0 === this.info.autoReset && this.info.reset(),
                  ue.render(h, e),
                  d.setupLights(v.physicallyCorrectLights),
                  t.isArrayCamera)
                )
                  for (var r = t.cameras, i = 0, a = r.length; i < a; i++) {
                    var o = r[i];
                    renderScene(h, e, o, o.viewport);
                  }
                else renderScene(h, e, t);
                null !== x &&
                  (Z.updateMultisampleRenderTarget(x),
                  Z.updateRenderTargetMipmap(x)),
                  !0 === e.isScene && e.onAfterRender(v, e, t),
                  pe.resetDefaultState(),
                  (_ = -1),
                  (M = null),
                  p.pop(),
                  (d = p.length > 0 ? p[p.length - 1] : null),
                  f.pop(),
                  (h = f.length > 0 ? f[f.length - 1] : null);
              }
            } else
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
          }),
          (this.getActiveCubeFace = function () {
            return y;
          }),
          (this.getActiveMipmapLevel = function () {
            return b;
          }),
          (this.getRenderTarget = function () {
            return x;
          }),
          (this.setRenderTargetTextures = function (e, t, n) {
            (Y.get(e.texture).__webglTexture = t),
              (Y.get(e.depthTexture).__webglTexture = n);
            var r = Y.get(e);
            (r.__hasExternalTextures = !0),
              r.__hasExternalTextures &&
                ((r.__autoAllocateDepthBuffer = void 0 === n),
                r.__autoAllocateDepthBuffer ||
                  (!0 === H.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (r.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (e, t) {
            var n = Y.get(e);
            (n.__webglFramebuffer = t),
              (n.__useDefaultFramebuffer = void 0 === t);
          }),
          (this.setRenderTarget = function (e) {
            var t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0;
            (x = e), (y = t), (b = n);
            var r = !0;
            if (e) {
              var i = Y.get(e);
              void 0 !== i.__useDefaultFramebuffer
                ? (X.bindFramebuffer(36160, null), (r = !1))
                : void 0 === i.__webglFramebuffer
                ? Z.setupRenderTarget(e)
                : i.__hasExternalTextures &&
                  Z.rebindTextures(
                    e,
                    Y.get(e.texture).__webglTexture,
                    Y.get(e.depthTexture).__webglTexture
                  );
            }
            var a = null,
              o = !1,
              s = !1;
            if (e) {
              var u = e.texture;
              (u.isData3DTexture || u.isDataArrayTexture) && (s = !0);
              var l = Y.get(e).__webglFramebuffer;
              e.isWebGLCubeRenderTarget
                ? ((a = l[t]), (o = !0))
                : (a =
                    q.isWebGL2 &&
                    e.samples > 0 &&
                    !1 === Z.useMultisampledRTT(e)
                      ? Y.get(e).__webglMultisampledFramebuffer
                      : l),
                S.copy(e.viewport),
                w.copy(e.scissor),
                (T = e.scissorTest);
            } else
              S.copy(I).multiplyScalar(E).floor(),
                w.copy(D).multiplyScalar(E).floor(),
                (T = j);
            if (
              (X.bindFramebuffer(36160, a) &&
                q.drawBuffers &&
                r &&
                X.drawBuffers(e, a),
              X.viewport(S),
              X.scissor(w),
              X.setScissorTest(T),
              o)
            ) {
              var c = Y.get(e.texture);
              ve.framebufferTexture2D(
                36160,
                36064,
                34069 + t,
                c.__webglTexture,
                n
              );
            } else if (s) {
              var h = Y.get(e.texture),
                d = t || 0;
              ve.framebufferTextureLayer(
                36160,
                36064,
                h.__webglTexture,
                n || 0,
                d
              );
            }
            _ = -1;
          }),
          (this.readRenderTargetPixels = function (e, t, n, r, i, a, o) {
            if (e && e.isWebGLRenderTarget) {
              var s = Y.get(e).__webglFramebuffer;
              if (
                (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s)
              ) {
                X.bindFramebuffer(36160, s);
                try {
                  var u = e.texture,
                    l = u.format,
                    c = u.type;
                  if (l !== Ye && fe.convert(l) !== ve.getParameter(35739))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  var h =
                    c === Ve &&
                    (H.has("EXT_color_buffer_half_float") ||
                      (q.isWebGL2 && H.has("EXT_color_buffer_float")));
                  if (
                    c !== je &&
                    fe.convert(c) !== ve.getParameter(35738) &&
                    (c !== Ue ||
                      !(
                        q.isWebGL2 ||
                        H.has("OES_texture_float") ||
                        H.has("WEBGL_color_buffer_float")
                      )) &&
                    !h
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  t >= 0 &&
                    t <= e.width - r &&
                    n >= 0 &&
                    n <= e.height - i &&
                    ve.readPixels(t, n, r, i, fe.convert(l), fe.convert(c), a);
                } finally {
                  var d = null !== x ? Y.get(x).__webglFramebuffer : null;
                  X.bindFramebuffer(36160, d);
                }
              }
            } else
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
          }),
          (this.copyFramebufferToTexture = function (e, t) {
            var n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              r = Math.pow(2, -n),
              i = Math.floor(t.image.width * r),
              a = Math.floor(t.image.height * r);
            Z.setTexture2D(t, 0),
              ve.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, i, a),
              X.unbindTexture();
          }),
          (this.copyTextureToTexture = function (e, t, n) {
            var r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0,
              i = t.image.width,
              a = t.image.height,
              o = fe.convert(n.format),
              s = fe.convert(n.type);
            Z.setTexture2D(n, 0),
              ve.pixelStorei(37440, n.flipY),
              ve.pixelStorei(37441, n.premultiplyAlpha),
              ve.pixelStorei(3317, n.unpackAlignment),
              t.isDataTexture
                ? ve.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data)
                : t.isCompressedTexture
                ? ve.compressedTexSubImage2D(
                    3553,
                    r,
                    e.x,
                    e.y,
                    t.mipmaps[0].width,
                    t.mipmaps[0].height,
                    o,
                    t.mipmaps[0].data
                  )
                : ve.texSubImage2D(3553, r, e.x, e.y, o, s, t.image),
              0 === r && n.generateMipmaps && ve.generateMipmap(3553),
              X.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (e, t, n, r) {
            var i =
              arguments.length > 4 && void 0 !== arguments[4]
                ? arguments[4]
                : 0;
            if (v.isWebGL1Renderer)
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
            else {
              var a,
                o = e.max.x - e.min.x + 1,
                s = e.max.y - e.min.y + 1,
                u = e.max.z - e.min.z + 1,
                l = fe.convert(r.format),
                c = fe.convert(r.type);
              if (r.isData3DTexture) Z.setTexture3D(r, 0), (a = 32879);
              else {
                if (!r.isDataArrayTexture)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                  );
                Z.setTexture2DArray(r, 0), (a = 35866);
              }
              ve.pixelStorei(37440, r.flipY),
                ve.pixelStorei(37441, r.premultiplyAlpha),
                ve.pixelStorei(3317, r.unpackAlignment);
              var h = ve.getParameter(3314),
                d = ve.getParameter(32878),
                f = ve.getParameter(3316),
                p = ve.getParameter(3315),
                m = ve.getParameter(32877),
                g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
              ve.pixelStorei(3314, g.width),
                ve.pixelStorei(32878, g.height),
                ve.pixelStorei(3316, e.min.x),
                ve.pixelStorei(3315, e.min.y),
                ve.pixelStorei(32877, e.min.z),
                n.isDataTexture || n.isData3DTexture
                  ? ve.texSubImage3D(a, i, t.x, t.y, t.z, o, s, u, l, c, g.data)
                  : n.isCompressedTexture
                  ? (console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                    ),
                    ve.compressedTexSubImage3D(
                      a,
                      i,
                      t.x,
                      t.y,
                      t.z,
                      o,
                      s,
                      u,
                      l,
                      g.data
                    ))
                  : ve.texSubImage3D(a, i, t.x, t.y, t.z, o, s, u, l, c, g),
                ve.pixelStorei(3314, h),
                ve.pixelStorei(32878, d),
                ve.pixelStorei(3316, f),
                ve.pixelStorei(3315, p),
                ve.pixelStorei(32877, m),
                0 === i && r.generateMipmaps && ve.generateMipmap(a),
                X.unbindTexture();
            }
          }),
          (this.initTexture = function (e) {
            e.isCubeTexture
              ? Z.setTextureCube(e, 0)
              : e.isData3DTexture
              ? Z.setTexture3D(e, 0)
              : e.isDataArrayTexture
              ? Z.setTexture2DArray(e, 0)
              : Z.setTexture2D(e, 0),
              X.unbindTexture();
          }),
          (this.resetState = function () {
            (y = 0), (b = 0), (x = null), X.reset(), pe.reset();
          }),
          "undefined" !== typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      var yo = (function (e) {
        function WebGL1Renderer() {
          return (
            Object(f.a)(this, WebGL1Renderer),
            Object(s.a)(
              this,
              Object(r.a)(WebGL1Renderer).apply(this, arguments)
            )
          );
        }
        return Object(u.a)(WebGL1Renderer, e), WebGL1Renderer;
      })(WebGLRenderer);
      yo.prototype.isWebGL1Renderer = !0;
      var bo,
        xo = (function () {
          function FogExp2(e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 25e-5;
            Object(f.a)(this, FogExp2),
              (this.isFogExp2 = !0),
              (this.name = ""),
              (this.color = new Hn(e)),
              (this.density = t);
          }
          return (
            Object(p.a)(FogExp2, [
              {
                key: "clone",
                value: function clone() {
                  return new FogExp2(this.color, this.density);
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density,
                  };
                },
              },
            ]),
            FogExp2
          );
        })(),
        _o = (function () {
          function Fog(e) {
            var t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1e3;
            Object(f.a)(this, Fog),
              (this.isFog = !0),
              (this.name = ""),
              (this.color = new Hn(e)),
              (this.near = t),
              (this.far = n);
          }
          return (
            Object(p.a)(Fog, [
              {
                key: "clone",
                value: function clone() {
                  return new Fog(this.color, this.near, this.far);
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far,
                  };
                },
              },
            ]),
            Fog
          );
        })(),
        Mo = (function (e) {
          function Scene() {
            var e;
            return (
              Object(f.a)(this, Scene),
              ((e = Object(s.a)(this, Object(r.a)(Scene).call(this))).isScene =
                !0),
              (e.type = "Scene"),
              (e.background = null),
              (e.environment = null),
              (e.fog = null),
              (e.overrideMaterial = null),
              (e.autoUpdate = !0),
              "undefined" !== typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", {
                    detail: Object(l.a)(Object(l.a)(e)),
                  })
                ),
              e
            );
          }
          return (
            Object(u.a)(Scene, e),
            Object(p.a)(Scene, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(Scene.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    null !== e.background &&
                      (this.background = e.background.clone()),
                    null !== e.environment &&
                      (this.environment = e.environment.clone()),
                    null !== e.fog && (this.fog = e.fog.clone()),
                    null !== e.overrideMaterial &&
                      (this.overrideMaterial = e.overrideMaterial.clone()),
                    (this.autoUpdate = e.autoUpdate),
                    (this.matrixAutoUpdate = e.matrixAutoUpdate),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(Scene.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (
                    null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                  );
                },
              },
            ]),
            Scene
          );
        })(ai),
        So = (function () {
          function InterleavedBuffer(e, t) {
            Object(f.a)(this, InterleavedBuffer),
              (this.isInterleavedBuffer = !0),
              (this.array = e),
              (this.stride = t),
              (this.count = void 0 !== e ? e.length / t : 0),
              (this.usage = gn),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.uuid = generateUUID());
          }
          return (
            Object(p.a)(InterleavedBuffer, [
              {
                key: "onUploadCallback",
                value: function onUploadCallback() {},
              },
              {
                key: "setUsage",
                value: function setUsage(e) {
                  return (this.usage = e), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.array = new e.array.constructor(e.array)),
                    (this.count = e.count),
                    (this.stride = e.stride),
                    (this.usage = e.usage),
                    this
                  );
                },
              },
              {
                key: "copyAt",
                value: function copyAt(e, t, n) {
                  (e *= this.stride), (n *= t.stride);
                  for (var r = 0, i = this.stride; r < i; r++)
                    this.array[e + r] = t.array[n + r];
                  return this;
                },
              },
              {
                key: "set",
                value: function set(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return this.array.set(e, t), this;
                },
              },
              {
                key: "clone",
                value: function clone(e) {
                  void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                    void 0 === this.array.buffer._uuid &&
                      (this.array.buffer._uuid = generateUUID()),
                    void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
                      (e.arrayBuffers[this.array.buffer._uuid] =
                        this.array.slice(0).buffer);
                  var t = new this.array.constructor(
                      e.arrayBuffers[this.array.buffer._uuid]
                    ),
                    n = new this.constructor(t, this.stride);
                  return n.setUsage(this.usage), n;
                },
              },
              {
                key: "onUpload",
                value: function onUpload(e) {
                  return (this.onUploadCallback = e), this;
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  return (
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                    void 0 === this.array.buffer._uuid &&
                      (this.array.buffer._uuid = generateUUID()),
                    void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
                      (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
                        new Uint32Array(this.array.buffer)
                      )),
                    {
                      uuid: this.uuid,
                      buffer: this.array.buffer._uuid,
                      type: this.array.constructor.name,
                      stride: this.stride,
                    }
                  );
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  !0 === e && this.version++;
                },
              },
            ]),
            InterleavedBuffer
          );
        })(),
        wo = new ir(),
        To = (function () {
          function InterleavedBufferAttribute(e, t, n) {
            var r =
              arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            Object(f.a)(this, InterleavedBufferAttribute),
              (this.isInterleavedBufferAttribute = !0),
              (this.name = ""),
              (this.data = e),
              (this.itemSize = t),
              (this.offset = n),
              (this.normalized = !0 === r);
          }
          return (
            Object(p.a)(InterleavedBufferAttribute, [
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  for (var t = 0, n = this.data.count; t < n; t++)
                    wo.fromBufferAttribute(this, t),
                      wo.applyMatrix4(e),
                      this.setXYZ(t, wo.x, wo.y, wo.z);
                  return this;
                },
              },
              {
                key: "applyNormalMatrix",
                value: function applyNormalMatrix(e) {
                  for (var t = 0, n = this.count; t < n; t++)
                    wo.fromBufferAttribute(this, t),
                      wo.applyNormalMatrix(e),
                      this.setXYZ(t, wo.x, wo.y, wo.z);
                  return this;
                },
              },
              {
                key: "transformDirection",
                value: function transformDirection(e) {
                  for (var t = 0, n = this.count; t < n; t++)
                    wo.fromBufferAttribute(this, t),
                      wo.transformDirection(e),
                      this.setXYZ(t, wo.x, wo.y, wo.z);
                  return this;
                },
              },
              {
                key: "setX",
                value: function setX(e, t) {
                  return (
                    (this.data.array[e * this.data.stride + this.offset] = t),
                    this
                  );
                },
              },
              {
                key: "setY",
                value: function setY(e, t) {
                  return (
                    (this.data.array[e * this.data.stride + this.offset + 1] =
                      t),
                    this
                  );
                },
              },
              {
                key: "setZ",
                value: function setZ(e, t) {
                  return (
                    (this.data.array[e * this.data.stride + this.offset + 2] =
                      t),
                    this
                  );
                },
              },
              {
                key: "setW",
                value: function setW(e, t) {
                  return (
                    (this.data.array[e * this.data.stride + this.offset + 3] =
                      t),
                    this
                  );
                },
              },
              {
                key: "getX",
                value: function getX(e) {
                  return this.data.array[e * this.data.stride + this.offset];
                },
              },
              {
                key: "getY",
                value: function getY(e) {
                  return this.data.array[
                    e * this.data.stride + this.offset + 1
                  ];
                },
              },
              {
                key: "getZ",
                value: function getZ(e) {
                  return this.data.array[
                    e * this.data.stride + this.offset + 2
                  ];
                },
              },
              {
                key: "getW",
                value: function getW(e) {
                  return this.data.array[
                    e * this.data.stride + this.offset + 3
                  ];
                },
              },
              {
                key: "setXY",
                value: function setXY(e, t, n) {
                  return (
                    (e = e * this.data.stride + this.offset),
                    (this.data.array[e + 0] = t),
                    (this.data.array[e + 1] = n),
                    this
                  );
                },
              },
              {
                key: "setXYZ",
                value: function setXYZ(e, t, n, r) {
                  return (
                    (e = e * this.data.stride + this.offset),
                    (this.data.array[e + 0] = t),
                    (this.data.array[e + 1] = n),
                    (this.data.array[e + 2] = r),
                    this
                  );
                },
              },
              {
                key: "setXYZW",
                value: function setXYZW(e, t, n, r, i) {
                  return (
                    (e = e * this.data.stride + this.offset),
                    (this.data.array[e + 0] = t),
                    (this.data.array[e + 1] = n),
                    (this.data.array[e + 2] = r),
                    (this.data.array[e + 3] = i),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone(e) {
                  if (void 0 === e) {
                    console.log(
                      "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data."
                    );
                    for (var t = [], n = 0; n < this.count; n++)
                      for (
                        var r = n * this.data.stride + this.offset, i = 0;
                        i < this.itemSize;
                        i++
                      )
                        t.push(this.data.array[r + i]);
                    return new Mi(
                      new this.array.constructor(t),
                      this.itemSize,
                      this.normalized
                    );
                  }
                  return (
                    void 0 === e.interleavedBuffers &&
                      (e.interleavedBuffers = {}),
                    void 0 === e.interleavedBuffers[this.data.uuid] &&
                      (e.interleavedBuffers[this.data.uuid] =
                        this.data.clone(e)),
                    new InterleavedBufferAttribute(
                      e.interleavedBuffers[this.data.uuid],
                      this.itemSize,
                      this.offset,
                      this.normalized
                    )
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  if (void 0 === e) {
                    console.log(
                      "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data."
                    );
                    for (var t = [], n = 0; n < this.count; n++)
                      for (
                        var r = n * this.data.stride + this.offset, i = 0;
                        i < this.itemSize;
                        i++
                      )
                        t.push(this.data.array[r + i]);
                    return {
                      itemSize: this.itemSize,
                      type: this.array.constructor.name,
                      array: t,
                      normalized: this.normalized,
                    };
                  }
                  return (
                    void 0 === e.interleavedBuffers &&
                      (e.interleavedBuffers = {}),
                    void 0 === e.interleavedBuffers[this.data.uuid] &&
                      (e.interleavedBuffers[this.data.uuid] =
                        this.data.toJSON(e)),
                    {
                      isInterleavedBufferAttribute: !0,
                      itemSize: this.itemSize,
                      data: this.data.uuid,
                      offset: this.offset,
                      normalized: this.normalized,
                    }
                  );
                },
              },
              {
                key: "count",
                get: function get() {
                  return this.data.count;
                },
              },
              {
                key: "array",
                get: function get() {
                  return this.data.array;
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  this.data.needsUpdate = e;
                },
              },
            ]),
            InterleavedBufferAttribute
          );
        })(),
        Ao = (function (e) {
          function SpriteMaterial(e) {
            var t;
            return (
              Object(f.a)(this, SpriteMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(SpriteMaterial).call(this)
              )).isSpriteMaterial = !0),
              (t.type = "SpriteMaterial"),
              (t.color = new Hn(16777215)),
              (t.map = null),
              (t.alphaMap = null),
              (t.rotation = 0),
              (t.sizeAttenuation = !0),
              (t.transparent = !0),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(SpriteMaterial, e),
            Object(p.a)(SpriteMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(SpriteMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.alphaMap = e.alphaMap),
                    (this.rotation = e.rotation),
                    (this.sizeAttenuation = e.sizeAttenuation),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            SpriteMaterial
          );
        })(yi),
        Oo = new ir(),
        Co = new ir(),
        Lo = new ir(),
        ko = new Dn(),
        Eo = new Dn(),
        Po = new Ir(),
        Ro = new ir(),
        Io = new ir(),
        Do = new ir(),
        jo = new Dn(),
        Bo = new Dn(),
        No = new Dn(),
        zo = (function (e) {
          function Sprite(e) {
            var t;
            if (
              (Object(f.a)(this, Sprite),
              ((t = Object(s.a)(
                this,
                Object(r.a)(Sprite).call(this)
              )).isSprite = !0),
              (t.type = "Sprite"),
              void 0 === bo)
            ) {
              bo = new Fi();
              var n = new Float32Array([
                  -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                  -0.5, 0.5, 0, 0, 1,
                ]),
                i = new So(n, 5);
              bo.setIndex([0, 1, 2, 0, 2, 3]),
                bo.setAttribute("position", new To(i, 3, 0, !1)),
                bo.setAttribute("uv", new To(i, 2, 3, !1));
            }
            return (
              (t.geometry = bo),
              (t.material = void 0 !== e ? e : new Ao()),
              (t.center = new Dn(0.5, 0.5)),
              t
            );
          }
          return (
            Object(u.a)(Sprite, e),
            Object(p.a)(Sprite, [
              {
                key: "raycast",
                value: function raycast(e, t) {
                  null === e.camera &&
                    console.error(
                      'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
                    ),
                    Co.setFromMatrixScale(this.matrixWorld),
                    Po.copy(e.camera.matrixWorld),
                    this.modelViewMatrix.multiplyMatrices(
                      e.camera.matrixWorldInverse,
                      this.matrixWorld
                    ),
                    Lo.setFromMatrixPosition(this.modelViewMatrix),
                    e.camera.isPerspectiveCamera &&
                      !1 === this.material.sizeAttenuation &&
                      Co.multiplyScalar(-Lo.z);
                  var n,
                    r,
                    i = this.material.rotation;
                  0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)));
                  var a = this.center;
                  transformVertex(Ro.set(-0.5, -0.5, 0), Lo, a, Co, n, r),
                    transformVertex(Io.set(0.5, -0.5, 0), Lo, a, Co, n, r),
                    transformVertex(Do.set(0.5, 0.5, 0), Lo, a, Co, n, r),
                    jo.set(0, 0),
                    Bo.set(1, 0),
                    No.set(1, 1);
                  var o = e.ray.intersectTriangle(Ro, Io, Do, !1, Oo);
                  if (
                    null !== o ||
                    (transformVertex(Io.set(-0.5, 0.5, 0), Lo, a, Co, n, r),
                    Bo.set(0, 1),
                    null !== (o = e.ray.intersectTriangle(Ro, Do, Io, !1, Oo)))
                  ) {
                    var s = e.ray.origin.distanceTo(Oo);
                    s < e.near ||
                      s > e.far ||
                      t.push({
                        distance: s,
                        point: Oo.clone(),
                        uv: vi.getUV(Oo, Ro, Io, Do, jo, Bo, No, new Dn()),
                        face: null,
                        object: this,
                      });
                  }
                },
              },
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(Sprite.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    void 0 !== e.center && this.center.copy(e.center),
                    (this.material = e.material),
                    this
                  );
                },
              },
            ]),
            Sprite
          );
        })(ai);
      function transformVertex(e, t, n, r, i, a) {
        ko.subVectors(e, n).addScalar(0.5).multiply(r),
          void 0 !== i
            ? ((Eo.x = a * ko.x - i * ko.y), (Eo.y = i * ko.x + a * ko.y))
            : Eo.copy(ko),
          e.copy(t),
          (e.x += Eo.x),
          (e.y += Eo.y),
          e.applyMatrix4(Po);
      }
      var Fo = new ir(),
        Go = new ir(),
        Uo = (function (e) {
          function LOD() {
            var e;
            return (
              Object(f.a)(this, LOD),
              ((e = Object(s.a)(
                this,
                Object(r.a)(LOD).call(this)
              ))._currentLevel = 0),
              (e.type = "LOD"),
              Object.defineProperties(Object(l.a)(Object(l.a)(e)), {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
              }),
              (e.autoUpdate = !0),
              e
            );
          }
          return (
            Object(u.a)(LOD, e),
            Object(p.a)(LOD, [
              {
                key: "copy",
                value: function copy(e) {
                  Object(o.a)(Object(r.a)(LOD.prototype), "copy", this).call(
                    this,
                    e,
                    !1
                  );
                  for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
                    var a = t[n];
                    this.addLevel(a.object.clone(), a.distance);
                  }
                  return (this.autoUpdate = e.autoUpdate), this;
                },
              },
              {
                key: "addLevel",
                value: function addLevel(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  t = Math.abs(t);
                  var n,
                    r = this.levels;
                  for (n = 0; n < r.length && !(t < r[n].distance); n++);
                  return (
                    r.splice(n, 0, { distance: t, object: e }),
                    this.add(e),
                    this
                  );
                },
              },
              {
                key: "getCurrentLevel",
                value: function getCurrentLevel() {
                  return this._currentLevel;
                },
              },
              {
                key: "getObjectForDistance",
                value: function getObjectForDistance(e) {
                  var t = this.levels;
                  if (t.length > 0) {
                    var n, r;
                    for (
                      n = 1, r = t.length;
                      n < r && !(e < t[n].distance);
                      n++
                    );
                    return t[n - 1].object;
                  }
                  return null;
                },
              },
              {
                key: "raycast",
                value: function raycast(e, t) {
                  if (this.levels.length > 0) {
                    Fo.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(Fo);
                    this.getObjectForDistance(n).raycast(e, t);
                  }
                },
              },
              {
                key: "update",
                value: function update(e) {
                  var t = this.levels;
                  if (t.length > 1) {
                    Fo.setFromMatrixPosition(e.matrixWorld),
                      Go.setFromMatrixPosition(this.matrixWorld);
                    var n,
                      r,
                      i = Fo.distanceTo(Go) / e.zoom;
                    for (
                      t[0].object.visible = !0, n = 1, r = t.length;
                      n < r && i >= t[n].distance;
                      n++
                    )
                      (t[n - 1].object.visible = !1),
                        (t[n].object.visible = !0);
                    for (this._currentLevel = n - 1; n < r; n++)
                      t[n].object.visible = !1;
                  }
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(LOD.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  !1 === this.autoUpdate && (t.object.autoUpdate = !1),
                    (t.object.levels = []);
                  for (var n = this.levels, i = 0, a = n.length; i < a; i++) {
                    var s = n[i];
                    t.object.levels.push({
                      object: s.object.uuid,
                      distance: s.distance,
                    });
                  }
                  return t;
                },
              },
            ]),
            LOD
          );
        })(ai),
        Vo = new ir(),
        Wo = new Zn(),
        Ho = new Zn(),
        qo = new ir(),
        Xo = new Ir(),
        Jo = (function (e) {
          function SkinnedMesh(e, t) {
            var n;
            return (
              Object(f.a)(this, SkinnedMesh),
              ((n = Object(s.a)(
                this,
                Object(r.a)(SkinnedMesh).call(this, e, t)
              )).isSkinnedMesh = !0),
              (n.type = "SkinnedMesh"),
              (n.bindMode = "attached"),
              (n.bindMatrix = new Ir()),
              (n.bindMatrixInverse = new Ir()),
              n
            );
          }
          return (
            Object(u.a)(SkinnedMesh, e),
            Object(p.a)(SkinnedMesh, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(SkinnedMesh.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.bindMode = e.bindMode),
                    this.bindMatrix.copy(e.bindMatrix),
                    this.bindMatrixInverse.copy(e.bindMatrixInverse),
                    (this.skeleton = e.skeleton),
                    this
                  );
                },
              },
              {
                key: "bind",
                value: function bind(e, t) {
                  (this.skeleton = e),
                    void 0 === t &&
                      (this.updateMatrixWorld(!0),
                      this.skeleton.calculateInverses(),
                      (t = this.matrixWorld)),
                    this.bindMatrix.copy(t),
                    this.bindMatrixInverse.copy(t).invert();
                },
              },
              {
                key: "pose",
                value: function pose() {
                  this.skeleton.pose();
                },
              },
              {
                key: "normalizeSkinWeights",
                value: function normalizeSkinWeights() {
                  for (
                    var e = new Zn(),
                      t = this.geometry.attributes.skinWeight,
                      n = 0,
                      r = t.count;
                    n < r;
                    n++
                  ) {
                    e.fromBufferAttribute(t, n);
                    var i = 1 / e.manhattanLength();
                    i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                      t.setXYZW(n, e.x, e.y, e.z, e.w);
                  }
                },
              },
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  Object(o.a)(
                    Object(r.a)(SkinnedMesh.prototype),
                    "updateMatrixWorld",
                    this
                  ).call(this, e),
                    "attached" === this.bindMode
                      ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                      : "detached" === this.bindMode
                      ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                      : console.warn(
                          "THREE.SkinnedMesh: Unrecognized bindMode: " +
                            this.bindMode
                        );
                },
              },
              {
                key: "boneTransform",
                value: function boneTransform(e, t) {
                  var n = this.skeleton,
                    r = this.geometry;
                  Wo.fromBufferAttribute(r.attributes.skinIndex, e),
                    Ho.fromBufferAttribute(r.attributes.skinWeight, e),
                    Vo.copy(t).applyMatrix4(this.bindMatrix),
                    t.set(0, 0, 0);
                  for (var i = 0; i < 4; i++) {
                    var a = Ho.getComponent(i);
                    if (0 !== a) {
                      var o = Wo.getComponent(i);
                      Xo.multiplyMatrices(
                        n.bones[o].matrixWorld,
                        n.boneInverses[o]
                      ),
                        t.addScaledVector(qo.copy(Vo).applyMatrix4(Xo), a);
                    }
                  }
                  return t.applyMatrix4(this.bindMatrixInverse);
                },
              },
            ]),
            SkinnedMesh
          );
        })(ia),
        Yo = (function (e) {
          function Bone() {
            var e;
            return (
              Object(f.a)(this, Bone),
              ((e = Object(s.a)(this, Object(r.a)(Bone).call(this))).isBone =
                !0),
              (e.type = "Bone"),
              e
            );
          }
          return Object(u.a)(Bone, e), Bone;
        })(ai),
        Zo = (function (e) {
          function DataTexture() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : null,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a = arguments.length > 3 ? arguments[3] : void 0,
              o = arguments.length > 4 ? arguments[4] : void 0,
              u = arguments.length > 5 ? arguments[5] : void 0,
              l = arguments.length > 6 ? arguments[6] : void 0,
              c = arguments.length > 7 ? arguments[7] : void 0,
              h =
                arguments.length > 8 && void 0 !== arguments[8]
                  ? arguments[8]
                  : Ae,
              d =
                arguments.length > 9 && void 0 !== arguments[9]
                  ? arguments[9]
                  : Ae,
              p = arguments.length > 10 ? arguments[10] : void 0,
              m = arguments.length > 11 ? arguments[11] : void 0;
            return (
              Object(f.a)(this, DataTexture),
              ((e = Object(s.a)(
                this,
                Object(r.a)(DataTexture).call(
                  this,
                  null,
                  u,
                  l,
                  c,
                  h,
                  d,
                  a,
                  o,
                  p,
                  m
                )
              )).isDataTexture = !0),
              (e.image = { data: t, width: n, height: i }),
              (e.generateMipmaps = !1),
              (e.flipY = !1),
              (e.unpackAlignment = 1),
              e
            );
          }
          return Object(u.a)(DataTexture, e), DataTexture;
        })(Yn),
        Ko = new Ir(),
        Qo = new Ir(),
        $o = (function () {
          function Skeleton() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [],
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : [];
            Object(f.a)(this, Skeleton),
              (this.uuid = generateUUID()),
              (this.bones = e.slice(0)),
              (this.boneInverses = t),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init();
          }
          return (
            Object(p.a)(Skeleton, [
              {
                key: "init",
                value: function init() {
                  var e = this.bones,
                    t = this.boneInverses;
                  if (
                    ((this.boneMatrices = new Float32Array(16 * e.length)),
                    0 === t.length)
                  )
                    this.calculateInverses();
                  else if (e.length !== t.length) {
                    console.warn(
                      "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
                    ),
                      (this.boneInverses = []);
                    for (var n = 0, r = this.bones.length; n < r; n++)
                      this.boneInverses.push(new Ir());
                  }
                },
              },
              {
                key: "calculateInverses",
                value: function calculateInverses() {
                  this.boneInverses.length = 0;
                  for (var e = 0, t = this.bones.length; e < t; e++) {
                    var n = new Ir();
                    this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
                      this.boneInverses.push(n);
                  }
                },
              },
              {
                key: "pose",
                value: function pose() {
                  for (var e = 0, t = this.bones.length; e < t; e++) {
                    var n = this.bones[e];
                    n && n.matrixWorld.copy(this.boneInverses[e]).invert();
                  }
                  for (var r = 0, i = this.bones.length; r < i; r++) {
                    var a = this.bones[r];
                    a &&
                      (a.parent && a.parent.isBone
                        ? (a.matrix.copy(a.parent.matrixWorld).invert(),
                          a.matrix.multiply(a.matrixWorld))
                        : a.matrix.copy(a.matrixWorld),
                      a.matrix.decompose(a.position, a.quaternion, a.scale));
                  }
                },
              },
              {
                key: "update",
                value: function update() {
                  for (
                    var e = this.bones,
                      t = this.boneInverses,
                      n = this.boneMatrices,
                      r = this.boneTexture,
                      i = 0,
                      a = e.length;
                    i < a;
                    i++
                  ) {
                    var o = e[i] ? e[i].matrixWorld : Qo;
                    Ko.multiplyMatrices(o, t[i]), Ko.toArray(n, 16 * i);
                  }
                  null !== r && (r.needsUpdate = !0);
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new Skeleton(this.bones, this.boneInverses);
                },
              },
              {
                key: "computeBoneTexture",
                value: function computeBoneTexture() {
                  var e = Math.sqrt(4 * this.bones.length);
                  (e = ceilPowerOfTwo(e)), (e = Math.max(e, 4));
                  var t = new Float32Array(e * e * 4);
                  t.set(this.boneMatrices);
                  var n = new Zo(t, e, e, Ye, Ue);
                  return (
                    (n.needsUpdate = !0),
                    (this.boneMatrices = t),
                    (this.boneTexture = n),
                    (this.boneTextureSize = e),
                    this
                  );
                },
              },
              {
                key: "getBoneByName",
                value: function getBoneByName(e) {
                  for (var t = 0, n = this.bones.length; t < n; t++) {
                    var r = this.bones[t];
                    if (r.name === e) return r;
                  }
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  null !== this.boneTexture &&
                    (this.boneTexture.dispose(), (this.boneTexture = null));
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e, t) {
                  this.uuid = e.uuid;
                  for (var n = 0, r = e.bones.length; n < r; n++) {
                    var i = e.bones[n],
                      a = t[i];
                    void 0 === a &&
                      (console.warn(
                        "THREE.Skeleton: No bone found with UUID:",
                        i
                      ),
                      (a = new Yo())),
                      this.bones.push(a),
                      this.boneInverses.push(
                        new Ir().fromArray(e.boneInverses[n])
                      );
                  }
                  return this.init(), this;
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = {
                    metadata: {
                      version: 4.5,
                      type: "Skeleton",
                      generator: "Skeleton.toJSON",
                    },
                    bones: [],
                    boneInverses: [],
                  };
                  e.uuid = this.uuid;
                  for (
                    var t = this.bones,
                      n = this.boneInverses,
                      r = 0,
                      i = t.length;
                    r < i;
                    r++
                  ) {
                    var a = t[r];
                    e.bones.push(a.uuid);
                    var o = n[r];
                    e.boneInverses.push(o.toArray());
                  }
                  return e;
                },
              },
            ]),
            Skeleton
          );
        })(),
        es = (function (e) {
          function InstancedBufferAttribute(e, t, n) {
            var i,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            return (
              Object(f.a)(this, InstancedBufferAttribute),
              "number" === typeof n &&
                ((a = n),
                (n = !1),
                console.error(
                  "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
                )),
              ((i = Object(s.a)(
                this,
                Object(r.a)(InstancedBufferAttribute).call(this, e, t, n)
              )).isInstancedBufferAttribute = !0),
              (i.meshPerAttribute = a),
              i
            );
          }
          return (
            Object(u.a)(InstancedBufferAttribute, e),
            Object(p.a)(InstancedBufferAttribute, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(InstancedBufferAttribute.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.meshPerAttribute = e.meshPerAttribute),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(InstancedBufferAttribute.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.meshPerAttribute = this.meshPerAttribute),
                    (e.isInstancedBufferAttribute = !0),
                    e
                  );
                },
              },
            ]),
            InstancedBufferAttribute
          );
        })(Mi),
        ts = new Ir(),
        ns = new Ir(),
        rs = [],
        is = new ia(),
        as = (function (e) {
          function InstancedMesh(e, t, n) {
            var i;
            return (
              Object(f.a)(this, InstancedMesh),
              ((i = Object(s.a)(
                this,
                Object(r.a)(InstancedMesh).call(this, e, t)
              )).isInstancedMesh = !0),
              (i.instanceMatrix = new es(new Float32Array(16 * n), 16)),
              (i.instanceColor = null),
              (i.count = n),
              (i.frustumCulled = !1),
              i
            );
          }
          return (
            Object(u.a)(InstancedMesh, e),
            Object(p.a)(InstancedMesh, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(InstancedMesh.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    this.instanceMatrix.copy(e.instanceMatrix),
                    null !== e.instanceColor &&
                      (this.instanceColor = e.instanceColor.clone()),
                    (this.count = e.count),
                    this
                  );
                },
              },
              {
                key: "getColorAt",
                value: function getColorAt(e, t) {
                  t.fromArray(this.instanceColor.array, 3 * e);
                },
              },
              {
                key: "getMatrixAt",
                value: function getMatrixAt(e, t) {
                  t.fromArray(this.instanceMatrix.array, 16 * e);
                },
              },
              {
                key: "raycast",
                value: function raycast(e, t) {
                  var n = this.matrixWorld,
                    r = this.count;
                  if (
                    ((is.geometry = this.geometry),
                    (is.material = this.material),
                    void 0 !== is.material)
                  )
                    for (var i = 0; i < r; i++) {
                      this.getMatrixAt(i, ts),
                        ns.multiplyMatrices(n, ts),
                        (is.matrixWorld = ns),
                        is.raycast(e, rs);
                      for (var a = 0, o = rs.length; a < o; a++) {
                        var s = rs[a];
                        (s.instanceId = i), (s.object = this), t.push(s);
                      }
                      rs.length = 0;
                    }
                },
              },
              {
                key: "setColorAt",
                value: function setColorAt(e, t) {
                  null === this.instanceColor &&
                    (this.instanceColor = new es(
                      new Float32Array(3 * this.instanceMatrix.count),
                      3
                    )),
                    t.toArray(this.instanceColor.array, 3 * e);
                },
              },
              {
                key: "setMatrixAt",
                value: function setMatrixAt(e, t) {
                  t.toArray(this.instanceMatrix.array, 16 * e);
                },
              },
              {
                key: "updateMorphTargets",
                value: function updateMorphTargets() {},
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.dispatchEvent({ type: "dispose" });
                },
              },
            ]),
            InstancedMesh
          );
        })(ia),
        os = (function (e) {
          function LineBasicMaterial(e) {
            var t;
            return (
              Object(f.a)(this, LineBasicMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(LineBasicMaterial).call(this)
              )).isLineBasicMaterial = !0),
              (t.type = "LineBasicMaterial"),
              (t.color = new Hn(16777215)),
              (t.linewidth = 1),
              (t.linecap = "round"),
              (t.linejoin = "round"),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(LineBasicMaterial, e),
            Object(p.a)(LineBasicMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LineBasicMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.linewidth = e.linewidth),
                    (this.linecap = e.linecap),
                    (this.linejoin = e.linejoin),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            LineBasicMaterial
          );
        })(yi),
        ss = new ir(),
        us = new ir(),
        ls = new Ir(),
        cs = new Rr(),
        hs = new Tr(),
        ds = (function (e) {
          function Line() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Fi(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new os();
            return (
              Object(f.a)(this, Line),
              ((e = Object(s.a)(this, Object(r.a)(Line).call(this))).isLine =
                !0),
              (e.type = "Line"),
              (e.geometry = t),
              (e.material = n),
              e.updateMorphTargets(),
              e
            );
          }
          return (
            Object(u.a)(Line, e),
            Object(p.a)(Line, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(Object(r.a)(Line.prototype), "copy", this).call(
                      this,
                      e,
                      t
                    ),
                    (this.material = e.material),
                    (this.geometry = e.geometry),
                    this
                  );
                },
              },
              {
                key: "computeLineDistances",
                value: function computeLineDistances() {
                  var e = this.geometry;
                  if (null === e.index) {
                    for (
                      var t = e.attributes.position,
                        n = [0],
                        r = 1,
                        i = t.count;
                      r < i;
                      r++
                    )
                      ss.fromBufferAttribute(t, r - 1),
                        us.fromBufferAttribute(t, r),
                        (n[r] = n[r - 1]),
                        (n[r] += ss.distanceTo(us));
                    e.setAttribute("lineDistance", new Ei(n, 1));
                  } else
                    console.warn(
                      "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                    );
                  return this;
                },
              },
              {
                key: "raycast",
                value: function raycast(e, t) {
                  var n = this.geometry,
                    r = this.matrixWorld,
                    i = e.params.Line.threshold,
                    a = n.drawRange;
                  if (
                    (null === n.boundingSphere && n.computeBoundingSphere(),
                    hs.copy(n.boundingSphere),
                    hs.applyMatrix4(r),
                    (hs.radius += i),
                    !1 !== e.ray.intersectsSphere(hs))
                  ) {
                    ls.copy(r).invert(), cs.copy(e.ray).applyMatrix4(ls);
                    var o =
                        i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                      s = o * o,
                      u = new ir(),
                      l = new ir(),
                      c = new ir(),
                      h = new ir(),
                      d = this.isLineSegments ? 2 : 1,
                      f = n.index,
                      p = n.attributes.position;
                    if (null !== f)
                      for (
                        var m = Math.max(0, a.start),
                          v = Math.min(f.count, a.start + a.count) - 1;
                        m < v;
                        m += d
                      ) {
                        var g = f.getX(m),
                          y = f.getX(m + 1);
                        if (
                          (u.fromBufferAttribute(p, g),
                          l.fromBufferAttribute(p, y),
                          !(cs.distanceSqToSegment(u, l, h, c) > s))
                        ) {
                          h.applyMatrix4(this.matrixWorld);
                          var b = e.ray.origin.distanceTo(h);
                          b < e.near ||
                            b > e.far ||
                            t.push({
                              distance: b,
                              point: c.clone().applyMatrix4(this.matrixWorld),
                              index: m,
                              face: null,
                              faceIndex: null,
                              object: this,
                            });
                        }
                      }
                    else
                      for (
                        var x = Math.max(0, a.start),
                          _ = Math.min(p.count, a.start + a.count) - 1;
                        x < _;
                        x += d
                      ) {
                        if (
                          (u.fromBufferAttribute(p, x),
                          l.fromBufferAttribute(p, x + 1),
                          !(cs.distanceSqToSegment(u, l, h, c) > s))
                        ) {
                          h.applyMatrix4(this.matrixWorld);
                          var M = e.ray.origin.distanceTo(h);
                          M < e.near ||
                            M > e.far ||
                            t.push({
                              distance: M,
                              point: c.clone().applyMatrix4(this.matrixWorld),
                              index: x,
                              face: null,
                              faceIndex: null,
                              object: this,
                            });
                        }
                      }
                  }
                },
              },
              {
                key: "updateMorphTargets",
                value: function updateMorphTargets() {
                  var e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                  if (t.length > 0) {
                    var n = e[t[0]];
                    if (void 0 !== n) {
                      (this.morphTargetInfluences = []),
                        (this.morphTargetDictionary = {});
                      for (var r = 0, i = n.length; r < i; r++) {
                        var a = n[r].name || String(r);
                        this.morphTargetInfluences.push(0),
                          (this.morphTargetDictionary[a] = r);
                      }
                    }
                  }
                },
              },
            ]),
            Line
          );
        })(ai),
        fs = new ir(),
        ps = new ir(),
        ms = (function (e) {
          function LineSegments(e, t) {
            var n;
            return (
              Object(f.a)(this, LineSegments),
              ((n = Object(s.a)(
                this,
                Object(r.a)(LineSegments).call(this, e, t)
              )).isLineSegments = !0),
              (n.type = "LineSegments"),
              n
            );
          }
          return (
            Object(u.a)(LineSegments, e),
            Object(p.a)(LineSegments, [
              {
                key: "computeLineDistances",
                value: function computeLineDistances() {
                  var e = this.geometry;
                  if (null === e.index) {
                    for (
                      var t = e.attributes.position, n = [], r = 0, i = t.count;
                      r < i;
                      r += 2
                    )
                      fs.fromBufferAttribute(t, r),
                        ps.fromBufferAttribute(t, r + 1),
                        (n[r] = 0 === r ? 0 : n[r - 1]),
                        (n[r + 1] = n[r] + fs.distanceTo(ps));
                    e.setAttribute("lineDistance", new Ei(n, 1));
                  } else
                    console.warn(
                      "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                    );
                  return this;
                },
              },
            ]),
            LineSegments
          );
        })(ds),
        vs = (function (e) {
          function LineLoop(e, t) {
            var n;
            return (
              Object(f.a)(this, LineLoop),
              ((n = Object(s.a)(
                this,
                Object(r.a)(LineLoop).call(this, e, t)
              )).isLineLoop = !0),
              (n.type = "LineLoop"),
              n
            );
          }
          return Object(u.a)(LineLoop, e), LineLoop;
        })(ds),
        gs = (function (e) {
          function PointsMaterial(e) {
            var t;
            return (
              Object(f.a)(this, PointsMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(PointsMaterial).call(this)
              )).isPointsMaterial = !0),
              (t.type = "PointsMaterial"),
              (t.color = new Hn(16777215)),
              (t.map = null),
              (t.alphaMap = null),
              (t.size = 1),
              (t.sizeAttenuation = !0),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(PointsMaterial, e),
            Object(p.a)(PointsMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(PointsMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.alphaMap = e.alphaMap),
                    (this.size = e.size),
                    (this.sizeAttenuation = e.sizeAttenuation),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            PointsMaterial
          );
        })(yi),
        ys = new Ir(),
        bs = new Rr(),
        xs = new Tr(),
        _s = new ir(),
        Ms = (function (e) {
          function Points() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Fi(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new gs();
            return (
              Object(f.a)(this, Points),
              ((e = Object(s.a)(
                this,
                Object(r.a)(Points).call(this)
              )).isPoints = !0),
              (e.type = "Points"),
              (e.geometry = t),
              (e.material = n),
              e.updateMorphTargets(),
              e
            );
          }
          return (
            Object(u.a)(Points, e),
            Object(p.a)(Points, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(Points.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.material = e.material),
                    (this.geometry = e.geometry),
                    this
                  );
                },
              },
              {
                key: "raycast",
                value: function raycast(e, t) {
                  var n = this.geometry,
                    r = this.matrixWorld,
                    i = e.params.Points.threshold,
                    a = n.drawRange;
                  if (
                    (null === n.boundingSphere && n.computeBoundingSphere(),
                    xs.copy(n.boundingSphere),
                    xs.applyMatrix4(r),
                    (xs.radius += i),
                    !1 !== e.ray.intersectsSphere(xs))
                  ) {
                    ys.copy(r).invert(), bs.copy(e.ray).applyMatrix4(ys);
                    var o =
                        i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                      s = o * o,
                      u = n.index,
                      l = n.attributes.position;
                    if (null !== u)
                      for (
                        var c = Math.max(0, a.start),
                          h = Math.min(u.count, a.start + a.count);
                        c < h;
                        c++
                      ) {
                        var d = u.getX(c);
                        _s.fromBufferAttribute(l, d),
                          testPoint(_s, d, s, r, e, t, this);
                      }
                    else
                      for (
                        var f = Math.max(0, a.start),
                          p = Math.min(l.count, a.start + a.count);
                        f < p;
                        f++
                      )
                        _s.fromBufferAttribute(l, f),
                          testPoint(_s, f, s, r, e, t, this);
                  }
                },
              },
              {
                key: "updateMorphTargets",
                value: function updateMorphTargets() {
                  var e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                  if (t.length > 0) {
                    var n = e[t[0]];
                    if (void 0 !== n) {
                      (this.morphTargetInfluences = []),
                        (this.morphTargetDictionary = {});
                      for (var r = 0, i = n.length; r < i; r++) {
                        var a = n[r].name || String(r);
                        this.morphTargetInfluences.push(0),
                          (this.morphTargetDictionary[a] = r);
                      }
                    }
                  }
                },
              },
            ]),
            Points
          );
        })(ai);
      function testPoint(e, t, n, r, i, a, o) {
        var s = bs.distanceSqToPoint(e);
        if (s < n) {
          var u = new ir();
          bs.closestPointToPoint(e, u), u.applyMatrix4(r);
          var l = i.ray.origin.distanceTo(u);
          if (l < i.near || l > i.far) return;
          a.push({
            distance: l,
            distanceToRay: Math.sqrt(s),
            point: u,
            index: t,
            face: null,
            object: o,
          });
        }
      }
      var Ss = (function (e) {
          function VideoTexture(e, t, n, i, a, o, u, c, h) {
            var d;
            Object(f.a)(this, VideoTexture),
              ((d = Object(s.a)(
                this,
                Object(r.a)(VideoTexture).call(this, e, t, n, i, a, o, u, c, h)
              )).isVideoTexture = !0),
              (d.minFilter = void 0 !== o ? o : Ee),
              (d.magFilter = void 0 !== a ? a : Ee),
              (d.generateMipmaps = !1);
            var p = Object(l.a)(Object(l.a)(d));
            return (
              "requestVideoFrameCallback" in e &&
                e.requestVideoFrameCallback(function updateVideo() {
                  (p.needsUpdate = !0),
                    e.requestVideoFrameCallback(updateVideo);
                }),
              d
            );
          }
          return (
            Object(u.a)(VideoTexture, e),
            Object(p.a)(VideoTexture, [
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor(this.image).copy(this);
                },
              },
              {
                key: "update",
                value: function update() {
                  var e = this.image;
                  !1 === "requestVideoFrameCallback" in e &&
                    e.readyState >= e.HAVE_CURRENT_DATA &&
                    (this.needsUpdate = !0);
                },
              },
            ]),
            VideoTexture
          );
        })(Yn),
        ws = (function (e) {
          function FramebufferTexture(e, t, n) {
            var i;
            return (
              Object(f.a)(this, FramebufferTexture),
              ((i = Object(s.a)(
                this,
                Object(r.a)(FramebufferTexture).call(this, {
                  width: e,
                  height: t,
                })
              )).isFramebufferTexture = !0),
              (i.format = n),
              (i.magFilter = Ae),
              (i.minFilter = Ae),
              (i.generateMipmaps = !1),
              (i.needsUpdate = !0),
              i
            );
          }
          return Object(u.a)(FramebufferTexture, e), FramebufferTexture;
        })(Yn),
        Ts = (function (e) {
          function CompressedTexture(e, t, n, i, a, o, u, l, c, h, d, p) {
            var m;
            return (
              Object(f.a)(this, CompressedTexture),
              ((m = Object(s.a)(
                this,
                Object(r.a)(CompressedTexture).call(
                  this,
                  null,
                  o,
                  u,
                  l,
                  c,
                  h,
                  i,
                  a,
                  d,
                  p
                )
              )).isCompressedTexture = !0),
              (m.image = { width: t, height: n }),
              (m.mipmaps = e),
              (m.flipY = !1),
              (m.generateMipmaps = !1),
              m
            );
          }
          return Object(u.a)(CompressedTexture, e), CompressedTexture;
        })(Yn),
        As = (function (e) {
          function CanvasTexture(e, t, n, i, a, o, u, l, c) {
            var h;
            return (
              Object(f.a)(this, CanvasTexture),
              ((h = Object(s.a)(
                this,
                Object(r.a)(CanvasTexture).call(this, e, t, n, i, a, o, u, l, c)
              )).isCanvasTexture = !0),
              (h.needsUpdate = !0),
              h
            );
          }
          return Object(u.a)(CanvasTexture, e), CanvasTexture;
        })(Yn),
        Os = (function () {
          function Curve() {
            Object(f.a)(this, Curve),
              (this.type = "Curve"),
              (this.arcLengthDivisions = 200);
          }
          return (
            Object(p.a)(Curve, [
              {
                key: "getPoint",
                value: function getPoint() {
                  return (
                    console.warn("THREE.Curve: .getPoint() not implemented."),
                    null
                  );
                },
              },
              {
                key: "getPointAt",
                value: function getPointAt(e, t) {
                  var n = this.getUtoTmapping(e);
                  return this.getPoint(n, t);
                },
              },
              {
                key: "getPoints",
                value: function getPoints() {
                  for (
                    var e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 5,
                      t = [],
                      n = 0;
                    n <= e;
                    n++
                  )
                    t.push(this.getPoint(n / e));
                  return t;
                },
              },
              {
                key: "getSpacedPoints",
                value: function getSpacedPoints() {
                  for (
                    var e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 5,
                      t = [],
                      n = 0;
                    n <= e;
                    n++
                  )
                    t.push(this.getPointAt(n / e));
                  return t;
                },
              },
              {
                key: "getLength",
                value: function getLength() {
                  var e = this.getLengths();
                  return e[e.length - 1];
                },
              },
              {
                key: "getLengths",
                value: function getLengths() {
                  var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : this.arcLengthDivisions;
                  if (
                    this.cacheArcLengths &&
                    this.cacheArcLengths.length === e + 1 &&
                    !this.needsUpdate
                  )
                    return this.cacheArcLengths;
                  this.needsUpdate = !1;
                  var t,
                    n = [],
                    r = this.getPoint(0),
                    i = 0;
                  n.push(0);
                  for (var a = 1; a <= e; a++)
                    (i += (t = this.getPoint(a / e)).distanceTo(r)),
                      n.push(i),
                      (r = t);
                  return (this.cacheArcLengths = n), n;
                },
              },
              {
                key: "updateArcLengths",
                value: function updateArcLengths() {
                  (this.needsUpdate = !0), this.getLengths();
                },
              },
              {
                key: "getUtoTmapping",
                value: function getUtoTmapping(e, t) {
                  var n,
                    r = this.getLengths(),
                    i = 0,
                    a = r.length;
                  n = t || e * r[a - 1];
                  for (var o, s = 0, u = a - 1; s <= u; )
                    if ((o = r[(i = Math.floor(s + (u - s) / 2))] - n) < 0)
                      s = i + 1;
                    else {
                      if (!(o > 0)) {
                        u = i;
                        break;
                      }
                      u = i - 1;
                    }
                  if (r[(i = u)] === n) return i / (a - 1);
                  var l = r[i];
                  return (i + (n - l) / (r[i + 1] - l)) / (a - 1);
                },
              },
              {
                key: "getTangent",
                value: function getTangent(e, t) {
                  var n = e - 1e-4,
                    r = e + 1e-4;
                  n < 0 && (n = 0), r > 1 && (r = 1);
                  var i = this.getPoint(n),
                    a = this.getPoint(r),
                    o = t || (i.isVector2 ? new Dn() : new ir());
                  return o.copy(a).sub(i).normalize(), o;
                },
              },
              {
                key: "getTangentAt",
                value: function getTangentAt(e, t) {
                  var n = this.getUtoTmapping(e);
                  return this.getTangent(n, t);
                },
              },
              {
                key: "computeFrenetFrames",
                value: function computeFrenetFrames(e, t) {
                  for (
                    var n = new ir(),
                      r = [],
                      i = [],
                      a = [],
                      o = new ir(),
                      s = new Ir(),
                      u = 0;
                    u <= e;
                    u++
                  ) {
                    var l = u / e;
                    r[u] = this.getTangentAt(l, new ir());
                  }
                  (i[0] = new ir()), (a[0] = new ir());
                  var c = Number.MAX_VALUE,
                    h = Math.abs(r[0].x),
                    d = Math.abs(r[0].y),
                    f = Math.abs(r[0].z);
                  h <= c && ((c = h), n.set(1, 0, 0)),
                    d <= c && ((c = d), n.set(0, 1, 0)),
                    f <= c && n.set(0, 0, 1),
                    o.crossVectors(r[0], n).normalize(),
                    i[0].crossVectors(r[0], o),
                    a[0].crossVectors(r[0], i[0]);
                  for (var p = 1; p <= e; p++) {
                    if (
                      ((i[p] = i[p - 1].clone()),
                      (a[p] = a[p - 1].clone()),
                      o.crossVectors(r[p - 1], r[p]),
                      o.length() > Number.EPSILON)
                    ) {
                      o.normalize();
                      var m = Math.acos(clamp(r[p - 1].dot(r[p]), -1, 1));
                      i[p].applyMatrix4(s.makeRotationAxis(o, m));
                    }
                    a[p].crossVectors(r[p], i[p]);
                  }
                  if (!0 === t) {
                    var v = Math.acos(clamp(i[0].dot(i[e]), -1, 1));
                    (v /= e),
                      r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (v = -v);
                    for (var g = 1; g <= e; g++)
                      i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)),
                        a[g].crossVectors(r[g], i[g]);
                  }
                  return { tangents: r, normals: i, binormals: a };
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (this.arcLengthDivisions = e.arcLengthDivisions), this;
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = {
                    metadata: {
                      version: 4.5,
                      type: "Curve",
                      generator: "Curve.toJSON",
                    },
                  };
                  return (
                    (e.arcLengthDivisions = this.arcLengthDivisions),
                    (e.type = this.type),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (this.arcLengthDivisions = e.arcLengthDivisions), this;
                },
              },
            ]),
            Curve
          );
        })(),
        Cs = (function (e) {
          function EllipseCurve() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 0,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 2 * Math.PI,
              l =
                arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
              c =
                arguments.length > 7 && void 0 !== arguments[7]
                  ? arguments[7]
                  : 0;
            return (
              Object(f.a)(this, EllipseCurve),
              ((e = Object(s.a)(
                this,
                Object(r.a)(EllipseCurve).call(this)
              )).isEllipseCurve = !0),
              (e.type = "EllipseCurve"),
              (e.aX = t),
              (e.aY = n),
              (e.xRadius = i),
              (e.yRadius = a),
              (e.aStartAngle = o),
              (e.aEndAngle = u),
              (e.aClockwise = l),
              (e.aRotation = c),
              e
            );
          }
          return (
            Object(u.a)(EllipseCurve, e),
            Object(p.a)(EllipseCurve, [
              {
                key: "getPoint",
                value: function getPoint(e, t) {
                  for (
                    var n = t || new Dn(),
                      r = 2 * Math.PI,
                      i = this.aEndAngle - this.aStartAngle,
                      a = Math.abs(i) < Number.EPSILON;
                    i < 0;

                  )
                    i += r;
                  for (; i > r; ) i -= r;
                  i < Number.EPSILON && (i = a ? 0 : r),
                    !0 !== this.aClockwise ||
                      a ||
                      (i === r ? (i = -r) : (i -= r));
                  var o = this.aStartAngle + e * i,
                    s = this.aX + this.xRadius * Math.cos(o),
                    u = this.aY + this.yRadius * Math.sin(o);
                  if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                      c = Math.sin(this.aRotation),
                      h = s - this.aX,
                      d = u - this.aY;
                    (s = h * l - d * c + this.aX),
                      (u = h * c + d * l + this.aY);
                  }
                  return n.set(s, u);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(EllipseCurve.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.aX = e.aX),
                    (this.aY = e.aY),
                    (this.xRadius = e.xRadius),
                    (this.yRadius = e.yRadius),
                    (this.aStartAngle = e.aStartAngle),
                    (this.aEndAngle = e.aEndAngle),
                    (this.aClockwise = e.aClockwise),
                    (this.aRotation = e.aRotation),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(EllipseCurve.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.aX = this.aX),
                    (e.aY = this.aY),
                    (e.xRadius = this.xRadius),
                    (e.yRadius = this.yRadius),
                    (e.aStartAngle = this.aStartAngle),
                    (e.aEndAngle = this.aEndAngle),
                    (e.aClockwise = this.aClockwise),
                    (e.aRotation = this.aRotation),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(EllipseCurve.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    (this.aX = e.aX),
                    (this.aY = e.aY),
                    (this.xRadius = e.xRadius),
                    (this.yRadius = e.yRadius),
                    (this.aStartAngle = e.aStartAngle),
                    (this.aEndAngle = e.aEndAngle),
                    (this.aClockwise = e.aClockwise),
                    (this.aRotation = e.aRotation),
                    this
                  );
                },
              },
            ]),
            EllipseCurve
          );
        })(Os),
        Ls = (function (e) {
          function ArcCurve(e, t, n, i, a, o) {
            var u;
            return (
              Object(f.a)(this, ArcCurve),
              ((u = Object(s.a)(
                this,
                Object(r.a)(ArcCurve).call(this, e, t, n, n, i, a, o)
              )).isArcCurve = !0),
              (u.type = "ArcCurve"),
              u
            );
          }
          return Object(u.a)(ArcCurve, e), ArcCurve;
        })(Cs);
      function CubicPoly() {
        var e = 0,
          t = 0,
          n = 0,
          r = 0;
        function init(i, a, o, s) {
          (e = i),
            (t = o),
            (n = -3 * i + 3 * a - 2 * o - s),
            (r = 2 * i - 2 * a + o + s);
        }
        return {
          initCatmullRom: function initCatmullRom(e, t, n, r, i) {
            init(t, n, i * (n - e), i * (r - t));
          },
          initNonuniformCatmullRom: function initNonuniformCatmullRom(
            e,
            t,
            n,
            r,
            i,
            a,
            o
          ) {
            var s = (t - e) / i - (n - e) / (i + a) + (n - t) / a,
              u = (n - t) / a - (r - t) / (a + o) + (r - n) / o;
            init(t, n, (s *= a), (u *= a));
          },
          calc: function calc(i) {
            var a = i * i;
            return e + t * i + n * a + r * (a * i);
          },
        };
      }
      var ks = new ir(),
        Es = new CubicPoly(),
        Ps = new CubicPoly(),
        Rs = new CubicPoly(),
        Is = (function (e) {
          function CatmullRomCurve3() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [],
              n =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : "centripetal",
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0.5;
            return (
              Object(f.a)(this, CatmullRomCurve3),
              ((e = Object(s.a)(
                this,
                Object(r.a)(CatmullRomCurve3).call(this)
              )).isCatmullRomCurve3 = !0),
              (e.type = "CatmullRomCurve3"),
              (e.points = t),
              (e.closed = n),
              (e.curveType = i),
              (e.tension = a),
              e
            );
          }
          return (
            Object(u.a)(CatmullRomCurve3, e),
            Object(p.a)(CatmullRomCurve3, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t,
                    n,
                    r =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new ir(),
                    i = this.points,
                    a = i.length,
                    o = (a - (this.closed ? 0 : 1)) * e,
                    s = Math.floor(o),
                    u = o - s;
                  this.closed
                    ? (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / a) + 1) * a)
                    : 0 === u && s === a - 1 && ((s = a - 2), (u = 1)),
                    this.closed || s > 0
                      ? (t = i[(s - 1) % a])
                      : (ks.subVectors(i[0], i[1]).add(i[0]), (t = ks));
                  var l = i[s % a],
                    c = i[(s + 1) % a];
                  if (
                    (this.closed || s + 2 < a
                      ? (n = i[(s + 2) % a])
                      : (ks.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]),
                        (n = ks)),
                    "centripetal" === this.curveType ||
                      "chordal" === this.curveType)
                  ) {
                    var h = "chordal" === this.curveType ? 0.5 : 0.25,
                      d = Math.pow(t.distanceToSquared(l), h),
                      f = Math.pow(l.distanceToSquared(c), h),
                      p = Math.pow(c.distanceToSquared(n), h);
                    f < 1e-4 && (f = 1),
                      d < 1e-4 && (d = f),
                      p < 1e-4 && (p = f),
                      Es.initNonuniformCatmullRom(t.x, l.x, c.x, n.x, d, f, p),
                      Ps.initNonuniformCatmullRom(t.y, l.y, c.y, n.y, d, f, p),
                      Rs.initNonuniformCatmullRom(t.z, l.z, c.z, n.z, d, f, p);
                  } else
                    "catmullrom" === this.curveType &&
                      (Es.initCatmullRom(t.x, l.x, c.x, n.x, this.tension),
                      Ps.initCatmullRom(t.y, l.y, c.y, n.y, this.tension),
                      Rs.initCatmullRom(t.z, l.z, c.z, n.z, this.tension));
                  return r.set(Es.calc(u), Ps.calc(u), Rs.calc(u)), r;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  Object(o.a)(
                    Object(r.a)(CatmullRomCurve3.prototype),
                    "copy",
                    this
                  ).call(this, e),
                    (this.points = []);
                  for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone());
                  }
                  return (
                    (this.closed = e.closed),
                    (this.curveType = e.curveType),
                    (this.tension = e.tension),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(CatmullRomCurve3.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  e.points = [];
                  for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray());
                  }
                  return (
                    (e.closed = this.closed),
                    (e.curveType = this.curveType),
                    (e.tension = this.tension),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  Object(o.a)(
                    Object(r.a)(CatmullRomCurve3.prototype),
                    "fromJSON",
                    this
                  ).call(this, e),
                    (this.points = []);
                  for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(new ir().fromArray(i));
                  }
                  return (
                    (this.closed = e.closed),
                    (this.curveType = e.curveType),
                    (this.tension = e.tension),
                    this
                  );
                },
              },
            ]),
            CatmullRomCurve3
          );
        })(Os);
      function CatmullRom(e, t, n, r, i) {
        var a = 0.5 * (r - t),
          o = 0.5 * (i - n),
          s = e * e;
        return (
          (2 * n - 2 * r + a + o) * (e * s) +
          (-3 * n + 3 * r - 2 * a - o) * s +
          a * e +
          n
        );
      }
      function QuadraticBezier(e, t, n, r) {
        return (
          (function QuadraticBezierP0(e, t) {
            var n = 1 - e;
            return n * n * t;
          })(e, t) +
          (function QuadraticBezierP1(e, t) {
            return 2 * (1 - e) * e * t;
          })(e, n) +
          (function QuadraticBezierP2(e, t) {
            return e * e * t;
          })(e, r)
        );
      }
      function CubicBezier(e, t, n, r, i) {
        return (
          (function CubicBezierP0(e, t) {
            var n = 1 - e;
            return n * n * n * t;
          })(e, t) +
          (function CubicBezierP1(e, t) {
            var n = 1 - e;
            return 3 * n * n * e * t;
          })(e, n) +
          (function CubicBezierP2(e, t) {
            return 3 * (1 - e) * e * e * t;
          })(e, r) +
          (function CubicBezierP3(e, t) {
            return e * e * e * t;
          })(e, i)
        );
      }
      var Ds = (function (e) {
          function CubicBezierCurve() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Dn(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new Dn(),
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : new Dn(),
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : new Dn();
            return (
              Object(f.a)(this, CubicBezierCurve),
              ((e = Object(s.a)(
                this,
                Object(r.a)(CubicBezierCurve).call(this)
              )).isCubicBezierCurve = !0),
              (e.type = "CubicBezierCurve"),
              (e.v0 = t),
              (e.v1 = n),
              (e.v2 = i),
              (e.v3 = a),
              e
            );
          }
          return (
            Object(u.a)(CubicBezierCurve, e),
            Object(p.a)(CubicBezierCurve, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new Dn(),
                    n = this.v0,
                    r = this.v1,
                    i = this.v2,
                    a = this.v3;
                  return (
                    t.set(
                      CubicBezier(e, n.x, r.x, i.x, a.x),
                      CubicBezier(e, n.y, r.y, i.y, a.y)
                    ),
                    t
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(CubicBezierCurve.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this.v3.copy(e.v3),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(CubicBezierCurve.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.v0 = this.v0.toArray()),
                    (e.v1 = this.v1.toArray()),
                    (e.v2 = this.v2.toArray()),
                    (e.v3 = this.v3.toArray()),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(CubicBezierCurve.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this.v3.fromArray(e.v3),
                    this
                  );
                },
              },
            ]),
            CubicBezierCurve
          );
        })(Os),
        js = (function (e) {
          function CubicBezierCurve3() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir(),
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : new ir(),
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : new ir();
            return (
              Object(f.a)(this, CubicBezierCurve3),
              ((e = Object(s.a)(
                this,
                Object(r.a)(CubicBezierCurve3).call(this)
              )).isCubicBezierCurve3 = !0),
              (e.type = "CubicBezierCurve3"),
              (e.v0 = t),
              (e.v1 = n),
              (e.v2 = i),
              (e.v3 = a),
              e
            );
          }
          return (
            Object(u.a)(CubicBezierCurve3, e),
            Object(p.a)(CubicBezierCurve3, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new ir(),
                    n = this.v0,
                    r = this.v1,
                    i = this.v2,
                    a = this.v3;
                  return (
                    t.set(
                      CubicBezier(e, n.x, r.x, i.x, a.x),
                      CubicBezier(e, n.y, r.y, i.y, a.y),
                      CubicBezier(e, n.z, r.z, i.z, a.z)
                    ),
                    t
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(CubicBezierCurve3.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this.v3.copy(e.v3),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(CubicBezierCurve3.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.v0 = this.v0.toArray()),
                    (e.v1 = this.v1.toArray()),
                    (e.v2 = this.v2.toArray()),
                    (e.v3 = this.v3.toArray()),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(CubicBezierCurve3.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this.v3.fromArray(e.v3),
                    this
                  );
                },
              },
            ]),
            CubicBezierCurve3
          );
        })(Os),
        Bs = (function (e) {
          function LineCurve() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Dn(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new Dn();
            return (
              Object(f.a)(this, LineCurve),
              ((e = Object(s.a)(
                this,
                Object(r.a)(LineCurve).call(this)
              )).isLineCurve = !0),
              (e.type = "LineCurve"),
              (e.v1 = t),
              (e.v2 = n),
              e
            );
          }
          return (
            Object(u.a)(LineCurve, e),
            Object(p.a)(LineCurve, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : new Dn();
                  return (
                    1 === e
                      ? t.copy(this.v2)
                      : (t.copy(this.v2).sub(this.v1),
                        t.multiplyScalar(e).add(this.v1)),
                    t
                  );
                },
              },
              {
                key: "getPointAt",
                value: function getPointAt(e, t) {
                  return this.getPoint(e, t);
                },
              },
              {
                key: "getTangent",
                value: function getTangent(e, t) {
                  var n = t || new Dn();
                  return n.copy(this.v2).sub(this.v1).normalize(), n;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LineCurve.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(LineCurve.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LineCurve.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                  );
                },
              },
            ]),
            LineCurve
          );
        })(Os),
        Ns = (function (e) {
          function LineCurve3() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir();
            return (
              Object(f.a)(this, LineCurve3),
              ((e = Object(s.a)(
                this,
                Object(r.a)(LineCurve3).call(this)
              )).isLineCurve3 = !0),
              (e.type = "LineCurve3"),
              (e.v1 = t),
              (e.v2 = n),
              e
            );
          }
          return (
            Object(u.a)(LineCurve3, e),
            Object(p.a)(LineCurve3, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : new ir();
                  return (
                    1 === e
                      ? t.copy(this.v2)
                      : (t.copy(this.v2).sub(this.v1),
                        t.multiplyScalar(e).add(this.v1)),
                    t
                  );
                },
              },
              {
                key: "getPointAt",
                value: function getPointAt(e, t) {
                  return this.getPoint(e, t);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LineCurve3.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(LineCurve3.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LineCurve3.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                  );
                },
              },
            ]),
            LineCurve3
          );
        })(Os),
        zs = (function (e) {
          function QuadraticBezierCurve() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Dn(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new Dn(),
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : new Dn();
            return (
              Object(f.a)(this, QuadraticBezierCurve),
              ((e = Object(s.a)(
                this,
                Object(r.a)(QuadraticBezierCurve).call(this)
              )).isQuadraticBezierCurve = !0),
              (e.type = "QuadraticBezierCurve"),
              (e.v0 = t),
              (e.v1 = n),
              (e.v2 = i),
              e
            );
          }
          return (
            Object(u.a)(QuadraticBezierCurve, e),
            Object(p.a)(QuadraticBezierCurve, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new Dn(),
                    n = this.v0,
                    r = this.v1,
                    i = this.v2;
                  return (
                    t.set(
                      QuadraticBezier(e, n.x, r.x, i.x),
                      QuadraticBezier(e, n.y, r.y, i.y)
                    ),
                    t
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(QuadraticBezierCurve.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(QuadraticBezierCurve.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.v0 = this.v0.toArray()),
                    (e.v1 = this.v1.toArray()),
                    (e.v2 = this.v2.toArray()),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(QuadraticBezierCurve.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                  );
                },
              },
            ]),
            QuadraticBezierCurve
          );
        })(Os),
        Fs = (function (e) {
          function QuadraticBezierCurve3() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir(),
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : new ir();
            return (
              Object(f.a)(this, QuadraticBezierCurve3),
              ((e = Object(s.a)(
                this,
                Object(r.a)(QuadraticBezierCurve3).call(this)
              )).isQuadraticBezierCurve3 = !0),
              (e.type = "QuadraticBezierCurve3"),
              (e.v0 = t),
              (e.v1 = n),
              (e.v2 = i),
              e
            );
          }
          return (
            Object(u.a)(QuadraticBezierCurve3, e),
            Object(p.a)(QuadraticBezierCurve3, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new ir(),
                    n = this.v0,
                    r = this.v1,
                    i = this.v2;
                  return (
                    t.set(
                      QuadraticBezier(e, n.x, r.x, i.x),
                      QuadraticBezier(e, n.y, r.y, i.y),
                      QuadraticBezier(e, n.z, r.z, i.z)
                    ),
                    t
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(QuadraticBezierCurve3.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(QuadraticBezierCurve3.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (
                    (e.v0 = this.v0.toArray()),
                    (e.v1 = this.v1.toArray()),
                    (e.v2 = this.v2.toArray()),
                    e
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(QuadraticBezierCurve3.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                  );
                },
              },
            ]),
            QuadraticBezierCurve3
          );
        })(Os),
        Gs = (function (e) {
          function SplineCurve() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [];
            return (
              Object(f.a)(this, SplineCurve),
              ((e = Object(s.a)(
                this,
                Object(r.a)(SplineCurve).call(this)
              )).isSplineCurve = !0),
              (e.type = "SplineCurve"),
              (e.points = t),
              e
            );
          }
          return (
            Object(u.a)(SplineCurve, e),
            Object(p.a)(SplineCurve, [
              {
                key: "getPoint",
                value: function getPoint(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new Dn(),
                    n = this.points,
                    r = (n.length - 1) * e,
                    i = Math.floor(r),
                    a = r - i,
                    o = n[0 === i ? i : i - 1],
                    s = n[i],
                    u = n[i > n.length - 2 ? n.length - 1 : i + 1],
                    l = n[i > n.length - 3 ? n.length - 1 : i + 2];
                  return (
                    t.set(
                      CatmullRom(a, o.x, s.x, u.x, l.x),
                      CatmullRom(a, o.y, s.y, u.y, l.y)
                    ),
                    t
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  Object(o.a)(
                    Object(r.a)(SplineCurve.prototype),
                    "copy",
                    this
                  ).call(this, e),
                    (this.points = []);
                  for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone());
                  }
                  return this;
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(SplineCurve.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  e.points = [];
                  for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray());
                  }
                  return e;
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  Object(o.a)(
                    Object(r.a)(SplineCurve.prototype),
                    "fromJSON",
                    this
                  ).call(this, e),
                    (this.points = []);
                  for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(new Dn().fromArray(i));
                  }
                  return this;
                },
              },
            ]),
            SplineCurve
          );
        })(Os),
        Us = Object.freeze({
          __proto__: null,
          ArcCurve: Ls,
          CatmullRomCurve3: Is,
          CubicBezierCurve: Ds,
          CubicBezierCurve3: js,
          EllipseCurve: Cs,
          LineCurve: Bs,
          LineCurve3: Ns,
          QuadraticBezierCurve: zs,
          QuadraticBezierCurve3: Fs,
          SplineCurve: Gs,
        }),
        Vs = (function (e) {
          function CurvePath() {
            var e;
            return (
              Object(f.a)(this, CurvePath),
              ((e = Object(s.a)(this, Object(r.a)(CurvePath).call(this))).type =
                "CurvePath"),
              (e.curves = []),
              (e.autoClose = !1),
              e
            );
          }
          return (
            Object(u.a)(CurvePath, e),
            Object(p.a)(CurvePath, [
              {
                key: "add",
                value: function add(e) {
                  this.curves.push(e);
                },
              },
              {
                key: "closePath",
                value: function closePath() {
                  var e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                  e.equals(t) || this.curves.push(new Bs(t, e));
                },
              },
              {
                key: "getPoint",
                value: function getPoint(e, t) {
                  for (
                    var n = e * this.getLength(),
                      r = this.getCurveLengths(),
                      i = 0;
                    i < r.length;

                  ) {
                    if (r[i] >= n) {
                      var a = r[i] - n,
                        o = this.curves[i],
                        s = o.getLength(),
                        u = 0 === s ? 0 : 1 - a / s;
                      return o.getPointAt(u, t);
                    }
                    i++;
                  }
                  return null;
                },
              },
              {
                key: "getLength",
                value: function getLength() {
                  var e = this.getCurveLengths();
                  return e[e.length - 1];
                },
              },
              {
                key: "updateArcLengths",
                value: function updateArcLengths() {
                  (this.needsUpdate = !0),
                    (this.cacheLengths = null),
                    this.getCurveLengths();
                },
              },
              {
                key: "getCurveLengths",
                value: function getCurveLengths() {
                  if (
                    this.cacheLengths &&
                    this.cacheLengths.length === this.curves.length
                  )
                    return this.cacheLengths;
                  for (
                    var e = [], t = 0, n = 0, r = this.curves.length;
                    n < r;
                    n++
                  )
                    (t += this.curves[n].getLength()), e.push(t);
                  return (this.cacheLengths = e), e;
                },
              },
              {
                key: "getSpacedPoints",
                value: function getSpacedPoints() {
                  for (
                    var e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 40,
                      t = [],
                      n = 0;
                    n <= e;
                    n++
                  )
                    t.push(this.getPoint(n / e));
                  return this.autoClose && t.push(t[0]), t;
                },
              },
              {
                key: "getPoints",
                value: function getPoints() {
                  for (
                    var e,
                      t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 12,
                      n = [],
                      r = 0,
                      i = this.curves;
                    r < i.length;
                    r++
                  )
                    for (
                      var a = i[r],
                        o = a.isEllipseCurve
                          ? 2 * t
                          : a.isLineCurve || a.isLineCurve3
                          ? 1
                          : a.isSplineCurve
                          ? t * a.points.length
                          : t,
                        s = a.getPoints(o),
                        u = 0;
                      u < s.length;
                      u++
                    ) {
                      var l = s[u];
                      (e && e.equals(l)) || (n.push(l), (e = l));
                    }
                  return (
                    this.autoClose &&
                      n.length > 1 &&
                      !n[n.length - 1].equals(n[0]) &&
                      n.push(n[0]),
                    n
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  Object(o.a)(
                    Object(r.a)(CurvePath.prototype),
                    "copy",
                    this
                  ).call(this, e),
                    (this.curves = []);
                  for (var t = 0, n = e.curves.length; t < n; t++) {
                    var i = e.curves[t];
                    this.curves.push(i.clone());
                  }
                  return (this.autoClose = e.autoClose), this;
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(CurvePath.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  (e.autoClose = this.autoClose), (e.curves = []);
                  for (var t = 0, n = this.curves.length; t < n; t++) {
                    var i = this.curves[t];
                    e.curves.push(i.toJSON());
                  }
                  return e;
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  Object(o.a)(
                    Object(r.a)(CurvePath.prototype),
                    "fromJSON",
                    this
                  ).call(this, e),
                    (this.autoClose = e.autoClose),
                    (this.curves = []);
                  for (var t = 0, n = e.curves.length; t < n; t++) {
                    var i = e.curves[t];
                    this.curves.push(new Us[i.type]().fromJSON(i));
                  }
                  return this;
                },
              },
            ]),
            CurvePath
          );
        })(Os),
        Ws = (function (e) {
          function Path(e) {
            var t;
            return (
              Object(f.a)(this, Path),
              ((t = Object(s.a)(this, Object(r.a)(Path).call(this))).type =
                "Path"),
              (t.currentPoint = new Dn()),
              e && t.setFromPoints(e),
              t
            );
          }
          return (
            Object(u.a)(Path, e),
            Object(p.a)(Path, [
              {
                key: "setFromPoints",
                value: function setFromPoints(e) {
                  this.moveTo(e[0].x, e[0].y);
                  for (var t = 1, n = e.length; t < n; t++)
                    this.lineTo(e[t].x, e[t].y);
                  return this;
                },
              },
              {
                key: "moveTo",
                value: function moveTo(e, t) {
                  return this.currentPoint.set(e, t), this;
                },
              },
              {
                key: "lineTo",
                value: function lineTo(e, t) {
                  var n = new Bs(this.currentPoint.clone(), new Dn(e, t));
                  return this.curves.push(n), this.currentPoint.set(e, t), this;
                },
              },
              {
                key: "quadraticCurveTo",
                value: function quadraticCurveTo(e, t, n, r) {
                  var i = new zs(
                    this.currentPoint.clone(),
                    new Dn(e, t),
                    new Dn(n, r)
                  );
                  return this.curves.push(i), this.currentPoint.set(n, r), this;
                },
              },
              {
                key: "bezierCurveTo",
                value: function bezierCurveTo(e, t, n, r, i, a) {
                  var o = new Ds(
                    this.currentPoint.clone(),
                    new Dn(e, t),
                    new Dn(n, r),
                    new Dn(i, a)
                  );
                  return this.curves.push(o), this.currentPoint.set(i, a), this;
                },
              },
              {
                key: "splineThru",
                value: function splineThru(e) {
                  var t = [this.currentPoint.clone()].concat(e),
                    n = new Gs(t);
                  return (
                    this.curves.push(n),
                    this.currentPoint.copy(e[e.length - 1]),
                    this
                  );
                },
              },
              {
                key: "arc",
                value: function arc(e, t, n, r, i, a) {
                  var o = this.currentPoint.x,
                    s = this.currentPoint.y;
                  return this.absarc(e + o, t + s, n, r, i, a), this;
                },
              },
              {
                key: "absarc",
                value: function absarc(e, t, n, r, i, a) {
                  return this.absellipse(e, t, n, n, r, i, a), this;
                },
              },
              {
                key: "ellipse",
                value: function ellipse(e, t, n, r, i, a, o, s) {
                  var u = this.currentPoint.x,
                    l = this.currentPoint.y;
                  return this.absellipse(e + u, t + l, n, r, i, a, o, s), this;
                },
              },
              {
                key: "absellipse",
                value: function absellipse(e, t, n, r, i, a, o, s) {
                  var u = new Cs(e, t, n, r, i, a, o, s);
                  if (this.curves.length > 0) {
                    var l = u.getPoint(0);
                    l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
                  }
                  this.curves.push(u);
                  var c = u.getPoint(1);
                  return this.currentPoint.copy(c), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(Object(r.a)(Path.prototype), "copy", this).call(
                      this,
                      e
                    ),
                    this.currentPoint.copy(e.currentPoint),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(Path.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  return (e.currentPoint = this.currentPoint.toArray()), e;
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(Path.prototype),
                      "fromJSON",
                      this
                    ).call(this, e),
                    this.currentPoint.fromArray(e.currentPoint),
                    this
                  );
                },
              },
            ]),
            Path
          );
        })(Vs),
        Hs = (function (e) {
          function LatheGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [new Dn(0, -0.5), new Dn(0.5, 0), new Dn(0, 0.5)],
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 12,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 2 * Math.PI;
            Object(f.a)(this, LatheGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(LatheGeometry).call(this)
              )).type = "LatheGeometry"),
              (e.parameters = {
                points: t,
                segments: n,
                phiStart: i,
                phiLength: a,
              }),
              (n = Math.floor(n)),
              (a = clamp(a, 0, 2 * Math.PI));
            for (
              var o = [],
                u = [],
                l = [],
                c = [],
                h = [],
                d = 1 / n,
                p = new ir(),
                m = new Dn(),
                v = new ir(),
                g = new ir(),
                y = new ir(),
                b = 0,
                x = 0,
                _ = 0;
              _ <= t.length - 1;
              _++
            )
              switch (_) {
                case 0:
                  (b = t[_ + 1].x - t[_].x),
                    (x = t[_ + 1].y - t[_].y),
                    (v.x = 1 * x),
                    (v.y = -b),
                    (v.z = 0 * x),
                    y.copy(v),
                    v.normalize(),
                    c.push(v.x, v.y, v.z);
                  break;
                case t.length - 1:
                  c.push(y.x, y.y, y.z);
                  break;
                default:
                  (b = t[_ + 1].x - t[_].x),
                    (x = t[_ + 1].y - t[_].y),
                    (v.x = 1 * x),
                    (v.y = -b),
                    (v.z = 0 * x),
                    g.copy(v),
                    (v.x += y.x),
                    (v.y += y.y),
                    (v.z += y.z),
                    v.normalize(),
                    c.push(v.x, v.y, v.z),
                    y.copy(g);
              }
            for (var M = 0; M <= n; M++)
              for (
                var S = i + M * d * a, w = Math.sin(S), T = Math.cos(S), A = 0;
                A <= t.length - 1;
                A++
              ) {
                (p.x = t[A].x * w),
                  (p.y = t[A].y),
                  (p.z = t[A].x * T),
                  u.push(p.x, p.y, p.z),
                  (m.x = M / n),
                  (m.y = A / (t.length - 1)),
                  l.push(m.x, m.y);
                var O = c[3 * A + 0] * w,
                  C = c[3 * A + 1],
                  L = c[3 * A + 0] * T;
                h.push(O, C, L);
              }
            for (var k = 0; k < n; k++)
              for (var E = 0; E < t.length - 1; E++) {
                var P = E + k * t.length,
                  R = P,
                  I = P + t.length,
                  D = P + t.length + 1,
                  j = P + 1;
                o.push(R, I, j), o.push(D, j, I);
              }
            return (
              e.setIndex(o),
              e.setAttribute("position", new Ei(u, 3)),
              e.setAttribute("uv", new Ei(l, 2)),
              e.setAttribute("normal", new Ei(h, 3)),
              e
            );
          }
          return (
            Object(u.a)(LatheGeometry, e),
            Object(p.a)(LatheGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new LatheGeometry(
                    e.points,
                    e.segments,
                    e.phiStart,
                    e.phiLength
                  );
                },
              },
            ]),
            LatheGeometry
          );
        })(Fi),
        qs = (function (e) {
          function CapsuleGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 4,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 8;
            Object(f.a)(this, CapsuleGeometry);
            var o = new Ws();
            return (
              o.absarc(0, -n / 2, t, 1.5 * Math.PI, 0),
              o.absarc(0, n / 2, t, 0, 0.5 * Math.PI),
              ((e = Object(s.a)(
                this,
                Object(r.a)(CapsuleGeometry).call(this, o.getPoints(i), a)
              )).type = "CapsuleGeometry"),
              (e.parameters = {
                radius: t,
                height: n,
                capSegments: i,
                radialSegments: a,
              }),
              e
            );
          }
          return (
            Object(u.a)(CapsuleGeometry, e),
            Object(p.a)(CapsuleGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new CapsuleGeometry(
                    e.radius,
                    e.length,
                    e.capSegments,
                    e.radialSegments
                  );
                },
              },
            ]),
            CapsuleGeometry
          );
        })(Hs),
        Xs = (function (e) {
          function CircleGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 8,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 2 * Math.PI;
            Object(f.a)(this, CircleGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(CircleGeometry).call(this)
              )).type = "CircleGeometry"),
              (e.parameters = {
                radius: t,
                segments: n,
                thetaStart: i,
                thetaLength: a,
              }),
              (n = Math.max(3, n));
            var o = [],
              u = [],
              l = [],
              c = [],
              h = new ir(),
              d = new Dn();
            u.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
            for (var p = 0, m = 3; p <= n; p++, m += 3) {
              var v = i + (p / n) * a;
              (h.x = t * Math.cos(v)),
                (h.y = t * Math.sin(v)),
                u.push(h.x, h.y, h.z),
                l.push(0, 0, 1),
                (d.x = (u[m] / t + 1) / 2),
                (d.y = (u[m + 1] / t + 1) / 2),
                c.push(d.x, d.y);
            }
            for (var g = 1; g <= n; g++) o.push(g, g + 1, 0);
            return (
              e.setIndex(o),
              e.setAttribute("position", new Ei(u, 3)),
              e.setAttribute("normal", new Ei(l, 3)),
              e.setAttribute("uv", new Ei(c, 2)),
              e
            );
          }
          return (
            Object(u.a)(CircleGeometry, e),
            Object(p.a)(CircleGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new CircleGeometry(
                    e.radius,
                    e.segments,
                    e.thetaStart,
                    e.thetaLength
                  );
                },
              },
            ]),
            CircleGeometry
          );
        })(Fi),
        Js = (function (e) {
          function CylinderGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 8,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 1,
              u =
                arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
              c =
                arguments.length > 6 && void 0 !== arguments[6]
                  ? arguments[6]
                  : 0,
              h =
                arguments.length > 7 && void 0 !== arguments[7]
                  ? arguments[7]
                  : 2 * Math.PI;
            Object(f.a)(this, CylinderGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(CylinderGeometry).call(this)
              )).type = "CylinderGeometry"),
              (e.parameters = {
                radiusTop: t,
                radiusBottom: n,
                height: i,
                radialSegments: a,
                heightSegments: o,
                openEnded: u,
                thetaStart: c,
                thetaLength: h,
              });
            var d = Object(l.a)(Object(l.a)(e));
            (a = Math.floor(a)), (o = Math.floor(o));
            var p = [],
              m = [],
              v = [],
              g = [],
              y = 0,
              b = [],
              x = i / 2,
              _ = 0;
            function generateCap(e) {
              for (
                var r = y,
                  i = new Dn(),
                  o = new ir(),
                  s = 0,
                  u = !0 === e ? t : n,
                  l = !0 === e ? 1 : -1,
                  f = 1;
                f <= a;
                f++
              )
                m.push(0, x * l, 0), v.push(0, l, 0), g.push(0.5, 0.5), y++;
              for (var b = y, M = 0; M <= a; M++) {
                var S = (M / a) * h + c,
                  w = Math.cos(S),
                  T = Math.sin(S);
                (o.x = u * T),
                  (o.y = x * l),
                  (o.z = u * w),
                  m.push(o.x, o.y, o.z),
                  v.push(0, l, 0),
                  (i.x = 0.5 * w + 0.5),
                  (i.y = 0.5 * T * l + 0.5),
                  g.push(i.x, i.y),
                  y++;
              }
              for (var A = 0; A < a; A++) {
                var O = r + A,
                  C = b + A;
                !0 === e ? p.push(C, C + 1, O) : p.push(C + 1, C, O), (s += 3);
              }
              d.addGroup(_, s, !0 === e ? 1 : 2), (_ += s);
            }
            return (
              (function generateTorso() {
                for (
                  var e = new ir(), r = new ir(), s = 0, u = (n - t) / i, l = 0;
                  l <= o;
                  l++
                ) {
                  for (
                    var f = [], M = l / o, S = M * (n - t) + t, w = 0;
                    w <= a;
                    w++
                  ) {
                    var T = w / a,
                      A = T * h + c,
                      O = Math.sin(A),
                      C = Math.cos(A);
                    (r.x = S * O),
                      (r.y = -M * i + x),
                      (r.z = S * C),
                      m.push(r.x, r.y, r.z),
                      e.set(O, u, C).normalize(),
                      v.push(e.x, e.y, e.z),
                      g.push(T, 1 - M),
                      f.push(y++);
                  }
                  b.push(f);
                }
                for (var L = 0; L < a; L++)
                  for (var k = 0; k < o; k++) {
                    var E = b[k][L],
                      P = b[k + 1][L],
                      R = b[k + 1][L + 1],
                      I = b[k][L + 1];
                    p.push(E, P, I), p.push(P, R, I), (s += 6);
                  }
                d.addGroup(_, s, 0), (_ += s);
              })(),
              !1 === u && (t > 0 && generateCap(!0), n > 0 && generateCap(!1)),
              e.setIndex(p),
              e.setAttribute("position", new Ei(m, 3)),
              e.setAttribute("normal", new Ei(v, 3)),
              e.setAttribute("uv", new Ei(g, 2)),
              e
            );
          }
          return (
            Object(u.a)(CylinderGeometry, e),
            Object(p.a)(CylinderGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new CylinderGeometry(
                    e.radiusTop,
                    e.radiusBottom,
                    e.height,
                    e.radialSegments,
                    e.heightSegments,
                    e.openEnded,
                    e.thetaStart,
                    e.thetaLength
                  );
                },
              },
            ]),
            CylinderGeometry
          );
        })(Fi),
        Ys = (function (e) {
          function ConeGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 8,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1,
              o =
                arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 0,
              l =
                arguments.length > 6 && void 0 !== arguments[6]
                  ? arguments[6]
                  : 2 * Math.PI;
            return (
              Object(f.a)(this, ConeGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(ConeGeometry).call(this, 0, t, n, i, a, o, u, l)
              )).type = "ConeGeometry"),
              (e.parameters = {
                radius: t,
                height: n,
                radialSegments: i,
                heightSegments: a,
                openEnded: o,
                thetaStart: u,
                thetaLength: l,
              }),
              e
            );
          }
          return (
            Object(u.a)(ConeGeometry, e),
            Object(p.a)(ConeGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new ConeGeometry(
                    e.radius,
                    e.height,
                    e.radialSegments,
                    e.heightSegments,
                    e.openEnded,
                    e.thetaStart,
                    e.thetaLength
                  );
                },
              },
            ]),
            ConeGeometry
          );
        })(Js),
        Zs = (function (e) {
          function PolyhedronGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [],
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : [],
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0;
            Object(f.a)(this, PolyhedronGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(PolyhedronGeometry).call(this)
              )).type = "PolyhedronGeometry"),
              (e.parameters = {
                vertices: t,
                indices: n,
                radius: i,
                detail: a,
              });
            var o = [],
              u = [];
            function subdivideFace(e, t, n, r) {
              for (var i = r + 1, a = [], o = 0; o <= i; o++) {
                a[o] = [];
                for (
                  var s = e.clone().lerp(n, o / i),
                    u = t.clone().lerp(n, o / i),
                    l = i - o,
                    c = 0;
                  c <= l;
                  c++
                )
                  a[o][c] = 0 === c && o === i ? s : s.clone().lerp(u, c / l);
              }
              for (var h = 0; h < i; h++)
                for (var d = 0; d < 2 * (i - h) - 1; d++) {
                  var f = Math.floor(d / 2);
                  d % 2 === 0
                    ? (pushVertex(a[h][f + 1]),
                      pushVertex(a[h + 1][f]),
                      pushVertex(a[h][f]))
                    : (pushVertex(a[h][f + 1]),
                      pushVertex(a[h + 1][f + 1]),
                      pushVertex(a[h + 1][f]));
                }
            }
            function pushVertex(e) {
              o.push(e.x, e.y, e.z);
            }
            function getVertexByIndex(e, n) {
              var r = 3 * e;
              (n.x = t[r + 0]), (n.y = t[r + 1]), (n.z = t[r + 2]);
            }
            function correctUV(e, t, n, r) {
              r < 0 && 1 === e.x && (u[t] = e.x - 1),
                0 === n.x && 0 === n.z && (u[t] = r / 2 / Math.PI + 0.5);
            }
            function azimuth(e) {
              return Math.atan2(e.z, -e.x);
            }
            return (
              (function subdivide(e) {
                for (
                  var t = new ir(), r = new ir(), i = new ir(), a = 0;
                  a < n.length;
                  a += 3
                )
                  getVertexByIndex(n[a + 0], t),
                    getVertexByIndex(n[a + 1], r),
                    getVertexByIndex(n[a + 2], i),
                    subdivideFace(t, r, i, e);
              })(a),
              (function applyRadius(e) {
                for (var t = new ir(), n = 0; n < o.length; n += 3)
                  (t.x = o[n + 0]),
                    (t.y = o[n + 1]),
                    (t.z = o[n + 2]),
                    t.normalize().multiplyScalar(e),
                    (o[n + 0] = t.x),
                    (o[n + 1] = t.y),
                    (o[n + 2] = t.z);
              })(i),
              (function generateUVs() {
                for (var e = new ir(), t = 0; t < o.length; t += 3) {
                  (e.x = o[t + 0]), (e.y = o[t + 1]), (e.z = o[t + 2]);
                  var n = azimuth(e) / 2 / Math.PI + 0.5,
                    r =
                      ((i = e),
                      Math.atan2(-i.y, Math.sqrt(i.x * i.x + i.z * i.z)) /
                        Math.PI +
                        0.5);
                  u.push(n, 1 - r);
                }
                var i;
                (function correctUVs() {
                  for (
                    var e = new ir(),
                      t = new ir(),
                      n = new ir(),
                      r = new ir(),
                      i = new Dn(),
                      a = new Dn(),
                      s = new Dn(),
                      l = 0,
                      c = 0;
                    l < o.length;
                    l += 9, c += 6
                  ) {
                    e.set(o[l + 0], o[l + 1], o[l + 2]),
                      t.set(o[l + 3], o[l + 4], o[l + 5]),
                      n.set(o[l + 6], o[l + 7], o[l + 8]),
                      i.set(u[c + 0], u[c + 1]),
                      a.set(u[c + 2], u[c + 3]),
                      s.set(u[c + 4], u[c + 5]),
                      r.copy(e).add(t).add(n).divideScalar(3);
                    var h = azimuth(r);
                    correctUV(i, c + 0, e, h),
                      correctUV(a, c + 2, t, h),
                      correctUV(s, c + 4, n, h);
                  }
                })(),
                  (function correctSeam() {
                    for (var e = 0; e < u.length; e += 6) {
                      var t = u[e + 0],
                        n = u[e + 2],
                        r = u[e + 4],
                        i = Math.max(t, n, r),
                        a = Math.min(t, n, r);
                      i > 0.9 &&
                        a < 0.1 &&
                        (t < 0.2 && (u[e + 0] += 1),
                        n < 0.2 && (u[e + 2] += 1),
                        r < 0.2 && (u[e + 4] += 1));
                    }
                  })();
              })(),
              e.setAttribute("position", new Ei(o, 3)),
              e.setAttribute("normal", new Ei(o.slice(), 3)),
              e.setAttribute("uv", new Ei(u, 2)),
              0 === a ? e.computeVertexNormals() : e.normalizeNormals(),
              e
            );
          }
          return (
            Object(u.a)(PolyhedronGeometry, e),
            Object(p.a)(PolyhedronGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new PolyhedronGeometry(
                    e.vertices,
                    e.indices,
                    e.radius,
                    e.details
                  );
                },
              },
            ]),
            PolyhedronGeometry
          );
        })(Fi),
        Ks = (function (e) {
          function DodecahedronGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            Object(f.a)(this, DodecahedronGeometry);
            var i = (1 + Math.sqrt(5)) / 2,
              a = 1 / i,
              o = [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -a,
                -i,
                0,
                -a,
                i,
                0,
                a,
                -i,
                0,
                a,
                i,
                -a,
                -i,
                0,
                -a,
                i,
                0,
                a,
                -i,
                0,
                a,
                i,
                0,
                -i,
                0,
                -a,
                i,
                0,
                -a,
                -i,
                0,
                a,
                i,
                0,
                a,
              ];
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(DodecahedronGeometry).call(
                  this,
                  o,
                  [
                    3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6,
                    15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8,
                    2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6,
                    13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11,
                    18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5,
                    19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14,
                    1, 14, 5, 1, 5, 9,
                  ],
                  t,
                  n
                )
              )).type = "DodecahedronGeometry"),
              (e.parameters = { radius: t, detail: n }),
              e
            );
          }
          return (
            Object(u.a)(DodecahedronGeometry, e),
            Object(p.a)(DodecahedronGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new DodecahedronGeometry(e.radius, e.detail);
                },
              },
            ]),
            DodecahedronGeometry
          );
        })(Zs),
        Qs = new ir(),
        $s = new ir(),
        eu = new ir(),
        tu = new vi(),
        nu = (function (e) {
          function EdgesGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : null,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1;
            if (
              (Object(f.a)(this, EdgesGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(EdgesGeometry).call(this)
              )).type = "EdgesGeometry"),
              (e.parameters = { geometry: t, thresholdAngle: n }),
              null !== t)
            ) {
              for (
                var i = Math.pow(10, 4),
                  a = Math.cos(Pn * n),
                  o = t.getIndex(),
                  u = t.getAttribute("position"),
                  l = o ? o.count : u.count,
                  c = [0, 0, 0],
                  h = ["a", "b", "c"],
                  d = new Array(3),
                  p = {},
                  m = [],
                  v = 0;
                v < l;
                v += 3
              ) {
                o
                  ? ((c[0] = o.getX(v)),
                    (c[1] = o.getX(v + 1)),
                    (c[2] = o.getX(v + 2)))
                  : ((c[0] = v), (c[1] = v + 1), (c[2] = v + 2));
                var g = tu.a,
                  y = tu.b,
                  b = tu.c;
                if (
                  (g.fromBufferAttribute(u, c[0]),
                  y.fromBufferAttribute(u, c[1]),
                  b.fromBufferAttribute(u, c[2]),
                  tu.getNormal(eu),
                  (d[0] = ""
                    .concat(Math.round(g.x * i), ",")
                    .concat(Math.round(g.y * i), ",")
                    .concat(Math.round(g.z * i))),
                  (d[1] = ""
                    .concat(Math.round(y.x * i), ",")
                    .concat(Math.round(y.y * i), ",")
                    .concat(Math.round(y.z * i))),
                  (d[2] = ""
                    .concat(Math.round(b.x * i), ",")
                    .concat(Math.round(b.y * i), ",")
                    .concat(Math.round(b.z * i))),
                  d[0] !== d[1] && d[1] !== d[2] && d[2] !== d[0])
                )
                  for (var x = 0; x < 3; x++) {
                    var _ = (x + 1) % 3,
                      M = d[x],
                      S = d[_],
                      w = tu[h[x]],
                      T = tu[h[_]],
                      A = "".concat(M, "_").concat(S),
                      O = "".concat(S, "_").concat(M);
                    O in p && p[O]
                      ? (eu.dot(p[O].normal) <= a &&
                          (m.push(w.x, w.y, w.z), m.push(T.x, T.y, T.z)),
                        (p[O] = null))
                      : A in p ||
                        (p[A] = {
                          index0: c[x],
                          index1: c[_],
                          normal: eu.clone(),
                        });
                  }
              }
              for (var C in p)
                if (p[C]) {
                  var L = p[C],
                    k = L.index0,
                    E = L.index1;
                  Qs.fromBufferAttribute(u, k),
                    $s.fromBufferAttribute(u, E),
                    m.push(Qs.x, Qs.y, Qs.z),
                    m.push($s.x, $s.y, $s.z);
                }
              e.setAttribute("position", new Ei(m, 3));
            }
            return e;
          }
          return Object(u.a)(EdgesGeometry, e), EdgesGeometry;
        })(Fi),
        ru = (function (e) {
          function Shape(e) {
            var t;
            return (
              Object(f.a)(this, Shape),
              ((t = Object(s.a)(this, Object(r.a)(Shape).call(this, e))).uuid =
                generateUUID()),
              (t.type = "Shape"),
              (t.holes = []),
              t
            );
          }
          return (
            Object(u.a)(Shape, e),
            Object(p.a)(Shape, [
              {
                key: "getPointsHoles",
                value: function getPointsHoles(e) {
                  for (var t = [], n = 0, r = this.holes.length; n < r; n++)
                    t[n] = this.holes[n].getPoints(e);
                  return t;
                },
              },
              {
                key: "extractPoints",
                value: function extractPoints(e) {
                  return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e),
                  };
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  Object(o.a)(Object(r.a)(Shape.prototype), "copy", this).call(
                    this,
                    e
                  ),
                    (this.holes = []);
                  for (var t = 0, n = e.holes.length; t < n; t++) {
                    var i = e.holes[t];
                    this.holes.push(i.clone());
                  }
                  return this;
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(Shape.prototype),
                    "toJSON",
                    this
                  ).call(this);
                  (e.uuid = this.uuid), (e.holes = []);
                  for (var t = 0, n = this.holes.length; t < n; t++) {
                    var i = this.holes[t];
                    e.holes.push(i.toJSON());
                  }
                  return e;
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  Object(o.a)(
                    Object(r.a)(Shape.prototype),
                    "fromJSON",
                    this
                  ).call(this, e),
                    (this.uuid = e.uuid),
                    (this.holes = []);
                  for (var t = 0, n = e.holes.length; t < n; t++) {
                    var i = e.holes[t];
                    this.holes.push(new Ws().fromJSON(i));
                  }
                  return this;
                },
              },
            ]),
            Shape
          );
        })(Ws),
        iu = function triangulate(e, t) {
          var n,
            r,
            i,
            a,
            o,
            s,
            u,
            l =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 2,
            c = t && t.length,
            h = c ? t[0] * l : e.length,
            d = linkedList(e, 0, h, l, !0),
            f = [];
          if (!d || d.next === d.prev) return f;
          if (
            (c &&
              (d = (function eliminateHoles(e, t, n, r) {
                var i,
                  a,
                  o,
                  s,
                  u,
                  l = [];
                for (i = 0, a = t.length; i < a; i++)
                  (o = t[i] * r),
                    (s = i < a - 1 ? t[i + 1] * r : e.length),
                    (u = linkedList(e, o, s, r, !1)) === u.next &&
                      (u.steiner = !0),
                    l.push(getLeftmost(u));
                for (l.sort(compareX), i = 0; i < l.length; i++)
                  eliminateHole(l[i], n), (n = filterPoints(n, n.next));
                return n;
              })(e, t, d, l)),
            e.length > 80 * l)
          ) {
            (n = i = e[0]), (r = a = e[1]);
            for (var p = l; p < h; p += l)
              (o = e[p]) < n && (n = o),
                (s = e[p + 1]) < r && (r = s),
                o > i && (i = o),
                s > a && (a = s);
            u = 0 !== (u = Math.max(i - n, a - r)) ? 1 / u : 0;
          }
          return earcutLinked(d, f, l, n, r, u), f;
        };
      function linkedList(e, t, n, r, i) {
        var a, o;
        if (
          i ===
          (function signedArea(e, t, n, r) {
            for (var i = 0, a = t, o = n - r; a < n; a += r)
              (i += (e[o] - e[a]) * (e[a + 1] + e[o + 1])), (o = a);
            return i;
          })(e, t, n, r) >
            0
        )
          for (a = t; a < n; a += r) o = insertNode(a, e[a], e[a + 1], o);
        else
          for (a = n - r; a >= t; a -= r) o = insertNode(a, e[a], e[a + 1], o);
        return o && equals(o, o.next) && (removeNode(o), (o = o.next)), o;
      }
      function filterPoints(e, t) {
        if (!e) return e;
        t || (t = e);
        var n,
          r = e;
        do {
          if (
            ((n = !1),
            r.steiner ||
              (!equals(r, r.next) &&
                0 !== three_module_area(r.prev, r, r.next)))
          )
            r = r.next;
          else {
            if ((removeNode(r), (r = t = r.prev) === r.next)) break;
            n = !0;
          }
        } while (n || r !== t);
        return t;
      }
      function earcutLinked(e, t, n, r, i, a, o) {
        if (e) {
          !o &&
            a &&
            (function indexCurve(e, t, n, r) {
              var i = e;
              do {
                null === i.z && (i.z = zOrder(i.x, i.y, t, n, r)),
                  (i.prevZ = i.prev),
                  (i.nextZ = i.next),
                  (i = i.next);
              } while (i !== e);
              (i.prevZ.nextZ = null),
                (i.prevZ = null),
                (function sortLinked(e) {
                  var t,
                    n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    u,
                    l = 1;
                  do {
                    for (n = e, e = null, a = null, o = 0; n; ) {
                      for (
                        o++, r = n, s = 0, t = 0;
                        t < l && (s++, (r = r.nextZ));
                        t++
                      );
                      for (u = l; s > 0 || (u > 0 && r); )
                        0 !== s && (0 === u || !r || n.z <= r.z)
                          ? ((i = n), (n = n.nextZ), s--)
                          : ((i = r), (r = r.nextZ), u--),
                          a ? (a.nextZ = i) : (e = i),
                          (i.prevZ = a),
                          (a = i);
                      n = r;
                    }
                    (a.nextZ = null), (l *= 2);
                  } while (o > 1);
                  return e;
                })(i);
            })(e, r, i, a);
          for (var s, u, l = e; e.prev !== e.next; )
            if (
              ((s = e.prev),
              (u = e.next),
              a ? isEarHashed(e, r, i, a) : isEar(e))
            )
              t.push(s.i / n),
                t.push(e.i / n),
                t.push(u.i / n),
                removeNode(e),
                (e = u.next),
                (l = u.next);
            else if ((e = u) === l) {
              o
                ? 1 === o
                  ? earcutLinked(
                      (e = cureLocalIntersections(filterPoints(e), t, n)),
                      t,
                      n,
                      r,
                      i,
                      a,
                      2
                    )
                  : 2 === o && splitEarcut(e, t, n, r, i, a)
                : earcutLinked(filterPoints(e), t, n, r, i, a, 1);
              break;
            }
        }
      }
      function isEar(e) {
        var t = e.prev,
          n = e,
          r = e.next;
        if (three_module_area(t, n, r) >= 0) return !1;
        for (var i = e.next.next; i !== e.prev; ) {
          if (
            pointInTriangle(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
            three_module_area(i.prev, i, i.next) >= 0
          )
            return !1;
          i = i.next;
        }
        return !0;
      }
      function isEarHashed(e, t, n, r) {
        var i = e.prev,
          a = e,
          o = e.next;
        if (three_module_area(i, a, o) >= 0) return !1;
        for (
          var s = i.x < a.x ? (i.x < o.x ? i.x : o.x) : a.x < o.x ? a.x : o.x,
            u = i.y < a.y ? (i.y < o.y ? i.y : o.y) : a.y < o.y ? a.y : o.y,
            l = i.x > a.x ? (i.x > o.x ? i.x : o.x) : a.x > o.x ? a.x : o.x,
            c = i.y > a.y ? (i.y > o.y ? i.y : o.y) : a.y > o.y ? a.y : o.y,
            h = zOrder(s, u, t, n, r),
            d = zOrder(l, c, t, n, r),
            f = e.prevZ,
            p = e.nextZ;
          f && f.z >= h && p && p.z <= d;

        ) {
          if (
            f !== e.prev &&
            f !== e.next &&
            pointInTriangle(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
            three_module_area(f.prev, f, f.next) >= 0
          )
            return !1;
          if (
            ((f = f.prevZ),
            p !== e.prev &&
              p !== e.next &&
              pointInTriangle(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
              three_module_area(p.prev, p, p.next) >= 0)
          )
            return !1;
          p = p.nextZ;
        }
        for (; f && f.z >= h; ) {
          if (
            f !== e.prev &&
            f !== e.next &&
            pointInTriangle(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
            three_module_area(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.prevZ;
        }
        for (; p && p.z <= d; ) {
          if (
            p !== e.prev &&
            p !== e.next &&
            pointInTriangle(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
            three_module_area(p.prev, p, p.next) >= 0
          )
            return !1;
          p = p.nextZ;
        }
        return !0;
      }
      function cureLocalIntersections(e, t, n) {
        var r = e;
        do {
          var i = r.prev,
            a = r.next.next;
          !equals(i, a) &&
            intersects(i, r, r.next, a) &&
            locallyInside(i, a) &&
            locallyInside(a, i) &&
            (t.push(i.i / n),
            t.push(r.i / n),
            t.push(a.i / n),
            removeNode(r),
            removeNode(r.next),
            (r = e = a)),
            (r = r.next);
        } while (r !== e);
        return filterPoints(r);
      }
      function splitEarcut(e, t, n, r, i, a) {
        var o = e;
        do {
          for (var s = o.next.next; s !== o.prev; ) {
            if (o.i !== s.i && isValidDiagonal(o, s)) {
              var u = splitPolygon(o, s);
              return (
                (o = filterPoints(o, o.next)),
                (u = filterPoints(u, u.next)),
                earcutLinked(o, t, n, r, i, a),
                void earcutLinked(u, t, n, r, i, a)
              );
            }
            s = s.next;
          }
          o = o.next;
        } while (o !== e);
      }
      function compareX(e, t) {
        return e.x - t.x;
      }
      function eliminateHole(e, t) {
        if (
          (t = (function findHoleBridge(e, t) {
            var n,
              r = t,
              i = e.x,
              a = e.y,
              o = -1 / 0;
            do {
              if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                var s = r.x + ((a - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
                if (s <= i && s > o) {
                  if (((o = s), s === i)) {
                    if (a === r.y) return r;
                    if (a === r.next.y) return r.next;
                  }
                  n = r.x < r.next.x ? r : r.next;
                }
              }
              r = r.next;
            } while (r !== t);
            if (!n) return null;
            if (i === o) return n;
            var u,
              l = n,
              c = n.x,
              h = n.y,
              d = 1 / 0;
            r = n;
            do {
              i >= r.x &&
                r.x >= c &&
                i !== r.x &&
                pointInTriangle(
                  a < h ? i : o,
                  a,
                  c,
                  h,
                  a < h ? o : i,
                  a,
                  r.x,
                  r.y
                ) &&
                ((u = Math.abs(a - r.y) / (i - r.x)),
                locallyInside(r, e) &&
                  (u < d ||
                    (u === d &&
                      (r.x > n.x ||
                        (r.x === n.x && sectorContainsSector(n, r))))) &&
                  ((n = r), (d = u))),
                (r = r.next);
            } while (r !== l);
            return n;
          })(e, t))
        ) {
          var n = splitPolygon(t, e);
          filterPoints(t, t.next), filterPoints(n, n.next);
        }
      }
      function sectorContainsSector(e, t) {
        return (
          three_module_area(e.prev, e, t.prev) < 0 &&
          three_module_area(t.next, e, e.next) < 0
        );
      }
      function zOrder(e, t, n, r, i) {
        return (
          (e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = 32767 * (e - n) * i) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = 32767 * (t - r) * i) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function getLeftmost(e) {
        var t = e,
          n = e;
        do {
          (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
        } while (t !== e);
        return n;
      }
      function pointInTriangle(e, t, n, r, i, a, o, s) {
        return (
          (i - o) * (t - s) - (e - o) * (a - s) >= 0 &&
          (e - o) * (r - s) - (n - o) * (t - s) >= 0 &&
          (n - o) * (a - s) - (i - o) * (r - s) >= 0
        );
      }
      function isValidDiagonal(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function intersectsPolygon(e, t) {
            var n = e;
            do {
              if (
                n.i !== e.i &&
                n.next.i !== e.i &&
                n.i !== t.i &&
                n.next.i !== t.i &&
                intersects(n, n.next, e, t)
              )
                return !0;
              n = n.next;
            } while (n !== e);
            return !1;
          })(e, t) &&
          ((locallyInside(e, t) &&
            locallyInside(t, e) &&
            (function middleInside(e, t) {
              var n = e,
                r = !1,
                i = (e.x + t.x) / 2,
                a = (e.y + t.y) / 2;
              do {
                n.y > a !== n.next.y > a &&
                  n.next.y !== n.y &&
                  i < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
                  (r = !r),
                  (n = n.next);
              } while (n !== e);
              return r;
            })(e, t) &&
            (three_module_area(e.prev, e, t.prev) ||
              three_module_area(e, t.prev, t))) ||
            (equals(e, t) &&
              three_module_area(e.prev, e, e.next) > 0 &&
              three_module_area(t.prev, t, t.next) > 0))
        );
      }
      function three_module_area(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
      }
      function equals(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function intersects(e, t, n, r) {
        var i = sign(three_module_area(e, t, n)),
          a = sign(three_module_area(e, t, r)),
          o = sign(three_module_area(n, r, e)),
          s = sign(three_module_area(n, r, t));
        return (
          (i !== a && o !== s) ||
          !(0 !== i || !onSegment(e, n, t)) ||
          !(0 !== a || !onSegment(e, r, t)) ||
          !(0 !== o || !onSegment(n, e, r)) ||
          !(0 !== s || !onSegment(n, t, r))
        );
      }
      function onSegment(e, t, n) {
        return (
          t.x <= Math.max(e.x, n.x) &&
          t.x >= Math.min(e.x, n.x) &&
          t.y <= Math.max(e.y, n.y) &&
          t.y >= Math.min(e.y, n.y)
        );
      }
      function sign(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function locallyInside(e, t) {
        return three_module_area(e.prev, e, e.next) < 0
          ? three_module_area(e, t, e.next) >= 0 &&
              three_module_area(e, e.prev, t) >= 0
          : three_module_area(e, t, e.prev) < 0 ||
              three_module_area(e, e.next, t) < 0;
      }
      function splitPolygon(e, t) {
        var n = new Node(e.i, e.x, e.y),
          r = new Node(t.i, t.x, t.y),
          i = e.next,
          a = t.prev;
        return (
          (e.next = t),
          (t.prev = e),
          (n.next = i),
          (i.prev = n),
          (r.next = n),
          (n.prev = r),
          (a.next = r),
          (r.prev = a),
          r
        );
      }
      function insertNode(e, t, n, r) {
        var i = new Node(e, t, n);
        return (
          r
            ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
            : ((i.prev = i), (i.next = i)),
          i
        );
      }
      function removeNode(e) {
        (e.next.prev = e.prev),
          (e.prev.next = e.next),
          e.prevZ && (e.prevZ.nextZ = e.nextZ),
          e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function Node(e, t, n) {
        (this.i = e),
          (this.x = t),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      var au = (function () {
        function ShapeUtils() {
          Object(f.a)(this, ShapeUtils);
        }
        return (
          Object(p.a)(ShapeUtils, null, [
            {
              key: "area",
              value: function area(e) {
                for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++)
                  n += e[r].x * e[i].y - e[i].x * e[r].y;
                return 0.5 * n;
              },
            },
            {
              key: "isClockWise",
              value: function isClockWise(e) {
                return ShapeUtils.area(e) < 0;
              },
            },
            {
              key: "triangulateShape",
              value: function triangulateShape(e, t) {
                var n = [],
                  r = [],
                  i = [];
                removeDupEndPts(e), addContour(n, e);
                var a = e.length;
                t.forEach(removeDupEndPts);
                for (var o = 0; o < t.length; o++)
                  r.push(a), (a += t[o].length), addContour(n, t[o]);
                for (var s = iu(n, r), u = 0; u < s.length; u += 3)
                  i.push(s.slice(u, u + 3));
                return i;
              },
            },
          ]),
          ShapeUtils
        );
      })();
      function removeDupEndPts(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function addContour(e, t) {
        for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
      }
      var ou = (function (e) {
          function ExtrudeGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ru([
                      new Dn(0.5, 0.5),
                      new Dn(-0.5, 0.5),
                      new Dn(-0.5, -0.5),
                      new Dn(0.5, -0.5),
                    ]),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
            Object(f.a)(this, ExtrudeGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(ExtrudeGeometry).call(this)
              )).type = "ExtrudeGeometry"),
              (e.parameters = { shapes: t, options: n }),
              (t = Array.isArray(t) ? t : [t]);
            for (
              var i = Object(l.a)(Object(l.a)(e)),
                a = [],
                o = [],
                u = 0,
                c = t.length;
              u < c;
              u++
            ) {
              addShape(t[u]);
            }
            function addShape(e) {
              var t,
                r,
                s,
                u,
                l,
                c = [],
                h = void 0 !== n.curveSegments ? n.curveSegments : 12,
                d = void 0 !== n.steps ? n.steps : 1,
                f = void 0 !== n.depth ? n.depth : 1,
                p = void 0 === n.bevelEnabled || n.bevelEnabled,
                m = void 0 !== n.bevelThickness ? n.bevelThickness : 0.2,
                g = void 0 !== n.bevelSize ? n.bevelSize : m - 0.1,
                y = void 0 !== n.bevelOffset ? n.bevelOffset : 0,
                b = void 0 !== n.bevelSegments ? n.bevelSegments : 3,
                x = n.extrudePath,
                _ = void 0 !== n.UVGenerator ? n.UVGenerator : su,
                M = !1;
              x &&
                ((t = x.getSpacedPoints(d)),
                (M = !0),
                (p = !1),
                (r = x.computeFrenetFrames(d, !1)),
                (s = new ir()),
                (u = new ir()),
                (l = new ir())),
                p || ((b = 0), (m = 0), (g = 0), (y = 0));
              var S = e.extractPoints(h),
                w = S.shape,
                T = S.holes;
              if (!au.isClockWise(w)) {
                w = w.reverse();
                for (var A = 0, O = T.length; A < O; A++) {
                  var C = T[A];
                  au.isClockWise(C) && (T[A] = C.reverse());
                }
              }
              for (
                var L = au.triangulateShape(w, T), k = w, E = 0, P = T.length;
                E < P;
                E++
              ) {
                var R = T[E];
                w = w.concat(R);
              }
              function scalePt2(e, t, n) {
                return (
                  t ||
                    console.error("THREE.ExtrudeGeometry: vec does not exist"),
                  t.clone().multiplyScalar(n).add(e)
                );
              }
              var I = w.length,
                D = L.length;
              function getBevelVec(e, t, n) {
                var r,
                  i,
                  a,
                  o = e.x - t.x,
                  s = e.y - t.y,
                  u = n.x - e.x,
                  l = n.y - e.y,
                  c = o * o + s * s,
                  h = o * l - s * u;
                if (Math.abs(h) > Number.EPSILON) {
                  var d = Math.sqrt(c),
                    f = Math.sqrt(u * u + l * l),
                    p = t.x - s / d,
                    m = t.y + o / d,
                    v =
                      ((n.x - l / f - p) * l - (n.y + u / f - m) * u) /
                      (o * l - s * u),
                    g = (r = p + o * v - e.x) * r + (i = m + s * v - e.y) * i;
                  if (g <= 2) return new Dn(r, i);
                  a = Math.sqrt(g / 2);
                } else {
                  var y = !1;
                  o > Number.EPSILON
                    ? u > Number.EPSILON && (y = !0)
                    : o < -Number.EPSILON
                    ? u < -Number.EPSILON && (y = !0)
                    : Math.sign(s) === Math.sign(l) && (y = !0),
                    y
                      ? ((r = -s), (i = o), (a = Math.sqrt(c)))
                      : ((r = o), (i = s), (a = Math.sqrt(c / 2)));
                }
                return new Dn(r / a, i / a);
              }
              for (
                var j = [], B = 0, N = k.length, z = N - 1, F = B + 1;
                B < N;
                B++, z++, F++
              )
                z === N && (z = 0),
                  F === N && (F = 0),
                  (j[B] = getBevelVec(k[B], k[z], k[F]));
              for (
                var G, U = [], V = j.concat(), W = 0, H = T.length;
                W < H;
                W++
              ) {
                var q = T[W];
                G = [];
                for (
                  var X = 0, J = q.length, Y = J - 1, Z = X + 1;
                  X < J;
                  X++, Y++, Z++
                )
                  Y === J && (Y = 0),
                    Z === J && (Z = 0),
                    (G[X] = getBevelVec(q[X], q[Y], q[Z]));
                U.push(G), (V = V.concat(G));
              }
              for (var K = 0; K < b; K++) {
                for (
                  var Q = K / b,
                    $ = m * Math.cos((Q * Math.PI) / 2),
                    ee = g * Math.sin((Q * Math.PI) / 2) + y,
                    te = 0,
                    ne = k.length;
                  te < ne;
                  te++
                ) {
                  var re = scalePt2(k[te], j[te], ee);
                  v(re.x, re.y, -$);
                }
                for (var ie = 0, ae = T.length; ie < ae; ie++) {
                  var oe = T[ie];
                  G = U[ie];
                  for (var se = 0, ue = oe.length; se < ue; se++) {
                    var le = scalePt2(oe[se], G[se], ee);
                    v(le.x, le.y, -$);
                  }
                }
              }
              for (var ce = g + y, he = 0; he < I; he++) {
                var de = p ? scalePt2(w[he], V[he], ce) : w[he];
                M
                  ? (u.copy(r.normals[0]).multiplyScalar(de.x),
                    s.copy(r.binormals[0]).multiplyScalar(de.y),
                    l.copy(t[0]).add(u).add(s),
                    v(l.x, l.y, l.z))
                  : v(de.x, de.y, 0);
              }
              for (var fe = 1; fe <= d; fe++)
                for (var pe = 0; pe < I; pe++) {
                  var me = p ? scalePt2(w[pe], V[pe], ce) : w[pe];
                  M
                    ? (u.copy(r.normals[fe]).multiplyScalar(me.x),
                      s.copy(r.binormals[fe]).multiplyScalar(me.y),
                      l.copy(t[fe]).add(u).add(s),
                      v(l.x, l.y, l.z))
                    : v(me.x, me.y, (f / d) * fe);
                }
              for (var ve = b - 1; ve >= 0; ve--) {
                for (
                  var ge = ve / b,
                    ye = m * Math.cos((ge * Math.PI) / 2),
                    be = g * Math.sin((ge * Math.PI) / 2) + y,
                    xe = 0,
                    _e = k.length;
                  xe < _e;
                  xe++
                ) {
                  var Me = scalePt2(k[xe], j[xe], be);
                  v(Me.x, Me.y, f + ye);
                }
                for (var Se = 0, we = T.length; Se < we; Se++) {
                  var Te = T[Se];
                  G = U[Se];
                  for (var Ae = 0, Oe = Te.length; Ae < Oe; Ae++) {
                    var Ce = scalePt2(Te[Ae], G[Ae], be);
                    M
                      ? v(Ce.x, Ce.y + t[d - 1].y, t[d - 1].x + ye)
                      : v(Ce.x, Ce.y, f + ye);
                  }
                }
              }
              function sidewalls(e, t) {
                for (var n = e.length; --n >= 0; ) {
                  var r = n,
                    i = n - 1;
                  i < 0 && (i = e.length - 1);
                  for (var a = 0, o = d + 2 * b; a < o; a++) {
                    var s = I * a,
                      u = I * (a + 1);
                    f4(t + r + s, t + i + s, t + i + u, t + r + u);
                  }
                }
              }
              function v(e, t, n) {
                c.push(e), c.push(t), c.push(n);
              }
              function f3(e, t, n) {
                addVertex(e), addVertex(t), addVertex(n);
                var r = a.length / 3,
                  o = _.generateTopUV(i, a, r - 3, r - 2, r - 1);
                addUV(o[0]), addUV(o[1]), addUV(o[2]);
              }
              function f4(e, t, n, r) {
                addVertex(e),
                  addVertex(t),
                  addVertex(r),
                  addVertex(t),
                  addVertex(n),
                  addVertex(r);
                var o = a.length / 3,
                  s = _.generateSideWallUV(i, a, o - 6, o - 3, o - 2, o - 1);
                addUV(s[0]),
                  addUV(s[1]),
                  addUV(s[3]),
                  addUV(s[1]),
                  addUV(s[2]),
                  addUV(s[3]);
              }
              function addVertex(e) {
                a.push(c[3 * e + 0]),
                  a.push(c[3 * e + 1]),
                  a.push(c[3 * e + 2]);
              }
              function addUV(e) {
                o.push(e.x), o.push(e.y);
              }
              !(function buildLidFaces() {
                var e = a.length / 3;
                if (p) {
                  for (var t = 0, n = I * t, r = 0; r < D; r++) {
                    var o = L[r];
                    f3(o[2] + n, o[1] + n, o[0] + n);
                  }
                  n = I * (t = d + 2 * b);
                  for (var s = 0; s < D; s++) {
                    var u = L[s];
                    f3(u[0] + n, u[1] + n, u[2] + n);
                  }
                } else {
                  for (var l = 0; l < D; l++) {
                    var c = L[l];
                    f3(c[2], c[1], c[0]);
                  }
                  for (var h = 0; h < D; h++) {
                    var f = L[h];
                    f3(f[0] + I * d, f[1] + I * d, f[2] + I * d);
                  }
                }
                i.addGroup(e, a.length / 3 - e, 0);
              })(),
                (function buildSideFaces() {
                  var e = a.length / 3,
                    t = 0;
                  sidewalls(k, t), (t += k.length);
                  for (var n = 0, r = T.length; n < r; n++) {
                    var o = T[n];
                    sidewalls(o, t), (t += o.length);
                  }
                  i.addGroup(e, a.length / 3 - e, 1);
                })();
            }
            return (
              e.setAttribute("position", new Ei(a, 3)),
              e.setAttribute("uv", new Ei(o, 2)),
              e.computeVertexNormals(),
              e
            );
          }
          return (
            Object(u.a)(ExtrudeGeometry, e),
            Object(p.a)(
              ExtrudeGeometry,
              [
                {
                  key: "toJSON",
                  value: function toJSON() {
                    var e = Object(o.a)(
                      Object(r.a)(ExtrudeGeometry.prototype),
                      "toJSON",
                      this
                    ).call(this);
                    return (function toJSON$1(e, t, n) {
                      if (((n.shapes = []), Array.isArray(e)))
                        for (var r = 0, i = e.length; r < i; r++) {
                          var a = e[r];
                          n.shapes.push(a.uuid);
                        }
                      else n.shapes.push(e.uuid);
                      (n.options = Object.assign({}, t)),
                        void 0 !== t.extrudePath &&
                          (n.options.extrudePath = t.extrudePath.toJSON());
                      return n;
                    })(this.parameters.shapes, this.parameters.options, e);
                  },
                },
              ],
              [
                {
                  key: "fromJSON",
                  value: function fromJSON(e, t) {
                    for (var n = [], r = 0, i = e.shapes.length; r < i; r++) {
                      var a = t[e.shapes[r]];
                      n.push(a);
                    }
                    var o = e.options.extrudePath;
                    return (
                      void 0 !== o &&
                        (e.options.extrudePath = new Us[o.type]().fromJSON(o)),
                      new ExtrudeGeometry(n, e.options)
                    );
                  },
                },
              ]
            ),
            ExtrudeGeometry
          );
        })(Fi),
        su = {
          generateTopUV: function generateTopUV(e, t, n, r, i) {
            var a = t[3 * n],
              o = t[3 * n + 1],
              s = t[3 * r],
              u = t[3 * r + 1],
              l = t[3 * i],
              c = t[3 * i + 1];
            return [new Dn(a, o), new Dn(s, u), new Dn(l, c)];
          },
          generateSideWallUV: function generateSideWallUV(e, t, n, r, i, a) {
            var o = t[3 * n],
              s = t[3 * n + 1],
              u = t[3 * n + 2],
              l = t[3 * r],
              c = t[3 * r + 1],
              h = t[3 * r + 2],
              d = t[3 * i],
              f = t[3 * i + 1],
              p = t[3 * i + 2],
              m = t[3 * a],
              v = t[3 * a + 1],
              g = t[3 * a + 2];
            return Math.abs(s - c) < Math.abs(o - l)
              ? [
                  new Dn(o, 1 - u),
                  new Dn(l, 1 - h),
                  new Dn(d, 1 - p),
                  new Dn(m, 1 - g),
                ]
              : [
                  new Dn(s, 1 - u),
                  new Dn(c, 1 - h),
                  new Dn(f, 1 - p),
                  new Dn(v, 1 - g),
                ];
          },
        };
      var uu = (function (e) {
          function IcosahedronGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            Object(f.a)(this, IcosahedronGeometry);
            var i = (1 + Math.sqrt(5)) / 2,
              a = [
                -1,
                i,
                0,
                1,
                i,
                0,
                -1,
                -i,
                0,
                1,
                -i,
                0,
                0,
                -1,
                i,
                0,
                1,
                i,
                0,
                -1,
                -i,
                0,
                1,
                -i,
                i,
                0,
                -1,
                i,
                0,
                1,
                -i,
                0,
                -1,
                -i,
                0,
                1,
              ];
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(IcosahedronGeometry).call(
                  this,
                  a,
                  [
                    0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5,
                    11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2,
                    6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7,
                    9, 8, 1,
                  ],
                  t,
                  n
                )
              )).type = "IcosahedronGeometry"),
              (e.parameters = { radius: t, detail: n }),
              e
            );
          }
          return (
            Object(u.a)(IcosahedronGeometry, e),
            Object(p.a)(IcosahedronGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new IcosahedronGeometry(e.radius, e.detail);
                },
              },
            ]),
            IcosahedronGeometry
          );
        })(Zs),
        lu = (function (e) {
          function OctahedronGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            Object(f.a)(this, OctahedronGeometry);
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(OctahedronGeometry).call(
                  this,
                  [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                  [
                    0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3,
                    4, 1, 4, 2,
                  ],
                  t,
                  n
                )
              )).type = "OctahedronGeometry"),
              (e.parameters = { radius: t, detail: n }),
              e
            );
          }
          return (
            Object(u.a)(OctahedronGeometry, e),
            Object(p.a)(OctahedronGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new OctahedronGeometry(e.radius, e.detail);
                },
              },
            ]),
            OctahedronGeometry
          );
        })(Zs),
        cu = (function (e) {
          function RingGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 0.5,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 8,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 0,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 2 * Math.PI;
            Object(f.a)(this, RingGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(RingGeometry).call(this)
              )).type = "RingGeometry"),
              (e.parameters = {
                innerRadius: t,
                outerRadius: n,
                thetaSegments: i,
                phiSegments: a,
                thetaStart: o,
                thetaLength: u,
              }),
              (i = Math.max(3, i));
            for (
              var l = [],
                c = [],
                h = [],
                d = [],
                p = t,
                m = (n - t) / (a = Math.max(1, a)),
                v = new ir(),
                g = new Dn(),
                y = 0;
              y <= a;
              y++
            ) {
              for (var b = 0; b <= i; b++) {
                var x = o + (b / i) * u;
                (v.x = p * Math.cos(x)),
                  (v.y = p * Math.sin(x)),
                  c.push(v.x, v.y, v.z),
                  h.push(0, 0, 1),
                  (g.x = (v.x / n + 1) / 2),
                  (g.y = (v.y / n + 1) / 2),
                  d.push(g.x, g.y);
              }
              p += m;
            }
            for (var _ = 0; _ < a; _++)
              for (var M = _ * (i + 1), S = 0; S < i; S++) {
                var w = S + M,
                  T = w,
                  A = w + i + 1,
                  O = w + i + 2,
                  C = w + 1;
                l.push(T, A, C), l.push(A, O, C);
              }
            return (
              e.setIndex(l),
              e.setAttribute("position", new Ei(c, 3)),
              e.setAttribute("normal", new Ei(h, 3)),
              e.setAttribute("uv", new Ei(d, 2)),
              e
            );
          }
          return (
            Object(u.a)(RingGeometry, e),
            Object(p.a)(RingGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new RingGeometry(
                    e.innerRadius,
                    e.outerRadius,
                    e.thetaSegments,
                    e.phiSegments,
                    e.thetaStart,
                    e.thetaLength
                  );
                },
              },
            ]),
            RingGeometry
          );
        })(Fi),
        hu = (function (e) {
          function ShapeGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ru([
                      new Dn(0, 0.5),
                      new Dn(-0.5, -0.5),
                      new Dn(0.5, -0.5),
                    ]),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 12;
            Object(f.a)(this, ShapeGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(ShapeGeometry).call(this)
              )).type = "ShapeGeometry"),
              (e.parameters = { shapes: t, curveSegments: n });
            var i = [],
              a = [],
              o = [],
              u = [],
              l = 0,
              c = 0;
            if (!1 === Array.isArray(t)) addShape(t);
            else
              for (var h = 0; h < t.length; h++)
                addShape(t[h]), e.addGroup(l, c, h), (l += c), (c = 0);
            function addShape(e) {
              var t = a.length / 3,
                r = e.extractPoints(n),
                s = r.shape,
                l = r.holes;
              !1 === au.isClockWise(s) && (s = s.reverse());
              for (var h = 0, d = l.length; h < d; h++) {
                var f = l[h];
                !0 === au.isClockWise(f) && (l[h] = f.reverse());
              }
              for (
                var p = au.triangulateShape(s, l), m = 0, v = l.length;
                m < v;
                m++
              ) {
                var g = l[m];
                s = s.concat(g);
              }
              for (var y = 0, b = s.length; y < b; y++) {
                var x = s[y];
                a.push(x.x, x.y, 0), o.push(0, 0, 1), u.push(x.x, x.y);
              }
              for (var _ = 0, M = p.length; _ < M; _++) {
                var S = p[_],
                  w = S[0] + t,
                  T = S[1] + t,
                  A = S[2] + t;
                i.push(w, T, A), (c += 3);
              }
            }
            return (
              e.setIndex(i),
              e.setAttribute("position", new Ei(a, 3)),
              e.setAttribute("normal", new Ei(o, 3)),
              e.setAttribute("uv", new Ei(u, 2)),
              e
            );
          }
          return (
            Object(u.a)(ShapeGeometry, e),
            Object(p.a)(
              ShapeGeometry,
              [
                {
                  key: "toJSON",
                  value: function toJSON() {
                    var e = Object(o.a)(
                      Object(r.a)(ShapeGeometry.prototype),
                      "toJSON",
                      this
                    ).call(this);
                    return (function _toJSON(e, t) {
                      if (((t.shapes = []), Array.isArray(e)))
                        for (var n = 0, r = e.length; n < r; n++) {
                          var i = e[n];
                          t.shapes.push(i.uuid);
                        }
                      else t.shapes.push(e.uuid);
                      return t;
                    })(this.parameters.shapes, e);
                  },
                },
              ],
              [
                {
                  key: "fromJSON",
                  value: function fromJSON(e, t) {
                    for (var n = [], r = 0, i = e.shapes.length; r < i; r++) {
                      var a = t[e.shapes[r]];
                      n.push(a);
                    }
                    return new ShapeGeometry(n, e.curveSegments);
                  },
                },
              ]
            ),
            ShapeGeometry
          );
        })(Fi);
      var du = (function (e) {
          function SphereGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 32,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 16,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 2 * Math.PI,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 0,
              l =
                arguments.length > 6 && void 0 !== arguments[6]
                  ? arguments[6]
                  : Math.PI;
            Object(f.a)(this, SphereGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(SphereGeometry).call(this)
              )).type = "SphereGeometry"),
              (e.parameters = {
                radius: t,
                widthSegments: n,
                heightSegments: i,
                phiStart: a,
                phiLength: o,
                thetaStart: u,
                thetaLength: l,
              }),
              (n = Math.max(3, Math.floor(n))),
              (i = Math.max(2, Math.floor(i)));
            for (
              var c = Math.min(u + l, Math.PI),
                h = 0,
                d = [],
                p = new ir(),
                m = new ir(),
                v = [],
                g = [],
                y = [],
                b = [],
                x = 0;
              x <= i;
              x++
            ) {
              var _ = [],
                M = x / i,
                S = 0;
              0 == x && 0 == u
                ? (S = 0.5 / n)
                : x == i && c == Math.PI && (S = -0.5 / n);
              for (var w = 0; w <= n; w++) {
                var T = w / n;
                (p.x = -t * Math.cos(a + T * o) * Math.sin(u + M * l)),
                  (p.y = t * Math.cos(u + M * l)),
                  (p.z = t * Math.sin(a + T * o) * Math.sin(u + M * l)),
                  g.push(p.x, p.y, p.z),
                  m.copy(p).normalize(),
                  y.push(m.x, m.y, m.z),
                  b.push(T + S, 1 - M),
                  _.push(h++);
              }
              d.push(_);
            }
            for (var A = 0; A < i; A++)
              for (var O = 0; O < n; O++) {
                var C = d[A][O + 1],
                  L = d[A][O],
                  k = d[A + 1][O],
                  E = d[A + 1][O + 1];
                (0 !== A || u > 0) && v.push(C, L, E),
                  (A !== i - 1 || c < Math.PI) && v.push(L, k, E);
              }
            return (
              e.setIndex(v),
              e.setAttribute("position", new Ei(g, 3)),
              e.setAttribute("normal", new Ei(y, 3)),
              e.setAttribute("uv", new Ei(b, 2)),
              e
            );
          }
          return (
            Object(u.a)(SphereGeometry, e),
            Object(p.a)(SphereGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new SphereGeometry(
                    e.radius,
                    e.widthSegments,
                    e.heightSegments,
                    e.phiStart,
                    e.phiLength,
                    e.thetaStart,
                    e.thetaLength
                  );
                },
              },
            ]),
            SphereGeometry
          );
        })(Fi),
        fu = (function (e) {
          function TetrahedronGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0;
            Object(f.a)(this, TetrahedronGeometry);
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(TetrahedronGeometry).call(
                  this,
                  [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                  [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
                  t,
                  n
                )
              )).type = "TetrahedronGeometry"),
              (e.parameters = { radius: t, detail: n }),
              e
            );
          }
          return (
            Object(u.a)(TetrahedronGeometry, e),
            Object(p.a)(TetrahedronGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new TetrahedronGeometry(e.radius, e.detail);
                },
              },
            ]),
            TetrahedronGeometry
          );
        })(Zs),
        pu = (function (e) {
          function TorusGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0.4,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 8,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 6,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 2 * Math.PI;
            Object(f.a)(this, TorusGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(TorusGeometry).call(this)
              )).type = "TorusGeometry"),
              (e.parameters = {
                radius: t,
                tube: n,
                radialSegments: i,
                tubularSegments: a,
                arc: o,
              }),
              (i = Math.floor(i)),
              (a = Math.floor(a));
            for (
              var u = [],
                l = [],
                c = [],
                h = [],
                d = new ir(),
                p = new ir(),
                m = new ir(),
                v = 0;
              v <= i;
              v++
            )
              for (var g = 0; g <= a; g++) {
                var y = (g / a) * o,
                  b = (v / i) * Math.PI * 2;
                (p.x = (t + n * Math.cos(b)) * Math.cos(y)),
                  (p.y = (t + n * Math.cos(b)) * Math.sin(y)),
                  (p.z = n * Math.sin(b)),
                  l.push(p.x, p.y, p.z),
                  (d.x = t * Math.cos(y)),
                  (d.y = t * Math.sin(y)),
                  m.subVectors(p, d).normalize(),
                  c.push(m.x, m.y, m.z),
                  h.push(g / a),
                  h.push(v / i);
              }
            for (var x = 1; x <= i; x++)
              for (var _ = 1; _ <= a; _++) {
                var M = (a + 1) * x + _ - 1,
                  S = (a + 1) * (x - 1) + _ - 1,
                  w = (a + 1) * (x - 1) + _,
                  T = (a + 1) * x + _;
                u.push(M, S, T), u.push(S, w, T);
              }
            return (
              e.setIndex(u),
              e.setAttribute("position", new Ei(l, 3)),
              e.setAttribute("normal", new Ei(c, 3)),
              e.setAttribute("uv", new Ei(h, 2)),
              e
            );
          }
          return (
            Object(u.a)(TorusGeometry, e),
            Object(p.a)(TorusGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new TorusGeometry(
                    e.radius,
                    e.tube,
                    e.radialSegments,
                    e.tubularSegments,
                    e.arc
                  );
                },
              },
            ]),
            TorusGeometry
          );
        })(Fi),
        mu = (function (e) {
          function TorusKnotGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0.4,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 64,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 8,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 2,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 3;
            Object(f.a)(this, TorusKnotGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(TorusKnotGeometry).call(this)
              )).type = "TorusKnotGeometry"),
              (e.parameters = {
                radius: t,
                tube: n,
                tubularSegments: i,
                radialSegments: a,
                p: o,
                q: u,
              }),
              (i = Math.floor(i)),
              (a = Math.floor(a));
            for (
              var l = [],
                c = [],
                h = [],
                d = [],
                p = new ir(),
                m = new ir(),
                v = new ir(),
                g = new ir(),
                y = new ir(),
                b = new ir(),
                x = new ir(),
                _ = 0;
              _ <= i;
              ++_
            ) {
              var M = (_ / i) * o * Math.PI * 2;
              calculatePositionOnCurve(M, o, u, t, v),
                calculatePositionOnCurve(M + 0.01, o, u, t, g),
                b.subVectors(g, v),
                x.addVectors(g, v),
                y.crossVectors(b, x),
                x.crossVectors(y, b),
                y.normalize(),
                x.normalize();
              for (var S = 0; S <= a; ++S) {
                var w = (S / a) * Math.PI * 2,
                  T = -n * Math.cos(w),
                  A = n * Math.sin(w);
                (p.x = v.x + (T * x.x + A * y.x)),
                  (p.y = v.y + (T * x.y + A * y.y)),
                  (p.z = v.z + (T * x.z + A * y.z)),
                  c.push(p.x, p.y, p.z),
                  m.subVectors(p, v).normalize(),
                  h.push(m.x, m.y, m.z),
                  d.push(_ / i),
                  d.push(S / a);
              }
            }
            for (var O = 1; O <= i; O++)
              for (var C = 1; C <= a; C++) {
                var L = (a + 1) * (O - 1) + (C - 1),
                  k = (a + 1) * O + (C - 1),
                  E = (a + 1) * O + C,
                  P = (a + 1) * (O - 1) + C;
                l.push(L, k, P), l.push(k, E, P);
              }
            function calculatePositionOnCurve(e, t, n, r, i) {
              var a = Math.cos(e),
                o = Math.sin(e),
                s = (n / t) * e,
                u = Math.cos(s);
              (i.x = r * (2 + u) * 0.5 * a),
                (i.y = r * (2 + u) * o * 0.5),
                (i.z = r * Math.sin(s) * 0.5);
            }
            return (
              e.setIndex(l),
              e.setAttribute("position", new Ei(c, 3)),
              e.setAttribute("normal", new Ei(h, 3)),
              e.setAttribute("uv", new Ei(d, 2)),
              e
            );
          }
          return (
            Object(u.a)(TorusKnotGeometry, e),
            Object(p.a)(TorusKnotGeometry, null, [
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return new TorusKnotGeometry(
                    e.radius,
                    e.tube,
                    e.tubularSegments,
                    e.radialSegments,
                    e.p,
                    e.q
                  );
                },
              },
            ]),
            TorusKnotGeometry
          );
        })(Fi),
        vu = (function (e) {
          function TubeGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Fs(
                      new ir(-1, -1, 0),
                      new ir(-1, 1, 0),
                      new ir(1, 1, 0)
                    ),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 64,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 8,
              o =
                arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            Object(f.a)(this, TubeGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(TubeGeometry).call(this)
              )).type = "TubeGeometry"),
              (e.parameters = {
                path: t,
                tubularSegments: n,
                radius: i,
                radialSegments: a,
                closed: o,
              });
            var u = t.computeFrenetFrames(n, o);
            (e.tangents = u.tangents),
              (e.normals = u.normals),
              (e.binormals = u.binormals);
            var l = new ir(),
              c = new ir(),
              h = new Dn(),
              d = new ir(),
              p = [],
              m = [],
              v = [],
              g = [];
            function generateSegment(e) {
              d = t.getPointAt(e / n, d);
              for (
                var r = u.normals[e], o = u.binormals[e], s = 0;
                s <= a;
                s++
              ) {
                var h = (s / a) * Math.PI * 2,
                  f = Math.sin(h),
                  v = -Math.cos(h);
                (c.x = v * r.x + f * o.x),
                  (c.y = v * r.y + f * o.y),
                  (c.z = v * r.z + f * o.z),
                  c.normalize(),
                  m.push(c.x, c.y, c.z),
                  (l.x = d.x + i * c.x),
                  (l.y = d.y + i * c.y),
                  (l.z = d.z + i * c.z),
                  p.push(l.x, l.y, l.z);
              }
            }
            return (
              (function generateBufferData() {
                for (var e = 0; e < n; e++) generateSegment(e);
                generateSegment(!1 === o ? n : 0),
                  (function generateUVs() {
                    for (var e = 0; e <= n; e++)
                      for (var t = 0; t <= a; t++)
                        (h.x = e / n), (h.y = t / a), v.push(h.x, h.y);
                  })(),
                  (function generateIndices() {
                    for (var e = 1; e <= n; e++)
                      for (var t = 1; t <= a; t++) {
                        var r = (a + 1) * (e - 1) + (t - 1),
                          i = (a + 1) * e + (t - 1),
                          o = (a + 1) * e + t,
                          s = (a + 1) * (e - 1) + t;
                        g.push(r, i, s), g.push(i, o, s);
                      }
                  })();
              })(),
              e.setIndex(g),
              e.setAttribute("position", new Ei(p, 3)),
              e.setAttribute("normal", new Ei(m, 3)),
              e.setAttribute("uv", new Ei(v, 2)),
              e
            );
          }
          return (
            Object(u.a)(TubeGeometry, e),
            Object(p.a)(
              TubeGeometry,
              [
                {
                  key: "toJSON",
                  value: function toJSON() {
                    var e = Object(o.a)(
                      Object(r.a)(TubeGeometry.prototype),
                      "toJSON",
                      this
                    ).call(this);
                    return (e.path = this.parameters.path.toJSON()), e;
                  },
                },
              ],
              [
                {
                  key: "fromJSON",
                  value: function fromJSON(e) {
                    return new TubeGeometry(
                      new Us[e.path.type]().fromJSON(e.path),
                      e.tubularSegments,
                      e.radius,
                      e.radialSegments,
                      e.closed
                    );
                  },
                },
              ]
            ),
            TubeGeometry
          );
        })(Fi),
        gu = (function (e) {
          function WireframeGeometry() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : null;
            if (
              (Object(f.a)(this, WireframeGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(WireframeGeometry).call(this)
              )).type = "WireframeGeometry"),
              (e.parameters = { geometry: t }),
              null !== t)
            ) {
              var n = [],
                i = new Set(),
                a = new ir(),
                o = new ir();
              if (null !== t.index) {
                var u = t.attributes.position,
                  l = t.index,
                  c = t.groups;
                0 === c.length &&
                  (c = [{ start: 0, count: l.count, materialIndex: 0 }]);
                for (var h = 0, d = c.length; h < d; ++h)
                  for (
                    var p = c[h], m = p.start, v = m, g = m + p.count;
                    v < g;
                    v += 3
                  )
                    for (var y = 0; y < 3; y++) {
                      var b = l.getX(v + y),
                        x = l.getX(v + ((y + 1) % 3));
                      a.fromBufferAttribute(u, b),
                        o.fromBufferAttribute(u, x),
                        !0 === isUniqueEdge(a, o, i) &&
                          (n.push(a.x, a.y, a.z), n.push(o.x, o.y, o.z));
                    }
              } else
                for (
                  var _ = t.attributes.position, M = 0, S = _.count / 3;
                  M < S;
                  M++
                )
                  for (var w = 0; w < 3; w++) {
                    var T = 3 * M + w,
                      A = 3 * M + ((w + 1) % 3);
                    a.fromBufferAttribute(_, T),
                      o.fromBufferAttribute(_, A),
                      !0 === isUniqueEdge(a, o, i) &&
                        (n.push(a.x, a.y, a.z), n.push(o.x, o.y, o.z));
                  }
              e.setAttribute("position", new Ei(n, 3));
            }
            return e;
          }
          return Object(u.a)(WireframeGeometry, e), WireframeGeometry;
        })(Fi);
      function isUniqueEdge(e, t, n) {
        var r = ""
            .concat(e.x, ",")
            .concat(e.y, ",")
            .concat(e.z, "-")
            .concat(t.x, ",")
            .concat(t.y, ",")
            .concat(t.z),
          i = ""
            .concat(t.x, ",")
            .concat(t.y, ",")
            .concat(t.z, "-")
            .concat(e.x, ",")
            .concat(e.y, ",")
            .concat(e.z);
        return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0);
      }
      var yu = Object.freeze({
          __proto__: null,
          BoxGeometry: aa,
          BoxBufferGeometry: aa,
          CapsuleGeometry: qs,
          CapsuleBufferGeometry: qs,
          CircleGeometry: Xs,
          CircleBufferGeometry: Xs,
          ConeGeometry: Ys,
          ConeBufferGeometry: Ys,
          CylinderGeometry: Js,
          CylinderBufferGeometry: Js,
          DodecahedronGeometry: Ks,
          DodecahedronBufferGeometry: Ks,
          EdgesGeometry: nu,
          ExtrudeGeometry: ou,
          ExtrudeBufferGeometry: ou,
          IcosahedronGeometry: uu,
          IcosahedronBufferGeometry: uu,
          LatheGeometry: Hs,
          LatheBufferGeometry: Hs,
          OctahedronGeometry: lu,
          OctahedronBufferGeometry: lu,
          PlaneGeometry: wa,
          PlaneBufferGeometry: wa,
          PolyhedronGeometry: Zs,
          PolyhedronBufferGeometry: Zs,
          RingGeometry: cu,
          RingBufferGeometry: cu,
          ShapeGeometry: hu,
          ShapeBufferGeometry: hu,
          SphereGeometry: du,
          SphereBufferGeometry: du,
          TetrahedronGeometry: fu,
          TetrahedronBufferGeometry: fu,
          TorusGeometry: pu,
          TorusBufferGeometry: pu,
          TorusKnotGeometry: mu,
          TorusKnotBufferGeometry: mu,
          TubeGeometry: vu,
          TubeBufferGeometry: vu,
          WireframeGeometry: gu,
        }),
        bu = (function (e) {
          function ShadowMaterial(e) {
            var t;
            return (
              Object(f.a)(this, ShadowMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(ShadowMaterial).call(this)
              )).isShadowMaterial = !0),
              (t.type = "ShadowMaterial"),
              (t.color = new Hn(0)),
              (t.transparent = !0),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(ShadowMaterial, e),
            Object(p.a)(ShadowMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(ShadowMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            ShadowMaterial
          );
        })(yi),
        xu = (function (e) {
          function RawShaderMaterial(e) {
            var t;
            return (
              Object(f.a)(this, RawShaderMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(RawShaderMaterial).call(this, e)
              )).isRawShaderMaterial = !0),
              (t.type = "RawShaderMaterial"),
              t
            );
          }
          return Object(u.a)(RawShaderMaterial, e), RawShaderMaterial;
        })(la),
        _u = (function (e) {
          function MeshStandardMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshStandardMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshStandardMaterial).call(this)
              )).isMeshStandardMaterial = !0),
              (t.defines = { STANDARD: "" }),
              (t.type = "MeshStandardMaterial"),
              (t.color = new Hn(16777215)),
              (t.roughness = 1),
              (t.metalness = 0),
              (t.map = null),
              (t.lightMap = null),
              (t.lightMapIntensity = 1),
              (t.aoMap = null),
              (t.aoMapIntensity = 1),
              (t.emissive = new Hn(0)),
              (t.emissiveIntensity = 1),
              (t.emissiveMap = null),
              (t.bumpMap = null),
              (t.bumpScale = 1),
              (t.normalMap = null),
              (t.normalMapType = Yt),
              (t.normalScale = new Dn(1, 1)),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              (t.roughnessMap = null),
              (t.metalnessMap = null),
              (t.alphaMap = null),
              (t.envMap = null),
              (t.envMapIntensity = 1),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.wireframeLinecap = "round"),
              (t.wireframeLinejoin = "round"),
              (t.flatShading = !1),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshStandardMaterial, e),
            Object(p.a)(MeshStandardMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshStandardMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.defines = { STANDARD: "" }),
                    this.color.copy(e.color),
                    (this.roughness = e.roughness),
                    (this.metalness = e.metalness),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.roughnessMap = e.roughnessMap),
                    (this.metalnessMap = e.metalnessMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.envMapIntensity = e.envMapIntensity),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.flatShading = e.flatShading),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            MeshStandardMaterial
          );
        })(yi),
        Mu = (function (e) {
          function MeshPhysicalMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshPhysicalMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshPhysicalMaterial).call(this)
              )).isMeshPhysicalMaterial = !0),
              (t.defines = { STANDARD: "", PHYSICAL: "" }),
              (t.type = "MeshPhysicalMaterial"),
              (t.clearcoatMap = null),
              (t.clearcoatRoughness = 0),
              (t.clearcoatRoughnessMap = null),
              (t.clearcoatNormalScale = new Dn(1, 1)),
              (t.clearcoatNormalMap = null),
              (t.ior = 1.5),
              Object.defineProperty(
                Object(l.a)(Object(l.a)(t)),
                "reflectivity",
                {
                  get: function get() {
                    return clamp((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                  },
                  set: function set(e) {
                    this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
                  },
                }
              ),
              (t.iridescenceMap = null),
              (t.iridescenceIOR = 1.3),
              (t.iridescenceThicknessRange = [100, 400]),
              (t.iridescenceThicknessMap = null),
              (t.sheenColor = new Hn(0)),
              (t.sheenColorMap = null),
              (t.sheenRoughness = 1),
              (t.sheenRoughnessMap = null),
              (t.transmissionMap = null),
              (t.thickness = 0),
              (t.thicknessMap = null),
              (t.attenuationDistance = 0),
              (t.attenuationColor = new Hn(1, 1, 1)),
              (t.specularIntensity = 1),
              (t.specularIntensityMap = null),
              (t.specularColor = new Hn(1, 1, 1)),
              (t.specularColorMap = null),
              (t._sheen = 0),
              (t._clearcoat = 0),
              (t._iridescence = 0),
              (t._transmission = 0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshPhysicalMaterial, e),
            Object(p.a)(MeshPhysicalMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshPhysicalMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.defines = { STANDARD: "", PHYSICAL: "" }),
                    (this.clearcoat = e.clearcoat),
                    (this.clearcoatMap = e.clearcoatMap),
                    (this.clearcoatRoughness = e.clearcoatRoughness),
                    (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
                    (this.clearcoatNormalMap = e.clearcoatNormalMap),
                    this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                    (this.ior = e.ior),
                    (this.iridescence = e.iridescence),
                    (this.iridescenceMap = e.iridescenceMap),
                    (this.iridescenceIOR = e.iridescenceIOR),
                    (this.iridescenceThicknessRange = _toConsumableArray(
                      e.iridescenceThicknessRange
                    )),
                    (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
                    (this.sheen = e.sheen),
                    this.sheenColor.copy(e.sheenColor),
                    (this.sheenColorMap = e.sheenColorMap),
                    (this.sheenRoughness = e.sheenRoughness),
                    (this.sheenRoughnessMap = e.sheenRoughnessMap),
                    (this.transmission = e.transmission),
                    (this.transmissionMap = e.transmissionMap),
                    (this.thickness = e.thickness),
                    (this.thicknessMap = e.thicknessMap),
                    (this.attenuationDistance = e.attenuationDistance),
                    this.attenuationColor.copy(e.attenuationColor),
                    (this.specularIntensity = e.specularIntensity),
                    (this.specularIntensityMap = e.specularIntensityMap),
                    this.specularColor.copy(e.specularColor),
                    (this.specularColorMap = e.specularColorMap),
                    this
                  );
                },
              },
              {
                key: "sheen",
                get: function get() {
                  return this._sheen;
                },
                set: function set(e) {
                  this._sheen > 0 !== e > 0 && this.version++,
                    (this._sheen = e);
                },
              },
              {
                key: "clearcoat",
                get: function get() {
                  return this._clearcoat;
                },
                set: function set(e) {
                  this._clearcoat > 0 !== e > 0 && this.version++,
                    (this._clearcoat = e);
                },
              },
              {
                key: "iridescence",
                get: function get() {
                  return this._iridescence;
                },
                set: function set(e) {
                  this._iridescence > 0 !== e > 0 && this.version++,
                    (this._iridescence = e);
                },
              },
              {
                key: "transmission",
                get: function get() {
                  return this._transmission;
                },
                set: function set(e) {
                  this._transmission > 0 !== e > 0 && this.version++,
                    (this._transmission = e);
                },
              },
            ]),
            MeshPhysicalMaterial
          );
        })(_u),
        Su = (function (e) {
          function MeshPhongMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshPhongMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshPhongMaterial).call(this)
              )).isMeshPhongMaterial = !0),
              (t.type = "MeshPhongMaterial"),
              (t.color = new Hn(16777215)),
              (t.specular = new Hn(1118481)),
              (t.shininess = 30),
              (t.map = null),
              (t.lightMap = null),
              (t.lightMapIntensity = 1),
              (t.aoMap = null),
              (t.aoMapIntensity = 1),
              (t.emissive = new Hn(0)),
              (t.emissiveIntensity = 1),
              (t.emissiveMap = null),
              (t.bumpMap = null),
              (t.bumpScale = 1),
              (t.normalMap = null),
              (t.normalMapType = Yt),
              (t.normalScale = new Dn(1, 1)),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              (t.specularMap = null),
              (t.alphaMap = null),
              (t.envMap = null),
              (t.combine = ue),
              (t.reflectivity = 1),
              (t.refractionRatio = 0.98),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.wireframeLinecap = "round"),
              (t.wireframeLinejoin = "round"),
              (t.flatShading = !1),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshPhongMaterial, e),
            Object(p.a)(MeshPhongMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshPhongMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    this.specular.copy(e.specular),
                    (this.shininess = e.shininess),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.specularMap = e.specularMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.combine = e.combine),
                    (this.reflectivity = e.reflectivity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.flatShading = e.flatShading),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            MeshPhongMaterial
          );
        })(yi),
        wu = (function (e) {
          function MeshToonMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshToonMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshToonMaterial).call(this)
              )).isMeshToonMaterial = !0),
              (t.defines = { TOON: "" }),
              (t.type = "MeshToonMaterial"),
              (t.color = new Hn(16777215)),
              (t.map = null),
              (t.gradientMap = null),
              (t.lightMap = null),
              (t.lightMapIntensity = 1),
              (t.aoMap = null),
              (t.aoMapIntensity = 1),
              (t.emissive = new Hn(0)),
              (t.emissiveIntensity = 1),
              (t.emissiveMap = null),
              (t.bumpMap = null),
              (t.bumpScale = 1),
              (t.normalMap = null),
              (t.normalMapType = Yt),
              (t.normalScale = new Dn(1, 1)),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              (t.alphaMap = null),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.wireframeLinecap = "round"),
              (t.wireframeLinejoin = "round"),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshToonMaterial, e),
            Object(p.a)(MeshToonMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshToonMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.gradientMap = e.gradientMap),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.alphaMap = e.alphaMap),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            MeshToonMaterial
          );
        })(yi),
        Tu = (function (e) {
          function MeshNormalMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshNormalMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshNormalMaterial).call(this)
              )).isMeshNormalMaterial = !0),
              (t.type = "MeshNormalMaterial"),
              (t.bumpMap = null),
              (t.bumpScale = 1),
              (t.normalMap = null),
              (t.normalMapType = Yt),
              (t.normalScale = new Dn(1, 1)),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.flatShading = !1),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshNormalMaterial, e),
            Object(p.a)(MeshNormalMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshNormalMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.flatShading = e.flatShading),
                    this
                  );
                },
              },
            ]),
            MeshNormalMaterial
          );
        })(yi),
        Au = (function (e) {
          function MeshLambertMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshLambertMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshLambertMaterial).call(this)
              )).isMeshLambertMaterial = !0),
              (t.type = "MeshLambertMaterial"),
              (t.color = new Hn(16777215)),
              (t.map = null),
              (t.lightMap = null),
              (t.lightMapIntensity = 1),
              (t.aoMap = null),
              (t.aoMapIntensity = 1),
              (t.emissive = new Hn(0)),
              (t.emissiveIntensity = 1),
              (t.emissiveMap = null),
              (t.specularMap = null),
              (t.alphaMap = null),
              (t.envMap = null),
              (t.combine = ue),
              (t.reflectivity = 1),
              (t.refractionRatio = 0.98),
              (t.wireframe = !1),
              (t.wireframeLinewidth = 1),
              (t.wireframeLinecap = "round"),
              (t.wireframeLinejoin = "round"),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshLambertMaterial, e),
            Object(p.a)(MeshLambertMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshLambertMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.specularMap = e.specularMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.combine = e.combine),
                    (this.reflectivity = e.reflectivity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            MeshLambertMaterial
          );
        })(yi),
        Ou = (function (e) {
          function MeshMatcapMaterial(e) {
            var t;
            return (
              Object(f.a)(this, MeshMatcapMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MeshMatcapMaterial).call(this)
              )).isMeshMatcapMaterial = !0),
              (t.defines = { MATCAP: "" }),
              (t.type = "MeshMatcapMaterial"),
              (t.color = new Hn(16777215)),
              (t.matcap = null),
              (t.map = null),
              (t.bumpMap = null),
              (t.bumpScale = 1),
              (t.normalMap = null),
              (t.normalMapType = Yt),
              (t.normalScale = new Dn(1, 1)),
              (t.displacementMap = null),
              (t.displacementScale = 1),
              (t.displacementBias = 0),
              (t.alphaMap = null),
              (t.flatShading = !1),
              (t.fog = !0),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(MeshMatcapMaterial, e),
            Object(p.a)(MeshMatcapMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(MeshMatcapMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.defines = { MATCAP: "" }),
                    this.color.copy(e.color),
                    (this.matcap = e.matcap),
                    (this.map = e.map),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.alphaMap = e.alphaMap),
                    (this.flatShading = e.flatShading),
                    (this.fog = e.fog),
                    this
                  );
                },
              },
            ]),
            MeshMatcapMaterial
          );
        })(yi),
        Cu = (function (e) {
          function LineDashedMaterial(e) {
            var t;
            return (
              Object(f.a)(this, LineDashedMaterial),
              ((t = Object(s.a)(
                this,
                Object(r.a)(LineDashedMaterial).call(this)
              )).isLineDashedMaterial = !0),
              (t.type = "LineDashedMaterial"),
              (t.scale = 1),
              (t.dashSize = 3),
              (t.gapSize = 1),
              t.setValues(e),
              t
            );
          }
          return (
            Object(u.a)(LineDashedMaterial, e),
            Object(p.a)(LineDashedMaterial, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LineDashedMaterial.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.scale = e.scale),
                    (this.dashSize = e.dashSize),
                    (this.gapSize = e.gapSize),
                    this
                  );
                },
              },
            ]),
            LineDashedMaterial
          );
        })(os);
      function arraySlice(e, t, n) {
        return isTypedArray(e)
          ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
          : e.slice(t, n);
      }
      function convertArray(e, t, n) {
        return !e || (!n && e.constructor === t)
          ? e
          : "number" === typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      }
      function isTypedArray(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function getKeyframeOrder(e) {
        for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r) n[r] = r;
        return (
          n.sort(function compareTime(t, n) {
            return e[t] - e[n];
          }),
          n
        );
      }
      function sortedArray(e, t, n) {
        for (
          var r = e.length, i = new e.constructor(r), a = 0, o = 0;
          o !== r;
          ++a
        )
          for (var s = n[a] * t, u = 0; u !== t; ++u) i[o++] = e[s + u];
        return i;
      }
      function flattenJSON(e, t, n, r) {
        for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r]; ) a = e[i++];
        if (void 0 !== a) {
          var o = a[r];
          if (void 0 !== o)
            if (Array.isArray(o))
              do {
                void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)),
                  (a = e[i++]);
              } while (void 0 !== a);
            else if (void 0 !== o.toArray)
              do {
                void 0 !== (o = a[r]) &&
                  (t.push(a.time), o.toArray(n, n.length)),
                  (a = e[i++]);
              } while (void 0 !== a);
            else
              do {
                void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)),
                  (a = e[i++]);
              } while (void 0 !== a);
        }
      }
      var Lu = Object.freeze({
          __proto__: null,
          arraySlice: arraySlice,
          convertArray: convertArray,
          isTypedArray: isTypedArray,
          getKeyframeOrder: getKeyframeOrder,
          sortedArray: sortedArray,
          flattenJSON: flattenJSON,
          subclip: function subclip(e, t, n, r) {
            var i =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 30,
              a = e.clone();
            a.name = t;
            for (var o = [], s = 0; s < a.tracks.length; ++s) {
              for (
                var u = a.tracks[s],
                  l = u.getValueSize(),
                  c = [],
                  h = [],
                  d = 0;
                d < u.times.length;
                ++d
              ) {
                var f = u.times[d] * i;
                if (!(f < n || f >= r)) {
                  c.push(u.times[d]);
                  for (var p = 0; p < l; ++p) h.push(u.values[d * l + p]);
                }
              }
              0 !== c.length &&
                ((u.times = convertArray(c, u.times.constructor)),
                (u.values = convertArray(h, u.values.constructor)),
                o.push(u));
            }
            a.tracks = o;
            for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v)
              m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
            for (var g = 0; g < a.tracks.length; ++g) a.tracks[g].shift(-1 * m);
            return a.resetDuration(), a;
          },
          makeClipAdditive: function makeClipAdditive(e) {
            var t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : e,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 30;
            r <= 0 && (r = 30);
            for (
              var i = n.tracks.length,
                a = t / r,
                o = function _loop(t) {
                  var r = n.tracks[t],
                    i = r.ValueTypeName;
                  if ("bool" === i || "string" === i) return "continue";
                  var o = e.tracks.find(function (e) {
                    return e.name === r.name && e.ValueTypeName === i;
                  });
                  if (void 0 === o) return "continue";
                  var s = 0,
                    u = r.getValueSize();
                  r.createInterpolant
                    .isInterpolantFactoryMethodGLTFCubicSpline && (s = u / 3);
                  var l = 0,
                    c = o.getValueSize();
                  o.createInterpolant
                    .isInterpolantFactoryMethodGLTFCubicSpline && (l = c / 3);
                  var h = r.times.length - 1,
                    d = void 0;
                  if (a <= r.times[0]) {
                    var f = s,
                      p = u - s;
                    d = arraySlice(r.values, f, p);
                  } else if (a >= r.times[h]) {
                    var m = h * u + s,
                      v = m + u - s;
                    d = arraySlice(r.values, m, v);
                  } else {
                    var g = r.createInterpolant(),
                      y = s,
                      b = u - s;
                    g.evaluate(a), (d = arraySlice(g.resultBuffer, y, b));
                  }
                  "quaternion" === i &&
                    new rr().fromArray(d).normalize().conjugate().toArray(d);
                  for (var x = o.times.length, _ = 0; _ < x; ++_) {
                    var M = _ * c + l;
                    if ("quaternion" === i)
                      rr.multiplyQuaternionsFlat(
                        o.values,
                        M,
                        d,
                        0,
                        o.values,
                        M
                      );
                    else
                      for (var S = c - 2 * l, w = 0; w < S; ++w)
                        o.values[M + w] -= d[w];
                  }
                },
                s = 0;
              s < i;
              ++s
            )
              o(s);
            return (e.blendMode = Gt), e;
          },
        }),
        ku = (function () {
          function Interpolant(e, t, n, r) {
            Object(f.a)(this, Interpolant),
              (this.parameterPositions = e),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== r ? r : new t.constructor(n)),
              (this.sampleValues = t),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          return (
            Object(p.a)(Interpolant, [
              {
                key: "evaluate",
                value: function evaluate(e) {
                  var t = this.parameterPositions,
                    n = this._cachedIndex,
                    r = t[n],
                    i = t[n - 1];
                  e: {
                    t: {
                      var a;
                      n: {
                        r: if (!(e < r)) {
                          for (var o = n + 2; ; ) {
                            if (void 0 === r) {
                              if (e < i) break r;
                              return (
                                (n = t.length),
                                (this._cachedIndex = n),
                                this.copySampleValue_(n - 1)
                              );
                            }
                            if (n === o) break;
                            if (((i = r), e < (r = t[++n]))) break t;
                          }
                          a = t.length;
                          break n;
                        }
                        if (e >= i) break e;
                        var s = t[1];
                        e < s && ((n = 2), (i = s));
                        for (var u = n - 2; ; ) {
                          if (void 0 === i)
                            return (
                              (this._cachedIndex = 0), this.copySampleValue_(0)
                            );
                          if (n === u) break;
                          if (((r = i), e >= (i = t[--n - 1]))) break t;
                        }
                        (a = n), (n = 0);
                      }
                      for (; n < a; ) {
                        var l = (n + a) >>> 1;
                        e < t[l] ? (a = l) : (n = l + 1);
                      }
                      if (((r = t[n]), void 0 === (i = t[n - 1])))
                        return (
                          (this._cachedIndex = 0), this.copySampleValue_(0)
                        );
                      if (void 0 === r)
                        return (
                          (n = t.length),
                          (this._cachedIndex = n),
                          this.copySampleValue_(n - 1)
                        );
                    }
                    (this._cachedIndex = n), this.intervalChanged_(n, i, r);
                  }
                  return this.interpolate_(n, i, e, r);
                },
              },
              {
                key: "getSettings_",
                value: function getSettings_() {
                  return this.settings || this.DefaultSettings_;
                },
              },
              {
                key: "copySampleValue_",
                value: function copySampleValue_(e) {
                  for (
                    var t = this.resultBuffer,
                      n = this.sampleValues,
                      r = this.valueSize,
                      i = e * r,
                      a = 0;
                    a !== r;
                    ++a
                  )
                    t[a] = n[i + a];
                  return t;
                },
              },
              {
                key: "interpolate_",
                value: function interpolate_() {
                  throw new Error("call to abstract method");
                },
              },
              {
                key: "intervalChanged_",
                value: function intervalChanged_() {},
              },
            ]),
            Interpolant
          );
        })(),
        Eu = (function (e) {
          function CubicInterpolant(e, t, n, i) {
            var a;
            return (
              Object(f.a)(this, CubicInterpolant),
              ((a = Object(s.a)(
                this,
                Object(r.a)(CubicInterpolant).call(this, e, t, n, i)
              ))._weightPrev = -0),
              (a._offsetPrev = -0),
              (a._weightNext = -0),
              (a._offsetNext = -0),
              (a.DefaultSettings_ = { endingStart: Bt, endingEnd: Bt }),
              a
            );
          }
          return (
            Object(u.a)(CubicInterpolant, e),
            Object(p.a)(CubicInterpolant, [
              {
                key: "intervalChanged_",
                value: function intervalChanged_(e, t, n) {
                  var r = this.parameterPositions,
                    i = e - 2,
                    a = e + 1,
                    o = r[i],
                    s = r[a];
                  if (void 0 === o)
                    switch (this.getSettings_().endingStart) {
                      case Nt:
                        (i = e), (o = 2 * t - n);
                        break;
                      case zt:
                        o = t + r[(i = r.length - 2)] - r[i + 1];
                        break;
                      default:
                        (i = e), (o = n);
                    }
                  if (void 0 === s)
                    switch (this.getSettings_().endingEnd) {
                      case Nt:
                        (a = e), (s = 2 * n - t);
                        break;
                      case zt:
                        (a = 1), (s = n + r[1] - r[0]);
                        break;
                      default:
                        (a = e - 1), (s = t);
                    }
                  var u = 0.5 * (n - t),
                    l = this.valueSize;
                  (this._weightPrev = u / (t - o)),
                    (this._weightNext = u / (s - n)),
                    (this._offsetPrev = i * l),
                    (this._offsetNext = a * l);
                },
              },
              {
                key: "interpolate_",
                value: function interpolate_(e, t, n, r) {
                  for (
                    var i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = e * o,
                      u = s - o,
                      l = this._offsetPrev,
                      c = this._offsetNext,
                      h = this._weightPrev,
                      d = this._weightNext,
                      f = (n - t) / (r - t),
                      p = f * f,
                      m = p * f,
                      v = -h * m + 2 * h * p - h * f,
                      g = (1 + h) * m + (-1.5 - 2 * h) * p + (-0.5 + h) * f + 1,
                      y = (-1 - d) * m + (1.5 + d) * p + 0.5 * f,
                      b = d * m - d * p,
                      x = 0;
                    x !== o;
                    ++x
                  )
                    i[x] =
                      v * a[l + x] + g * a[u + x] + y * a[s + x] + b * a[c + x];
                  return i;
                },
              },
            ]),
            CubicInterpolant
          );
        })(ku),
        Pu = (function (e) {
          function LinearInterpolant(e, t, n, i) {
            return (
              Object(f.a)(this, LinearInterpolant),
              Object(s.a)(
                this,
                Object(r.a)(LinearInterpolant).call(this, e, t, n, i)
              )
            );
          }
          return (
            Object(u.a)(LinearInterpolant, e),
            Object(p.a)(LinearInterpolant, [
              {
                key: "interpolate_",
                value: function interpolate_(e, t, n, r) {
                  for (
                    var i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = e * o,
                      u = s - o,
                      l = (n - t) / (r - t),
                      c = 1 - l,
                      h = 0;
                    h !== o;
                    ++h
                  )
                    i[h] = a[u + h] * c + a[s + h] * l;
                  return i;
                },
              },
            ]),
            LinearInterpolant
          );
        })(ku),
        Ru = (function (e) {
          function DiscreteInterpolant(e, t, n, i) {
            return (
              Object(f.a)(this, DiscreteInterpolant),
              Object(s.a)(
                this,
                Object(r.a)(DiscreteInterpolant).call(this, e, t, n, i)
              )
            );
          }
          return (
            Object(u.a)(DiscreteInterpolant, e),
            Object(p.a)(DiscreteInterpolant, [
              {
                key: "interpolate_",
                value: function interpolate_(e) {
                  return this.copySampleValue_(e - 1);
                },
              },
            ]),
            DiscreteInterpolant
          );
        })(ku),
        Iu = (function () {
          function KeyframeTrack(e, t, n, r) {
            if ((Object(f.a)(this, KeyframeTrack), void 0 === e))
              throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length)
              throw new Error(
                "THREE.KeyframeTrack: no keyframes in track named " + e
              );
            (this.name = e),
              (this.times = convertArray(t, this.TimeBufferType)),
              (this.values = convertArray(n, this.ValueBufferType)),
              this.setInterpolation(r || this.DefaultInterpolation);
          }
          return (
            Object(p.a)(
              KeyframeTrack,
              [
                {
                  key: "InterpolantFactoryMethodDiscrete",
                  value: function InterpolantFactoryMethodDiscrete(e) {
                    return new Ru(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      e
                    );
                  },
                },
                {
                  key: "InterpolantFactoryMethodLinear",
                  value: function InterpolantFactoryMethodLinear(e) {
                    return new Pu(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      e
                    );
                  },
                },
                {
                  key: "InterpolantFactoryMethodSmooth",
                  value: function InterpolantFactoryMethodSmooth(e) {
                    return new Eu(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      e
                    );
                  },
                },
                {
                  key: "setInterpolation",
                  value: function setInterpolation(e) {
                    var t;
                    switch (e) {
                      case It:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                      case Dt:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                      case jt:
                        t = this.InterpolantFactoryMethodSmooth;
                    }
                    if (void 0 === t) {
                      var n =
                        "unsupported interpolation for " +
                        this.ValueTypeName +
                        " keyframe track named " +
                        this.name;
                      if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(n);
                        this.setInterpolation(this.DefaultInterpolation);
                      }
                      return console.warn("THREE.KeyframeTrack:", n), this;
                    }
                    return (this.createInterpolant = t), this;
                  },
                },
                {
                  key: "getInterpolation",
                  value: function getInterpolation() {
                    switch (this.createInterpolant) {
                      case this.InterpolantFactoryMethodDiscrete:
                        return It;
                      case this.InterpolantFactoryMethodLinear:
                        return Dt;
                      case this.InterpolantFactoryMethodSmooth:
                        return jt;
                    }
                  },
                },
                {
                  key: "getValueSize",
                  value: function getValueSize() {
                    return this.values.length / this.times.length;
                  },
                },
                {
                  key: "shift",
                  value: function shift(e) {
                    if (0 !== e)
                      for (
                        var t = this.times, n = 0, r = t.length;
                        n !== r;
                        ++n
                      )
                        t[n] += e;
                    return this;
                  },
                },
                {
                  key: "scale",
                  value: function scale(e) {
                    if (1 !== e)
                      for (
                        var t = this.times, n = 0, r = t.length;
                        n !== r;
                        ++n
                      )
                        t[n] *= e;
                    return this;
                  },
                },
                {
                  key: "trim",
                  value: function trim(e, t) {
                    for (
                      var n = this.times, r = n.length, i = 0, a = r - 1;
                      i !== r && n[i] < e;

                    )
                      ++i;
                    for (; -1 !== a && n[a] > t; ) --a;
                    if ((++a, 0 !== i || a !== r)) {
                      i >= a && (i = (a = Math.max(a, 1)) - 1);
                      var o = this.getValueSize();
                      (this.times = arraySlice(n, i, a)),
                        (this.values = arraySlice(this.values, i * o, a * o));
                    }
                    return this;
                  },
                },
                {
                  key: "validate",
                  value: function validate() {
                    var e = !0,
                      t = this.getValueSize();
                    t - Math.floor(t) !== 0 &&
                      (console.error(
                        "THREE.KeyframeTrack: Invalid value size in track.",
                        this
                      ),
                      (e = !1));
                    var n = this.times,
                      r = this.values,
                      i = n.length;
                    0 === i &&
                      (console.error(
                        "THREE.KeyframeTrack: Track is empty.",
                        this
                      ),
                      (e = !1));
                    for (var a = null, o = 0; o !== i; o++) {
                      var s = n[o];
                      if ("number" === typeof s && isNaN(s)) {
                        console.error(
                          "THREE.KeyframeTrack: Time is not a valid number.",
                          this,
                          o,
                          s
                        ),
                          (e = !1);
                        break;
                      }
                      if (null !== a && a > s) {
                        console.error(
                          "THREE.KeyframeTrack: Out of order keys.",
                          this,
                          o,
                          s,
                          a
                        ),
                          (e = !1);
                        break;
                      }
                      a = s;
                    }
                    if (void 0 !== r && isTypedArray(r))
                      for (var u = 0, l = r.length; u !== l; ++u) {
                        var c = r[u];
                        if (isNaN(c)) {
                          console.error(
                            "THREE.KeyframeTrack: Value is not a valid number.",
                            this,
                            u,
                            c
                          ),
                            (e = !1);
                          break;
                        }
                      }
                    return e;
                  },
                },
                {
                  key: "optimize",
                  value: function optimize() {
                    for (
                      var e = arraySlice(this.times),
                        t = arraySlice(this.values),
                        n = this.getValueSize(),
                        r = this.getInterpolation() === jt,
                        i = e.length - 1,
                        a = 1,
                        o = 1;
                      o < i;
                      ++o
                    ) {
                      var s = !1,
                        u = e[o];
                      if (u !== e[o + 1] && (1 !== o || u !== e[0]))
                        if (r) s = !0;
                        else
                          for (
                            var l = o * n, c = l - n, h = l + n, d = 0;
                            d !== n;
                            ++d
                          ) {
                            var f = t[l + d];
                            if (f !== t[c + d] || f !== t[h + d]) {
                              s = !0;
                              break;
                            }
                          }
                      if (s) {
                        if (o !== a) {
                          e[a] = e[o];
                          for (var p = o * n, m = a * n, v = 0; v !== n; ++v)
                            t[m + v] = t[p + v];
                        }
                        ++a;
                      }
                    }
                    if (i > 0) {
                      e[a] = e[i];
                      for (var g = i * n, y = a * n, b = 0; b !== n; ++b)
                        t[y + b] = t[g + b];
                      ++a;
                    }
                    return (
                      a !== e.length
                        ? ((this.times = arraySlice(e, 0, a)),
                          (this.values = arraySlice(t, 0, a * n)))
                        : ((this.times = e), (this.values = t)),
                      this
                    );
                  },
                },
                {
                  key: "clone",
                  value: function clone() {
                    var e = arraySlice(this.times, 0),
                      t = arraySlice(this.values, 0),
                      n = new (0, this.constructor)(this.name, e, t);
                    return (n.createInterpolant = this.createInterpolant), n;
                  },
                },
              ],
              [
                {
                  key: "toJSON",
                  value: function toJSON(e) {
                    var t,
                      n = e.constructor;
                    if (n.toJSON !== this.toJSON) t = n.toJSON(e);
                    else {
                      t = {
                        name: e.name,
                        times: convertArray(e.times, Array),
                        values: convertArray(e.values, Array),
                      };
                      var r = e.getInterpolation();
                      r !== e.DefaultInterpolation && (t.interpolation = r);
                    }
                    return (t.type = e.ValueTypeName), t;
                  },
                },
              ]
            ),
            KeyframeTrack
          );
        })();
      (Iu.prototype.TimeBufferType = Float32Array),
        (Iu.prototype.ValueBufferType = Float32Array),
        (Iu.prototype.DefaultInterpolation = Dt);
      var Du = (function (e) {
        function BooleanKeyframeTrack() {
          return (
            Object(f.a)(this, BooleanKeyframeTrack),
            Object(s.a)(
              this,
              Object(r.a)(BooleanKeyframeTrack).apply(this, arguments)
            )
          );
        }
        return Object(u.a)(BooleanKeyframeTrack, e), BooleanKeyframeTrack;
      })(Iu);
      (Du.prototype.ValueTypeName = "bool"),
        (Du.prototype.ValueBufferType = Array),
        (Du.prototype.DefaultInterpolation = It),
        (Du.prototype.InterpolantFactoryMethodLinear = void 0),
        (Du.prototype.InterpolantFactoryMethodSmooth = void 0);
      var ju = (function (e) {
        function ColorKeyframeTrack() {
          return (
            Object(f.a)(this, ColorKeyframeTrack),
            Object(s.a)(
              this,
              Object(r.a)(ColorKeyframeTrack).apply(this, arguments)
            )
          );
        }
        return Object(u.a)(ColorKeyframeTrack, e), ColorKeyframeTrack;
      })(Iu);
      ju.prototype.ValueTypeName = "color";
      var Bu = (function (e) {
        function NumberKeyframeTrack() {
          return (
            Object(f.a)(this, NumberKeyframeTrack),
            Object(s.a)(
              this,
              Object(r.a)(NumberKeyframeTrack).apply(this, arguments)
            )
          );
        }
        return Object(u.a)(NumberKeyframeTrack, e), NumberKeyframeTrack;
      })(Iu);
      Bu.prototype.ValueTypeName = "number";
      var Nu = (function (e) {
          function QuaternionLinearInterpolant(e, t, n, i) {
            return (
              Object(f.a)(this, QuaternionLinearInterpolant),
              Object(s.a)(
                this,
                Object(r.a)(QuaternionLinearInterpolant).call(this, e, t, n, i)
              )
            );
          }
          return (
            Object(u.a)(QuaternionLinearInterpolant, e),
            Object(p.a)(QuaternionLinearInterpolant, [
              {
                key: "interpolate_",
                value: function interpolate_(e, t, n, r) {
                  for (
                    var i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = (n - t) / (r - t),
                      u = e * o,
                      l = u + o;
                    u !== l;
                    u += 4
                  )
                    rr.slerpFlat(i, 0, a, u - o, a, u, s);
                  return i;
                },
              },
            ]),
            QuaternionLinearInterpolant
          );
        })(ku),
        zu = (function (e) {
          function QuaternionKeyframeTrack() {
            return (
              Object(f.a)(this, QuaternionKeyframeTrack),
              Object(s.a)(
                this,
                Object(r.a)(QuaternionKeyframeTrack).apply(this, arguments)
              )
            );
          }
          return (
            Object(u.a)(QuaternionKeyframeTrack, e),
            Object(p.a)(QuaternionKeyframeTrack, [
              {
                key: "InterpolantFactoryMethodLinear",
                value: function InterpolantFactoryMethodLinear(e) {
                  return new Nu(
                    this.times,
                    this.values,
                    this.getValueSize(),
                    e
                  );
                },
              },
            ]),
            QuaternionKeyframeTrack
          );
        })(Iu);
      (zu.prototype.ValueTypeName = "quaternion"),
        (zu.prototype.DefaultInterpolation = Dt),
        (zu.prototype.InterpolantFactoryMethodSmooth = void 0);
      var Fu = (function (e) {
        function StringKeyframeTrack() {
          return (
            Object(f.a)(this, StringKeyframeTrack),
            Object(s.a)(
              this,
              Object(r.a)(StringKeyframeTrack).apply(this, arguments)
            )
          );
        }
        return Object(u.a)(StringKeyframeTrack, e), StringKeyframeTrack;
      })(Iu);
      (Fu.prototype.ValueTypeName = "string"),
        (Fu.prototype.ValueBufferType = Array),
        (Fu.prototype.DefaultInterpolation = It),
        (Fu.prototype.InterpolantFactoryMethodLinear = void 0),
        (Fu.prototype.InterpolantFactoryMethodSmooth = void 0);
      var Gu = (function (e) {
        function VectorKeyframeTrack() {
          return (
            Object(f.a)(this, VectorKeyframeTrack),
            Object(s.a)(
              this,
              Object(r.a)(VectorKeyframeTrack).apply(this, arguments)
            )
          );
        }
        return Object(u.a)(VectorKeyframeTrack, e), VectorKeyframeTrack;
      })(Iu);
      Gu.prototype.ValueTypeName = "vector";
      var Uu = (function () {
        function AnimationClip(e) {
          var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : -1,
            n = arguments.length > 2 ? arguments[2] : void 0,
            r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : Ft;
          Object(f.a)(this, AnimationClip),
            (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = r),
            (this.uuid = generateUUID()),
            this.duration < 0 && this.resetDuration();
        }
        return (
          Object(p.a)(
            AnimationClip,
            [
              {
                key: "resetDuration",
                value: function resetDuration() {
                  for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                    var r = this.tracks[t];
                    e = Math.max(e, r.times[r.times.length - 1]);
                  }
                  return (this.duration = e), this;
                },
              },
              {
                key: "trim",
                value: function trim() {
                  for (var e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                  return this;
                },
              },
              {
                key: "validate",
                value: function validate() {
                  for (var e = !0, t = 0; t < this.tracks.length; t++)
                    e = e && this.tracks[t].validate();
                  return e;
                },
              },
              {
                key: "optimize",
                value: function optimize() {
                  for (var e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                  return this;
                },
              },
              {
                key: "clone",
                value: function clone() {
                  for (var e = [], t = 0; t < this.tracks.length; t++)
                    e.push(this.tracks[t].clone());
                  return new this.constructor(
                    this.name,
                    this.duration,
                    e,
                    this.blendMode
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  return this.constructor.toJSON(this);
                },
              },
            ],
            [
              {
                key: "parse",
                value: function parse(e) {
                  for (
                    var t = [],
                      n = e.tracks,
                      r = 1 / (e.fps || 1),
                      i = 0,
                      a = n.length;
                    i !== a;
                    ++i
                  )
                    t.push(parseKeyframeTrack(n[i]).scale(r));
                  var o = new this(e.name, e.duration, t, e.blendMode);
                  return (o.uuid = e.uuid), o;
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  for (
                    var t = [],
                      n = e.tracks,
                      r = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid,
                        blendMode: e.blendMode,
                      },
                      i = 0,
                      a = n.length;
                    i !== a;
                    ++i
                  )
                    t.push(Iu.toJSON(n[i]));
                  return r;
                },
              },
              {
                key: "CreateFromMorphTargetSequence",
                value: function CreateFromMorphTargetSequence(e, t, n, r) {
                  for (var i = t.length, a = [], o = 0; o < i; o++) {
                    var s = [],
                      u = [];
                    s.push((o + i - 1) % i, o, (o + 1) % i), u.push(0, 1, 0);
                    var l = getKeyframeOrder(s);
                    (s = sortedArray(s, 1, l)),
                      (u = sortedArray(u, 1, l)),
                      r || 0 !== s[0] || (s.push(i), u.push(u[0])),
                      a.push(
                        new Bu(
                          ".morphTargetInfluences[" + t[o].name + "]",
                          s,
                          u
                        ).scale(1 / n)
                      );
                  }
                  return new this(e, -1, a);
                },
              },
              {
                key: "findByName",
                value: function findByName(e, t) {
                  var n = e;
                  if (!Array.isArray(e)) {
                    var r = e;
                    n = (r.geometry && r.geometry.animations) || r.animations;
                  }
                  for (var i = 0; i < n.length; i++)
                    if (n[i].name === t) return n[i];
                  return null;
                },
              },
              {
                key: "CreateClipsFromMorphTargetSequences",
                value: function CreateClipsFromMorphTargetSequences(e, t, n) {
                  for (
                    var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length;
                    a < o;
                    a++
                  ) {
                    var s = e[a],
                      u = s.name.match(i);
                    if (u && u.length > 1) {
                      var l = u[1],
                        c = r[l];
                      c || (r[l] = c = []), c.push(s);
                    }
                  }
                  var h = [];
                  for (var d in r)
                    h.push(this.CreateFromMorphTargetSequence(d, r[d], t, n));
                  return h;
                },
              },
              {
                key: "parseAnimation",
                value: function parseAnimation(e, t) {
                  if (!e)
                    return (
                      console.error(
                        "THREE.AnimationClip: No animation in JSONLoader data."
                      ),
                      null
                    );
                  for (
                    var n = function addNonemptyTrack(e, t, n, r, i) {
                        if (0 !== n.length) {
                          var a = [],
                            o = [];
                          flattenJSON(n, a, o, r),
                            0 !== a.length && i.push(new e(t, a, o));
                        }
                      },
                      r = [],
                      i = e.name || "default",
                      a = e.fps || 30,
                      o = e.blendMode,
                      s = e.length || -1,
                      u = e.hierarchy || [],
                      l = 0;
                    l < u.length;
                    l++
                  ) {
                    var c = u[l].keys;
                    if (c && 0 !== c.length)
                      if (c[0].morphTargets) {
                        var h = {},
                          d = void 0;
                        for (d = 0; d < c.length; d++)
                          if (c[d].morphTargets)
                            for (var f = 0; f < c[d].morphTargets.length; f++)
                              h[c[d].morphTargets[f]] = -1;
                        for (var p in h) {
                          for (
                            var m = [], v = [], g = 0;
                            g !== c[d].morphTargets.length;
                            ++g
                          ) {
                            var y = c[d];
                            m.push(y.time), v.push(y.morphTarget === p ? 1 : 0);
                          }
                          r.push(
                            new Bu(".morphTargetInfluence[" + p + "]", m, v)
                          );
                        }
                        s = h.length * a;
                      } else {
                        var b = ".bones[" + t[l].name + "]";
                        n(Gu, b + ".position", c, "pos", r),
                          n(zu, b + ".quaternion", c, "rot", r),
                          n(Gu, b + ".scale", c, "scl", r);
                      }
                  }
                  return 0 === r.length ? null : new this(i, s, r, o);
                },
              },
            ]
          ),
          AnimationClip
        );
      })();
      function parseKeyframeTrack(e) {
        if (void 0 === e.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        var t = (function getTrackTypeForValueTypeName(e) {
          switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Bu;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Gu;
            case "color":
              return ju;
            case "quaternion":
              return zu;
            case "bool":
            case "boolean":
              return Du;
            case "string":
              return Fu;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
        })(e.type);
        if (void 0 === e.times) {
          var n = [],
            r = [];
          flattenJSON(e.keys, n, r, "value"), (e.times = n), (e.values = r);
        }
        return void 0 !== t.parse
          ? t.parse(e)
          : new t(e.name, e.times, e.values, e.interpolation);
      }
      var Vu,
        Wu = {
          enabled: !1,
          files: {},
          add: function add(e, t) {
            !1 !== this.enabled && (this.files[e] = t);
          },
          get: function get(e) {
            if (!1 !== this.enabled) return this.files[e];
          },
          remove: function remove(e) {
            delete this.files[e];
          },
          clear: function clear() {
            this.files = {};
          },
        },
        Hu = function LoadingManager(e, t, n) {
          Object(f.a)(this, LoadingManager);
          var r = this,
            i = !1,
            a = 0,
            o = 0,
            s = void 0,
            u = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (e) {
              o++,
                !1 === i && void 0 !== r.onStart && r.onStart(e, a, o),
                (i = !0);
            }),
            (this.itemEnd = function (e) {
              a++,
                void 0 !== r.onProgress && r.onProgress(e, a, o),
                a === o && ((i = !1), void 0 !== r.onLoad && r.onLoad());
            }),
            (this.itemError = function (e) {
              void 0 !== r.onError && r.onError(e);
            }),
            (this.resolveURL = function (e) {
              return s ? s(e) : e;
            }),
            (this.setURLModifier = function (e) {
              return (s = e), this;
            }),
            (this.addHandler = function (e, t) {
              return u.push(e, t), this;
            }),
            (this.removeHandler = function (e) {
              var t = u.indexOf(e);
              return -1 !== t && u.splice(t, 2), this;
            }),
            (this.getHandler = function (e) {
              for (var t = 0, n = u.length; t < n; t += 2) {
                var r = u[t],
                  i = u[t + 1];
                if ((r.global && (r.lastIndex = 0), r.test(e))) return i;
              }
              return null;
            });
        },
        qu = new Hu(),
        Xu = (function () {
          function Loader(e) {
            Object(f.a)(this, Loader),
              (this.manager = void 0 !== e ? e : qu),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          return (
            Object(p.a)(Loader, [
              { key: "load", value: function load() {} },
              {
                key: "loadAsync",
                value: function loadAsync(e, t) {
                  var n = this;
                  return new Promise(function (r, i) {
                    n.load(e, r, t, i);
                  });
                },
              },
              { key: "parse", value: function parse() {} },
              {
                key: "setCrossOrigin",
                value: function setCrossOrigin(e) {
                  return (this.crossOrigin = e), this;
                },
              },
              {
                key: "setWithCredentials",
                value: function setWithCredentials(e) {
                  return (this.withCredentials = e), this;
                },
              },
              {
                key: "setPath",
                value: function setPath(e) {
                  return (this.path = e), this;
                },
              },
              {
                key: "setResourcePath",
                value: function setResourcePath(e) {
                  return (this.resourcePath = e), this;
                },
              },
              {
                key: "setRequestHeader",
                value: function setRequestHeader(e) {
                  return (this.requestHeader = e), this;
                },
              },
            ]),
            Loader
          );
        })(),
        Ju = {},
        Yu = (function (e) {
          function HttpError(e, t) {
            var n;
            return (
              Object(f.a)(this, HttpError),
              ((n = Object(s.a)(
                this,
                Object(r.a)(HttpError).call(this, e)
              )).response = t),
              n
            );
          }
          return Object(u.a)(HttpError, e), HttpError;
        })(wrapNativeSuper_wrapNativeSuper(Error)),
        Zu = (function (e) {
          function FileLoader(e) {
            return (
              Object(f.a)(this, FileLoader),
              Object(s.a)(this, Object(r.a)(FileLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(FileLoader, e),
            Object(p.a)(FileLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this;
                  void 0 === e && (e = ""),
                    void 0 !== this.path && (e = this.path + e),
                    (e = this.manager.resolveURL(e));
                  var a = Wu.get(e);
                  if (void 0 !== a)
                    return (
                      this.manager.itemStart(e),
                      setTimeout(function () {
                        t && t(a), i.manager.itemEnd(e);
                      }, 0),
                      a
                    );
                  if (void 0 === Ju[e]) {
                    (Ju[e] = []),
                      Ju[e].push({ onLoad: t, onProgress: n, onError: r });
                    var o = new Request(e, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials
                          ? "include"
                          : "same-origin",
                      }),
                      s = this.mimeType,
                      u = this.responseType;
                    fetch(o)
                      .then(function (t) {
                        if (200 === t.status || 0 === t.status) {
                          if (
                            (0 === t.status &&
                              console.warn(
                                "THREE.FileLoader: HTTP Status 0 received."
                              ),
                            "undefined" === typeof ReadableStream ||
                              void 0 === t.body ||
                              void 0 === t.body.getReader)
                          )
                            return t;
                          var n = Ju[e],
                            r = t.body.getReader(),
                            i = t.headers.get("Content-Length"),
                            a = i ? parseInt(i) : 0,
                            o = 0 !== a,
                            s = 0,
                            u = new ReadableStream({
                              start: function start(e) {
                                !(function readData() {
                                  r.read().then(function (t) {
                                    var r = t.done,
                                      i = t.value;
                                    if (r) e.close();
                                    else {
                                      s += i.byteLength;
                                      for (
                                        var u = new ProgressEvent("progress", {
                                            lengthComputable: o,
                                            loaded: s,
                                            total: a,
                                          }),
                                          l = 0,
                                          c = n.length;
                                        l < c;
                                        l++
                                      ) {
                                        var h = n[l];
                                        h.onProgress && h.onProgress(u);
                                      }
                                      e.enqueue(i), readData();
                                    }
                                  });
                                })();
                              },
                            });
                          return new Response(u);
                        }
                        throw new Yu(
                          'fetch for "'
                            .concat(t.url, '" responded with ')
                            .concat(t.status, ": ")
                            .concat(t.statusText),
                          t
                        );
                      })
                      .then(function (e) {
                        switch (u) {
                          case "arraybuffer":
                            return e.arrayBuffer();
                          case "blob":
                            return e.blob();
                          case "document":
                            return e.text().then(function (e) {
                              return new DOMParser().parseFromString(e, s);
                            });
                          case "json":
                            return e.json();
                          default:
                            if (void 0 === s) return e.text();
                            var t = /charset="?([^;"\s]*)"?/i.exec(s),
                              n = t && t[1] ? t[1].toLowerCase() : void 0,
                              r = new TextDecoder(n);
                            return e.arrayBuffer().then(function (e) {
                              return r.decode(e);
                            });
                        }
                      })
                      .then(function (t) {
                        Wu.add(e, t);
                        var n = Ju[e];
                        delete Ju[e];
                        for (var r = 0, i = n.length; r < i; r++) {
                          var a = n[r];
                          a.onLoad && a.onLoad(t);
                        }
                      })
                      .catch(function (t) {
                        var n = Ju[e];
                        if (void 0 === n) throw (i.manager.itemError(e), t);
                        delete Ju[e];
                        for (var r = 0, a = n.length; r < a; r++) {
                          var o = n[r];
                          o.onError && o.onError(t);
                        }
                        i.manager.itemError(e);
                      })
                      .finally(function () {
                        i.manager.itemEnd(e);
                      }),
                      this.manager.itemStart(e);
                  } else Ju[e].push({ onLoad: t, onProgress: n, onError: r });
                },
              },
              {
                key: "setResponseType",
                value: function setResponseType(e) {
                  return (this.responseType = e), this;
                },
              },
              {
                key: "setMimeType",
                value: function setMimeType(e) {
                  return (this.mimeType = e), this;
                },
              },
            ]),
            FileLoader
          );
        })(Xu),
        Ku = (function (e) {
          function AnimationLoader(e) {
            return (
              Object(f.a)(this, AnimationLoader),
              Object(s.a)(this, Object(r.a)(AnimationLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(AnimationLoader, e),
            Object(p.a)(AnimationLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this,
                    a = new Zu(this.manager);
                  a.setPath(this.path),
                    a.setRequestHeader(this.requestHeader),
                    a.setWithCredentials(this.withCredentials),
                    a.load(
                      e,
                      function (n) {
                        try {
                          t(i.parse(JSON.parse(n)));
                        } catch (a) {
                          r ? r(a) : console.error(a), i.manager.itemError(e);
                        }
                      },
                      n,
                      r
                    );
                },
              },
              {
                key: "parse",
                value: function parse(e) {
                  for (var t = [], n = 0; n < e.length; n++) {
                    var r = Uu.parse(e[n]);
                    t.push(r);
                  }
                  return t;
                },
              },
            ]),
            AnimationLoader
          );
        })(Xu),
        Qu = (function (e) {
          function CompressedTextureLoader(e) {
            return (
              Object(f.a)(this, CompressedTextureLoader),
              Object(s.a)(
                this,
                Object(r.a)(CompressedTextureLoader).call(this, e)
              )
            );
          }
          return (
            Object(u.a)(CompressedTextureLoader, e),
            Object(p.a)(CompressedTextureLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this,
                    a = [],
                    o = new Ts(),
                    s = new Zu(this.manager);
                  s.setPath(this.path),
                    s.setResponseType("arraybuffer"),
                    s.setRequestHeader(this.requestHeader),
                    s.setWithCredentials(i.withCredentials);
                  var u = 0;
                  function loadTexture(l) {
                    s.load(
                      e[l],
                      function (e) {
                        var n = i.parse(e, !0);
                        (a[l] = {
                          width: n.width,
                          height: n.height,
                          format: n.format,
                          mipmaps: n.mipmaps,
                        }),
                          6 === (u += 1) &&
                            (1 === n.mipmapCount && (o.minFilter = Ee),
                            (o.image = a),
                            (o.format = n.format),
                            (o.needsUpdate = !0),
                            t && t(o));
                      },
                      n,
                      r
                    );
                  }
                  if (Array.isArray(e))
                    for (var l = 0, c = e.length; l < c; ++l) loadTexture(l);
                  else
                    s.load(
                      e,
                      function (e) {
                        var n = i.parse(e, !0);
                        if (n.isCubemap) {
                          for (
                            var r = n.mipmaps.length / n.mipmapCount, s = 0;
                            s < r;
                            s++
                          ) {
                            a[s] = { mipmaps: [] };
                            for (var u = 0; u < n.mipmapCount; u++)
                              a[s].mipmaps.push(
                                n.mipmaps[s * n.mipmapCount + u]
                              ),
                                (a[s].format = n.format),
                                (a[s].width = n.width),
                                (a[s].height = n.height);
                          }
                          o.image = a;
                        } else
                          (o.image.width = n.width),
                            (o.image.height = n.height),
                            (o.mipmaps = n.mipmaps);
                        1 === n.mipmapCount && (o.minFilter = Ee),
                          (o.format = n.format),
                          (o.needsUpdate = !0),
                          t && t(o);
                      },
                      n,
                      r
                    );
                  return o;
                },
              },
            ]),
            CompressedTextureLoader
          );
        })(Xu),
        $u = (function (e) {
          function ImageLoader(e) {
            return (
              Object(f.a)(this, ImageLoader),
              Object(s.a)(this, Object(r.a)(ImageLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(ImageLoader, e),
            Object(p.a)(ImageLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  void 0 !== this.path && (e = this.path + e),
                    (e = this.manager.resolveURL(e));
                  var i = this,
                    a = Wu.get(e);
                  if (void 0 !== a)
                    return (
                      i.manager.itemStart(e),
                      setTimeout(function () {
                        t && t(a), i.manager.itemEnd(e);
                      }, 0),
                      a
                    );
                  var o = createElementNS("img");
                  function onImageLoad() {
                    removeEventListeners(),
                      Wu.add(e, this),
                      t && t(this),
                      i.manager.itemEnd(e);
                  }
                  function onImageError(t) {
                    removeEventListeners(),
                      r && r(t),
                      i.manager.itemError(e),
                      i.manager.itemEnd(e);
                  }
                  function removeEventListeners() {
                    o.removeEventListener("load", onImageLoad, !1),
                      o.removeEventListener("error", onImageError, !1);
                  }
                  return (
                    o.addEventListener("load", onImageLoad, !1),
                    o.addEventListener("error", onImageError, !1),
                    "data:" !== e.slice(0, 5) &&
                      void 0 !== this.crossOrigin &&
                      (o.crossOrigin = this.crossOrigin),
                    i.manager.itemStart(e),
                    (o.src = e),
                    o
                  );
                },
              },
            ]),
            ImageLoader
          );
        })(Xu),
        el = (function (e) {
          function CubeTextureLoader(e) {
            return (
              Object(f.a)(this, CubeTextureLoader),
              Object(s.a)(this, Object(r.a)(CubeTextureLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(CubeTextureLoader, e),
            Object(p.a)(CubeTextureLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = new ma(),
                    a = new $u(this.manager);
                  a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                  var o = 0;
                  function loadTexture(n) {
                    a.load(
                      e[n],
                      function (e) {
                        (i.images[n] = e),
                          6 === ++o && ((i.needsUpdate = !0), t && t(i));
                      },
                      void 0,
                      r
                    );
                  }
                  for (var s = 0; s < e.length; ++s) loadTexture(s);
                  return i;
                },
              },
            ]),
            CubeTextureLoader
          );
        })(Xu),
        tl = (function (e) {
          function DataTextureLoader(e) {
            return (
              Object(f.a)(this, DataTextureLoader),
              Object(s.a)(this, Object(r.a)(DataTextureLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(DataTextureLoader, e),
            Object(p.a)(DataTextureLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this,
                    a = new Zo(),
                    o = new Zu(this.manager);
                  return (
                    o.setResponseType("arraybuffer"),
                    o.setRequestHeader(this.requestHeader),
                    o.setPath(this.path),
                    o.setWithCredentials(i.withCredentials),
                    o.load(
                      e,
                      function (e) {
                        var n = i.parse(e);
                        n &&
                          (void 0 !== n.image
                            ? (a.image = n.image)
                            : void 0 !== n.data &&
                              ((a.image.width = n.width),
                              (a.image.height = n.height),
                              (a.image.data = n.data)),
                          (a.wrapS = void 0 !== n.wrapS ? n.wrapS : we),
                          (a.wrapT = void 0 !== n.wrapT ? n.wrapT : we),
                          (a.magFilter =
                            void 0 !== n.magFilter ? n.magFilter : Ee),
                          (a.minFilter =
                            void 0 !== n.minFilter ? n.minFilter : Ee),
                          (a.anisotropy =
                            void 0 !== n.anisotropy ? n.anisotropy : 1),
                          void 0 !== n.encoding && (a.encoding = n.encoding),
                          void 0 !== n.flipY && (a.flipY = n.flipY),
                          void 0 !== n.format && (a.format = n.format),
                          void 0 !== n.type && (a.type = n.type),
                          void 0 !== n.mipmaps &&
                            ((a.mipmaps = n.mipmaps), (a.minFilter = Ie)),
                          1 === n.mipmapCount && (a.minFilter = Ee),
                          void 0 !== n.generateMipmaps &&
                            (a.generateMipmaps = n.generateMipmaps),
                          (a.needsUpdate = !0),
                          t && t(a, n));
                      },
                      n,
                      r
                    ),
                    a
                  );
                },
              },
            ]),
            DataTextureLoader
          );
        })(Xu),
        nl = (function (e) {
          function TextureLoader(e) {
            return (
              Object(f.a)(this, TextureLoader),
              Object(s.a)(this, Object(r.a)(TextureLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(TextureLoader, e),
            Object(p.a)(TextureLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = new Yn(),
                    a = new $u(this.manager);
                  return (
                    a.setCrossOrigin(this.crossOrigin),
                    a.setPath(this.path),
                    a.load(
                      e,
                      function (e) {
                        (i.image = e),
                          (i.needsUpdate = !0),
                          void 0 !== t && t(i);
                      },
                      n,
                      r
                    ),
                    i
                  );
                },
              },
            ]),
            TextureLoader
          );
        })(Xu),
        rl = (function (e) {
          function Light(e) {
            var t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1;
            return (
              Object(f.a)(this, Light),
              ((t = Object(s.a)(this, Object(r.a)(Light).call(this))).isLight =
                !0),
              (t.type = "Light"),
              (t.color = new Hn(e)),
              (t.intensity = n),
              t
            );
          }
          return (
            Object(u.a)(Light, e),
            Object(p.a)(Light, [
              { key: "dispose", value: function dispose() {} },
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(Light.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    this.color.copy(e.color),
                    (this.intensity = e.intensity),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(Light.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (
                    (t.object.color = this.color.getHex()),
                    (t.object.intensity = this.intensity),
                    void 0 !== this.groundColor &&
                      (t.object.groundColor = this.groundColor.getHex()),
                    void 0 !== this.distance &&
                      (t.object.distance = this.distance),
                    void 0 !== this.angle && (t.object.angle = this.angle),
                    void 0 !== this.decay && (t.object.decay = this.decay),
                    void 0 !== this.penumbra &&
                      (t.object.penumbra = this.penumbra),
                    void 0 !== this.shadow &&
                      (t.object.shadow = this.shadow.toJSON()),
                    t
                  );
                },
              },
            ]),
            Light
          );
        })(ai),
        il = (function (e) {
          function HemisphereLight(e, t, n) {
            var i;
            return (
              Object(f.a)(this, HemisphereLight),
              ((i = Object(s.a)(
                this,
                Object(r.a)(HemisphereLight).call(this, e, n)
              )).isHemisphereLight = !0),
              (i.type = "HemisphereLight"),
              i.position.copy(ai.DefaultUp),
              i.updateMatrix(),
              (i.groundColor = new Hn(t)),
              i
            );
          }
          return (
            Object(u.a)(HemisphereLight, e),
            Object(p.a)(HemisphereLight, [
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(HemisphereLight.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    this.groundColor.copy(e.groundColor),
                    this
                  );
                },
              },
            ]),
            HemisphereLight
          );
        })(rl),
        al = new Ir(),
        ol = new ir(),
        sl = new ir(),
        ul = (function () {
          function LightShadow(e) {
            Object(f.a)(this, LightShadow),
              (this.camera = e),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new Dn(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new Ir()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new Sa()),
              (this._frameExtents = new Dn(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new Zn(0, 0, 1, 1)]);
          }
          return (
            Object(p.a)(LightShadow, [
              {
                key: "getViewportCount",
                value: function getViewportCount() {
                  return this._viewportCount;
                },
              },
              {
                key: "getFrustum",
                value: function getFrustum() {
                  return this._frustum;
                },
              },
              {
                key: "updateMatrices",
                value: function updateMatrices(e) {
                  var t = this.camera,
                    n = this.matrix;
                  ol.setFromMatrixPosition(e.matrixWorld),
                    t.position.copy(ol),
                    sl.setFromMatrixPosition(e.target.matrixWorld),
                    t.lookAt(sl),
                    t.updateMatrixWorld(),
                    al.multiplyMatrices(
                      t.projectionMatrix,
                      t.matrixWorldInverse
                    ),
                    this._frustum.setFromProjectionMatrix(al),
                    n.set(
                      0.5,
                      0,
                      0,
                      0.5,
                      0,
                      0.5,
                      0,
                      0.5,
                      0,
                      0,
                      0.5,
                      0.5,
                      0,
                      0,
                      0,
                      1
                    ),
                    n.multiply(t.projectionMatrix),
                    n.multiply(t.matrixWorldInverse);
                },
              },
              {
                key: "getViewport",
                value: function getViewport(e) {
                  return this._viewports[e];
                },
              },
              {
                key: "getFrameExtents",
                value: function getFrameExtents() {
                  return this._frameExtents;
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.map && this.map.dispose(),
                    this.mapPass && this.mapPass.dispose();
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.camera = e.camera.clone()),
                    (this.bias = e.bias),
                    (this.radius = e.radius),
                    this.mapSize.copy(e.mapSize),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = {};
                  return (
                    0 !== this.bias && (e.bias = this.bias),
                    0 !== this.normalBias && (e.normalBias = this.normalBias),
                    1 !== this.radius && (e.radius = this.radius),
                    (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                      (e.mapSize = this.mapSize.toArray()),
                    (e.camera = this.camera.toJSON(!1).object),
                    delete e.camera.matrix,
                    e
                  );
                },
              },
            ]),
            LightShadow
          );
        })(),
        ll = (function (e) {
          function SpotLightShadow() {
            var e;
            return (
              Object(f.a)(this, SpotLightShadow),
              ((e = Object(s.a)(
                this,
                Object(r.a)(SpotLightShadow).call(this, new ha(50, 1, 0.5, 500))
              )).isSpotLightShadow = !0),
              (e.focus = 1),
              e
            );
          }
          return (
            Object(u.a)(SpotLightShadow, e),
            Object(p.a)(SpotLightShadow, [
              {
                key: "updateMatrices",
                value: function updateMatrices(e) {
                  var t = this.camera,
                    n = 2 * Rn * e.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    a = e.distance || t.far;
                  (n === t.fov && i === t.aspect && a === t.far) ||
                    ((t.fov = n),
                    (t.aspect = i),
                    (t.far = a),
                    t.updateProjectionMatrix()),
                    Object(o.a)(
                      Object(r.a)(SpotLightShadow.prototype),
                      "updateMatrices",
                      this
                    ).call(this, e);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(SpotLightShadow.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.focus = e.focus),
                    this
                  );
                },
              },
            ]),
            SpotLightShadow
          );
        })(ul),
        cl = (function (e) {
          function SpotLight(e, t) {
            var n,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : Math.PI / 3,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 0,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 1;
            return (
              Object(f.a)(this, SpotLight),
              ((n = Object(s.a)(
                this,
                Object(r.a)(SpotLight).call(this, e, t)
              )).isSpotLight = !0),
              (n.type = "SpotLight"),
              n.position.copy(ai.DefaultUp),
              n.updateMatrix(),
              (n.target = new ai()),
              (n.distance = i),
              (n.angle = a),
              (n.penumbra = o),
              (n.decay = u),
              (n.shadow = new ll()),
              n
            );
          }
          return (
            Object(u.a)(SpotLight, e),
            Object(p.a)(SpotLight, [
              {
                key: "dispose",
                value: function dispose() {
                  this.shadow.dispose();
                },
              },
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(SpotLight.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.distance = e.distance),
                    (this.angle = e.angle),
                    (this.penumbra = e.penumbra),
                    (this.decay = e.decay),
                    (this.target = e.target.clone()),
                    (this.shadow = e.shadow.clone()),
                    this
                  );
                },
              },
              {
                key: "power",
                get: function get() {
                  return this.intensity * Math.PI;
                },
                set: function set(e) {
                  this.intensity = e / Math.PI;
                },
              },
            ]),
            SpotLight
          );
        })(rl),
        hl = new Ir(),
        dl = new ir(),
        fl = new ir(),
        pl = (function (e) {
          function PointLightShadow() {
            var e;
            return (
              Object(f.a)(this, PointLightShadow),
              ((e = Object(s.a)(
                this,
                Object(r.a)(PointLightShadow).call(
                  this,
                  new ha(90, 1, 0.5, 500)
                )
              )).isPointLightShadow = !0),
              (e._frameExtents = new Dn(4, 2)),
              (e._viewportCount = 6),
              (e._viewports = [
                new Zn(2, 1, 1, 1),
                new Zn(0, 1, 1, 1),
                new Zn(3, 1, 1, 1),
                new Zn(1, 1, 1, 1),
                new Zn(3, 0, 1, 1),
                new Zn(1, 0, 1, 1),
              ]),
              (e._cubeDirections = [
                new ir(1, 0, 0),
                new ir(-1, 0, 0),
                new ir(0, 0, 1),
                new ir(0, 0, -1),
                new ir(0, 1, 0),
                new ir(0, -1, 0),
              ]),
              (e._cubeUps = [
                new ir(0, 1, 0),
                new ir(0, 1, 0),
                new ir(0, 1, 0),
                new ir(0, 1, 0),
                new ir(0, 0, 1),
                new ir(0, 0, -1),
              ]),
              e
            );
          }
          return (
            Object(u.a)(PointLightShadow, e),
            Object(p.a)(PointLightShadow, [
              {
                key: "updateMatrices",
                value: function updateMatrices(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0,
                    n = this.camera,
                    r = this.matrix,
                    i = e.distance || n.far;
                  i !== n.far && ((n.far = i), n.updateProjectionMatrix()),
                    dl.setFromMatrixPosition(e.matrixWorld),
                    n.position.copy(dl),
                    fl.copy(n.position),
                    fl.add(this._cubeDirections[t]),
                    n.up.copy(this._cubeUps[t]),
                    n.lookAt(fl),
                    n.updateMatrixWorld(),
                    r.makeTranslation(-dl.x, -dl.y, -dl.z),
                    hl.multiplyMatrices(
                      n.projectionMatrix,
                      n.matrixWorldInverse
                    ),
                    this._frustum.setFromProjectionMatrix(hl);
                },
              },
            ]),
            PointLightShadow
          );
        })(ul),
        ml = (function (e) {
          function PointLight(e, t) {
            var n,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1;
            return (
              Object(f.a)(this, PointLight),
              ((n = Object(s.a)(
                this,
                Object(r.a)(PointLight).call(this, e, t)
              )).isPointLight = !0),
              (n.type = "PointLight"),
              (n.distance = i),
              (n.decay = a),
              (n.shadow = new pl()),
              n
            );
          }
          return (
            Object(u.a)(PointLight, e),
            Object(p.a)(PointLight, [
              {
                key: "dispose",
                value: function dispose() {
                  this.shadow.dispose();
                },
              },
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(PointLight.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.distance = e.distance),
                    (this.decay = e.decay),
                    (this.shadow = e.shadow.clone()),
                    this
                  );
                },
              },
              {
                key: "power",
                get: function get() {
                  return 4 * this.intensity * Math.PI;
                },
                set: function set(e) {
                  this.intensity = e / (4 * Math.PI);
                },
              },
            ]),
            PointLight
          );
        })(rl),
        vl = (function (e) {
          function DirectionalLightShadow() {
            var e;
            return (
              Object(f.a)(this, DirectionalLightShadow),
              ((e = Object(s.a)(
                this,
                Object(r.a)(DirectionalLightShadow).call(
                  this,
                  new Ca(-5, 5, 5, -5, 0.5, 500)
                )
              )).isDirectionalLightShadow = !0),
              e
            );
          }
          return Object(u.a)(DirectionalLightShadow, e), DirectionalLightShadow;
        })(ul),
        gl = (function (e) {
          function DirectionalLight(e, t) {
            var n;
            return (
              Object(f.a)(this, DirectionalLight),
              ((n = Object(s.a)(
                this,
                Object(r.a)(DirectionalLight).call(this, e, t)
              )).isDirectionalLight = !0),
              (n.type = "DirectionalLight"),
              n.position.copy(ai.DefaultUp),
              n.updateMatrix(),
              (n.target = new ai()),
              (n.shadow = new vl()),
              n
            );
          }
          return (
            Object(u.a)(DirectionalLight, e),
            Object(p.a)(DirectionalLight, [
              {
                key: "dispose",
                value: function dispose() {
                  this.shadow.dispose();
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(DirectionalLight.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.target = e.target.clone()),
                    (this.shadow = e.shadow.clone()),
                    this
                  );
                },
              },
            ]),
            DirectionalLight
          );
        })(rl),
        yl = (function (e) {
          function AmbientLight(e, t) {
            var n;
            return (
              Object(f.a)(this, AmbientLight),
              ((n = Object(s.a)(
                this,
                Object(r.a)(AmbientLight).call(this, e, t)
              )).isAmbientLight = !0),
              (n.type = "AmbientLight"),
              n
            );
          }
          return Object(u.a)(AmbientLight, e), AmbientLight;
        })(rl),
        bl = (function (e) {
          function RectAreaLight(e, t) {
            var n,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 10,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 10;
            return (
              Object(f.a)(this, RectAreaLight),
              ((n = Object(s.a)(
                this,
                Object(r.a)(RectAreaLight).call(this, e, t)
              )).isRectAreaLight = !0),
              (n.type = "RectAreaLight"),
              (n.width = i),
              (n.height = a),
              n
            );
          }
          return (
            Object(u.a)(RectAreaLight, e),
            Object(p.a)(RectAreaLight, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(RectAreaLight.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.width = e.width),
                    (this.height = e.height),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(RectAreaLight.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (
                    (t.object.width = this.width),
                    (t.object.height = this.height),
                    t
                  );
                },
              },
              {
                key: "power",
                get: function get() {
                  return this.intensity * this.width * this.height * Math.PI;
                },
                set: function set(e) {
                  this.intensity = e / (this.width * this.height * Math.PI);
                },
              },
            ]),
            RectAreaLight
          );
        })(rl),
        xl = (function () {
          function SphericalHarmonics3() {
            Object(f.a)(this, SphericalHarmonics3),
              (this.isSphericalHarmonics3 = !0),
              (this.coefficients = []);
            for (var e = 0; e < 9; e++) this.coefficients.push(new ir());
          }
          return (
            Object(p.a)(
              SphericalHarmonics3,
              [
                {
                  key: "set",
                  value: function set(e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this;
                  },
                },
                {
                  key: "zero",
                  value: function zero() {
                    for (var e = 0; e < 9; e++)
                      this.coefficients[e].set(0, 0, 0);
                    return this;
                  },
                },
                {
                  key: "getAt",
                  value: function getAt(e, t) {
                    var n = e.x,
                      r = e.y,
                      i = e.z,
                      a = this.coefficients;
                    return (
                      t.copy(a[0]).multiplyScalar(0.282095),
                      t.addScaledVector(a[1], 0.488603 * r),
                      t.addScaledVector(a[2], 0.488603 * i),
                      t.addScaledVector(a[3], 0.488603 * n),
                      t.addScaledVector(a[4], n * r * 1.092548),
                      t.addScaledVector(a[5], r * i * 1.092548),
                      t.addScaledVector(a[6], 0.315392 * (3 * i * i - 1)),
                      t.addScaledVector(a[7], n * i * 1.092548),
                      t.addScaledVector(a[8], 0.546274 * (n * n - r * r)),
                      t
                    );
                  },
                },
                {
                  key: "getIrradianceAt",
                  value: function getIrradianceAt(e, t) {
                    var n = e.x,
                      r = e.y,
                      i = e.z,
                      a = this.coefficients;
                    return (
                      t.copy(a[0]).multiplyScalar(0.886227),
                      t.addScaledVector(a[1], 1.023328 * r),
                      t.addScaledVector(a[2], 1.023328 * i),
                      t.addScaledVector(a[3], 1.023328 * n),
                      t.addScaledVector(a[4], 0.858086 * n * r),
                      t.addScaledVector(a[5], 0.858086 * r * i),
                      t.addScaledVector(a[6], 0.743125 * i * i - 0.247708),
                      t.addScaledVector(a[7], 0.858086 * n * i),
                      t.addScaledVector(a[8], 0.429043 * (n * n - r * r)),
                      t
                    );
                  },
                },
                {
                  key: "add",
                  value: function add(e) {
                    for (var t = 0; t < 9; t++)
                      this.coefficients[t].add(e.coefficients[t]);
                    return this;
                  },
                },
                {
                  key: "addScaledSH",
                  value: function addScaledSH(e, t) {
                    for (var n = 0; n < 9; n++)
                      this.coefficients[n].addScaledVector(
                        e.coefficients[n],
                        t
                      );
                    return this;
                  },
                },
                {
                  key: "scale",
                  value: function scale(e) {
                    for (var t = 0; t < 9; t++)
                      this.coefficients[t].multiplyScalar(e);
                    return this;
                  },
                },
                {
                  key: "lerp",
                  value: function lerp(e, t) {
                    for (var n = 0; n < 9; n++)
                      this.coefficients[n].lerp(e.coefficients[n], t);
                    return this;
                  },
                },
                {
                  key: "equals",
                  value: function equals(e) {
                    for (var t = 0; t < 9; t++)
                      if (!this.coefficients[t].equals(e.coefficients[t]))
                        return !1;
                    return !0;
                  },
                },
                {
                  key: "copy",
                  value: function copy(e) {
                    return this.set(e.coefficients);
                  },
                },
                {
                  key: "clone",
                  value: function clone() {
                    return new this.constructor().copy(this);
                  },
                },
                {
                  key: "fromArray",
                  value: function fromArray(e) {
                    for (
                      var t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : 0,
                        n = this.coefficients,
                        r = 0;
                      r < 9;
                      r++
                    )
                      n[r].fromArray(e, t + 3 * r);
                    return this;
                  },
                },
                {
                  key: "toArray",
                  value: function toArray() {
                    for (
                      var e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : [],
                        t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : 0,
                        n = this.coefficients,
                        r = 0;
                      r < 9;
                      r++
                    )
                      n[r].toArray(e, t + 3 * r);
                    return e;
                  },
                },
              ],
              [
                {
                  key: "getBasisAt",
                  value: function getBasisAt(e, t) {
                    var n = e.x,
                      r = e.y,
                      i = e.z;
                    (t[0] = 0.282095),
                      (t[1] = 0.488603 * r),
                      (t[2] = 0.488603 * i),
                      (t[3] = 0.488603 * n),
                      (t[4] = 1.092548 * n * r),
                      (t[5] = 1.092548 * r * i),
                      (t[6] = 0.315392 * (3 * i * i - 1)),
                      (t[7] = 1.092548 * n * i),
                      (t[8] = 0.546274 * (n * n - r * r));
                  },
                },
              ]
            ),
            SphericalHarmonics3
          );
        })(),
        _l = (function (e) {
          function LightProbe() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new xl(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1;
            return (
              Object(f.a)(this, LightProbe),
              ((e = Object(s.a)(
                this,
                Object(r.a)(LightProbe).call(this, void 0, n)
              )).isLightProbe = !0),
              (e.sh = t),
              e
            );
          }
          return (
            Object(u.a)(LightProbe, e),
            Object(p.a)(LightProbe, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(LightProbe.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    this.sh.copy(e.sh),
                    this
                  );
                },
              },
              {
                key: "fromJSON",
                value: function fromJSON(e) {
                  return (
                    (this.intensity = e.intensity),
                    this.sh.fromArray(e.sh),
                    this
                  );
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(LightProbe.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (t.object.sh = this.sh.toArray()), t;
                },
              },
            ]),
            LightProbe
          );
        })(rl),
        Ml = (function (e) {
          function MaterialLoader(e) {
            console.log(e);
            var t;
            return (
              Object(f.a)(this, MaterialLoader),
              ((t = Object(s.a)(
                this,
                Object(r.a)(MaterialLoader).call(this, e)
              )).textures = {}),
              t
            );
          }
          return (
            Object(u.a)(MaterialLoader, e),
            Object(p.a)(
              MaterialLoader,
              [
                {
                  key: "load",
                  value: function load(e, t, n, r) {
                    console.log(e, t, n, r);
                    var i = this,
                      a = new Zu(i.manager);
                    a.setPath(i.path),
                      a.setRequestHeader(i.requestHeader),
                      a.setWithCredentials(i.withCredentials),
                      a.load(
                        e,
                        function (n) {
                          try {
                            t(i.parse(JSON.parse(n)));
                          } catch (a) {
                            r ? r(a) : console.error(a), i.manager.itemError(e);
                          }
                        },
                        n,
                        r
                      );
                  },
                },
                {
                  key: "parse",
                  value: function parse(e) {
                    console.log(e);
                    var t;
                    t = this.textures;

                    function getTexture(e) {
                      return (
                        void 0 === t[e] &&
                          console.warn(
                            "THREE.MaterialLoader: Undefined texture",
                            e
                          ),
                        t[e]
                      );
                    }
                    var n = MaterialLoader.createMaterialFromType(e.type);
                    if (
                      (void 0 !== e.uuid && (n.uuid = e.uuid),
                      void 0 !== e.name && (n.name = e.name),
                      void 0 !== e.color &&
                        void 0 !== n.color &&
                        n.color.setHex(e.color),
                      void 0 !== e.roughness && (n.roughness = e.roughness),
                      void 0 !== e.metalness && (n.metalness = e.metalness),
                      void 0 !== e.sheen && (n.sheen = e.sheen),
                      void 0 !== e.sheenColor &&
                        (n.sheenColor = new Hn().setHex(e.sheenColor)),
                      void 0 !== e.sheenRoughness &&
                        (n.sheenRoughness = e.sheenRoughness),
                      void 0 !== e.emissive &&
                        void 0 !== n.emissive &&
                        n.emissive.setHex(e.emissive),
                      void 0 !== e.specular &&
                        void 0 !== n.specular &&
                        n.specular.setHex(e.specular),
                      void 0 !== e.specularIntensity &&
                        (n.specularIntensity = e.specularIntensity),
                      void 0 !== e.specularColor &&
                        void 0 !== n.specularColor &&
                        n.specularColor.setHex(e.specularColor),
                      void 0 !== e.shininess && (n.shininess = e.shininess),
                      void 0 !== e.clearcoat && (n.clearcoat = e.clearcoat),
                      void 0 !== e.clearcoatRoughness &&
                        (n.clearcoatRoughness = e.clearcoatRoughness),
                      void 0 !== e.iridescence &&
                        (n.iridescence = e.iridescence),
                      void 0 !== e.iridescenceIOR &&
                        (n.iridescenceIOR = e.iridescenceIOR),
                      void 0 !== e.iridescenceThicknessRange &&
                        (n.iridescenceThicknessRange =
                          e.iridescenceThicknessRange),
                      void 0 !== e.transmission &&
                        (n.transmission = e.transmission),
                      void 0 !== e.thickness && (n.thickness = e.thickness),
                      void 0 !== e.attenuationDistance &&
                        (n.attenuationDistance = e.attenuationDistance),
                      void 0 !== e.attenuationColor &&
                        void 0 !== n.attenuationColor &&
                        n.attenuationColor.setHex(e.attenuationColor),
                      void 0 !== e.fog && (n.fog = e.fog),
                      void 0 !== e.flatShading &&
                        (n.flatShading = e.flatShading),
                      void 0 !== e.blending && (n.blending = e.blending),
                      void 0 !== e.combine && (n.combine = e.combine),
                      void 0 !== e.side && (n.side = e.side),
                      void 0 !== e.shadowSide && (n.shadowSide = e.shadowSide),
                      void 0 !== e.opacity && (n.opacity = e.opacity),
                      void 0 !== e.transparent &&
                        (n.transparent = e.transparent),
                      void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest),
                      void 0 !== e.depthTest && (n.depthTest = e.depthTest),
                      void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite),
                      void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite),
                      void 0 !== e.stencilWrite &&
                        (n.stencilWrite = e.stencilWrite),
                      void 0 !== e.stencilWriteMask &&
                        (n.stencilWriteMask = e.stencilWriteMask),
                      void 0 !== e.stencilFunc &&
                        (n.stencilFunc = e.stencilFunc),
                      void 0 !== e.stencilRef && (n.stencilRef = e.stencilRef),
                      void 0 !== e.stencilFuncMask &&
                        (n.stencilFuncMask = e.stencilFuncMask),
                      void 0 !== e.stencilFail &&
                        (n.stencilFail = e.stencilFail),
                      void 0 !== e.stencilZFail &&
                        (n.stencilZFail = e.stencilZFail),
                      void 0 !== e.stencilZPass &&
                        (n.stencilZPass = e.stencilZPass),
                      void 0 !== e.wireframe && (n.wireframe = e.wireframe),
                      void 0 !== e.wireframeLinewidth &&
                        (n.wireframeLinewidth = e.wireframeLinewidth),
                      void 0 !== e.wireframeLinecap &&
                        (n.wireframeLinecap = e.wireframeLinecap),
                      void 0 !== e.wireframeLinejoin &&
                        (n.wireframeLinejoin = e.wireframeLinejoin),
                      void 0 !== e.rotation && (n.rotation = e.rotation),
                      1 !== e.linewidth && (n.linewidth = e.linewidth),
                      void 0 !== e.dashSize && (n.dashSize = e.dashSize),
                      void 0 !== e.gapSize && (n.gapSize = e.gapSize),
                      void 0 !== e.scale && (n.scale = e.scale),
                      void 0 !== e.polygonOffset &&
                        (n.polygonOffset = e.polygonOffset),
                      void 0 !== e.polygonOffsetFactor &&
                        (n.polygonOffsetFactor = e.polygonOffsetFactor),
                      void 0 !== e.polygonOffsetUnits &&
                        (n.polygonOffsetUnits = e.polygonOffsetUnits),
                      void 0 !== e.dithering && (n.dithering = e.dithering),
                      void 0 !== e.alphaToCoverage &&
                        (n.alphaToCoverage = e.alphaToCoverage),
                      void 0 !== e.premultipliedAlpha &&
                        (n.premultipliedAlpha = e.premultipliedAlpha),
                      void 0 !== e.visible && (n.visible = e.visible),
                      void 0 !== e.toneMapped && (n.toneMapped = e.toneMapped),
                      void 0 !== e.userData && (n.userData = e.userData),
                      void 0 !== e.vertexColors &&
                        ("number" === typeof e.vertexColors
                          ? (n.vertexColors = e.vertexColors > 0)
                          : (n.vertexColors = e.vertexColors)),
                      void 0 !== e.uniforms)
                    )
                      for (var r in e.uniforms) {
                        var i = e.uniforms[r];
                        switch (((n.uniforms[r] = {}), i.type)) {
                          case "t":
                            n.uniforms[r].value = getTexture(i.value);
                            break;
                          case "c":
                            n.uniforms[r].value = new Hn().setHex(i.value);
                            break;
                          case "v2":
                            n.uniforms[r].value = new Dn().fromArray(i.value);
                            break;
                          case "v3":
                            n.uniforms[r].value = new ir().fromArray(i.value);
                            break;
                          case "v4":
                            n.uniforms[r].value = new Zn().fromArray(i.value);
                            break;
                          case "m3":
                            n.uniforms[r].value = new jn().fromArray(i.value);
                            break;
                          case "m4":
                            n.uniforms[r].value = new Ir().fromArray(i.value);
                            break;
                          default:
                            n.uniforms[r].value = i.value;
                        }
                      }
                    if (
                      (void 0 !== e.defines && (n.defines = e.defines),
                      void 0 !== e.vertexShader &&
                        (n.vertexShader = e.vertexShader),
                      void 0 !== e.fragmentShader &&
                        (n.fragmentShader = e.fragmentShader),
                      void 0 !== e.extensions)
                    )
                      for (var a in e.extensions)
                        n.extensions[a] = e.extensions[a];
                    if (
                      (void 0 !== e.shading &&
                        (n.flatShading = 1 === e.shading),
                      void 0 !== e.size && (n.size = e.size),
                      void 0 !== e.sizeAttenuation &&
                        (n.sizeAttenuation = e.sizeAttenuation),
                      void 0 !== e.map && (n.map = getTexture(e.map)),
                      void 0 !== e.matcap && (n.matcap = getTexture(e.matcap)),
                      void 0 !== e.alphaMap &&
                        (n.alphaMap = getTexture(e.alphaMap)),
                      void 0 !== e.bumpMap &&
                        (n.bumpMap = getTexture(e.bumpMap)),
                      void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale),
                      void 0 !== e.normalMap &&
                        (n.normalMap = getTexture(e.normalMap)),
                      void 0 !== e.normalMapType &&
                        (n.normalMapType = e.normalMapType),
                      void 0 !== e.normalScale)
                    ) {
                      var o = e.normalScale;
                      !1 === Array.isArray(o) && (o = [o, o]),
                        (n.normalScale = new Dn().fromArray(o));
                    }
                    return (
                      void 0 !== e.displacementMap &&
                        (n.displacementMap = getTexture(e.displacementMap)),
                      void 0 !== e.displacementScale &&
                        (n.displacementScale = e.displacementScale),
                      void 0 !== e.displacementBias &&
                        (n.displacementBias = e.displacementBias),
                      void 0 !== e.roughnessMap &&
                        (n.roughnessMap = getTexture(e.roughnessMap)),
                      void 0 !== e.metalnessMap &&
                        (n.metalnessMap = getTexture(e.metalnessMap)),
                      void 0 !== e.emissiveMap &&
                        (n.emissiveMap = getTexture(e.emissiveMap)),
                      void 0 !== e.emissiveIntensity &&
                        (n.emissiveIntensity = e.emissiveIntensity),
                      void 0 !== e.specularMap &&
                        (n.specularMap = getTexture(e.specularMap)),
                      void 0 !== e.specularIntensityMap &&
                        (n.specularIntensityMap = getTexture(
                          e.specularIntensityMap
                        )),
                      void 0 !== e.specularColorMap &&
                        (n.specularColorMap = getTexture(e.specularColorMap)),
                      void 0 !== e.envMap && (n.envMap = getTexture(e.envMap)),
                      void 0 !== e.envMapIntensity &&
                        (n.envMapIntensity = e.envMapIntensity),
                      void 0 !== e.reflectivity &&
                        (n.reflectivity = e.reflectivity),
                      void 0 !== e.refractionRatio &&
                        (n.refractionRatio = e.refractionRatio),
                      void 0 !== e.lightMap &&
                        (n.lightMap = getTexture(e.lightMap)),
                      void 0 !== e.lightMapIntensity &&
                        (n.lightMapIntensity = e.lightMapIntensity),
                      void 0 !== e.aoMap && (n.aoMap = getTexture(e.aoMap)),
                      void 0 !== e.aoMapIntensity &&
                        (n.aoMapIntensity = e.aoMapIntensity),
                      void 0 !== e.gradientMap &&
                        (n.gradientMap = getTexture(e.gradientMap)),
                      void 0 !== e.clearcoatMap &&
                        (n.clearcoatMap = getTexture(e.clearcoatMap)),
                      void 0 !== e.clearcoatRoughnessMap &&
                        (n.clearcoatRoughnessMap = getTexture(
                          e.clearcoatRoughnessMap
                        )),
                      void 0 !== e.clearcoatNormalMap &&
                        (n.clearcoatNormalMap = getTexture(
                          e.clearcoatNormalMap
                        )),
                      void 0 !== e.clearcoatNormalScale &&
                        (n.clearcoatNormalScale = new Dn().fromArray(
                          e.clearcoatNormalScale
                        )),
                      void 0 !== e.iridescenceMap &&
                        (n.iridescenceMap = getTexture(e.iridescenceMap)),
                      void 0 !== e.iridescenceThicknessMap &&
                        (n.iridescenceThicknessMap = getTexture(
                          e.iridescenceThicknessMap
                        )),
                      void 0 !== e.transmissionMap &&
                        (n.transmissionMap = getTexture(e.transmissionMap)),
                      void 0 !== e.thicknessMap &&
                        (n.thicknessMap = getTexture(e.thicknessMap)),
                      void 0 !== e.sheenColorMap &&
                        (n.sheenColorMap = getTexture(e.sheenColorMap)),
                      void 0 !== e.sheenRoughnessMap &&
                        (n.sheenRoughnessMap = getTexture(e.sheenRoughnessMap)),
                      n
                    );
                  },
                },
                {
                  key: "setTextures",
                  value: function setTextures(e) {
                    return (this.textures = e), this;
                  },
                },
              ],
              [
                {
                  key: "createMaterialFromType",
                  value: function createMaterialFromType(e) {
                    return new {
                      ShadowMaterial: bu,
                      SpriteMaterial: Ao,
                      RawShaderMaterial: xu,
                      ShaderMaterial: la,
                      PointsMaterial: gs,
                      MeshPhysicalMaterial: Mu,
                      MeshStandardMaterial: _u,
                      MeshPhongMaterial: Su,
                      MeshToonMaterial: wu,
                      MeshNormalMaterial: Tu,
                      MeshLambertMaterial: Au,
                      MeshDepthMaterial: so,
                      MeshDistanceMaterial: uo,
                      MeshBasicMaterial: bi,
                      MeshMatcapMaterial: Ou,
                      LineDashedMaterial: Cu,
                      LineBasicMaterial: os,
                      Material: yi,
                    }[e]();
                  },
                },
              ]
            ),
            MaterialLoader
          );
        })(Xu),
        Sl = (function () {
          function LoaderUtils() {
            Object(f.a)(this, LoaderUtils);
          }
          return (
            Object(p.a)(LoaderUtils, null, [
              {
                key: "decodeText",
                value: function decodeText(e) {
                  if ("undefined" !== typeof TextDecoder)
                    return new TextDecoder().decode(e);
                  for (var t = "", n = 0, r = e.length; n < r; n++)
                    t += String.fromCharCode(e[n]);
                  try {
                    return decodeURIComponent(escape(t));
                  } catch (i) {
                    return t;
                  }
                },
              },
              {
                key: "extractUrlBase",
                value: function extractUrlBase(e) {
                  var t = e.lastIndexOf("/");
                  return -1 === t ? "./" : e.slice(0, t + 1);
                },
              },
              {
                key: "resolveURL",
                value: function resolveURL(e, t) {
                  return "string" !== typeof e || "" === e
                    ? ""
                    : (/^https?:\/\//i.test(t) &&
                        /^\//.test(e) &&
                        (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                      /^(https?:)?\/\//i.test(e)
                        ? e
                        : /^data:.*,.*$/i.test(e)
                        ? e
                        : /^blob:.*$/i.test(e)
                        ? e
                        : t + e);
                },
              },
            ]),
            LoaderUtils
          );
        })(),
        wl = (function (e) {
          function InstancedBufferGeometry() {
            var e;
            return (
              Object(f.a)(this, InstancedBufferGeometry),
              ((e = Object(s.a)(
                this,
                Object(r.a)(InstancedBufferGeometry).call(this)
              )).isInstancedBufferGeometry = !0),
              (e.type = "InstancedBufferGeometry"),
              (e.instanceCount = 1 / 0),
              e
            );
          }
          return (
            Object(u.a)(InstancedBufferGeometry, e),
            Object(p.a)(InstancedBufferGeometry, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(InstancedBufferGeometry.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.instanceCount = e.instanceCount),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "toJSON",
                value: function toJSON() {
                  var e = Object(o.a)(
                    Object(r.a)(InstancedBufferGeometry.prototype),
                    "toJSON",
                    this
                  ).call(this, this);
                  return (
                    (e.instanceCount = this.instanceCount),
                    (e.isInstancedBufferGeometry = !0),
                    e
                  );
                },
              },
            ]),
            InstancedBufferGeometry
          );
        })(Fi),
        Tl = (function (e) {
          function BufferGeometryLoader(e) {
            return (
              Object(f.a)(this, BufferGeometryLoader),
              Object(s.a)(this, Object(r.a)(BufferGeometryLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(BufferGeometryLoader, e),
            Object(p.a)(BufferGeometryLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this,
                    a = new Zu(i.manager);
                  a.setPath(i.path),
                    a.setRequestHeader(i.requestHeader),
                    a.setWithCredentials(i.withCredentials),
                    a.load(
                      e,
                      function (n) {
                        try {
                          t(i.parse(JSON.parse(n)));
                        } catch (a) {
                          r ? r(a) : console.error(a), i.manager.itemError(e);
                        }
                      },
                      n,
                      r
                    );
                },
              },
              {
                key: "parse",
                value: function parse(e) {
                  var t = {},
                    n = {};
                  function getInterleavedBuffer(e, r) {
                    if (void 0 !== t[r]) return t[r];
                    var i = e.interleavedBuffers[r],
                      a = (function getArrayBuffer(e, t) {
                        if (void 0 !== n[t]) return n[t];
                        var r = e.arrayBuffers[t],
                          i = new Uint32Array(r).buffer;
                        return (n[t] = i), i;
                      })(e, i.buffer),
                      o = getTypedArray(i.type, a),
                      s = new So(o, i.stride);
                    return (s.uuid = i.uuid), (t[r] = s), s;
                  }
                  var r = e.isInstancedBufferGeometry ? new wl() : new Fi(),
                    i = e.data.index;
                  if (void 0 !== i) {
                    var a = getTypedArray(i.type, i.array);
                    r.setIndex(new Mi(a, 1));
                  }
                  var o = e.data.attributes;
                  for (var s in o) {
                    var u = o[s],
                      l = void 0;
                    if (u.isInterleavedBufferAttribute) {
                      var c = getInterleavedBuffer(e.data, u.data);
                      l = new To(c, u.itemSize, u.offset, u.normalized);
                    } else {
                      var h = getTypedArray(u.type, u.array);
                      l = new (u.isInstancedBufferAttribute ? es : Mi)(
                        h,
                        u.itemSize,
                        u.normalized
                      );
                    }
                    void 0 !== u.name && (l.name = u.name),
                      void 0 !== u.usage && l.setUsage(u.usage),
                      void 0 !== u.updateRange &&
                        ((l.updateRange.offset = u.updateRange.offset),
                        (l.updateRange.count = u.updateRange.count)),
                      r.setAttribute(s, l);
                  }
                  var d = e.data.morphAttributes;
                  if (d)
                    for (var f in d) {
                      for (
                        var p = d[f], m = [], v = 0, g = p.length;
                        v < g;
                        v++
                      ) {
                        var y = p[v],
                          b = void 0;
                        if (y.isInterleavedBufferAttribute) {
                          var x = getInterleavedBuffer(e.data, y.data);
                          b = new To(x, y.itemSize, y.offset, y.normalized);
                        } else {
                          var _ = getTypedArray(y.type, y.array);
                          b = new Mi(_, y.itemSize, y.normalized);
                        }
                        void 0 !== y.name && (b.name = y.name), m.push(b);
                      }
                      r.morphAttributes[f] = m;
                    }
                  e.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                  var M = e.data.groups || e.data.drawcalls || e.data.offsets;
                  if (void 0 !== M)
                    for (var S = 0, w = M.length; S !== w; ++S) {
                      var T = M[S];
                      r.addGroup(T.start, T.count, T.materialIndex);
                    }
                  var A = e.data.boundingSphere;
                  if (void 0 !== A) {
                    var O = new ir();
                    void 0 !== A.center && O.fromArray(A.center),
                      (r.boundingSphere = new Tr(O, A.radius));
                  }
                  return (
                    e.name && (r.name = e.name),
                    e.userData && (r.userData = e.userData),
                    r
                  );
                },
              },
            ]),
            BufferGeometryLoader
          );
        })(Xu),
        Al = (function (e) {
          function ObjectLoader(e) {
            return (
              Object(f.a)(this, ObjectLoader),
              Object(s.a)(this, Object(r.a)(ObjectLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(ObjectLoader, e),
            Object(p.a)(ObjectLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this,
                    a = "" === this.path ? Sl.extractUrlBase(e) : this.path;
                  this.resourcePath = this.resourcePath || a;
                  var o = new Zu(this.manager);
                  o.setPath(this.path),
                    o.setRequestHeader(this.requestHeader),
                    o.setWithCredentials(this.withCredentials),
                    o.load(
                      e,
                      function (n) {
                        var a = null;
                        try {
                          a = JSON.parse(n);
                        } catch (s) {
                          return (
                            void 0 !== r && r(s),
                            void console.error(
                              "THREE:ObjectLoader: Can't parse " + e + ".",
                              s.message
                            )
                          );
                        }
                        var o = a.metadata;
                        void 0 !== o &&
                        void 0 !== o.type &&
                        "geometry" !== o.type.toLowerCase()
                          ? i.parse(a, t)
                          : console.error(
                              "THREE.ObjectLoader: Can't load " + e
                            );
                      },
                      n,
                      r
                    );
                },
              },
              {
                key: "loadAsync",
                value: (function () {
                  var e = _asyncToGenerator(
                    d.a.mark(function _callee2(e, t) {
                      var n, r, i, a, o, s;
                      return d.a.wrap(
                        function _callee2$(u) {
                          for (;;)
                            switch ((u.prev = u.next)) {
                              case 0:
                                return (
                                  (n = this),
                                  (r =
                                    "" === this.path
                                      ? Sl.extractUrlBase(e)
                                      : this.path),
                                  (this.resourcePath = this.resourcePath || r),
                                  (i = new Zu(this.manager)).setPath(this.path),
                                  i.setRequestHeader(this.requestHeader),
                                  i.setWithCredentials(this.withCredentials),
                                  (u.next = 9),
                                  i.loadAsync(e, t)
                                );
                              case 9:
                                if (
                                  ((a = u.sent),
                                  (o = JSON.parse(a)),
                                  void 0 !== (s = o.metadata) &&
                                    void 0 !== s.type &&
                                    "geometry" !== s.type.toLowerCase())
                                ) {
                                  u.next = 14;
                                  break;
                                }
                                throw new Error(
                                  "THREE.ObjectLoader: Can't load " + e
                                );
                              case 14:
                                return (u.next = 16), n.parseAsync(o);
                              case 16:
                                return u.abrupt("return", u.sent);
                              case 17:
                              case "end":
                                return u.stop();
                            }
                        },
                        _callee2,
                        this
                      );
                    })
                  );
                  return function loadAsync(t, n) {
                    return e.apply(this, arguments);
                  };
                })(),
              },
              {
                key: "parse",
                value: function parse(e, t) {
                  var n = this.parseAnimations(e.animations),
                    r = this.parseShapes(e.shapes),
                    i = this.parseGeometries(e.geometries, r),
                    a = this.parseImages(e.images, function () {
                      void 0 !== t && t(u);
                    }),
                    o = this.parseTextures(e.textures, a),
                    s = this.parseMaterials(e.materials, o),
                    u = this.parseObject(e.object, i, s, o, n),
                    l = this.parseSkeletons(e.skeletons, u);
                  if ((this.bindSkeletons(u, l), void 0 !== t)) {
                    var c = !1;
                    for (var h in a)
                      if (a[h].data instanceof HTMLImageElement) {
                        c = !0;
                        break;
                      }
                    !1 === c && t(u);
                  }
                  return u;
                },
              },
              {
                key: "parseAsync",
                value: (function () {
                  var e = _asyncToGenerator(
                    d.a.mark(function _callee3(e) {
                      var t, n, r, i, a, o, s, u;
                      return d.a.wrap(
                        function _callee3$(l) {
                          for (;;)
                            switch ((l.prev = l.next)) {
                              case 0:
                                return (
                                  (t = this.parseAnimations(e.animations)),
                                  (n = this.parseShapes(e.shapes)),
                                  (r = this.parseGeometries(e.geometries, n)),
                                  (l.next = 5),
                                  this.parseImagesAsync(e.images)
                                );
                              case 5:
                                return (
                                  (i = l.sent),
                                  (a = this.parseTextures(e.textures, i)),
                                  (o = this.parseMaterials(e.materials, a)),
                                  (s = this.parseObject(e.object, r, o, a, t)),
                                  (u = this.parseSkeletons(e.skeletons, s)),
                                  this.bindSkeletons(s, u),
                                  l.abrupt("return", s)
                                );
                              case 12:
                              case "end":
                                return l.stop();
                            }
                        },
                        _callee3,
                        this
                      );
                    })
                  );
                  return function parseAsync(t) {
                    return e.apply(this, arguments);
                  };
                })(),
              },
              {
                key: "parseShapes",
                value: function parseShapes(e) {
                  var t = {};
                  if (void 0 !== e)
                    for (var n = 0, r = e.length; n < r; n++) {
                      var i = new ru().fromJSON(e[n]);
                      t[i.uuid] = i;
                    }
                  return t;
                },
              },
              {
                key: "parseSkeletons",
                value: function parseSkeletons(e, t) {
                  var n = {},
                    r = {};
                  if (
                    (t.traverse(function (e) {
                      e.isBone && (r[e.uuid] = e);
                    }),
                    void 0 !== e)
                  )
                    for (var i = 0, a = e.length; i < a; i++) {
                      var o = new $o().fromJSON(e[i], r);
                      n[o.uuid] = o;
                    }
                  return n;
                },
              },
              {
                key: "parseGeometries",
                value: function parseGeometries(e, t) {
                  var n = {};
                  if (void 0 !== e)
                    for (var r = new Tl(), i = 0, a = e.length; i < a; i++) {
                      var o = void 0,
                        s = e[i];
                      switch (s.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                          o = r.parse(s);
                          break;
                        case "Geometry":
                          console.error(
                            "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                          );
                          break;
                        default:
                          s.type in yu
                            ? (o = yu[s.type].fromJSON(s, t))
                            : console.warn(
                                'THREE.ObjectLoader: Unsupported geometry type "'.concat(
                                  s.type,
                                  '"'
                                )
                              );
                      }
                      (o.uuid = s.uuid),
                        void 0 !== s.name && (o.name = s.name),
                        !0 === o.isBufferGeometry &&
                          void 0 !== s.userData &&
                          (o.userData = s.userData),
                        (n[s.uuid] = o);
                    }
                  return n;
                },
              },
              {
                key: "parseMaterials",
                value: function parseMaterials(e, t) {
                  console.log(e, t);
                  var n = {},
                    r = {};
                  if (void 0 !== e) {
                    var i = new Ml();
                    i.setTextures(t);
                    console.log("i", i);
                    for (var a = 0, o = e.length; a < o; a++) {
                      console.log(e);
                      var s = e[a];
                      if ("MultiMaterial" === s.type) {
                        for (var u = [], l = 0; l < s.materials.length; l++) {
                          var c = s.materials[l];
                          console.log(u);
                          void 0 === n[c.uuid] && (n[c.uuid] = i.parse(c)),
                            u.push(n[c.uuid]);
                        }
                        r[s.uuid] = u;
                        console.log(r);
                        console.log(u);
                      } else
                        void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)),
                          (r[s.uuid] = n[s.uuid]);
                    }
                  }
                  return r;
                },
              },
              {
                key: "parseAnimations",
                value: function parseAnimations(e) {
                  var t = {};
                  if (void 0 !== e)
                    for (var n = 0; n < e.length; n++) {
                      var r = e[n],
                        i = Uu.parse(r);
                      t[i.uuid] = i;
                    }
                  return t;
                },
              },
              {
                key: "parseImages",
                value: function parseImages(e, t) {
                  var n,
                    r = this,
                    i = {};
                  function deserializeImage(e) {
                    if ("string" === typeof e) {
                      var t = e;
                      return (function loadImage(e) {
                        return (
                          r.manager.itemStart(e),
                          n.load(
                            e,
                            function () {
                              r.manager.itemEnd(e);
                            },
                            void 0,
                            function () {
                              r.manager.itemError(e), r.manager.itemEnd(e);
                            }
                          )
                        );
                      })(
                        /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)
                          ? t
                          : r.resourcePath + t
                      );
                    }
                    return e.data
                      ? {
                          data: getTypedArray(e.type, e.data),
                          width: e.width,
                          height: e.height,
                        }
                      : null;
                  }
                  if (void 0 !== e && e.length > 0) {
                    var a = new Hu(t);
                    (n = new $u(a)).setCrossOrigin(this.crossOrigin);
                    for (var o = 0, s = e.length; o < s; o++) {
                      var u = e[o],
                        l = u.url;
                      if (Array.isArray(l)) {
                        for (var c = [], h = 0, d = l.length; h < d; h++) {
                          var f = deserializeImage(l[h]);
                          null !== f &&
                            (f instanceof HTMLImageElement
                              ? c.push(f)
                              : c.push(new Zo(f.data, f.width, f.height)));
                        }
                        i[u.uuid] = new Xn(c);
                      } else {
                        var p = deserializeImage(u.url);
                        i[u.uuid] = new Xn(p);
                      }
                    }
                  }
                  return i;
                },
              },
              {
                key: "parseImagesAsync",
                value: (function () {
                  var e = _asyncToGenerator(
                    d.a.mark(function _callee5(e) {
                      var t, n, r, i, a, o, s, u, l, c, h, f, p, m, v;
                      return d.a.wrap(
                        function _callee5$(g) {
                          for (;;)
                            switch ((g.prev = g.next)) {
                              case 0:
                                if (
                                  ((a = function _ref4() {
                                    return (a = _asyncToGenerator(
                                      d.a.mark(function _callee4(e) {
                                        var n, i;
                                        return d.a.wrap(function _callee4$(a) {
                                          for (;;)
                                            switch ((a.prev = a.next)) {
                                              case 0:
                                                if ("string" !== typeof e) {
                                                  a.next = 8;
                                                  break;
                                                }
                                                return (
                                                  (i =
                                                    /^(\/\/)|([a-z]+:(\/\/)?)/i.test(
                                                      (n = e)
                                                    )
                                                      ? n
                                                      : t.resourcePath + n),
                                                  (a.next = 5),
                                                  r.loadAsync(i)
                                                );
                                              case 5:
                                                return a.abrupt(
                                                  "return",
                                                  a.sent
                                                );
                                              case 8:
                                                if (!e.data) {
                                                  a.next = 12;
                                                  break;
                                                }
                                                return a.abrupt("return", {
                                                  data: getTypedArray(
                                                    e.type,
                                                    e.data
                                                  ),
                                                  width: e.width,
                                                  height: e.height,
                                                });
                                              case 12:
                                                return a.abrupt("return", null);
                                              case 13:
                                              case "end":
                                                return a.stop();
                                            }
                                        }, _callee4);
                                      })
                                    )).apply(this, arguments);
                                  }),
                                  (i = function _ref3(e) {
                                    return a.apply(this, arguments);
                                  }),
                                  (t = this),
                                  (n = {}),
                                  !(void 0 !== e && e.length > 0))
                                ) {
                                  g.next = 33;
                                  break;
                                }
                                (r = new $u(this.manager)).setCrossOrigin(
                                  this.crossOrigin
                                ),
                                  (o = 0),
                                  (s = e.length);
                              case 8:
                                if (!(o < s)) {
                                  g.next = 33;
                                  break;
                                }
                                if (
                                  ((u = e[o]), (l = u.url), !Array.isArray(l))
                                ) {
                                  g.next = 26;
                                  break;
                                }
                                (c = []), (h = 0), (f = l.length);
                              case 14:
                                if (!(h < f)) {
                                  g.next = 23;
                                  break;
                                }
                                return (p = l[h]), (g.next = 18), i(p);
                              case 18:
                                null !== (m = g.sent) &&
                                  (m instanceof HTMLImageElement
                                    ? c.push(m)
                                    : c.push(
                                        new Zo(m.data, m.width, m.height)
                                      ));
                              case 20:
                                h++, (g.next = 14);
                                break;
                              case 23:
                                (n[u.uuid] = new Xn(c)), (g.next = 30);
                                break;
                              case 26:
                                return (g.next = 28), i(u.url);
                              case 28:
                                (v = g.sent), (n[u.uuid] = new Xn(v));
                              case 30:
                                o++, (g.next = 8);
                                break;
                              case 33:
                                return g.abrupt("return", n);
                              case 34:
                              case "end":
                                return g.stop();
                            }
                        },
                        _callee5,
                        this
                      );
                    })
                  );
                  return function parseImagesAsync(t) {
                    return e.apply(this, arguments);
                  };
                })(),
              },
              {
                key: "parseTextures",
                value: function parseTextures(e, t) {
                  function parseConstant(e, t) {
                    return "number" === typeof e
                      ? e
                      : (console.warn(
                          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                          e
                        ),
                        t[e]);
                  }
                  var n = {};
                  if (void 0 !== e)
                    for (var r = 0, i = e.length; r < i; r++) {
                      var a = e[r];
                      void 0 === a.image &&
                        console.warn(
                          'THREE.ObjectLoader: No "image" specified for',
                          a.uuid
                        ),
                        void 0 === t[a.image] &&
                          console.warn(
                            "THREE.ObjectLoader: Undefined image",
                            a.image
                          );
                      var o = t[a.image],
                        s = o.data,
                        u = void 0;
                      Array.isArray(s)
                        ? ((u = new ma()),
                          6 === s.length && (u.needsUpdate = !0))
                        : ((u = s && s.data ? new Zo() : new Yn()),
                          s && (u.needsUpdate = !0)),
                        (u.source = o),
                        (u.uuid = a.uuid),
                        void 0 !== a.name && (u.name = a.name),
                        void 0 !== a.mapping &&
                          (u.mapping = parseConstant(a.mapping, Ol)),
                        void 0 !== a.offset && u.offset.fromArray(a.offset),
                        void 0 !== a.repeat && u.repeat.fromArray(a.repeat),
                        void 0 !== a.center && u.center.fromArray(a.center),
                        void 0 !== a.rotation && (u.rotation = a.rotation),
                        void 0 !== a.wrap &&
                          ((u.wrapS = parseConstant(a.wrap[0], Cl)),
                          (u.wrapT = parseConstant(a.wrap[1], Cl))),
                        void 0 !== a.format && (u.format = a.format),
                        void 0 !== a.type && (u.type = a.type),
                        void 0 !== a.encoding && (u.encoding = a.encoding),
                        void 0 !== a.minFilter &&
                          (u.minFilter = parseConstant(a.minFilter, Ll)),
                        void 0 !== a.magFilter &&
                          (u.magFilter = parseConstant(a.magFilter, Ll)),
                        void 0 !== a.anisotropy &&
                          (u.anisotropy = a.anisotropy),
                        void 0 !== a.flipY && (u.flipY = a.flipY),
                        void 0 !== a.premultiplyAlpha &&
                          (u.premultiplyAlpha = a.premultiplyAlpha),
                        void 0 !== a.unpackAlignment &&
                          (u.unpackAlignment = a.unpackAlignment),
                        void 0 !== a.userData && (u.userData = a.userData),
                        (n[a.uuid] = u);
                    }
                  return n;
                },
              },
              {
                key: "parseObject",
                value: function parseObject(e, t, n, r, i) {
                  var a, o, s;
                  function getGeometry(e) {
                    return (
                      void 0 === t[e] &&
                        console.warn(
                          "THREE.ObjectLoader: Undefined geometry",
                          e
                        ),
                      t[e]
                    );
                  }
                  function getMaterial(e) {
                    if (void 0 !== e) {
                      if (Array.isArray(e)) {
                        for (var t = [], r = 0, i = e.length; r < i; r++) {
                          var a = e[r];
                          void 0 === n[a] &&
                            console.warn(
                              "THREE.ObjectLoader: Undefined material",
                              a
                            ),
                            t.push(n[a]);
                        }
                        return t;
                      }
                      return (
                        void 0 === n[e] &&
                          console.warn(
                            "THREE.ObjectLoader: Undefined material",
                            e
                          ),
                        n[e]
                      );
                    }
                  }
                  function getTexture(e) {
                    return (
                      void 0 === r[e] &&
                        console.warn(
                          "THREE.ObjectLoader: Undefined texture",
                          e
                        ),
                      r[e]
                    );
                  }
                  switch (e.type) {
                    case "Scene":
                      (a = new Mo()),
                        void 0 !== e.background &&
                          (Number.isInteger(e.background)
                            ? (a.background = new Hn(e.background))
                            : (a.background = getTexture(e.background))),
                        void 0 !== e.environment &&
                          (a.environment = getTexture(e.environment)),
                        void 0 !== e.fog &&
                          ("Fog" === e.fog.type
                            ? (a.fog = new _o(
                                e.fog.color,
                                e.fog.near,
                                e.fog.far
                              ))
                            : "FogExp2" === e.fog.type &&
                              (a.fog = new xo(e.fog.color, e.fog.density)));
                      break;
                    case "PerspectiveCamera":
                      (a = new ha(e.fov, e.aspect, e.near, e.far)),
                        void 0 !== e.focus && (a.focus = e.focus),
                        void 0 !== e.zoom && (a.zoom = e.zoom),
                        void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge),
                        void 0 !== e.filmOffset &&
                          (a.filmOffset = e.filmOffset),
                        void 0 !== e.view &&
                          (a.view = Object.assign({}, e.view));
                      break;
                    case "OrthographicCamera":
                      (a = new Ca(
                        e.left,
                        e.right,
                        e.top,
                        e.bottom,
                        e.near,
                        e.far
                      )),
                        void 0 !== e.zoom && (a.zoom = e.zoom),
                        void 0 !== e.view &&
                          (a.view = Object.assign({}, e.view));
                      break;
                    case "AmbientLight":
                      a = new yl(e.color, e.intensity);
                      break;
                    case "DirectionalLight":
                      a = new gl(e.color, e.intensity);
                      break;
                    case "PointLight":
                      a = new ml(e.color, e.intensity, e.distance, e.decay);
                      break;
                    case "RectAreaLight":
                      a = new bl(e.color, e.intensity, e.width, e.height);
                      break;
                    case "SpotLight":
                      a = new cl(
                        e.color,
                        e.intensity,
                        e.distance,
                        e.angle,
                        e.penumbra,
                        e.decay
                      );
                      break;
                    case "HemisphereLight":
                      a = new il(e.color, e.groundColor, e.intensity);
                      break;
                    case "LightProbe":
                      a = new _l().fromJSON(e);
                      break;
                    case "SkinnedMesh":
                      (o = getGeometry(e.geometry)),
                        (s = getMaterial(e.material)),
                        (a = new Jo(o, s)),
                        void 0 !== e.bindMode && (a.bindMode = e.bindMode),
                        void 0 !== e.bindMatrix &&
                          a.bindMatrix.fromArray(e.bindMatrix),
                        void 0 !== e.skeleton && (a.skeleton = e.skeleton);
                      break;
                    case "Mesh":
                      (o = getGeometry(e.geometry)),
                        (s = getMaterial(e.material)),
                        (a = new ia(o, s));
                      break;
                    case "InstancedMesh":
                      (o = getGeometry(e.geometry)),
                        (s = getMaterial(e.material));
                      var u = e.count,
                        l = e.instanceMatrix,
                        c = e.instanceColor;
                      ((a = new as(o, s, u)).instanceMatrix = new es(
                        new Float32Array(l.array),
                        16
                      )),
                        void 0 !== c &&
                          (a.instanceColor = new es(
                            new Float32Array(c.array),
                            c.itemSize
                          ));
                      break;
                    case "LOD":
                      a = new Uo();
                      break;
                    case "Line":
                      a = new ds(
                        getGeometry(e.geometry),
                        getMaterial(e.material)
                      );
                      break;
                    case "LineLoop":
                      a = new vs(
                        getGeometry(e.geometry),
                        getMaterial(e.material)
                      );
                      break;
                    case "LineSegments":
                      a = new ms(
                        getGeometry(e.geometry),
                        getMaterial(e.material)
                      );
                      break;
                    case "PointCloud":
                    case "Points":
                      a = new Ms(
                        getGeometry(e.geometry),
                        getMaterial(e.material)
                      );
                      break;
                    case "Sprite":
                      a = new zo(getMaterial(e.material));
                      break;
                    case "Group":
                      a = new fo();
                      break;
                    case "Bone":
                      a = new Yo();
                      break;
                    default:
                      a = new ai();
                  }
                  if (
                    ((a.uuid = e.uuid),
                    void 0 !== e.name && (a.name = e.name),
                    void 0 !== e.matrix
                      ? (a.matrix.fromArray(e.matrix),
                        void 0 !== e.matrixAutoUpdate &&
                          (a.matrixAutoUpdate = e.matrixAutoUpdate),
                        a.matrixAutoUpdate &&
                          a.matrix.decompose(a.position, a.quaternion, a.scale))
                      : (void 0 !== e.position &&
                          a.position.fromArray(e.position),
                        void 0 !== e.rotation &&
                          a.rotation.fromArray(e.rotation),
                        void 0 !== e.quaternion &&
                          a.quaternion.fromArray(e.quaternion),
                        void 0 !== e.scale && a.scale.fromArray(e.scale)),
                    void 0 !== e.castShadow && (a.castShadow = e.castShadow),
                    void 0 !== e.receiveShadow &&
                      (a.receiveShadow = e.receiveShadow),
                    e.shadow &&
                      (void 0 !== e.shadow.bias &&
                        (a.shadow.bias = e.shadow.bias),
                      void 0 !== e.shadow.normalBias &&
                        (a.shadow.normalBias = e.shadow.normalBias),
                      void 0 !== e.shadow.radius &&
                        (a.shadow.radius = e.shadow.radius),
                      void 0 !== e.shadow.mapSize &&
                        a.shadow.mapSize.fromArray(e.shadow.mapSize),
                      void 0 !== e.shadow.camera &&
                        (a.shadow.camera = this.parseObject(e.shadow.camera))),
                    void 0 !== e.visible && (a.visible = e.visible),
                    void 0 !== e.frustumCulled &&
                      (a.frustumCulled = e.frustumCulled),
                    void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder),
                    void 0 !== e.userData && (a.userData = e.userData),
                    void 0 !== e.layers && (a.layers.mask = e.layers),
                    void 0 !== e.children)
                  )
                    for (var h = e.children, d = 0; d < h.length; d++)
                      a.add(this.parseObject(h[d], t, n, r, i));
                  if (void 0 !== e.animations)
                    for (var f = e.animations, p = 0; p < f.length; p++) {
                      var m = f[p];
                      a.animations.push(i[m]);
                    }
                  if ("LOD" === e.type) {
                    void 0 !== e.autoUpdate && (a.autoUpdate = e.autoUpdate);
                    for (var v = e.levels, g = 0; g < v.length; g++) {
                      var y = v[g],
                        b = a.getObjectByProperty("uuid", y.object);
                      void 0 !== b && a.addLevel(b, y.distance);
                    }
                  }
                  return a;
                },
              },
              {
                key: "bindSkeletons",
                value: function bindSkeletons(e, t) {
                  0 !== Object.keys(t).length &&
                    e.traverse(function (e) {
                      if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                        var n = t[e.skeleton];
                        void 0 === n
                          ? console.warn(
                              "THREE.ObjectLoader: No skeleton found with UUID:",
                              e.skeleton
                            )
                          : e.bind(n, e.bindMatrix);
                      }
                    });
                },
              },
            ]),
            ObjectLoader
          );
        })(Xu),
        Ol = {
          UVMapping: ge,
          CubeReflectionMapping: ye,
          CubeRefractionMapping: be,
          EquirectangularReflectionMapping: xe,
          EquirectangularRefractionMapping: _e,
          CubeUVReflectionMapping: Me,
        },
        Cl = {
          RepeatWrapping: Se,
          ClampToEdgeWrapping: we,
          MirroredRepeatWrapping: Te,
        },
        Ll = {
          NearestFilter: Ae,
          NearestMipmapNearestFilter: Oe,
          NearestMipmapLinearFilter: Le,
          LinearFilter: Ee,
          LinearMipmapNearestFilter: Pe,
          LinearMipmapLinearFilter: Ie,
        },
        kl = (function (e) {
          function ImageBitmapLoader(e) {
            var t;
            return (
              Object(f.a)(this, ImageBitmapLoader),
              ((t = Object(s.a)(
                this,
                Object(r.a)(ImageBitmapLoader).call(this, e)
              )).isImageBitmapLoader = !0),
              "undefined" === typeof createImageBitmap &&
                console.warn(
                  "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                ),
              "undefined" === typeof fetch &&
                console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              (t.options = { premultiplyAlpha: "none" }),
              t
            );
          }
          return (
            Object(u.a)(ImageBitmapLoader, e),
            Object(p.a)(ImageBitmapLoader, [
              {
                key: "setOptions",
                value: function setOptions(e) {
                  return (this.options = e), this;
                },
              },
              {
                key: "load",
                value: function load(e, t, n, r) {
                  void 0 === e && (e = ""),
                    void 0 !== this.path && (e = this.path + e),
                    (e = this.manager.resolveURL(e));
                  var i = this,
                    a = Wu.get(e);
                  if (void 0 !== a)
                    return (
                      i.manager.itemStart(e),
                      setTimeout(function () {
                        t && t(a), i.manager.itemEnd(e);
                      }, 0),
                      a
                    );
                  var o = {};
                  (o.credentials =
                    "anonymous" === this.crossOrigin
                      ? "same-origin"
                      : "include"),
                    (o.headers = this.requestHeader),
                    fetch(e, o)
                      .then(function (e) {
                        return e.blob();
                      })
                      .then(function (e) {
                        return createImageBitmap(
                          e,
                          Object.assign(i.options, {
                            colorSpaceConversion: "none",
                          })
                        );
                      })
                      .then(function (n) {
                        Wu.add(e, n), t && t(n), i.manager.itemEnd(e);
                      })
                      .catch(function (t) {
                        r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
                      }),
                    i.manager.itemStart(e);
                },
              },
            ]),
            ImageBitmapLoader
          );
        })(Xu),
        El = {
          getContext: function getContext() {
            return (
              void 0 === Vu &&
                (Vu = new (window.AudioContext || window.webkitAudioContext)()),
              Vu
            );
          },
          setContext: function setContext(e) {
            Vu = e;
          },
        },
        Pl = (function (e) {
          function AudioLoader(e) {
            return (
              Object(f.a)(this, AudioLoader),
              Object(s.a)(this, Object(r.a)(AudioLoader).call(this, e))
            );
          }
          return (
            Object(u.a)(AudioLoader, e),
            Object(p.a)(AudioLoader, [
              {
                key: "load",
                value: function load(e, t, n, r) {
                  var i = this,
                    a = new Zu(this.manager);
                  a.setResponseType("arraybuffer"),
                    a.setPath(this.path),
                    a.setRequestHeader(this.requestHeader),
                    a.setWithCredentials(this.withCredentials),
                    a.load(
                      e,
                      function (n) {
                        try {
                          var a = n.slice(0);
                          El.getContext().decodeAudioData(a, function (e) {
                            t(e);
                          });
                        } catch (o) {
                          r ? r(o) : console.error(o), i.manager.itemError(e);
                        }
                      },
                      n,
                      r
                    );
                },
              },
            ]),
            AudioLoader
          );
        })(Xu),
        Rl = (function (e) {
          function HemisphereLightProbe(e, t) {
            var n,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1;
            Object(f.a)(this, HemisphereLightProbe),
              ((n = Object(s.a)(
                this,
                Object(r.a)(HemisphereLightProbe).call(this, void 0, i)
              )).isHemisphereLightProbe = !0);
            var a = new Hn().set(e),
              o = new Hn().set(t),
              u = new ir(a.r, a.g, a.b),
              l = new ir(o.r, o.g, o.b),
              c = Math.sqrt(Math.PI),
              h = c * Math.sqrt(0.75);
            return (
              n.sh.coefficients[0].copy(u).add(l).multiplyScalar(c),
              n.sh.coefficients[1].copy(u).sub(l).multiplyScalar(h),
              n
            );
          }
          return Object(u.a)(HemisphereLightProbe, e), HemisphereLightProbe;
        })(_l),
        Il = (function (e) {
          function AmbientLightProbe(e) {
            var t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1;
            Object(f.a)(this, AmbientLightProbe),
              ((t = Object(s.a)(
                this,
                Object(r.a)(AmbientLightProbe).call(this, void 0, n)
              )).isAmbientLightProbe = !0);
            var i = new Hn().set(e);
            return (
              t.sh.coefficients[0]
                .set(i.r, i.g, i.b)
                .multiplyScalar(2 * Math.sqrt(Math.PI)),
              t
            );
          }
          return Object(u.a)(AmbientLightProbe, e), AmbientLightProbe;
        })(_l),
        Dl = new Ir(),
        jl = new Ir(),
        Bl = new Ir(),
        Nl = (function () {
          function StereoCamera() {
            Object(f.a)(this, StereoCamera),
              (this.type = "StereoCamera"),
              (this.aspect = 1),
              (this.eyeSep = 0.064),
              (this.cameraL = new ha()),
              this.cameraL.layers.enable(1),
              (this.cameraL.matrixAutoUpdate = !1),
              (this.cameraR = new ha()),
              this.cameraR.layers.enable(2),
              (this.cameraR.matrixAutoUpdate = !1),
              (this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null,
              });
          }
          return (
            Object(p.a)(StereoCamera, [
              {
                key: "update",
                value: function update(e) {
                  var t = this._cache;
                  if (
                    t.focus !== e.focus ||
                    t.fov !== e.fov ||
                    t.aspect !== e.aspect * this.aspect ||
                    t.near !== e.near ||
                    t.far !== e.far ||
                    t.zoom !== e.zoom ||
                    t.eyeSep !== this.eyeSep
                  ) {
                    (t.focus = e.focus),
                      (t.fov = e.fov),
                      (t.aspect = e.aspect * this.aspect),
                      (t.near = e.near),
                      (t.far = e.far),
                      (t.zoom = e.zoom),
                      (t.eyeSep = this.eyeSep),
                      Bl.copy(e.projectionMatrix);
                    var n,
                      r,
                      i = t.eyeSep / 2,
                      a = (i * t.near) / t.focus,
                      o = (t.near * Math.tan(Pn * t.fov * 0.5)) / t.zoom;
                    (jl.elements[12] = -i),
                      (Dl.elements[12] = i),
                      (n = -o * t.aspect + a),
                      (r = o * t.aspect + a),
                      (Bl.elements[0] = (2 * t.near) / (r - n)),
                      (Bl.elements[8] = (r + n) / (r - n)),
                      this.cameraL.projectionMatrix.copy(Bl),
                      (n = -o * t.aspect - a),
                      (r = o * t.aspect - a),
                      (Bl.elements[0] = (2 * t.near) / (r - n)),
                      (Bl.elements[8] = (r + n) / (r - n)),
                      this.cameraR.projectionMatrix.copy(Bl);
                  }
                  this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(jl),
                    this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Dl);
                },
              },
            ]),
            StereoCamera
          );
        })(),
        zl = (function () {
          function Clock() {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            Object(f.a)(this, Clock),
              (this.autoStart = e),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          return (
            Object(p.a)(Clock, [
              {
                key: "start",
                value: function start() {
                  (this.startTime = now()),
                    (this.oldTime = this.startTime),
                    (this.elapsedTime = 0),
                    (this.running = !0);
                },
              },
              {
                key: "stop",
                value: function stop() {
                  this.getElapsedTime(),
                    (this.running = !1),
                    (this.autoStart = !1);
                },
              },
              {
                key: "getElapsedTime",
                value: function getElapsedTime() {
                  return this.getDelta(), this.elapsedTime;
                },
              },
              {
                key: "getDelta",
                value: function getDelta() {
                  var e = 0;
                  if (this.autoStart && !this.running) return this.start(), 0;
                  if (this.running) {
                    var t = now();
                    (e = (t - this.oldTime) / 1e3),
                      (this.oldTime = t),
                      (this.elapsedTime += e);
                  }
                  return e;
                },
              },
            ]),
            Clock
          );
        })();
      function now() {
        return ("undefined" === typeof performance ? Date : performance).now();
      }
      var Fl = new ir(),
        Gl = new rr(),
        Ul = new ir(),
        Vl = new ir(),
        Wl = (function (e) {
          function AudioListener() {
            var e;
            return (
              Object(f.a)(this, AudioListener),
              ((e = Object(s.a)(
                this,
                Object(r.a)(AudioListener).call(this)
              )).type = "AudioListener"),
              (e.context = El.getContext()),
              (e.gain = e.context.createGain()),
              e.gain.connect(e.context.destination),
              (e.filter = null),
              (e.timeDelta = 0),
              (e._clock = new zl()),
              e
            );
          }
          return (
            Object(u.a)(AudioListener, e),
            Object(p.a)(AudioListener, [
              {
                key: "getInput",
                value: function getInput() {
                  return this.gain;
                },
              },
              {
                key: "removeFilter",
                value: function removeFilter() {
                  return (
                    null !== this.filter &&
                      (this.gain.disconnect(this.filter),
                      this.filter.disconnect(this.context.destination),
                      this.gain.connect(this.context.destination),
                      (this.filter = null)),
                    this
                  );
                },
              },
              {
                key: "getFilter",
                value: function getFilter() {
                  return this.filter;
                },
              },
              {
                key: "setFilter",
                value: function setFilter(e) {
                  return (
                    null !== this.filter
                      ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination))
                      : this.gain.disconnect(this.context.destination),
                    (this.filter = e),
                    this.gain.connect(this.filter),
                    this.filter.connect(this.context.destination),
                    this
                  );
                },
              },
              {
                key: "getMasterVolume",
                value: function getMasterVolume() {
                  return this.gain.gain.value;
                },
              },
              {
                key: "setMasterVolume",
                value: function setMasterVolume(e) {
                  return (
                    this.gain.gain.setTargetAtTime(
                      e,
                      this.context.currentTime,
                      0.01
                    ),
                    this
                  );
                },
              },
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  Object(o.a)(
                    Object(r.a)(AudioListener.prototype),
                    "updateMatrixWorld",
                    this
                  ).call(this, e);
                  var t = this.context.listener,
                    n = this.up;
                  if (
                    ((this.timeDelta = this._clock.getDelta()),
                    this.matrixWorld.decompose(Fl, Gl, Ul),
                    Vl.set(0, 0, -1).applyQuaternion(Gl),
                    t.positionX)
                  ) {
                    var i = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(Fl.x, i),
                      t.positionY.linearRampToValueAtTime(Fl.y, i),
                      t.positionZ.linearRampToValueAtTime(Fl.z, i),
                      t.forwardX.linearRampToValueAtTime(Vl.x, i),
                      t.forwardY.linearRampToValueAtTime(Vl.y, i),
                      t.forwardZ.linearRampToValueAtTime(Vl.z, i),
                      t.upX.linearRampToValueAtTime(n.x, i),
                      t.upY.linearRampToValueAtTime(n.y, i),
                      t.upZ.linearRampToValueAtTime(n.z, i);
                  } else
                    t.setPosition(Fl.x, Fl.y, Fl.z),
                      t.setOrientation(Vl.x, Vl.y, Vl.z, n.x, n.y, n.z);
                },
              },
            ]),
            AudioListener
          );
        })(ai),
        Hl = (function (e) {
          function Audio(e) {
            var t;
            return (
              Object(f.a)(this, Audio),
              ((t = Object(s.a)(this, Object(r.a)(Audio).call(this))).type =
                "Audio"),
              (t.listener = e),
              (t.context = e.context),
              (t.gain = t.context.createGain()),
              t.gain.connect(e.getInput()),
              (t.autoplay = !1),
              (t.buffer = null),
              (t.detune = 0),
              (t.loop = !1),
              (t.loopStart = 0),
              (t.loopEnd = 0),
              (t.offset = 0),
              (t.duration = void 0),
              (t.playbackRate = 1),
              (t.isPlaying = !1),
              (t.hasPlaybackControl = !0),
              (t.source = null),
              (t.sourceType = "empty"),
              (t._startedAt = 0),
              (t._progress = 0),
              (t._connected = !1),
              (t.filters = []),
              t
            );
          }
          return (
            Object(u.a)(Audio, e),
            Object(p.a)(Audio, [
              {
                key: "getOutput",
                value: function getOutput() {
                  return this.gain;
                },
              },
              {
                key: "setNodeSource",
                value: function setNodeSource(e) {
                  return (
                    (this.hasPlaybackControl = !1),
                    (this.sourceType = "audioNode"),
                    (this.source = e),
                    this.connect(),
                    this
                  );
                },
              },
              {
                key: "setMediaElementSource",
                value: function setMediaElementSource(e) {
                  return (
                    (this.hasPlaybackControl = !1),
                    (this.sourceType = "mediaNode"),
                    (this.source = this.context.createMediaElementSource(e)),
                    this.connect(),
                    this
                  );
                },
              },
              {
                key: "setMediaStreamSource",
                value: function setMediaStreamSource(e) {
                  return (
                    (this.hasPlaybackControl = !1),
                    (this.sourceType = "mediaStreamNode"),
                    (this.source = this.context.createMediaStreamSource(e)),
                    this.connect(),
                    this
                  );
                },
              },
              {
                key: "setBuffer",
                value: function setBuffer(e) {
                  return (
                    (this.buffer = e),
                    (this.sourceType = "buffer"),
                    this.autoplay && this.play(),
                    this
                  );
                },
              },
              {
                key: "play",
                value: function play() {
                  var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0;
                  if (!0 !== this.isPlaying) {
                    if (!1 !== this.hasPlaybackControl) {
                      this._startedAt = this.context.currentTime + e;
                      var t = this.context.createBufferSource();
                      return (
                        (t.buffer = this.buffer),
                        (t.loop = this.loop),
                        (t.loopStart = this.loopStart),
                        (t.loopEnd = this.loopEnd),
                        (t.onended = this.onEnded.bind(this)),
                        t.start(
                          this._startedAt,
                          this._progress + this.offset,
                          this.duration
                        ),
                        (this.isPlaying = !0),
                        (this.source = t),
                        this.setDetune(this.detune),
                        this.setPlaybackRate(this.playbackRate),
                        this.connect()
                      );
                    }
                    console.warn(
                      "THREE.Audio: this Audio has no playback control."
                    );
                  } else console.warn("THREE.Audio: Audio is already playing.");
                },
              },
              {
                key: "pause",
                value: function pause() {
                  if (!1 !== this.hasPlaybackControl)
                    return (
                      !0 === this.isPlaying &&
                        ((this._progress +=
                          Math.max(
                            this.context.currentTime - this._startedAt,
                            0
                          ) * this.playbackRate),
                        !0 === this.loop &&
                          (this._progress =
                            this._progress %
                            (this.duration || this.buffer.duration)),
                        this.source.stop(),
                        (this.source.onended = null),
                        (this.isPlaying = !1)),
                      this
                    );
                  console.warn(
                    "THREE.Audio: this Audio has no playback control."
                  );
                },
              },
              {
                key: "stop",
                value: function stop() {
                  if (!1 !== this.hasPlaybackControl)
                    return (
                      (this._progress = 0),
                      this.source.stop(),
                      (this.source.onended = null),
                      (this.isPlaying = !1),
                      this
                    );
                  console.warn(
                    "THREE.Audio: this Audio has no playback control."
                  );
                },
              },
              {
                key: "connect",
                value: function connect() {
                  if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++)
                      this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(
                      this.getOutput()
                    );
                  } else this.source.connect(this.getOutput());
                  return (this._connected = !0), this;
                },
              },
              {
                key: "disconnect",
                value: function disconnect() {
                  if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++)
                      this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(
                      this.getOutput()
                    );
                  } else this.source.disconnect(this.getOutput());
                  return (this._connected = !1), this;
                },
              },
              {
                key: "getFilters",
                value: function getFilters() {
                  return this.filters;
                },
              },
              {
                key: "setFilters",
                value: function setFilters(e) {
                  return (
                    e || (e = []),
                    !0 === this._connected
                      ? (this.disconnect(),
                        (this.filters = e.slice()),
                        this.connect())
                      : (this.filters = e.slice()),
                    this
                  );
                },
              },
              {
                key: "setDetune",
                value: function setDetune(e) {
                  if (((this.detune = e), void 0 !== this.source.detune))
                    return (
                      !0 === this.isPlaying &&
                        this.source.detune.setTargetAtTime(
                          this.detune,
                          this.context.currentTime,
                          0.01
                        ),
                      this
                    );
                },
              },
              {
                key: "getDetune",
                value: function getDetune() {
                  return this.detune;
                },
              },
              {
                key: "getFilter",
                value: function getFilter() {
                  return this.getFilters()[0];
                },
              },
              {
                key: "setFilter",
                value: function setFilter(e) {
                  return this.setFilters(e ? [e] : []);
                },
              },
              {
                key: "setPlaybackRate",
                value: function setPlaybackRate(e) {
                  if (!1 !== this.hasPlaybackControl)
                    return (
                      (this.playbackRate = e),
                      !0 === this.isPlaying &&
                        this.source.playbackRate.setTargetAtTime(
                          this.playbackRate,
                          this.context.currentTime,
                          0.01
                        ),
                      this
                    );
                  console.warn(
                    "THREE.Audio: this Audio has no playback control."
                  );
                },
              },
              {
                key: "getPlaybackRate",
                value: function getPlaybackRate() {
                  return this.playbackRate;
                },
              },
              {
                key: "onEnded",
                value: function onEnded() {
                  this.isPlaying = !1;
                },
              },
              {
                key: "getLoop",
                value: function getLoop() {
                  return !1 === this.hasPlaybackControl
                    ? (console.warn(
                        "THREE.Audio: this Audio has no playback control."
                      ),
                      !1)
                    : this.loop;
                },
              },
              {
                key: "setLoop",
                value: function setLoop(e) {
                  if (!1 !== this.hasPlaybackControl)
                    return (
                      (this.loop = e),
                      !0 === this.isPlaying && (this.source.loop = this.loop),
                      this
                    );
                  console.warn(
                    "THREE.Audio: this Audio has no playback control."
                  );
                },
              },
              {
                key: "setLoopStart",
                value: function setLoopStart(e) {
                  return (this.loopStart = e), this;
                },
              },
              {
                key: "setLoopEnd",
                value: function setLoopEnd(e) {
                  return (this.loopEnd = e), this;
                },
              },
              {
                key: "getVolume",
                value: function getVolume() {
                  return this.gain.gain.value;
                },
              },
              {
                key: "setVolume",
                value: function setVolume(e) {
                  return (
                    this.gain.gain.setTargetAtTime(
                      e,
                      this.context.currentTime,
                      0.01
                    ),
                    this
                  );
                },
              },
            ]),
            Audio
          );
        })(ai),
        ql = new ir(),
        Xl = new rr(),
        Jl = new ir(),
        Yl = new ir(),
        Zl = (function (e) {
          function PositionalAudio(e) {
            var t;
            return (
              Object(f.a)(this, PositionalAudio),
              ((t = Object(s.a)(
                this,
                Object(r.a)(PositionalAudio).call(this, e)
              )).panner = t.context.createPanner()),
              (t.panner.panningModel = "HRTF"),
              t.panner.connect(t.gain),
              t
            );
          }
          return (
            Object(u.a)(PositionalAudio, e),
            Object(p.a)(PositionalAudio, [
              {
                key: "disconnect",
                value: function disconnect() {
                  Object(o.a)(
                    Object(r.a)(PositionalAudio.prototype),
                    "disconnect",
                    this
                  ).call(this),
                    this.panner.disconnect(this.gain);
                },
              },
              {
                key: "getOutput",
                value: function getOutput() {
                  return this.panner;
                },
              },
              {
                key: "getRefDistance",
                value: function getRefDistance() {
                  return this.panner.refDistance;
                },
              },
              {
                key: "setRefDistance",
                value: function setRefDistance(e) {
                  return (this.panner.refDistance = e), this;
                },
              },
              {
                key: "getRolloffFactor",
                value: function getRolloffFactor() {
                  return this.panner.rolloffFactor;
                },
              },
              {
                key: "setRolloffFactor",
                value: function setRolloffFactor(e) {
                  return (this.panner.rolloffFactor = e), this;
                },
              },
              {
                key: "getDistanceModel",
                value: function getDistanceModel() {
                  return this.panner.distanceModel;
                },
              },
              {
                key: "setDistanceModel",
                value: function setDistanceModel(e) {
                  return (this.panner.distanceModel = e), this;
                },
              },
              {
                key: "getMaxDistance",
                value: function getMaxDistance() {
                  return this.panner.maxDistance;
                },
              },
              {
                key: "setMaxDistance",
                value: function setMaxDistance(e) {
                  return (this.panner.maxDistance = e), this;
                },
              },
              {
                key: "setDirectionalCone",
                value: function setDirectionalCone(e, t, n) {
                  return (
                    (this.panner.coneInnerAngle = e),
                    (this.panner.coneOuterAngle = t),
                    (this.panner.coneOuterGain = n),
                    this
                  );
                },
              },
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  if (
                    (Object(o.a)(
                      Object(r.a)(PositionalAudio.prototype),
                      "updateMatrixWorld",
                      this
                    ).call(this, e),
                    !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                  ) {
                    this.matrixWorld.decompose(ql, Xl, Jl),
                      Yl.set(0, 0, 1).applyQuaternion(Xl);
                    var t = this.panner;
                    if (t.positionX) {
                      var n =
                        this.context.currentTime + this.listener.timeDelta;
                      t.positionX.linearRampToValueAtTime(ql.x, n),
                        t.positionY.linearRampToValueAtTime(ql.y, n),
                        t.positionZ.linearRampToValueAtTime(ql.z, n),
                        t.orientationX.linearRampToValueAtTime(Yl.x, n),
                        t.orientationY.linearRampToValueAtTime(Yl.y, n),
                        t.orientationZ.linearRampToValueAtTime(Yl.z, n);
                    } else
                      t.setPosition(ql.x, ql.y, ql.z),
                        t.setOrientation(Yl.x, Yl.y, Yl.z);
                  }
                },
              },
            ]),
            PositionalAudio
          );
        })(Hl),
        Kl = (function () {
          function AudioAnalyser(e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 2048;
            Object(f.a)(this, AudioAnalyser),
              (this.analyser = e.context.createAnalyser()),
              (this.analyser.fftSize = t),
              (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
              e.getOutput().connect(this.analyser);
          }
          return (
            Object(p.a)(AudioAnalyser, [
              {
                key: "getFrequencyData",
                value: function getFrequencyData() {
                  return (
                    this.analyser.getByteFrequencyData(this.data), this.data
                  );
                },
              },
              {
                key: "getAverageFrequency",
                value: function getAverageFrequency() {
                  for (
                    var e = 0, t = this.getFrequencyData(), n = 0;
                    n < t.length;
                    n++
                  )
                    e += t[n];
                  return e / t.length;
                },
              },
            ]),
            AudioAnalyser
          );
        })(),
        Ql = (function () {
          function PropertyMixer(e, t, n) {
            var r, i, a;
            switch (
              (Object(f.a)(this, PropertyMixer),
              (this.binding = e),
              (this.valueSize = n),
              t)
            ) {
              case "quaternion":
                (r = this._slerp),
                  (i = this._slerpAdditive),
                  (a = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (r = this._select),
                  (i = this._select),
                  (a = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (r = this._lerp),
                  (i = this._lerpAdditive),
                  (a = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = r),
              (this._mixBufferRegionAdditive = i),
              (this._setIdentity = a),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          return (
            Object(p.a)(PropertyMixer, [
              {
                key: "accumulate",
                value: function accumulate(e, t) {
                  var n = this.buffer,
                    r = this.valueSize,
                    i = e * r + r,
                    a = this.cumulativeWeight;
                  if (0 === a) {
                    for (var o = 0; o !== r; ++o) n[i + o] = n[o];
                    a = t;
                  } else {
                    var s = t / (a += t);
                    this._mixBufferRegion(n, i, 0, s, r);
                  }
                  this.cumulativeWeight = a;
                },
              },
              {
                key: "accumulateAdditive",
                value: function accumulateAdditive(e) {
                  var t = this.buffer,
                    n = this.valueSize,
                    r = n * this._addIndex;
                  0 === this.cumulativeWeightAdditive && this._setIdentity(),
                    this._mixBufferRegionAdditive(t, r, 0, e, n),
                    (this.cumulativeWeightAdditive += e);
                },
              },
              {
                key: "apply",
                value: function apply(e) {
                  var t = this.valueSize,
                    n = this.buffer,
                    r = e * t + t,
                    i = this.cumulativeWeight,
                    a = this.cumulativeWeightAdditive,
                    o = this.binding;
                  if (
                    ((this.cumulativeWeight = 0),
                    (this.cumulativeWeightAdditive = 0),
                    i < 1)
                  ) {
                    var s = t * this._origIndex;
                    this._mixBufferRegion(n, r, s, 1 - i, t);
                  }
                  a > 0 &&
                    this._mixBufferRegionAdditive(
                      n,
                      r,
                      this._addIndex * t,
                      1,
                      t
                    );
                  for (var u = t, l = t + t; u !== l; ++u)
                    if (n[u] !== n[u + t]) {
                      o.setValue(n, r);
                      break;
                    }
                },
              },
              {
                key: "saveOriginalState",
                value: function saveOriginalState() {
                  var e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    r = n * this._origIndex;
                  e.getValue(t, r);
                  for (var i = n, a = r; i !== a; ++i) t[i] = t[r + (i % n)];
                  this._setIdentity(),
                    (this.cumulativeWeight = 0),
                    (this.cumulativeWeightAdditive = 0);
                },
              },
              {
                key: "restoreOriginalState",
                value: function restoreOriginalState() {
                  var e = 3 * this.valueSize;
                  this.binding.setValue(this.buffer, e);
                },
              },
              {
                key: "_setAdditiveIdentityNumeric",
                value: function _setAdditiveIdentityNumeric() {
                  for (
                    var e = this._addIndex * this.valueSize,
                      t = e + this.valueSize,
                      n = e;
                    n < t;
                    n++
                  )
                    this.buffer[n] = 0;
                },
              },
              {
                key: "_setAdditiveIdentityQuaternion",
                value: function _setAdditiveIdentityQuaternion() {
                  this._setAdditiveIdentityNumeric(),
                    (this.buffer[this._addIndex * this.valueSize + 3] = 1);
                },
              },
              {
                key: "_setAdditiveIdentityOther",
                value: function _setAdditiveIdentityOther() {
                  for (
                    var e = this._origIndex * this.valueSize,
                      t = this._addIndex * this.valueSize,
                      n = 0;
                    n < this.valueSize;
                    n++
                  )
                    this.buffer[t + n] = this.buffer[e + n];
                },
              },
              {
                key: "_select",
                value: function _select(e, t, n, r, i) {
                  if (r >= 0.5)
                    for (var a = 0; a !== i; ++a) e[t + a] = e[n + a];
                },
              },
              {
                key: "_slerp",
                value: function _slerp(e, t, n, r) {
                  rr.slerpFlat(e, t, e, t, e, n, r);
                },
              },
              {
                key: "_slerpAdditive",
                value: function _slerpAdditive(e, t, n, r, i) {
                  var a = this._workIndex * i;
                  rr.multiplyQuaternionsFlat(e, a, e, t, e, n),
                    rr.slerpFlat(e, t, e, t, e, a, r);
                },
              },
              {
                key: "_lerp",
                value: function _lerp(e, t, n, r, i) {
                  for (var a = 1 - r, o = 0; o !== i; ++o) {
                    var s = t + o;
                    e[s] = e[s] * a + e[n + o] * r;
                  }
                },
              },
              {
                key: "_lerpAdditive",
                value: function _lerpAdditive(e, t, n, r, i) {
                  for (var a = 0; a !== i; ++a) {
                    var o = t + a;
                    e[o] = e[o] + e[n + a] * r;
                  }
                },
              },
            ]),
            PropertyMixer
          );
        })(),
        $l = new RegExp("[\\[\\]\\.:\\/]", "g"),
        ec = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        tc = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]") +
            /(WCOD+)?/.source.replace("WCOD", ec) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
              "WC",
              "[^\\[\\]\\.:\\/]"
            ) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]") +
            "$"
        ),
        nc = ["material", "materials", "bones"],
        rc = (function () {
          function Composite(e, t, n) {
            Object(f.a)(this, Composite);
            var r = n || ic.parseTrackName(t);
            (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
          }
          return (
            Object(p.a)(Composite, [
              {
                key: "getValue",
                value: function getValue(e, t) {
                  this.bind();
                  var n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                  void 0 !== r && r.getValue(e, t);
                },
              },
              {
                key: "setValue",
                value: function setValue(e, t) {
                  for (
                    var n = this._bindings,
                      r = this._targetGroup.nCachedObjects_,
                      i = n.length;
                    r !== i;
                    ++r
                  )
                    n[r].setValue(e, t);
                },
              },
              {
                key: "bind",
                value: function bind() {
                  for (
                    var e = this._bindings,
                      t = this._targetGroup.nCachedObjects_,
                      n = e.length;
                    t !== n;
                    ++t
                  )
                    e[t].bind();
                },
              },
              {
                key: "unbind",
                value: function unbind() {
                  for (
                    var e = this._bindings,
                      t = this._targetGroup.nCachedObjects_,
                      n = e.length;
                    t !== n;
                    ++t
                  )
                    e[t].unbind();
                },
              },
            ]),
            Composite
          );
        })(),
        ic = (function () {
          function PropertyBinding(e, t, n) {
            Object(f.a)(this, PropertyBinding),
              (this.path = t),
              (this.parsedPath = n || PropertyBinding.parseTrackName(t)),
              (this.node =
                PropertyBinding.findNode(e, this.parsedPath.nodeName) || e),
              (this.rootNode = e),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          return (
            Object(p.a)(
              PropertyBinding,
              [
                {
                  key: "_getValue_unavailable",
                  value: function _getValue_unavailable() {},
                },
                {
                  key: "_setValue_unavailable",
                  value: function _setValue_unavailable() {},
                },
                {
                  key: "_getValue_direct",
                  value: function _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName];
                  },
                },
                {
                  key: "_getValue_array",
                  value: function _getValue_array(e, t) {
                    for (
                      var n = this.resolvedProperty, r = 0, i = n.length;
                      r !== i;
                      ++r
                    )
                      e[t++] = n[r];
                  },
                },
                {
                  key: "_getValue_arrayElement",
                  value: function _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex];
                  },
                },
                {
                  key: "_getValue_toArray",
                  value: function _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t);
                  },
                },
                {
                  key: "_setValue_direct",
                  value: function _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t];
                  },
                },
                {
                  key: "_setValue_direct_setNeedsUpdate",
                  value: function _setValue_direct_setNeedsUpdate(e, t) {
                    (this.targetObject[this.propertyName] = e[t]),
                      (this.targetObject.needsUpdate = !0);
                  },
                },
                {
                  key: "_setValue_direct_setMatrixWorldNeedsUpdate",
                  value: function _setValue_direct_setMatrixWorldNeedsUpdate(
                    e,
                    t
                  ) {
                    (this.targetObject[this.propertyName] = e[t]),
                      (this.targetObject.matrixWorldNeedsUpdate = !0);
                  },
                },
                {
                  key: "_setValue_array",
                  value: function _setValue_array(e, t) {
                    for (
                      var n = this.resolvedProperty, r = 0, i = n.length;
                      r !== i;
                      ++r
                    )
                      n[r] = e[t++];
                  },
                },
                {
                  key: "_setValue_array_setNeedsUpdate",
                  value: function _setValue_array_setNeedsUpdate(e, t) {
                    for (
                      var n = this.resolvedProperty, r = 0, i = n.length;
                      r !== i;
                      ++r
                    )
                      n[r] = e[t++];
                    this.targetObject.needsUpdate = !0;
                  },
                },
                {
                  key: "_setValue_array_setMatrixWorldNeedsUpdate",
                  value: function _setValue_array_setMatrixWorldNeedsUpdate(
                    e,
                    t
                  ) {
                    for (
                      var n = this.resolvedProperty, r = 0, i = n.length;
                      r !== i;
                      ++r
                    )
                      n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0;
                  },
                },
                {
                  key: "_setValue_arrayElement",
                  value: function _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t];
                  },
                },
                {
                  key: "_setValue_arrayElement_setNeedsUpdate",
                  value: function _setValue_arrayElement_setNeedsUpdate(e, t) {
                    (this.resolvedProperty[this.propertyIndex] = e[t]),
                      (this.targetObject.needsUpdate = !0);
                  },
                },
                {
                  key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
                  value:
                    function _setValue_arrayElement_setMatrixWorldNeedsUpdate(
                      e,
                      t
                    ) {
                      (this.resolvedProperty[this.propertyIndex] = e[t]),
                        (this.targetObject.matrixWorldNeedsUpdate = !0);
                    },
                },
                {
                  key: "_setValue_fromArray",
                  value: function _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t);
                  },
                },
                {
                  key: "_setValue_fromArray_setNeedsUpdate",
                  value: function _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t),
                      (this.targetObject.needsUpdate = !0);
                  },
                },
                {
                  key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
                  value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(
                    e,
                    t
                  ) {
                    this.resolvedProperty.fromArray(e, t),
                      (this.targetObject.matrixWorldNeedsUpdate = !0);
                  },
                },
                {
                  key: "_getValue_unbound",
                  value: function _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t);
                  },
                },
                {
                  key: "_setValue_unbound",
                  value: function _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t);
                  },
                },
                {
                  key: "bind",
                  value: function bind() {
                    var e = this.node,
                      t = this.parsedPath,
                      n = t.objectName,
                      r = t.propertyName,
                      i = t.propertyIndex;
                    if (
                      (e ||
                        ((e =
                          PropertyBinding.findNode(this.rootNode, t.nodeName) ||
                          this.rootNode),
                        (this.node = e)),
                      (this.getValue = this._getValue_unavailable),
                      (this.setValue = this._setValue_unavailable),
                      e)
                    ) {
                      if (n) {
                        var a = t.objectIndex;
                        switch (n) {
                          case "materials":
                            if (!e.material)
                              return void console.error(
                                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                                this
                              );
                            if (!e.material.materials)
                              return void console.error(
                                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                                this
                              );
                            e = e.material.materials;
                            break;
                          case "bones":
                            if (!e.skeleton)
                              return void console.error(
                                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                                this
                              );
                            e = e.skeleton.bones;
                            for (var o = 0; o < e.length; o++)
                              if (e[o].name === a) {
                                a = o;
                                break;
                              }
                            break;
                          default:
                            if (void 0 === e[n])
                              return void console.error(
                                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                                this
                              );
                            e = e[n];
                        }
                        if (void 0 !== a) {
                          if (void 0 === e[a])
                            return void console.error(
                              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                              this,
                              e
                            );
                          e = e[a];
                        }
                      }
                      var s = e[r];
                      if (void 0 !== s) {
                        var u = this.Versioning.None;
                        (this.targetObject = e),
                          void 0 !== e.needsUpdate
                            ? (u = this.Versioning.NeedsUpdate)
                            : void 0 !== e.matrixWorldNeedsUpdate &&
                              (u = this.Versioning.MatrixWorldNeedsUpdate);
                        var l = this.BindingType.Direct;
                        if (void 0 !== i) {
                          if ("morphTargetInfluences" === r) {
                            if (!e.geometry)
                              return void console.error(
                                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                                this
                              );
                            if (!e.geometry.morphAttributes)
                              return void console.error(
                                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                                this
                              );
                            void 0 !== e.morphTargetDictionary[i] &&
                              (i = e.morphTargetDictionary[i]);
                          }
                          (l = this.BindingType.ArrayElement),
                            (this.resolvedProperty = s),
                            (this.propertyIndex = i);
                        } else
                          void 0 !== s.fromArray && void 0 !== s.toArray
                            ? ((l = this.BindingType.HasFromToArray),
                              (this.resolvedProperty = s))
                            : Array.isArray(s)
                            ? ((l = this.BindingType.EntireArray),
                              (this.resolvedProperty = s))
                            : (this.propertyName = r);
                        (this.getValue = this.GetterByBindingType[l]),
                          (this.setValue =
                            this.SetterByBindingTypeAndVersioning[l][u]);
                      } else {
                        var c = t.nodeName;
                        console.error(
                          "THREE.PropertyBinding: Trying to update property for track: " +
                            c +
                            "." +
                            r +
                            " but it wasn't found.",
                          e
                        );
                      }
                    } else
                      console.error(
                        "THREE.PropertyBinding: Trying to update node for track: " +
                          this.path +
                          " but it wasn't found."
                      );
                  },
                },
                {
                  key: "unbind",
                  value: function unbind() {
                    (this.node = null),
                      (this.getValue = this._getValue_unbound),
                      (this.setValue = this._setValue_unbound);
                  },
                },
              ],
              [
                {
                  key: "create",
                  value: function create(e, t, n) {
                    return e && e.isAnimationObjectGroup
                      ? new PropertyBinding.Composite(e, t, n)
                      : new PropertyBinding(e, t, n);
                  },
                },
                {
                  key: "sanitizeNodeName",
                  value: function sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace($l, "");
                  },
                },
                {
                  key: "parseTrackName",
                  value: function parseTrackName(e) {
                    var t = tc.exec(e);
                    if (null === t)
                      throw new Error(
                        "PropertyBinding: Cannot parse trackName: " + e
                      );
                    var n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6],
                      },
                      r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                      var i = n.nodeName.substring(r + 1);
                      -1 !== nc.indexOf(i) &&
                        ((n.nodeName = n.nodeName.substring(0, r)),
                        (n.objectName = i));
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                      throw new Error(
                        "PropertyBinding: can not parse propertyName from trackName: " +
                          e
                      );
                    return n;
                  },
                },
                {
                  key: "findNode",
                  value: function findNode(e, t) {
                    if (
                      void 0 === t ||
                      "" === t ||
                      "." === t ||
                      -1 === t ||
                      t === e.name ||
                      t === e.uuid
                    )
                      return e;
                    if (e.skeleton) {
                      var n = e.skeleton.getBoneByName(t);
                      if (void 0 !== n) return n;
                    }
                    if (e.children) {
                      var r = (function searchNodeSubtree(e) {
                        for (var n = 0; n < e.length; n++) {
                          var r = e[n];
                          if (r.name === t || r.uuid === t) return r;
                          var i = searchNodeSubtree(r.children);
                          if (i) return i;
                        }
                        return null;
                      })(e.children);
                      if (r) return r;
                    }
                    return null;
                  },
                },
              ]
            ),
            PropertyBinding
          );
        })();
      (ic.Composite = rc),
        (ic.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (ic.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (ic.prototype.GetterByBindingType = [
          ic.prototype._getValue_direct,
          ic.prototype._getValue_array,
          ic.prototype._getValue_arrayElement,
          ic.prototype._getValue_toArray,
        ]),
        (ic.prototype.SetterByBindingTypeAndVersioning = [
          [
            ic.prototype._setValue_direct,
            ic.prototype._setValue_direct_setNeedsUpdate,
            ic.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            ic.prototype._setValue_array,
            ic.prototype._setValue_array_setNeedsUpdate,
            ic.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            ic.prototype._setValue_arrayElement,
            ic.prototype._setValue_arrayElement_setNeedsUpdate,
            ic.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            ic.prototype._setValue_fromArray,
            ic.prototype._setValue_fromArray_setNeedsUpdate,
            ic.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      var ac = (function () {
          function AnimationObjectGroup() {
            Object(f.a)(this, AnimationObjectGroup),
              (this.isAnimationObjectGroup = !0),
              (this.uuid = generateUUID()),
              (this._objects = Array.prototype.slice.call(arguments)),
              (this.nCachedObjects_ = 0);
            var e = {};
            this._indicesByUUID = e;
            for (var t = 0, n = arguments.length; t !== n; ++t)
              e[arguments[t].uuid] = t;
            (this._paths = []),
              (this._parsedPaths = []),
              (this._bindings = []),
              (this._bindingsIndicesByPath = {});
            var r = this;
            this.stats = {
              objects: {
                get total() {
                  return r._objects.length;
                },
                get inUse() {
                  return this.total - r.nCachedObjects_;
                },
              },
              get bindingsPerObject() {
                return r._bindings.length;
              },
            };
          }
          return (
            Object(p.a)(AnimationObjectGroup, [
              {
                key: "add",
                value: function add() {
                  for (
                    var e = this._objects,
                      t = this._indicesByUUID,
                      n = this._paths,
                      r = this._parsedPaths,
                      i = this._bindings,
                      a = i.length,
                      o = void 0,
                      s = e.length,
                      u = this.nCachedObjects_,
                      l = 0,
                      c = arguments.length;
                    l !== c;
                    ++l
                  ) {
                    var h = arguments[l],
                      d = h.uuid,
                      f = t[d];
                    if (void 0 === f) {
                      (f = s++), (t[d] = f), e.push(h);
                      for (var p = 0, m = a; p !== m; ++p)
                        i[p].push(new ic(h, n[p], r[p]));
                    } else if (f < u) {
                      o = e[f];
                      var v = --u,
                        g = e[v];
                      (t[g.uuid] = f), (e[f] = g), (t[d] = v), (e[v] = h);
                      for (var y = 0, b = a; y !== b; ++y) {
                        var x = i[y],
                          _ = x[v],
                          M = x[f];
                        (x[f] = _),
                          void 0 === M && (M = new ic(h, n[y], r[y])),
                          (x[v] = M);
                      }
                    } else
                      e[f] !== o &&
                        console.error(
                          "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                        );
                  }
                  this.nCachedObjects_ = u;
                },
              },
              {
                key: "remove",
                value: function remove() {
                  for (
                    var e = this._objects,
                      t = this._indicesByUUID,
                      n = this._bindings,
                      r = n.length,
                      i = this.nCachedObjects_,
                      a = 0,
                      o = arguments.length;
                    a !== o;
                    ++a
                  ) {
                    var s = arguments[a],
                      u = s.uuid,
                      l = t[u];
                    if (void 0 !== l && l >= i) {
                      var c = i++,
                        h = e[c];
                      (t[h.uuid] = l), (e[l] = h), (t[u] = c), (e[c] = s);
                      for (var d = 0, f = r; d !== f; ++d) {
                        var p = n[d],
                          m = p[c],
                          v = p[l];
                        (p[l] = m), (p[c] = v);
                      }
                    }
                  }
                  this.nCachedObjects_ = i;
                },
              },
              {
                key: "uncache",
                value: function uncache() {
                  for (
                    var e = this._objects,
                      t = this._indicesByUUID,
                      n = this._bindings,
                      r = n.length,
                      i = this.nCachedObjects_,
                      a = e.length,
                      o = 0,
                      s = arguments.length;
                    o !== s;
                    ++o
                  ) {
                    var u = arguments[o].uuid,
                      l = t[u];
                    if (void 0 !== l)
                      if ((delete t[u], l < i)) {
                        var c = --i,
                          h = e[c],
                          d = --a,
                          f = e[d];
                        (t[h.uuid] = l),
                          (e[l] = h),
                          (t[f.uuid] = c),
                          (e[c] = f),
                          e.pop();
                        for (var p = 0, m = r; p !== m; ++p) {
                          var v = n[p],
                            g = v[c],
                            y = v[d];
                          (v[l] = g), (v[c] = y), v.pop();
                        }
                      } else {
                        var b = --a,
                          x = e[b];
                        b > 0 && (t[x.uuid] = l), (e[l] = x), e.pop();
                        for (var _ = 0, M = r; _ !== M; ++_) {
                          var S = n[_];
                          (S[l] = S[b]), S.pop();
                        }
                      }
                  }
                  this.nCachedObjects_ = i;
                },
              },
              {
                key: "subscribe_",
                value: function subscribe_(e, t) {
                  var n = this._bindingsIndicesByPath,
                    r = n[e],
                    i = this._bindings;
                  if (void 0 !== r) return i[r];
                  var a = this._paths,
                    o = this._parsedPaths,
                    s = this._objects,
                    u = s.length,
                    l = this.nCachedObjects_,
                    c = new Array(u);
                  (r = i.length), (n[e] = r), a.push(e), o.push(t), i.push(c);
                  for (var h = l, d = s.length; h !== d; ++h) {
                    var f = s[h];
                    c[h] = new ic(f, e, t);
                  }
                  return c;
                },
              },
              {
                key: "unsubscribe_",
                value: function unsubscribe_(e) {
                  var t = this._bindingsIndicesByPath,
                    n = t[e];
                  if (void 0 !== n) {
                    var r = this._paths,
                      i = this._parsedPaths,
                      a = this._bindings,
                      o = a.length - 1,
                      s = a[o];
                    (t[e[o]] = n),
                      (a[n] = s),
                      a.pop(),
                      (i[n] = i[o]),
                      i.pop(),
                      (r[n] = r[o]),
                      r.pop();
                  }
                },
              },
            ]),
            AnimationObjectGroup
          );
        })(),
        oc = (function () {
          function AnimationAction(e, t) {
            var n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : null,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : t.blendMode;
            Object(f.a)(this, AnimationAction),
              (this._mixer = e),
              (this._clip = t),
              (this._localRoot = n),
              (this.blendMode = r);
            for (
              var i = t.tracks,
                a = i.length,
                o = new Array(a),
                s = { endingStart: Bt, endingEnd: Bt },
                u = 0;
              u !== a;
              ++u
            ) {
              var l = i[u].createInterpolant(null);
              (o[u] = l), (l.settings = s);
            }
            (this._interpolantSettings = s),
              (this._interpolants = o),
              (this._propertyBindings = new Array(a)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = Pt),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          return (
            Object(p.a)(AnimationAction, [
              {
                key: "play",
                value: function play() {
                  return this._mixer._activateAction(this), this;
                },
              },
              {
                key: "stop",
                value: function stop() {
                  return this._mixer._deactivateAction(this), this.reset();
                },
              },
              {
                key: "reset",
                value: function reset() {
                  return (
                    (this.paused = !1),
                    (this.enabled = !0),
                    (this.time = 0),
                    (this._loopCount = -1),
                    (this._startTime = null),
                    this.stopFading().stopWarping()
                  );
                },
              },
              {
                key: "isRunning",
                value: function isRunning() {
                  return (
                    this.enabled &&
                    !this.paused &&
                    0 !== this.timeScale &&
                    null === this._startTime &&
                    this._mixer._isActiveAction(this)
                  );
                },
              },
              {
                key: "isScheduled",
                value: function isScheduled() {
                  return this._mixer._isActiveAction(this);
                },
              },
              {
                key: "startAt",
                value: function startAt(e) {
                  return (this._startTime = e), this;
                },
              },
              {
                key: "setLoop",
                value: function setLoop(e, t) {
                  return (this.loop = e), (this.repetitions = t), this;
                },
              },
              {
                key: "setEffectiveWeight",
                value: function setEffectiveWeight(e) {
                  return (
                    (this.weight = e),
                    (this._effectiveWeight = this.enabled ? e : 0),
                    this.stopFading()
                  );
                },
              },
              {
                key: "getEffectiveWeight",
                value: function getEffectiveWeight() {
                  return this._effectiveWeight;
                },
              },
              {
                key: "fadeIn",
                value: function fadeIn(e) {
                  return this._scheduleFading(e, 0, 1);
                },
              },
              {
                key: "fadeOut",
                value: function fadeOut(e) {
                  return this._scheduleFading(e, 1, 0);
                },
              },
              {
                key: "crossFadeFrom",
                value: function crossFadeFrom(e, t, n) {
                  if ((e.fadeOut(t), this.fadeIn(t), n)) {
                    var r = this._clip.duration,
                      i = e._clip.duration,
                      a = i / r,
                      o = r / i;
                    e.warp(1, a, t), this.warp(o, 1, t);
                  }
                  return this;
                },
              },
              {
                key: "crossFadeTo",
                value: function crossFadeTo(e, t, n) {
                  return e.crossFadeFrom(this, t, n);
                },
              },
              {
                key: "stopFading",
                value: function stopFading() {
                  var e = this._weightInterpolant;
                  return (
                    null !== e &&
                      ((this._weightInterpolant = null),
                      this._mixer._takeBackControlInterpolant(e)),
                    this
                  );
                },
              },
              {
                key: "setEffectiveTimeScale",
                value: function setEffectiveTimeScale(e) {
                  return (
                    (this.timeScale = e),
                    (this._effectiveTimeScale = this.paused ? 0 : e),
                    this.stopWarping()
                  );
                },
              },
              {
                key: "getEffectiveTimeScale",
                value: function getEffectiveTimeScale() {
                  return this._effectiveTimeScale;
                },
              },
              {
                key: "setDuration",
                value: function setDuration(e) {
                  return (
                    (this.timeScale = this._clip.duration / e),
                    this.stopWarping()
                  );
                },
              },
              {
                key: "syncWith",
                value: function syncWith(e) {
                  return (
                    (this.time = e.time),
                    (this.timeScale = e.timeScale),
                    this.stopWarping()
                  );
                },
              },
              {
                key: "halt",
                value: function halt(e) {
                  return this.warp(this._effectiveTimeScale, 0, e);
                },
              },
              {
                key: "warp",
                value: function warp(e, t, n) {
                  var r = this._mixer,
                    i = r.time,
                    a = this.timeScale,
                    o = this._timeScaleInterpolant;
                  null === o &&
                    ((o = r._lendControlInterpolant()),
                    (this._timeScaleInterpolant = o));
                  var s = o.parameterPositions,
                    u = o.sampleValues;
                  return (
                    (s[0] = i),
                    (s[1] = i + n),
                    (u[0] = e / a),
                    (u[1] = t / a),
                    this
                  );
                },
              },
              {
                key: "stopWarping",
                value: function stopWarping() {
                  var e = this._timeScaleInterpolant;
                  return (
                    null !== e &&
                      ((this._timeScaleInterpolant = null),
                      this._mixer._takeBackControlInterpolant(e)),
                    this
                  );
                },
              },
              {
                key: "getMixer",
                value: function getMixer() {
                  return this._mixer;
                },
              },
              {
                key: "getClip",
                value: function getClip() {
                  return this._clip;
                },
              },
              {
                key: "getRoot",
                value: function getRoot() {
                  return this._localRoot || this._mixer._root;
                },
              },
              {
                key: "_update",
                value: function _update(e, t, n, r) {
                  if (this.enabled) {
                    var i = this._startTime;
                    if (null !== i) {
                      var a = (e - i) * n;
                      if (a < 0 || 0 === n) return;
                      (this._startTime = null), (t = n * a);
                    }
                    t *= this._updateTimeScale(e);
                    var o = this._updateTime(t),
                      s = this._updateWeight(e);
                    if (s > 0) {
                      var u = this._interpolants,
                        l = this._propertyBindings;
                      switch (this.blendMode) {
                        case Gt:
                          for (var c = 0, h = u.length; c !== h; ++c)
                            u[c].evaluate(o), l[c].accumulateAdditive(s);
                          break;
                        case Ft:
                        default:
                          for (var d = 0, f = u.length; d !== f; ++d)
                            u[d].evaluate(o), l[d].accumulate(r, s);
                      }
                    }
                  } else this._updateWeight(e);
                },
              },
              {
                key: "_updateWeight",
                value: function _updateWeight(e) {
                  var t = 0;
                  if (this.enabled) {
                    t = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                      var r = n.evaluate(e)[0];
                      (t *= r),
                        e > n.parameterPositions[1] &&
                          (this.stopFading(), 0 === r && (this.enabled = !1));
                    }
                  }
                  return (this._effectiveWeight = t), t;
                },
              },
              {
                key: "_updateTimeScale",
                value: function _updateTimeScale(e) {
                  var t = 0;
                  if (!this.paused) {
                    t = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n)
                      (t *= n.evaluate(e)[0]),
                        e > n.parameterPositions[1] &&
                          (this.stopWarping(),
                          0 === t ? (this.paused = !0) : (this.timeScale = t));
                  }
                  return (this._effectiveTimeScale = t), t;
                },
              },
              {
                key: "_updateTime",
                value: function _updateTime(e) {
                  var t = this._clip.duration,
                    n = this.loop,
                    r = this.time + e,
                    i = this._loopCount,
                    a = n === Rt;
                  if (0 === e)
                    return -1 === i ? r : a && 1 === (1 & i) ? t - r : r;
                  if (n === Et) {
                    -1 === i &&
                      ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                    e: {
                      if (r >= t) r = t;
                      else {
                        if (!(r < 0)) {
                          this.time = r;
                          break e;
                        }
                        r = 0;
                      }
                      this.clampWhenFinished
                        ? (this.paused = !0)
                        : (this.enabled = !1),
                        (this.time = r),
                        this._mixer.dispatchEvent({
                          type: "finished",
                          action: this,
                          direction: e < 0 ? -1 : 1,
                        });
                    }
                  } else {
                    if (
                      (-1 === i &&
                        (e >= 0
                          ? ((i = 0),
                            this._setEndings(!0, 0 === this.repetitions, a))
                          : this._setEndings(0 === this.repetitions, !0, a)),
                      r >= t || r < 0)
                    ) {
                      var o = Math.floor(r / t);
                      (r -= t * o), (i += Math.abs(o));
                      var s = this.repetitions - i;
                      if (s <= 0)
                        this.clampWhenFinished
                          ? (this.paused = !0)
                          : (this.enabled = !1),
                          (r = e > 0 ? t : 0),
                          (this.time = r),
                          this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1,
                          });
                      else {
                        if (1 === s) {
                          var u = e < 0;
                          this._setEndings(u, !u, a);
                        } else this._setEndings(!1, !1, a);
                        (this._loopCount = i),
                          (this.time = r),
                          this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o,
                          });
                      }
                    } else this.time = r;
                    if (a && 1 === (1 & i)) return t - r;
                  }
                  return r;
                },
              },
              {
                key: "_setEndings",
                value: function _setEndings(e, t, n) {
                  var r = this._interpolantSettings;
                  n
                    ? ((r.endingStart = Nt), (r.endingEnd = Nt))
                    : ((r.endingStart = e
                        ? this.zeroSlopeAtStart
                          ? Nt
                          : Bt
                        : zt),
                      (r.endingEnd = t ? (this.zeroSlopeAtEnd ? Nt : Bt) : zt));
                },
              },
              {
                key: "_scheduleFading",
                value: function _scheduleFading(e, t, n) {
                  var r = this._mixer,
                    i = r.time,
                    a = this._weightInterpolant;
                  null === a &&
                    ((a = r._lendControlInterpolant()),
                    (this._weightInterpolant = a));
                  var o = a.parameterPositions,
                    s = a.sampleValues;
                  return (
                    (o[0] = i), (s[0] = t), (o[1] = i + e), (s[1] = n), this
                  );
                },
              },
            ]),
            AnimationAction
          );
        })(),
        sc = new Float32Array(1),
        uc = (function (e) {
          function AnimationMixer(e) {
            var t;
            return (
              Object(f.a)(this, AnimationMixer),
              ((t = Object(s.a)(
                this,
                Object(r.a)(AnimationMixer).call(this)
              ))._root = e),
              t._initMemoryManager(),
              (t._accuIndex = 0),
              (t.time = 0),
              (t.timeScale = 1),
              t
            );
          }
          return (
            Object(u.a)(AnimationMixer, e),
            Object(p.a)(AnimationMixer, [
              {
                key: "_bindAction",
                value: function _bindAction(e, t) {
                  var n = e._localRoot || this._root,
                    r = e._clip.tracks,
                    i = r.length,
                    a = e._propertyBindings,
                    o = e._interpolants,
                    s = n.uuid,
                    u = this._bindingsByRootAndName,
                    l = u[s];
                  void 0 === l && ((l = {}), (u[s] = l));
                  for (var c = 0; c !== i; ++c) {
                    var h = r[c],
                      d = h.name,
                      f = l[d];
                    if (void 0 !== f) ++f.referenceCount, (a[c] = f);
                    else {
                      if (void 0 !== (f = a[c])) {
                        null === f._cacheIndex &&
                          (++f.referenceCount,
                          this._addInactiveBinding(f, s, d));
                        continue;
                      }
                      var p = t && t._propertyBindings[c].binding.parsedPath;
                      ++(f = new Ql(
                        ic.create(n, d, p),
                        h.ValueTypeName,
                        h.getValueSize()
                      )).referenceCount,
                        this._addInactiveBinding(f, s, d),
                        (a[c] = f);
                    }
                    o[c].resultBuffer = f.buffer;
                  }
                },
              },
              {
                key: "_activateAction",
                value: function _activateAction(e) {
                  if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                      var t = (e._localRoot || this._root).uuid,
                        n = e._clip.uuid,
                        r = this._actionsByClip[n];
                      this._bindAction(e, r && r.knownActions[0]),
                        this._addInactiveAction(e, n, t);
                    }
                    for (
                      var i = e._propertyBindings, a = 0, o = i.length;
                      a !== o;
                      ++a
                    ) {
                      var s = i[a];
                      0 === s.useCount++ &&
                        (this._lendBinding(s), s.saveOriginalState());
                    }
                    this._lendAction(e);
                  }
                },
              },
              {
                key: "_deactivateAction",
                value: function _deactivateAction(e) {
                  if (this._isActiveAction(e)) {
                    for (
                      var t = e._propertyBindings, n = 0, r = t.length;
                      n !== r;
                      ++n
                    ) {
                      var i = t[n];
                      0 === --i.useCount &&
                        (i.restoreOriginalState(), this._takeBackBinding(i));
                    }
                    this._takeBackAction(e);
                  }
                },
              },
              {
                key: "_initMemoryManager",
                value: function _initMemoryManager() {
                  (this._actions = []),
                    (this._nActiveActions = 0),
                    (this._actionsByClip = {}),
                    (this._bindings = []),
                    (this._nActiveBindings = 0),
                    (this._bindingsByRootAndName = {}),
                    (this._controlInterpolants = []),
                    (this._nActiveControlInterpolants = 0);
                  var e = this;
                  this.stats = {
                    actions: {
                      get total() {
                        return e._actions.length;
                      },
                      get inUse() {
                        return e._nActiveActions;
                      },
                    },
                    bindings: {
                      get total() {
                        return e._bindings.length;
                      },
                      get inUse() {
                        return e._nActiveBindings;
                      },
                    },
                    controlInterpolants: {
                      get total() {
                        return e._controlInterpolants.length;
                      },
                      get inUse() {
                        return e._nActiveControlInterpolants;
                      },
                    },
                  };
                },
              },
              {
                key: "_isActiveAction",
                value: function _isActiveAction(e) {
                  var t = e._cacheIndex;
                  return null !== t && t < this._nActiveActions;
                },
              },
              {
                key: "_addInactiveAction",
                value: function _addInactiveAction(e, t, n) {
                  var r = this._actions,
                    i = this._actionsByClip,
                    a = i[t];
                  if (void 0 === a)
                    (a = { knownActions: [e], actionByRoot: {} }),
                      (e._byClipCacheIndex = 0),
                      (i[t] = a);
                  else {
                    var o = a.knownActions;
                    (e._byClipCacheIndex = o.length), o.push(e);
                  }
                  (e._cacheIndex = r.length),
                    r.push(e),
                    (a.actionByRoot[n] = e);
                },
              },
              {
                key: "_removeInactiveAction",
                value: function _removeInactiveAction(e) {
                  var t = this._actions,
                    n = t[t.length - 1],
                    r = e._cacheIndex;
                  (n._cacheIndex = r),
                    (t[r] = n),
                    t.pop(),
                    (e._cacheIndex = null);
                  var i = e._clip.uuid,
                    a = this._actionsByClip,
                    o = a[i],
                    s = o.knownActions,
                    u = s[s.length - 1],
                    l = e._byClipCacheIndex;
                  (u._byClipCacheIndex = l),
                    (s[l] = u),
                    s.pop(),
                    (e._byClipCacheIndex = null),
                    delete o.actionByRoot[(e._localRoot || this._root).uuid],
                    0 === s.length && delete a[i],
                    this._removeInactiveBindingsForAction(e);
                },
              },
              {
                key: "_removeInactiveBindingsForAction",
                value: function _removeInactiveBindingsForAction(e) {
                  for (
                    var t = e._propertyBindings, n = 0, r = t.length;
                    n !== r;
                    ++n
                  ) {
                    var i = t[n];
                    0 === --i.referenceCount && this._removeInactiveBinding(i);
                  }
                },
              },
              {
                key: "_lendAction",
                value: function _lendAction(e) {
                  var t = this._actions,
                    n = e._cacheIndex,
                    r = this._nActiveActions++,
                    i = t[r];
                  (e._cacheIndex = r),
                    (t[r] = e),
                    (i._cacheIndex = n),
                    (t[n] = i);
                },
              },
              {
                key: "_takeBackAction",
                value: function _takeBackAction(e) {
                  var t = this._actions,
                    n = e._cacheIndex,
                    r = --this._nActiveActions,
                    i = t[r];
                  (e._cacheIndex = r),
                    (t[r] = e),
                    (i._cacheIndex = n),
                    (t[n] = i);
                },
              },
              {
                key: "_addInactiveBinding",
                value: function _addInactiveBinding(e, t, n) {
                  var r = this._bindingsByRootAndName,
                    i = this._bindings,
                    a = r[t];
                  void 0 === a && ((a = {}), (r[t] = a)),
                    (a[n] = e),
                    (e._cacheIndex = i.length),
                    i.push(e);
                },
              },
              {
                key: "_removeInactiveBinding",
                value: function _removeInactiveBinding(e) {
                  var t = this._bindings,
                    n = e.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    a = this._bindingsByRootAndName,
                    o = a[r],
                    s = t[t.length - 1],
                    u = e._cacheIndex;
                  (s._cacheIndex = u),
                    (t[u] = s),
                    t.pop(),
                    delete o[i],
                    0 === Object.keys(o).length && delete a[r];
                },
              },
              {
                key: "_lendBinding",
                value: function _lendBinding(e) {
                  var t = this._bindings,
                    n = e._cacheIndex,
                    r = this._nActiveBindings++,
                    i = t[r];
                  (e._cacheIndex = r),
                    (t[r] = e),
                    (i._cacheIndex = n),
                    (t[n] = i);
                },
              },
              {
                key: "_takeBackBinding",
                value: function _takeBackBinding(e) {
                  var t = this._bindings,
                    n = e._cacheIndex,
                    r = --this._nActiveBindings,
                    i = t[r];
                  (e._cacheIndex = r),
                    (t[r] = e),
                    (i._cacheIndex = n),
                    (t[n] = i);
                },
              },
              {
                key: "_lendControlInterpolant",
                value: function _lendControlInterpolant() {
                  var e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++,
                    n = e[t];
                  return (
                    void 0 === n &&
                      (((n = new Pu(
                        new Float32Array(2),
                        new Float32Array(2),
                        1,
                        sc
                      )).__cacheIndex = t),
                      (e[t] = n)),
                    n
                  );
                },
              },
              {
                key: "_takeBackControlInterpolant",
                value: function _takeBackControlInterpolant(e) {
                  var t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = t[r];
                  (e.__cacheIndex = r),
                    (t[r] = e),
                    (i.__cacheIndex = n),
                    (t[n] = i);
                },
              },
              {
                key: "clipAction",
                value: function clipAction(e, t, n) {
                  var r = t || this._root,
                    i = r.uuid,
                    a = "string" === typeof e ? Uu.findByName(r, e) : e,
                    o = null !== a ? a.uuid : e,
                    s = this._actionsByClip[o],
                    u = null;
                  if (
                    (void 0 === n && (n = null !== a ? a.blendMode : Ft),
                    void 0 !== s)
                  ) {
                    var l = s.actionByRoot[i];
                    if (void 0 !== l && l.blendMode === n) return l;
                    (u = s.knownActions[0]), null === a && (a = u._clip);
                  }
                  if (null === a) return null;
                  var c = new oc(this, a, t, n);
                  return (
                    this._bindAction(c, u), this._addInactiveAction(c, o, i), c
                  );
                },
              },
              {
                key: "existingAction",
                value: function existingAction(e, t) {
                  var n = t || this._root,
                    r = n.uuid,
                    i = "string" === typeof e ? Uu.findByName(n, e) : e,
                    a = i ? i.uuid : e,
                    o = this._actionsByClip[a];
                  return (void 0 !== o && o.actionByRoot[r]) || null;
                },
              },
              {
                key: "stopAllAction",
                value: function stopAllAction() {
                  for (
                    var e = this._actions, t = this._nActiveActions - 1;
                    t >= 0;
                    --t
                  )
                    e[t].stop();
                  return this;
                },
              },
              {
                key: "update",
                value: function update(e) {
                  e *= this.timeScale;
                  for (
                    var t = this._actions,
                      n = this._nActiveActions,
                      r = (this.time += e),
                      i = Math.sign(e),
                      a = (this._accuIndex ^= 1),
                      o = 0;
                    o !== n;
                    ++o
                  ) {
                    t[o]._update(r, e, i, a);
                  }
                  for (
                    var s = this._bindings, u = this._nActiveBindings, l = 0;
                    l !== u;
                    ++l
                  )
                    s[l].apply(a);
                  return this;
                },
              },
              {
                key: "setTime",
                value: function setTime(e) {
                  this.time = 0;
                  for (var t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                  return this.update(e);
                },
              },
              {
                key: "getRoot",
                value: function getRoot() {
                  return this._root;
                },
              },
              {
                key: "uncacheClip",
                value: function uncacheClip(e) {
                  var t = this._actions,
                    n = e.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                  if (void 0 !== i) {
                    for (
                      var a = i.knownActions, o = 0, s = a.length;
                      o !== s;
                      ++o
                    ) {
                      var u = a[o];
                      this._deactivateAction(u);
                      var l = u._cacheIndex,
                        c = t[t.length - 1];
                      (u._cacheIndex = null),
                        (u._byClipCacheIndex = null),
                        (c._cacheIndex = l),
                        (t[l] = c),
                        t.pop(),
                        this._removeInactiveBindingsForAction(u);
                    }
                    delete r[n];
                  }
                },
              },
              {
                key: "uncacheRoot",
                value: function uncacheRoot(e) {
                  var t = e.uuid,
                    n = this._actionsByClip;
                  for (var r in n) {
                    var i = n[r].actionByRoot[t];
                    void 0 !== i &&
                      (this._deactivateAction(i),
                      this._removeInactiveAction(i));
                  }
                  var a = this._bindingsByRootAndName[t];
                  if (void 0 !== a)
                    for (var o in a) {
                      var s = a[o];
                      s.restoreOriginalState(), this._removeInactiveBinding(s);
                    }
                },
              },
              {
                key: "uncacheAction",
                value: function uncacheAction(e, t) {
                  var n = this.existingAction(e, t);
                  null !== n &&
                    (this._deactivateAction(n), this._removeInactiveAction(n));
                },
              },
            ]),
            AnimationMixer
          );
        })(Ln),
        lc = (function () {
          function Uniform(e) {
            Object(f.a)(this, Uniform),
              "string" === typeof e &&
                (console.warn(
                  "THREE.Uniform: Type parameter is no longer needed."
                ),
                (e = arguments[1])),
              (this.value = e);
          }
          return (
            Object(p.a)(Uniform, [
              {
                key: "clone",
                value: function clone() {
                  return new Uniform(
                    void 0 === this.value.clone
                      ? this.value
                      : this.value.clone()
                  );
                },
              },
            ]),
            Uniform
          );
        })(),
        cc = 0,
        hc = (function (e) {
          function UniformsGroup() {
            var e;
            return (
              Object(f.a)(this, UniformsGroup),
              ((e = Object(s.a)(
                this,
                Object(r.a)(UniformsGroup).call(this)
              )).isUniformsGroup = !0),
              Object.defineProperty(Object(l.a)(Object(l.a)(e)), "id", {
                value: cc++,
              }),
              (e.name = ""),
              (e.usage = gn),
              (e.uniforms = []),
              e
            );
          }
          return (
            Object(u.a)(UniformsGroup, e),
            Object(p.a)(UniformsGroup, [
              {
                key: "add",
                value: function add(e) {
                  return this.uniforms.push(e), this;
                },
              },
              {
                key: "remove",
                value: function remove(e) {
                  var t = this.uniforms.indexOf(e);
                  return -1 !== t && this.uniforms.splice(t, 1), this;
                },
              },
              {
                key: "setName",
                value: function setName(e) {
                  return (this.name = e), this;
                },
              },
              {
                key: "setUsage",
                value: function setUsage(e) {
                  return (this.usage = e), this;
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  return this.dispatchEvent({ type: "dispose" }), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  (this.name = e.name), (this.usage = e.usage);
                  var t = e.uniforms;
                  this.uniforms.length = 0;
                  for (var n = 0, r = t.length; n < r; n++)
                    this.uniforms.push(t[n].clone());
                  return this;
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            UniformsGroup
          );
        })(Ln),
        dc = (function (e) {
          function InstancedInterleavedBuffer(e, t) {
            var n,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1;
            return (
              Object(f.a)(this, InstancedInterleavedBuffer),
              ((n = Object(s.a)(
                this,
                Object(r.a)(InstancedInterleavedBuffer).call(this, e, t)
              )).isInstancedInterleavedBuffer = !0),
              (n.meshPerAttribute = i),
              n
            );
          }
          return (
            Object(u.a)(InstancedInterleavedBuffer, e),
            Object(p.a)(InstancedInterleavedBuffer, [
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(InstancedInterleavedBuffer.prototype),
                      "copy",
                      this
                    ).call(this, e),
                    (this.meshPerAttribute = e.meshPerAttribute),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone(e) {
                  var t = Object(o.a)(
                    Object(r.a)(InstancedInterleavedBuffer.prototype),
                    "clone",
                    this
                  ).call(this, e);
                  return (t.meshPerAttribute = this.meshPerAttribute), t;
                },
              },
              {
                key: "toJSON",
                value: function toJSON(e) {
                  var t = Object(o.a)(
                    Object(r.a)(InstancedInterleavedBuffer.prototype),
                    "toJSON",
                    this
                  ).call(this, e);
                  return (
                    (t.isInstancedInterleavedBuffer = !0),
                    (t.meshPerAttribute = this.meshPerAttribute),
                    t
                  );
                },
              },
            ]),
            InstancedInterleavedBuffer
          );
        })(So),
        fc = (function () {
          function GLBufferAttribute(e, t, n, r, i) {
            Object(f.a)(this, GLBufferAttribute),
              (this.isGLBufferAttribute = !0),
              (this.buffer = e),
              (this.type = t),
              (this.itemSize = n),
              (this.elementSize = r),
              (this.count = i),
              (this.version = 0);
          }
          return (
            Object(p.a)(GLBufferAttribute, [
              {
                key: "setBuffer",
                value: function setBuffer(e) {
                  return (this.buffer = e), this;
                },
              },
              {
                key: "setType",
                value: function setType(e, t) {
                  return (this.type = e), (this.elementSize = t), this;
                },
              },
              {
                key: "setItemSize",
                value: function setItemSize(e) {
                  return (this.itemSize = e), this;
                },
              },
              {
                key: "setCount",
                value: function setCount(e) {
                  return (this.count = e), this;
                },
              },
              {
                key: "needsUpdate",
                set: function set(e) {
                  !0 === e && this.version++;
                },
              },
            ]),
            GLBufferAttribute
          );
        })(),
        pc = (function () {
          function Raycaster(e, t) {
            var n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 1 / 0;
            Object(f.a)(this, Raycaster),
              (this.ray = new Rr(e, t)),
              (this.near = n),
              (this.far = r),
              (this.camera = null),
              (this.layers = new Hr()),
              (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
              });
          }
          return (
            Object(p.a)(Raycaster, [
              {
                key: "set",
                value: function set(e, t) {
                  this.ray.set(e, t);
                },
              },
              {
                key: "setFromCamera",
                value: function setFromCamera(e, t) {
                  t.isPerspectiveCamera
                    ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                      this.ray.direction
                        .set(e.x, e.y, 0.5)
                        .unproject(t)
                        .sub(this.ray.origin)
                        .normalize(),
                      (this.camera = t))
                    : t.isOrthographicCamera
                    ? (this.ray.origin
                        .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                        .unproject(t),
                      this.ray.direction
                        .set(0, 0, -1)
                        .transformDirection(t.matrixWorld),
                      (this.camera = t))
                    : console.error(
                        "THREE.Raycaster: Unsupported camera type: " + t.type
                      );
                },
              },
              {
                key: "intersectObject",
                value: function intersectObject(e) {
                  var t =
                      !(arguments.length > 1 && void 0 !== arguments[1]) ||
                      arguments[1],
                    n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : [];
                  return _intersectObject(e, this, n, t), n.sort(ascSort), n;
                },
              },
              {
                key: "intersectObjects",
                value: function intersectObjects(e) {
                  for (
                    var t =
                        !(arguments.length > 1 && void 0 !== arguments[1]) ||
                        arguments[1],
                      n =
                        arguments.length > 2 && void 0 !== arguments[2]
                          ? arguments[2]
                          : [],
                      r = 0,
                      i = e.length;
                    r < i;
                    r++
                  )
                    _intersectObject(e[r], this, n, t);
                  return n.sort(ascSort), n;
                },
              },
            ]),
            Raycaster
          );
        })();
      function ascSort(e, t) {
        return e.distance - t.distance;
      }
      function _intersectObject(e, t, n, r) {
        if ((e.layers.test(t.layers) && e.raycast(t, n), !0 === r))
          for (var i = e.children, a = 0, o = i.length; a < o; a++)
            _intersectObject(i[a], t, n, !0);
      }
      var mc = (function () {
          function Spherical() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0;
            return (
              Object(f.a)(this, Spherical),
              (this.radius = e),
              (this.phi = t),
              (this.theta = n),
              this
            );
          }
          return (
            Object(p.a)(Spherical, [
              {
                key: "set",
                value: function set(e, t, n) {
                  return (
                    (this.radius = e), (this.phi = t), (this.theta = n), this
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.radius = e.radius),
                    (this.phi = e.phi),
                    (this.theta = e.theta),
                    this
                  );
                },
              },
              {
                key: "makeSafe",
                value: function makeSafe() {
                  return (
                    (this.phi = Math.max(
                      1e-6,
                      Math.min(Math.PI - 1e-6, this.phi)
                    )),
                    this
                  );
                },
              },
              {
                key: "setFromVector3",
                value: function setFromVector3(e) {
                  return this.setFromCartesianCoords(e.x, e.y, e.z);
                },
              },
              {
                key: "setFromCartesianCoords",
                value: function setFromCartesianCoords(e, t, n) {
                  return (
                    (this.radius = Math.sqrt(e * e + t * t + n * n)),
                    0 === this.radius
                      ? ((this.theta = 0), (this.phi = 0))
                      : ((this.theta = Math.atan2(e, n)),
                        (this.phi = Math.acos(clamp(t / this.radius, -1, 1)))),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Spherical
          );
        })(),
        vc = (function () {
          function Cylindrical() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0;
            return (
              Object(f.a)(this, Cylindrical),
              (this.radius = e),
              (this.theta = t),
              (this.y = n),
              this
            );
          }
          return (
            Object(p.a)(Cylindrical, [
              {
                key: "set",
                value: function set(e, t, n) {
                  return (
                    (this.radius = e), (this.theta = t), (this.y = n), this
                  );
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    (this.radius = e.radius),
                    (this.theta = e.theta),
                    (this.y = e.y),
                    this
                  );
                },
              },
              {
                key: "setFromVector3",
                value: function setFromVector3(e) {
                  return this.setFromCartesianCoords(e.x, e.y, e.z);
                },
              },
              {
                key: "setFromCartesianCoords",
                value: function setFromCartesianCoords(e, t, n) {
                  return (
                    (this.radius = Math.sqrt(e * e + n * n)),
                    (this.theta = Math.atan2(e, n)),
                    (this.y = t),
                    this
                  );
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Cylindrical
          );
        })(),
        gc = new Dn(),
        yc = (function () {
          function Box2() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new Dn(1 / 0, 1 / 0),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new Dn(-1 / 0, -1 / 0);
            Object(f.a)(this, Box2),
              (this.isBox2 = !0),
              (this.min = e),
              (this.max = t);
          }
          return (
            Object(p.a)(Box2, [
              {
                key: "set",
                value: function set(e, t) {
                  return this.min.copy(e), this.max.copy(t), this;
                },
              },
              {
                key: "setFromPoints",
                value: function setFromPoints(e) {
                  this.makeEmpty();
                  for (var t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                  return this;
                },
              },
              {
                key: "setFromCenterAndSize",
                value: function setFromCenterAndSize(e, t) {
                  var n = gc.copy(t).multiplyScalar(0.5);
                  return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return this.min.copy(e.min), this.max.copy(e.max), this;
                },
              },
              {
                key: "makeEmpty",
                value: function makeEmpty() {
                  return (
                    (this.min.x = this.min.y = 1 / 0),
                    (this.max.x = this.max.y = -1 / 0),
                    this
                  );
                },
              },
              {
                key: "isEmpty",
                value: function isEmpty() {
                  return this.max.x < this.min.x || this.max.y < this.min.y;
                },
              },
              {
                key: "getCenter",
                value: function getCenter(e) {
                  return this.isEmpty()
                    ? e.set(0, 0)
                    : e.addVectors(this.min, this.max).multiplyScalar(0.5);
                },
              },
              {
                key: "getSize",
                value: function getSize(e) {
                  return this.isEmpty()
                    ? e.set(0, 0)
                    : e.subVectors(this.max, this.min);
                },
              },
              {
                key: "expandByPoint",
                value: function expandByPoint(e) {
                  return this.min.min(e), this.max.max(e), this;
                },
              },
              {
                key: "expandByVector",
                value: function expandByVector(e) {
                  return this.min.sub(e), this.max.add(e), this;
                },
              },
              {
                key: "expandByScalar",
                value: function expandByScalar(e) {
                  return this.min.addScalar(-e), this.max.addScalar(e), this;
                },
              },
              {
                key: "containsPoint",
                value: function containsPoint(e) {
                  return !(
                    e.x < this.min.x ||
                    e.x > this.max.x ||
                    e.y < this.min.y ||
                    e.y > this.max.y
                  );
                },
              },
              {
                key: "containsBox",
                value: function containsBox(e) {
                  return (
                    this.min.x <= e.min.x &&
                    e.max.x <= this.max.x &&
                    this.min.y <= e.min.y &&
                    e.max.y <= this.max.y
                  );
                },
              },
              {
                key: "getParameter",
                value: function getParameter(e, t) {
                  return t.set(
                    (e.x - this.min.x) / (this.max.x - this.min.x),
                    (e.y - this.min.y) / (this.max.y - this.min.y)
                  );
                },
              },
              {
                key: "intersectsBox",
                value: function intersectsBox(e) {
                  return !(
                    e.max.x < this.min.x ||
                    e.min.x > this.max.x ||
                    e.max.y < this.min.y ||
                    e.min.y > this.max.y
                  );
                },
              },
              {
                key: "clampPoint",
                value: function clampPoint(e, t) {
                  return t.copy(e).clamp(this.min, this.max);
                },
              },
              {
                key: "distanceToPoint",
                value: function distanceToPoint(e) {
                  return gc.copy(e).clamp(this.min, this.max).sub(e).length();
                },
              },
              {
                key: "intersect",
                value: function intersect(e) {
                  return this.min.max(e.min), this.max.min(e.max), this;
                },
              },
              {
                key: "union",
                value: function union(e) {
                  return this.min.min(e.min), this.max.max(e.max), this;
                },
              },
              {
                key: "translate",
                value: function translate(e) {
                  return this.min.add(e), this.max.add(e), this;
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return e.min.equals(this.min) && e.max.equals(this.max);
                },
              },
            ]),
            Box2
          );
        })(),
        bc = new ir(),
        xc = new ir(),
        _c = (function () {
          function Line3() {
            var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir();
            Object(f.a)(this, Line3), (this.start = e), (this.end = t);
          }
          return (
            Object(p.a)(Line3, [
              {
                key: "set",
                value: function set(e, t) {
                  return this.start.copy(e), this.end.copy(t), this;
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return this.start.copy(e.start), this.end.copy(e.end), this;
                },
              },
              {
                key: "getCenter",
                value: function getCenter(e) {
                  return e.addVectors(this.start, this.end).multiplyScalar(0.5);
                },
              },
              {
                key: "delta",
                value: function delta(e) {
                  return e.subVectors(this.end, this.start);
                },
              },
              {
                key: "distanceSq",
                value: function distanceSq() {
                  return this.start.distanceToSquared(this.end);
                },
              },
              {
                key: "distance",
                value: function distance() {
                  return this.start.distanceTo(this.end);
                },
              },
              {
                key: "at",
                value: function at(e, t) {
                  return this.delta(t).multiplyScalar(e).add(this.start);
                },
              },
              {
                key: "closestPointToPointParameter",
                value: function closestPointToPointParameter(e, t) {
                  bc.subVectors(e, this.start),
                    xc.subVectors(this.end, this.start);
                  var n = xc.dot(xc),
                    r = xc.dot(bc) / n;
                  return t && (r = clamp(r, 0, 1)), r;
                },
              },
              {
                key: "closestPointToPoint",
                value: function closestPointToPoint(e, t, n) {
                  var r = this.closestPointToPointParameter(e, t);
                  return this.delta(n).multiplyScalar(r).add(this.start);
                },
              },
              {
                key: "applyMatrix4",
                value: function applyMatrix4(e) {
                  return (
                    this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                  );
                },
              },
              {
                key: "equals",
                value: function equals(e) {
                  return e.start.equals(this.start) && e.end.equals(this.end);
                },
              },
              {
                key: "clone",
                value: function clone() {
                  return new this.constructor().copy(this);
                },
              },
            ]),
            Line3
          );
        })(),
        Mc = new ir(),
        Sc = (function (e) {
          function SpotLightHelper(e, t) {
            var n;
            Object(f.a)(this, SpotLightHelper),
              ((n = Object(s.a)(
                this,
                Object(r.a)(SpotLightHelper).call(this)
              )).light = e),
              n.light.updateMatrixWorld(),
              (n.matrix = e.matrixWorld),
              (n.matrixAutoUpdate = !1),
              (n.color = t);
            for (
              var i = new Fi(),
                a = [
                  0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0,
                  0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
                ],
                o = 0,
                u = 1;
              o < 32;
              o++, u++
            ) {
              var l = (o / 32) * Math.PI * 2,
                c = (u / 32) * Math.PI * 2;
              a.push(Math.cos(l), Math.sin(l), 1, Math.cos(c), Math.sin(c), 1);
            }
            i.setAttribute("position", new Ei(a, 3));
            var h = new os({ fog: !1, toneMapped: !1 });
            return (n.cone = new ms(i, h)), n.add(n.cone), n.update(), n;
          }
          return (
            Object(u.a)(SpotLightHelper, e),
            Object(p.a)(SpotLightHelper, [
              {
                key: "dispose",
                value: function dispose() {
                  this.cone.geometry.dispose(), this.cone.material.dispose();
                },
              },
              {
                key: "update",
                value: function update() {
                  this.light.updateMatrixWorld();
                  var e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                  this.cone.scale.set(t, t, e),
                    Mc.setFromMatrixPosition(this.light.target.matrixWorld),
                    this.cone.lookAt(Mc),
                    void 0 !== this.color
                      ? this.cone.material.color.set(this.color)
                      : this.cone.material.color.copy(this.light.color);
                },
              },
            ]),
            SpotLightHelper
          );
        })(ai),
        wc = new ir(),
        Tc = new Ir(),
        Ac = new Ir(),
        Oc = (function (e) {
          function SkeletonHelper(e) {
            var t;
            Object(f.a)(this, SkeletonHelper);
            for (
              var n = (function getBoneList(e) {
                  var t = [];
                  !0 === e.isBone && t.push(e);
                  for (var n = 0; n < e.children.length; n++)
                    t.push.apply(t, getBoneList(e.children[n]));
                  return t;
                })(e),
                i = new Fi(),
                a = [],
                o = [],
                u = new Hn(0, 0, 1),
                l = new Hn(0, 1, 0),
                c = 0;
              c < n.length;
              c++
            ) {
              var h = n[c];
              h.parent &&
                h.parent.isBone &&
                (a.push(0, 0, 0),
                a.push(0, 0, 0),
                o.push(u.r, u.g, u.b),
                o.push(l.r, l.g, l.b));
            }
            i.setAttribute("position", new Ei(a, 3)),
              i.setAttribute("color", new Ei(o, 3));
            var d = new os({
              vertexColors: !0,
              depthTest: !1,
              depthWrite: !1,
              toneMapped: !1,
              transparent: !0,
            });
            return (
              ((t = Object(s.a)(
                this,
                Object(r.a)(SkeletonHelper).call(this, i, d)
              )).isSkeletonHelper = !0),
              (t.type = "SkeletonHelper"),
              (t.root = e),
              (t.bones = n),
              (t.matrix = e.matrixWorld),
              (t.matrixAutoUpdate = !1),
              t
            );
          }
          return (
            Object(u.a)(SkeletonHelper, e),
            Object(p.a)(SkeletonHelper, [
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  var t = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                  Ac.copy(this.root.matrixWorld).invert();
                  for (var a = 0, s = 0; a < t.length; a++) {
                    var u = t[a];
                    u.parent &&
                      u.parent.isBone &&
                      (Tc.multiplyMatrices(Ac, u.matrixWorld),
                      wc.setFromMatrixPosition(Tc),
                      i.setXYZ(s, wc.x, wc.y, wc.z),
                      Tc.multiplyMatrices(Ac, u.parent.matrixWorld),
                      wc.setFromMatrixPosition(Tc),
                      i.setXYZ(s + 1, wc.x, wc.y, wc.z),
                      (s += 2));
                  }
                  (n.getAttribute("position").needsUpdate = !0),
                    Object(o.a)(
                      Object(r.a)(SkeletonHelper.prototype),
                      "updateMatrixWorld",
                      this
                    ).call(this, e);
                },
              },
            ]),
            SkeletonHelper
          );
        })(ms);
      var Cc = (function (e) {
          function PointLightHelper(e, t, n) {
            var i;
            Object(f.a)(this, PointLightHelper);
            var a = new du(t, 4, 2),
              o = new bi({ wireframe: !0, fog: !1, toneMapped: !1 });
            return (
              ((i = Object(s.a)(
                this,
                Object(r.a)(PointLightHelper).call(this, a, o)
              )).light = e),
              i.light.updateMatrixWorld(),
              (i.color = n),
              (i.type = "PointLightHelper"),
              (i.matrix = i.light.matrixWorld),
              (i.matrixAutoUpdate = !1),
              i.update(),
              i
            );
          }
          return (
            Object(u.a)(PointLightHelper, e),
            Object(p.a)(PointLightHelper, [
              {
                key: "dispose",
                value: function dispose() {
                  this.geometry.dispose(), this.material.dispose();
                },
              },
              {
                key: "update",
                value: function update() {
                  void 0 !== this.color
                    ? this.material.color.set(this.color)
                    : this.material.color.copy(this.light.color);
                },
              },
            ]),
            PointLightHelper
          );
        })(ia),
        Lc = new ir(),
        kc = new Hn(),
        Ec = new Hn(),
        Pc = (function (e) {
          function HemisphereLightHelper(e, t, n) {
            var i;
            Object(f.a)(this, HemisphereLightHelper),
              ((i = Object(s.a)(
                this,
                Object(r.a)(HemisphereLightHelper).call(this)
              )).light = e),
              i.light.updateMatrixWorld(),
              (i.matrix = e.matrixWorld),
              (i.matrixAutoUpdate = !1),
              (i.color = n);
            var a = new lu(t);
            a.rotateY(0.5 * Math.PI),
              (i.material = new bi({ wireframe: !0, fog: !1, toneMapped: !1 })),
              void 0 === i.color && (i.material.vertexColors = !0);
            var o = a.getAttribute("position"),
              u = new Float32Array(3 * o.count);
            return (
              a.setAttribute("color", new Mi(u, 3)),
              i.add(new ia(a, i.material)),
              i.update(),
              i
            );
          }
          return (
            Object(u.a)(HemisphereLightHelper, e),
            Object(p.a)(HemisphereLightHelper, [
              {
                key: "dispose",
                value: function dispose() {
                  this.children[0].geometry.dispose(),
                    this.children[0].material.dispose();
                },
              },
              {
                key: "update",
                value: function update() {
                  var e = this.children[0];
                  if (void 0 !== this.color)
                    this.material.color.set(this.color);
                  else {
                    var t = e.geometry.getAttribute("color");
                    kc.copy(this.light.color), Ec.copy(this.light.groundColor);
                    for (var n = 0, r = t.count; n < r; n++) {
                      var i = n < r / 2 ? kc : Ec;
                      t.setXYZ(n, i.r, i.g, i.b);
                    }
                    t.needsUpdate = !0;
                  }
                  e.lookAt(
                    Lc.setFromMatrixPosition(this.light.matrixWorld).negate()
                  );
                },
              },
            ]),
            HemisphereLightHelper
          );
        })(ai),
        Rc = (function (e) {
          function GridHelper() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 10,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 10,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 4473924,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 8947848;
            Object(f.a)(this, GridHelper), (i = new Hn(i)), (a = new Hn(a));
            for (
              var o = n / 2,
                u = t / n,
                l = t / 2,
                c = [],
                h = [],
                d = 0,
                p = 0,
                m = -l;
              d <= n;
              d++, m += u
            ) {
              c.push(-l, 0, m, l, 0, m), c.push(m, 0, -l, m, 0, l);
              var v = d === o ? i : a;
              v.toArray(h, p),
                (p += 3),
                v.toArray(h, p),
                (p += 3),
                v.toArray(h, p),
                (p += 3),
                v.toArray(h, p),
                (p += 3);
            }
            var g = new Fi();
            g.setAttribute("position", new Ei(c, 3)),
              g.setAttribute("color", new Ei(h, 3));
            var y = new os({ vertexColors: !0, toneMapped: !1 });
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(GridHelper).call(this, g, y)
              )).type = "GridHelper"),
              e
            );
          }
          return Object(u.a)(GridHelper, e), GridHelper;
        })(ms),
        Ic = (function (e) {
          function PolarGridHelper() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 10,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 16,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 8,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 64,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 4473924,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 8947848;
            Object(f.a)(this, PolarGridHelper),
              (o = new Hn(o)),
              (u = new Hn(u));
            for (var l = [], c = [], h = 0; h <= n; h++) {
              var d = (h / n) * (2 * Math.PI),
                p = Math.sin(d) * t,
                m = Math.cos(d) * t;
              l.push(0, 0, 0), l.push(p, 0, m);
              var v = 1 & h ? o : u;
              c.push(v.r, v.g, v.b), c.push(v.r, v.g, v.b);
            }
            for (var g = 0; g <= i; g++)
              for (
                var y = 1 & g ? o : u, b = t - (t / i) * g, x = 0;
                x < a;
                x++
              ) {
                var _ = (x / a) * (2 * Math.PI),
                  M = Math.sin(_) * b,
                  S = Math.cos(_) * b;
                l.push(M, 0, S),
                  c.push(y.r, y.g, y.b),
                  (_ = ((x + 1) / a) * (2 * Math.PI)),
                  (M = Math.sin(_) * b),
                  (S = Math.cos(_) * b),
                  l.push(M, 0, S),
                  c.push(y.r, y.g, y.b);
              }
            var w = new Fi();
            w.setAttribute("position", new Ei(l, 3)),
              w.setAttribute("color", new Ei(c, 3));
            var T = new os({ vertexColors: !0, toneMapped: !1 });
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(PolarGridHelper).call(this, w, T)
              )).type = "PolarGridHelper"),
              e
            );
          }
          return Object(u.a)(PolarGridHelper, e), PolarGridHelper;
        })(ms),
        Dc = new ir(),
        jc = new ir(),
        Bc = new ir(),
        Nc = (function (e) {
          function DirectionalLightHelper(e, t, n) {
            var i;
            Object(f.a)(this, DirectionalLightHelper),
              ((i = Object(s.a)(
                this,
                Object(r.a)(DirectionalLightHelper).call(this)
              )).light = e),
              i.light.updateMatrixWorld(),
              (i.matrix = e.matrixWorld),
              (i.matrixAutoUpdate = !1),
              (i.color = n),
              void 0 === t && (t = 1);
            var a = new Fi();
            a.setAttribute(
              "position",
              new Ei([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
            );
            var o = new os({ fog: !1, toneMapped: !1 });
            return (
              (i.lightPlane = new ds(a, o)),
              i.add(i.lightPlane),
              (a = new Fi()).setAttribute(
                "position",
                new Ei([0, 0, 0, 0, 0, 1], 3)
              ),
              (i.targetLine = new ds(a, o)),
              i.add(i.targetLine),
              i.update(),
              i
            );
          }
          return (
            Object(u.a)(DirectionalLightHelper, e),
            Object(p.a)(DirectionalLightHelper, [
              {
                key: "dispose",
                value: function dispose() {
                  this.lightPlane.geometry.dispose(),
                    this.lightPlane.material.dispose(),
                    this.targetLine.geometry.dispose(),
                    this.targetLine.material.dispose();
                },
              },
              {
                key: "update",
                value: function update() {
                  Dc.setFromMatrixPosition(this.light.matrixWorld),
                    jc.setFromMatrixPosition(this.light.target.matrixWorld),
                    Bc.subVectors(jc, Dc),
                    this.lightPlane.lookAt(jc),
                    void 0 !== this.color
                      ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color))
                      : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                    this.targetLine.lookAt(jc),
                    (this.targetLine.scale.z = Bc.length());
                },
              },
            ]),
            DirectionalLightHelper
          );
        })(ai),
        zc = new ir(),
        Fc = new ca(),
        Gc = (function (e) {
          function CameraHelper(e) {
            var t;
            Object(f.a)(this, CameraHelper);
            var n = new Fi(),
              i = new os({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              a = [],
              o = [],
              u = {};
            function addLine(e, t) {
              addPoint(e), addPoint(t);
            }
            function addPoint(e) {
              a.push(0, 0, 0),
                o.push(0, 0, 0),
                void 0 === u[e] && (u[e] = []),
                u[e].push(a.length / 3 - 1);
            }
            addLine("n1", "n2"),
              addLine("n2", "n4"),
              addLine("n4", "n3"),
              addLine("n3", "n1"),
              addLine("f1", "f2"),
              addLine("f2", "f4"),
              addLine("f4", "f3"),
              addLine("f3", "f1"),
              addLine("n1", "f1"),
              addLine("n2", "f2"),
              addLine("n3", "f3"),
              addLine("n4", "f4"),
              addLine("p", "n1"),
              addLine("p", "n2"),
              addLine("p", "n3"),
              addLine("p", "n4"),
              addLine("u1", "u2"),
              addLine("u2", "u3"),
              addLine("u3", "u1"),
              addLine("c", "t"),
              addLine("p", "c"),
              addLine("cn1", "cn2"),
              addLine("cn3", "cn4"),
              addLine("cf1", "cf2"),
              addLine("cf3", "cf4"),
              n.setAttribute("position", new Ei(a, 3)),
              n.setAttribute("color", new Ei(o, 3)),
              ((t = Object(s.a)(
                this,
                Object(r.a)(CameraHelper).call(this, n, i)
              )).type = "CameraHelper"),
              (t.camera = e),
              t.camera.updateProjectionMatrix &&
                t.camera.updateProjectionMatrix(),
              (t.matrix = e.matrixWorld),
              (t.matrixAutoUpdate = !1),
              (t.pointMap = u),
              t.update();
            var l = new Hn(16755200),
              c = new Hn(16711680),
              h = new Hn(43775),
              d = new Hn(16777215),
              p = new Hn(3355443);
            return t.setColors(l, c, h, d, p), t;
          }
          return (
            Object(u.a)(CameraHelper, e),
            Object(p.a)(CameraHelper, [
              {
                key: "setColors",
                value: function setColors(e, t, n, r, i) {
                  var a = this.geometry.getAttribute("color");
                  a.setXYZ(0, e.r, e.g, e.b),
                    a.setXYZ(1, e.r, e.g, e.b),
                    a.setXYZ(2, e.r, e.g, e.b),
                    a.setXYZ(3, e.r, e.g, e.b),
                    a.setXYZ(4, e.r, e.g, e.b),
                    a.setXYZ(5, e.r, e.g, e.b),
                    a.setXYZ(6, e.r, e.g, e.b),
                    a.setXYZ(7, e.r, e.g, e.b),
                    a.setXYZ(8, e.r, e.g, e.b),
                    a.setXYZ(9, e.r, e.g, e.b),
                    a.setXYZ(10, e.r, e.g, e.b),
                    a.setXYZ(11, e.r, e.g, e.b),
                    a.setXYZ(12, e.r, e.g, e.b),
                    a.setXYZ(13, e.r, e.g, e.b),
                    a.setXYZ(14, e.r, e.g, e.b),
                    a.setXYZ(15, e.r, e.g, e.b),
                    a.setXYZ(16, e.r, e.g, e.b),
                    a.setXYZ(17, e.r, e.g, e.b),
                    a.setXYZ(18, e.r, e.g, e.b),
                    a.setXYZ(19, e.r, e.g, e.b),
                    a.setXYZ(20, e.r, e.g, e.b),
                    a.setXYZ(21, e.r, e.g, e.b),
                    a.setXYZ(22, e.r, e.g, e.b),
                    a.setXYZ(23, e.r, e.g, e.b),
                    a.setXYZ(24, t.r, t.g, t.b),
                    a.setXYZ(25, t.r, t.g, t.b),
                    a.setXYZ(26, t.r, t.g, t.b),
                    a.setXYZ(27, t.r, t.g, t.b),
                    a.setXYZ(28, t.r, t.g, t.b),
                    a.setXYZ(29, t.r, t.g, t.b),
                    a.setXYZ(30, t.r, t.g, t.b),
                    a.setXYZ(31, t.r, t.g, t.b),
                    a.setXYZ(32, n.r, n.g, n.b),
                    a.setXYZ(33, n.r, n.g, n.b),
                    a.setXYZ(34, n.r, n.g, n.b),
                    a.setXYZ(35, n.r, n.g, n.b),
                    a.setXYZ(36, n.r, n.g, n.b),
                    a.setXYZ(37, n.r, n.g, n.b),
                    a.setXYZ(38, r.r, r.g, r.b),
                    a.setXYZ(39, r.r, r.g, r.b),
                    a.setXYZ(40, i.r, i.g, i.b),
                    a.setXYZ(41, i.r, i.g, i.b),
                    a.setXYZ(42, i.r, i.g, i.b),
                    a.setXYZ(43, i.r, i.g, i.b),
                    a.setXYZ(44, i.r, i.g, i.b),
                    a.setXYZ(45, i.r, i.g, i.b),
                    a.setXYZ(46, i.r, i.g, i.b),
                    a.setXYZ(47, i.r, i.g, i.b),
                    a.setXYZ(48, i.r, i.g, i.b),
                    a.setXYZ(49, i.r, i.g, i.b),
                    (a.needsUpdate = !0);
                },
              },
              {
                key: "update",
                value: function update() {
                  var e = this.geometry,
                    t = this.pointMap;
                  Fc.projectionMatrixInverse.copy(
                    this.camera.projectionMatrixInverse
                  ),
                    setPoint("c", t, e, Fc, 0, 0, -1),
                    setPoint("t", t, e, Fc, 0, 0, 1),
                    setPoint("n1", t, e, Fc, -1, -1, -1),
                    setPoint("n2", t, e, Fc, 1, -1, -1),
                    setPoint("n3", t, e, Fc, -1, 1, -1),
                    setPoint("n4", t, e, Fc, 1, 1, -1),
                    setPoint("f1", t, e, Fc, -1, -1, 1),
                    setPoint("f2", t, e, Fc, 1, -1, 1),
                    setPoint("f3", t, e, Fc, -1, 1, 1),
                    setPoint("f4", t, e, Fc, 1, 1, 1),
                    setPoint("u1", t, e, Fc, 0.7, 1.1, -1),
                    setPoint("u2", t, e, Fc, -0.7, 1.1, -1),
                    setPoint("u3", t, e, Fc, 0, 2, -1),
                    setPoint("cf1", t, e, Fc, -1, 0, 1),
                    setPoint("cf2", t, e, Fc, 1, 0, 1),
                    setPoint("cf3", t, e, Fc, 0, -1, 1),
                    setPoint("cf4", t, e, Fc, 0, 1, 1),
                    setPoint("cn1", t, e, Fc, -1, 0, -1),
                    setPoint("cn2", t, e, Fc, 1, 0, -1),
                    setPoint("cn3", t, e, Fc, 0, -1, -1),
                    setPoint("cn4", t, e, Fc, 0, 1, -1),
                    (e.getAttribute("position").needsUpdate = !0);
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.geometry.dispose(), this.material.dispose();
                },
              },
            ]),
            CameraHelper
          );
        })(ms);
      function setPoint(e, t, n, r, i, a, o) {
        zc.set(i, a, o).unproject(r);
        var s = t[e];
        if (void 0 !== s)
          for (
            var u = n.getAttribute("position"), l = 0, c = s.length;
            l < c;
            l++
          )
            u.setXYZ(s[l], zc.x, zc.y, zc.z);
      }
      var Uc,
        Vc,
        Wc = new sr(),
        Hc = (function (e) {
          function BoxHelper(e) {
            var t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 16776960;
            Object(f.a)(this, BoxHelper);
            var i = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              a = new Float32Array(24),
              o = new Fi();
            return (
              o.setIndex(new Mi(i, 1)),
              o.setAttribute("position", new Mi(a, 3)),
              ((t = Object(s.a)(
                this,
                Object(r.a)(BoxHelper).call(
                  this,
                  o,
                  new os({ color: n, toneMapped: !1 })
                )
              )).object = e),
              (t.type = "BoxHelper"),
              (t.matrixAutoUpdate = !1),
              t.update(),
              t
            );
          }
          return (
            Object(u.a)(BoxHelper, e),
            Object(p.a)(BoxHelper, [
              {
                key: "update",
                value: function update(e) {
                  if (
                    (void 0 !== e &&
                      console.warn(
                        "THREE.BoxHelper: .update() has no longer arguments."
                      ),
                    void 0 !== this.object && Wc.setFromObject(this.object),
                    !Wc.isEmpty())
                  ) {
                    var t = Wc.min,
                      n = Wc.max,
                      r = this.geometry.attributes.position,
                      i = r.array;
                    (i[0] = n.x),
                      (i[1] = n.y),
                      (i[2] = n.z),
                      (i[3] = t.x),
                      (i[4] = n.y),
                      (i[5] = n.z),
                      (i[6] = t.x),
                      (i[7] = t.y),
                      (i[8] = n.z),
                      (i[9] = n.x),
                      (i[10] = t.y),
                      (i[11] = n.z),
                      (i[12] = n.x),
                      (i[13] = n.y),
                      (i[14] = t.z),
                      (i[15] = t.x),
                      (i[16] = n.y),
                      (i[17] = t.z),
                      (i[18] = t.x),
                      (i[19] = t.y),
                      (i[20] = t.z),
                      (i[21] = n.x),
                      (i[22] = t.y),
                      (i[23] = t.z),
                      (r.needsUpdate = !0),
                      this.geometry.computeBoundingSphere();
                  }
                },
              },
              {
                key: "setFromObject",
                value: function setFromObject(e) {
                  return (this.object = e), this.update(), this;
                },
              },
              {
                key: "copy",
                value: function copy(e, t) {
                  return (
                    Object(o.a)(
                      Object(r.a)(BoxHelper.prototype),
                      "copy",
                      this
                    ).call(this, e, t),
                    (this.object = e.object),
                    this
                  );
                },
              },
            ]),
            BoxHelper
          );
        })(ms),
        qc = (function (e) {
          function Box3Helper(e) {
            var t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 16776960;
            Object(f.a)(this, Box3Helper);
            var i = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              a = new Fi();
            return (
              a.setIndex(new Mi(i, 1)),
              a.setAttribute(
                "position",
                new Ei(
                  [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                  ],
                  3
                )
              ),
              ((t = Object(s.a)(
                this,
                Object(r.a)(Box3Helper).call(
                  this,
                  a,
                  new os({ color: n, toneMapped: !1 })
                )
              )).box = e),
              (t.type = "Box3Helper"),
              t.geometry.computeBoundingSphere(),
              t
            );
          }
          return (
            Object(u.a)(Box3Helper, e),
            Object(p.a)(Box3Helper, [
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  var t = this.box;
                  t.isEmpty() ||
                    (t.getCenter(this.position),
                    t.getSize(this.scale),
                    this.scale.multiplyScalar(0.5),
                    Object(o.a)(
                      Object(r.a)(Box3Helper.prototype),
                      "updateMatrixWorld",
                      this
                    ).call(this, e));
                },
              },
            ]),
            Box3Helper
          );
        })(ms),
        Xc = (function (e) {
          function PlaneHelper(e) {
            var t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 1,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 16776960;
            Object(f.a)(this, PlaneHelper);
            var a = i,
              o = new Fi();
            o.setAttribute(
              "position",
              new Ei(
                [
                  1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0,
                  1, -1, 0, 1, 1, 0,
                ],
                3
              )
            ),
              o.computeBoundingSphere(),
              ((t = Object(s.a)(
                this,
                Object(r.a)(PlaneHelper).call(
                  this,
                  o,
                  new os({ color: a, toneMapped: !1 })
                )
              )).type = "PlaneHelper"),
              (t.plane = e),
              (t.size = n);
            var u = new Fi();
            return (
              u.setAttribute(
                "position",
                new Ei(
                  [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
                  3
                )
              ),
              u.computeBoundingSphere(),
              t.add(
                new ia(
                  u,
                  new bi({
                    color: a,
                    opacity: 0.2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1,
                  })
                )
              ),
              t
            );
          }
          return (
            Object(u.a)(PlaneHelper, e),
            Object(p.a)(PlaneHelper, [
              {
                key: "updateMatrixWorld",
                value: function updateMatrixWorld(e) {
                  this.position.set(0, 0, 0),
                    this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
                    this.lookAt(this.plane.normal),
                    this.translateZ(-this.plane.constant),
                    Object(o.a)(
                      Object(r.a)(PlaneHelper.prototype),
                      "updateMatrixWorld",
                      this
                    ).call(this, e);
                },
              },
            ]),
            PlaneHelper
          );
        })(ds),
        Jc = new ir(),
        Yc = (function (e) {
          function ArrowHelper() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : new ir(0, 0, 1),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : new ir(0, 0, 0),
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 1,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 16776960,
              o =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 0.2 * i,
              u =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : 0.2 * o;
            return (
              Object(f.a)(this, ArrowHelper),
              ((e = Object(s.a)(
                this,
                Object(r.a)(ArrowHelper).call(this)
              )).type = "ArrowHelper"),
              void 0 === Uc &&
                ((Uc = new Fi()).setAttribute(
                  "position",
                  new Ei([0, 0, 0, 0, 1, 0], 3)
                ),
                (Vc = new Js(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
              e.position.copy(n),
              (e.line = new ds(Uc, new os({ color: a, toneMapped: !1 }))),
              (e.line.matrixAutoUpdate = !1),
              e.add(e.line),
              (e.cone = new ia(Vc, new bi({ color: a, toneMapped: !1 }))),
              (e.cone.matrixAutoUpdate = !1),
              e.add(e.cone),
              e.setDirection(t),
              e.setLength(i, o, u),
              e
            );
          }
          return (
            Object(u.a)(ArrowHelper, e),
            Object(p.a)(ArrowHelper, [
              {
                key: "setDirection",
                value: function setDirection(e) {
                  if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
                  else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
                  else {
                    Jc.set(e.z, 0, -e.x).normalize();
                    var t = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(Jc, t);
                  }
                },
              },
              {
                key: "setLength",
                value: function setLength(e) {
                  var t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0.2 * e,
                    n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : 0.2 * t;
                  this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                    this.line.updateMatrix(),
                    this.cone.scale.set(n, t, n),
                    (this.cone.position.y = e),
                    this.cone.updateMatrix();
                },
              },
              {
                key: "setColor",
                value: function setColor(e) {
                  this.line.material.color.set(e),
                    this.cone.material.color.set(e);
                },
              },
              {
                key: "copy",
                value: function copy(e) {
                  return (
                    Object(o.a)(
                      Object(r.a)(ArrowHelper.prototype),
                      "copy",
                      this
                    ).call(this, e, !1),
                    this.line.copy(e.line),
                    this.cone.copy(e.cone),
                    this
                  );
                },
              },
            ]),
            ArrowHelper
          );
        })(ai),
        Zc = (function (e) {
          function AxesHelper() {
            var e,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1;
            Object(f.a)(this, AxesHelper);
            var n = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
              i = new Fi();
            i.setAttribute("position", new Ei(n, 3)),
              i.setAttribute(
                "color",
                new Ei(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3
                )
              );
            var a = new os({ vertexColors: !0, toneMapped: !1 });
            return (
              ((e = Object(s.a)(
                this,
                Object(r.a)(AxesHelper).call(this, i, a)
              )).type = "AxesHelper"),
              e
            );
          }
          return (
            Object(u.a)(AxesHelper, e),
            Object(p.a)(AxesHelper, [
              {
                key: "setColors",
                value: function setColors(e, t, n) {
                  var r = new Hn(),
                    i = this.geometry.attributes.color.array;
                  return (
                    r.set(e),
                    r.toArray(i, 0),
                    r.toArray(i, 3),
                    r.set(t),
                    r.toArray(i, 6),
                    r.toArray(i, 9),
                    r.set(n),
                    r.toArray(i, 12),
                    r.toArray(i, 15),
                    (this.geometry.attributes.color.needsUpdate = !0),
                    this
                  );
                },
              },
              {
                key: "dispose",
                value: function dispose() {
                  this.geometry.dispose(), this.material.dispose();
                },
              },
            ]),
            AxesHelper
          );
        })(ms),
        Kc = (function () {
          function ShapePath() {
            Object(f.a)(this, ShapePath),
              (this.type = "ShapePath"),
              (this.color = new Hn()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          return (
            Object(p.a)(ShapePath, [
              {
                key: "moveTo",
                value: function moveTo(e, t) {
                  return (
                    (this.currentPath = new Ws()),
                    this.subPaths.push(this.currentPath),
                    this.currentPath.moveTo(e, t),
                    this
                  );
                },
              },
              {
                key: "lineTo",
                value: function lineTo(e, t) {
                  return this.currentPath.lineTo(e, t), this;
                },
              },
              {
                key: "quadraticCurveTo",
                value: function quadraticCurveTo(e, t, n, r) {
                  return this.currentPath.quadraticCurveTo(e, t, n, r), this;
                },
              },
              {
                key: "bezierCurveTo",
                value: function bezierCurveTo(e, t, n, r, i, a) {
                  return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this;
                },
              },
              {
                key: "splineThru",
                value: function splineThru(e) {
                  return this.currentPath.splineThru(e), this;
                },
              },
              {
                key: "toShapes",
                value: function toShapes(e, t) {
                  function toShapesNoHoles(e) {
                    for (var t = [], n = 0, r = e.length; n < r; n++) {
                      var i = e[n],
                        a = new ru();
                      (a.curves = i.curves), t.push(a);
                    }
                    return t;
                  }
                  function isPointInsidePolygon(e, t) {
                    for (
                      var n = t.length, r = !1, i = n - 1, a = 0;
                      a < n;
                      i = a++
                    ) {
                      var o = t[i],
                        s = t[a],
                        u = s.x - o.x,
                        l = s.y - o.y;
                      if (Math.abs(l) > Number.EPSILON) {
                        if (
                          (l < 0 &&
                            ((o = t[a]), (u = -u), (s = t[i]), (l = -l)),
                          e.y < o.y || e.y > s.y)
                        )
                          continue;
                        if (e.y === o.y) {
                          if (e.x === o.x) return !0;
                        } else {
                          var c = l * (e.x - o.x) - u * (e.y - o.y);
                          if (0 === c) return !0;
                          if (c < 0) continue;
                          r = !r;
                        }
                      } else {
                        if (e.y !== o.y) continue;
                        if (
                          (s.x <= e.x && e.x <= o.x) ||
                          (o.x <= e.x && e.x <= s.x)
                        )
                          return !0;
                      }
                    }
                    return r;
                  }
                  var n,
                    r,
                    i,
                    a = au.isClockWise,
                    o = this.subPaths;
                  if (0 === o.length) return [];
                  if (!0 === t) return toShapesNoHoles(o);
                  var s = [];
                  if (1 === o.length)
                    return (
                      (r = o[0]),
                      ((i = new ru()).curves = r.curves),
                      s.push(i),
                      s
                    );
                  var u = !a(o[0].getPoints());
                  u = e ? !u : u;
                  var l,
                    c,
                    h = [],
                    d = [],
                    f = [],
                    p = 0;
                  (d[p] = void 0), (f[p] = []);
                  for (var m = 0, v = o.length; m < v; m++)
                    (n = a((l = (r = o[m]).getPoints()))),
                      (n = e ? !n : n)
                        ? (!u && d[p] && p++,
                          (d[p] = { s: new ru(), p: l }),
                          (d[p].s.curves = r.curves),
                          u && p++,
                          (f[p] = []))
                        : f[p].push({ h: r, p: l[0] });
                  if (!d[0]) return toShapesNoHoles(o);
                  if (d.length > 1) {
                    for (var g = !1, y = 0, b = 0, x = d.length; b < x; b++)
                      h[b] = [];
                    for (var _ = 0, M = d.length; _ < M; _++)
                      for (var S = f[_], w = 0; w < S.length; w++) {
                        for (var T = S[w], A = !0, O = 0; O < d.length; O++)
                          isPointInsidePolygon(T.p, d[O].p) &&
                            (_ !== O && y++,
                            A ? ((A = !1), h[O].push(T)) : (g = !0));
                        A && h[_].push(T);
                      }
                    y > 0 && !1 === g && (f = h);
                  }
                  for (var C = 0, L = d.length; C < L; C++) {
                    (i = d[C].s), s.push(i);
                    for (var k = 0, E = (c = f[C]).length; k < E; k++)
                      i.holes.push(c[k].h);
                  }
                  return s;
                },
              },
            ]),
            ShapePath
          );
        })(),
        Qc = _generateTables();
      function _generateTables() {
        for (
          var e = new ArrayBuffer(4),
            t = new Float32Array(e),
            n = new Uint32Array(e),
            r = new Uint32Array(512),
            i = new Uint32Array(512),
            a = 0;
          a < 256;
          ++a
        ) {
          var o = a - 127;
          o < -27
            ? ((r[a] = 0), (r[256 | a] = 32768), (i[a] = 24), (i[256 | a] = 24))
            : o < -14
            ? ((r[a] = 1024 >> (-o - 14)),
              (r[256 | a] = (1024 >> (-o - 14)) | 32768),
              (i[a] = -o - 1),
              (i[256 | a] = -o - 1))
            : o <= 15
            ? ((r[a] = (o + 15) << 10),
              (r[256 | a] = ((o + 15) << 10) | 32768),
              (i[a] = 13),
              (i[256 | a] = 13))
            : o < 128
            ? ((r[a] = 31744),
              (r[256 | a] = 64512),
              (i[a] = 24),
              (i[256 | a] = 24))
            : ((r[a] = 31744),
              (r[256 | a] = 64512),
              (i[a] = 13),
              (i[256 | a] = 13));
        }
        for (
          var s = new Uint32Array(2048),
            u = new Uint32Array(64),
            l = new Uint32Array(64),
            c = 1;
          c < 1024;
          ++c
        ) {
          for (var h = c << 13, d = 0; 0 === (8388608 & h); )
            (h <<= 1), (d -= 8388608);
          (h &= -8388609), (d += 947912704), (s[c] = h | d);
        }
        for (var f = 1024; f < 2048; ++f) s[f] = 939524096 + ((f - 1024) << 13);
        for (var p = 1; p < 31; ++p) u[p] = p << 23;
        (u[31] = 1199570944), (u[32] = 2147483648);
        for (var m = 33; m < 63; ++m) u[m] = 2147483648 + ((m - 32) << 23);
        u[63] = 3347054592;
        for (var v = 1; v < 64; ++v) 32 !== v && (l[v] = 1024);
        return {
          floatView: t,
          uint32View: n,
          baseTable: r,
          shiftTable: i,
          mantissaTable: s,
          exponentTable: u,
          offsetTable: l,
        };
      }
      var $c = Object.freeze({
          __proto__: null,
          toHalfFloat: function toHalfFloat(e) {
            Math.abs(e) > 65504 &&
              console.warn(
                "THREE.DataUtils.toHalfFloat(): Value out of range."
              ),
              (e = clamp(e, -65504, 65504)),
              (Qc.floatView[0] = e);
            var t = Qc.uint32View[0],
              n = (t >> 23) & 511;
            return Qc.baseTable[n] + ((8388607 & t) >> Qc.shiftTable[n]);
          },
          fromHalfFloat: function fromHalfFloat(e) {
            var t = e >> 10;
            return (
              (Qc.uint32View[0] =
                Qc.mantissaTable[Qc.offsetTable[t] + (1023 & e)] +
                Qc.exponentTable[t]),
              Qc.floatView[0]
            );
          },
        }),
        eh = (function (e) {
          function ParametricGeometry() {
            return (
              Object(f.a)(this, ParametricGeometry),
              console.error(
                "THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"
              ),
              Object(s.a)(this, Object(r.a)(ParametricGeometry).call(this))
            );
          }
          return Object(u.a)(ParametricGeometry, e), ParametricGeometry;
        })(Fi),
        th = (function (e) {
          function TextGeometry() {
            return (
              Object(f.a)(this, TextGeometry),
              console.error(
                "THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"
              ),
              Object(s.a)(this, Object(r.a)(TextGeometry).call(this))
            );
          }
          return Object(u.a)(TextGeometry, e), TextGeometry;
        })(Fi);
      function FontLoader() {
        console.error(
          "THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js"
        );
      }
      function Font() {
        console.error(
          "THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js"
        );
      }
      function ImmediateRenderObject() {
        console.error("THREE.ImmediateRenderObject has been removed.");
      }
      var nh = (function (e) {
          function WebGLMultisampleRenderTarget(e, t, n) {
            var i;
            return (
              Object(f.a)(this, WebGLMultisampleRenderTarget),
              console.error(
                'THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'
              ),
              ((i = Object(s.a)(
                this,
                Object(r.a)(WebGLMultisampleRenderTarget).call(this, e, t, n)
              )).samples = 4),
              i
            );
          }
          return (
            Object(u.a)(WebGLMultisampleRenderTarget, e),
            WebGLMultisampleRenderTarget
          );
        })(Kn),
        rh = (function (e) {
          function DataTexture2DArray(e, t, n, i) {
            return (
              Object(f.a)(this, DataTexture2DArray),
              console.warn(
                "THREE.DataTexture2DArray has been renamed to DataArrayTexture."
              ),
              Object(s.a)(
                this,
                Object(r.a)(DataTexture2DArray).call(this, e, t, n, i)
              )
            );
          }
          return Object(u.a)(DataTexture2DArray, e), DataTexture2DArray;
        })(Qn),
        ih = (function (e) {
          function DataTexture3D(e, t, n, i) {
            return (
              Object(f.a)(this, DataTexture3D),
              console.warn(
                "THREE.DataTexture3D has been renamed to Data3DTexture."
              ),
              Object(s.a)(
                this,
                Object(r.a)(DataTexture3D).call(this, e, t, n, i)
              )
            );
          }
          return Object(u.a)(DataTexture3D, e), DataTexture3D;
        })(er);
      "undefined" !== typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: m } })
        ),
        "undefined" !== typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = m));
    },
    20: function (e, t, n) {
      "use strict";
      function _setPrototypeOf(e, t) {
        return (_setPrototypeOf =
          Object.setPrototypeOf ||
          function _setPrototypeOf(e, t) {
            return (e.__proto__ = t), e;
          })(e, t);
      }
      n.d(t, "a", function () {
        return _setPrototypeOf;
      });
    },
    21: function (e, t, n) {
      "use strict";
      function _slicedToArray(e, t) {
        return (
          (function _arrayWithHoles(e) {
            if (Array.isArray(e)) return e;
          })(e) ||
          (function _iterableToArrayLimit(e, t) {
            var n = [],
              r = !0,
              i = !1,
              a = void 0;
            try {
              for (
                var o, s = e[Symbol.iterator]();
                !(r = (o = s.next()).done) &&
                (n.push(o.value), !t || n.length !== t);
                r = !0
              );
            } catch (u) {
              (i = !0), (a = u);
            } finally {
              try {
                r || null == s.return || s.return();
              } finally {
                if (i) throw a;
              }
            }
            return n;
          })(e, t) ||
          (function _nonIterableRest() {
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance"
            );
          })()
        );
      }
      n.d(t, "a", function () {
        return _slicedToArray;
      });
    },
    3: function (e, t, n) {
      "use strict";
      function _getPrototypeOf(e) {
        return (_getPrototypeOf = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function _getPrototypeOf(e) {
              return e.__proto__ || Object.getPrototypeOf(e);
            })(e);
      }
      n.d(t, "a", function () {
        return _getPrototypeOf;
      });
    },
    4: function (e, t, n) {
      "use strict";
      function _classCallCheck(e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      }
      n.d(t, "a", function () {
        return _classCallCheck;
      });
    },
    6: function (e, t, n) {
      "use strict";
      function _defineProperties(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(e, r.key, r);
        }
      }
      function _createClass(e, t, n) {
        return (
          t && _defineProperties(e.prototype, t),
          n && _defineProperties(e, n),
          e
        );
      }
      n.d(t, "a", function () {
        return _createClass;
      });
    },
    77: function (e, t, n) {
      var r =
          (function () {
            return this || ("object" === typeof self && self);
          })() || Function("return this")(),
        i =
          r.regeneratorRuntime &&
          Object.getOwnPropertyNames(r).indexOf("regeneratorRuntime") >= 0,
        a = i && r.regeneratorRuntime;
      if (((r.regeneratorRuntime = void 0), (e.exports = n(78)), i))
        r.regeneratorRuntime = a;
      else
        try {
          delete r.regeneratorRuntime;
        } catch (o) {
          r.regeneratorRuntime = void 0;
        }
    },
    78: function (e, t) {
      !(function (t) {
        "use strict";
        var n,
          r = Object.prototype,
          i = r.hasOwnProperty,
          a = "function" === typeof Symbol ? Symbol : {},
          o = a.iterator || "@@iterator",
          s = a.asyncIterator || "@@asyncIterator",
          u = a.toStringTag || "@@toStringTag",
          l = "object" === typeof e,
          c = t.regeneratorRuntime;
        if (c) l && (e.exports = c);
        else {
          (c = t.regeneratorRuntime = l ? e.exports : {}).wrap = wrap;
          var h = "suspendedStart",
            d = "suspendedYield",
            f = "executing",
            p = "completed",
            m = {},
            v = {};
          v[o] = function () {
            return this;
          };
          var g = Object.getPrototypeOf,
            y = g && g(g(values([])));
          y && y !== r && i.call(y, o) && (v = y);
          var b =
            (GeneratorFunctionPrototype.prototype =
            Generator.prototype =
              Object.create(v));
          (GeneratorFunction.prototype = b.constructor =
            GeneratorFunctionPrototype),
            (GeneratorFunctionPrototype.constructor = GeneratorFunction),
            (GeneratorFunctionPrototype[u] = GeneratorFunction.displayName =
              "GeneratorFunction"),
            (c.isGeneratorFunction = function (e) {
              var t = "function" === typeof e && e.constructor;
              return (
                !!t &&
                (t === GeneratorFunction ||
                  "GeneratorFunction" === (t.displayName || t.name))
              );
            }),
            (c.mark = function (e) {
              return (
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(e, GeneratorFunctionPrototype)
                  : ((e.__proto__ = GeneratorFunctionPrototype),
                    u in e || (e[u] = "GeneratorFunction")),
                (e.prototype = Object.create(b)),
                e
              );
            }),
            (c.awrap = function (e) {
              return { __await: e };
            }),
            defineIteratorMethods(AsyncIterator.prototype),
            (AsyncIterator.prototype[s] = function () {
              return this;
            }),
            (c.AsyncIterator = AsyncIterator),
            (c.async = function (e, t, n, r) {
              var i = new AsyncIterator(wrap(e, t, n, r));
              return c.isGeneratorFunction(t)
                ? i
                : i.next().then(function (e) {
                    return e.done ? e.value : i.next();
                  });
            }),
            defineIteratorMethods(b),
            (b[u] = "Generator"),
            (b[o] = function () {
              return this;
            }),
            (b.toString = function () {
              return "[object Generator]";
            }),
            (c.keys = function (e) {
              var t = [];
              for (var n in e) t.push(n);
              return (
                t.reverse(),
                function next() {
                  for (; t.length; ) {
                    var n = t.pop();
                    if (n in e) return (next.value = n), (next.done = !1), next;
                  }
                  return (next.done = !0), next;
                }
              );
            }),
            (c.values = values),
            (Context.prototype = {
              constructor: Context,
              reset: function (e) {
                if (
                  ((this.prev = 0),
                  (this.next = 0),
                  (this.sent = this._sent = n),
                  (this.done = !1),
                  (this.delegate = null),
                  (this.method = "next"),
                  (this.arg = n),
                  this.tryEntries.forEach(resetTryEntry),
                  !e)
                )
                  for (var t in this)
                    "t" === t.charAt(0) &&
                      i.call(this, t) &&
                      !isNaN(+t.slice(1)) &&
                      (this[t] = n);
              },
              stop: function () {
                this.done = !0;
                var e = this.tryEntries[0].completion;
                if ("throw" === e.type) throw e.arg;
                return this.rval;
              },
              dispatchException: function (e) {
                if (this.done) throw e;
                var t = this;
                function handle(r, i) {
                  return (
                    (o.type = "throw"),
                    (o.arg = e),
                    (t.next = r),
                    i && ((t.method = "next"), (t.arg = n)),
                    !!i
                  );
                }
                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                  var a = this.tryEntries[r],
                    o = a.completion;
                  if ("root" === a.tryLoc) return handle("end");
                  if (a.tryLoc <= this.prev) {
                    var s = i.call(a, "catchLoc"),
                      u = i.call(a, "finallyLoc");
                    if (s && u) {
                      if (this.prev < a.catchLoc) return handle(a.catchLoc, !0);
                      if (this.prev < a.finallyLoc) return handle(a.finallyLoc);
                    } else if (s) {
                      if (this.prev < a.catchLoc) return handle(a.catchLoc, !0);
                    } else {
                      if (!u)
                        throw new Error(
                          "try statement without catch or finally"
                        );
                      if (this.prev < a.finallyLoc) return handle(a.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function (e, t) {
                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                  var r = this.tryEntries[n];
                  if (
                    r.tryLoc <= this.prev &&
                    i.call(r, "finallyLoc") &&
                    this.prev < r.finallyLoc
                  ) {
                    var a = r;
                    break;
                  }
                }
                a &&
                  ("break" === e || "continue" === e) &&
                  a.tryLoc <= t &&
                  t <= a.finallyLoc &&
                  (a = null);
                var o = a ? a.completion : {};
                return (
                  (o.type = e),
                  (o.arg = t),
                  a
                    ? ((this.method = "next"), (this.next = a.finallyLoc), m)
                    : this.complete(o)
                );
              },
              complete: function (e, t) {
                if ("throw" === e.type) throw e.arg;
                return (
                  "break" === e.type || "continue" === e.type
                    ? (this.next = e.arg)
                    : "return" === e.type
                    ? ((this.rval = this.arg = e.arg),
                      (this.method = "return"),
                      (this.next = "end"))
                    : "normal" === e.type && t && (this.next = t),
                  m
                );
              },
              finish: function (e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                  var n = this.tryEntries[t];
                  if (n.finallyLoc === e)
                    return (
                      this.complete(n.completion, n.afterLoc),
                      resetTryEntry(n),
                      m
                    );
                }
              },
              catch: function (e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                  var n = this.tryEntries[t];
                  if (n.tryLoc === e) {
                    var r = n.completion;
                    if ("throw" === r.type) {
                      var i = r.arg;
                      resetTryEntry(n);
                    }
                    return i;
                  }
                }
                throw new Error("illegal catch attempt");
              },
              delegateYield: function (e, t, r) {
                return (
                  (this.delegate = {
                    iterator: values(e),
                    resultName: t,
                    nextLoc: r,
                  }),
                  "next" === this.method && (this.arg = n),
                  m
                );
              },
            });
        }
        function wrap(e, t, n, r) {
          var i = t && t.prototype instanceof Generator ? t : Generator,
            a = Object.create(i.prototype),
            o = new Context(r || []);
          return (
            (a._invoke = (function makeInvokeMethod(e, t, n) {
              var r = h;
              return function invoke(i, a) {
                if (r === f) throw new Error("Generator is already running");
                if (r === p) {
                  if ("throw" === i) throw a;
                  return doneResult();
                }
                for (n.method = i, n.arg = a; ; ) {
                  var o = n.delegate;
                  if (o) {
                    var s = maybeInvokeDelegate(o, n);
                    if (s) {
                      if (s === m) continue;
                      return s;
                    }
                  }
                  if ("next" === n.method) n.sent = n._sent = n.arg;
                  else if ("throw" === n.method) {
                    if (r === h) throw ((r = p), n.arg);
                    n.dispatchException(n.arg);
                  } else "return" === n.method && n.abrupt("return", n.arg);
                  r = f;
                  var u = tryCatch(e, t, n);
                  if ("normal" === u.type) {
                    if (((r = n.done ? p : d), u.arg === m)) continue;
                    return { value: u.arg, done: n.done };
                  }
                  "throw" === u.type &&
                    ((r = p), (n.method = "throw"), (n.arg = u.arg));
                }
              };
            })(e, n, o)),
            a
          );
        }
        function tryCatch(e, t, n) {
          try {
            return { type: "normal", arg: e.call(t, n) };
          } catch (r) {
            return { type: "throw", arg: r };
          }
        }
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}
        function defineIteratorMethods(e) {
          ["next", "throw", "return"].forEach(function (t) {
            e[t] = function (e) {
              return this._invoke(t, e);
            };
          });
        }
        function AsyncIterator(e) {
          var t;
          this._invoke = function enqueue(n, r) {
            function callInvokeWithMethodAndArg() {
              return new Promise(function (t, a) {
                !(function invoke(t, n, r, a) {
                  var o = tryCatch(e[t], e, n);
                  if ("throw" !== o.type) {
                    var s = o.arg,
                      u = s.value;
                    return u && "object" === typeof u && i.call(u, "__await")
                      ? Promise.resolve(u.__await).then(
                          function (e) {
                            invoke("next", e, r, a);
                          },
                          function (e) {
                            invoke("throw", e, r, a);
                          }
                        )
                      : Promise.resolve(u).then(
                          function (e) {
                            (s.value = e), r(s);
                          },
                          function (e) {
                            return invoke("throw", e, r, a);
                          }
                        );
                  }
                  a(o.arg);
                })(n, r, t, a);
              });
            }
            return (t = t
              ? t.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg)
              : callInvokeWithMethodAndArg());
          };
        }
        function maybeInvokeDelegate(e, t) {
          var r = e.iterator[t.method];
          if (r === n) {
            if (((t.delegate = null), "throw" === t.method)) {
              if (
                e.iterator.return &&
                ((t.method = "return"),
                (t.arg = n),
                maybeInvokeDelegate(e, t),
                "throw" === t.method)
              )
                return m;
              (t.method = "throw"),
                (t.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                ));
            }
            return m;
          }
          var i = tryCatch(r, e.iterator, t.arg);
          if ("throw" === i.type)
            return (
              (t.method = "throw"), (t.arg = i.arg), (t.delegate = null), m
            );
          var a = i.arg;
          return a
            ? a.done
              ? ((t[e.resultName] = a.value),
                (t.next = e.nextLoc),
                "return" !== t.method && ((t.method = "next"), (t.arg = n)),
                (t.delegate = null),
                m)
              : a
            : ((t.method = "throw"),
              (t.arg = new TypeError("iterator result is not an object")),
              (t.delegate = null),
              m);
        }
        function pushTryEntry(e) {
          var t = { tryLoc: e[0] };
          1 in e && (t.catchLoc = e[1]),
            2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])),
            this.tryEntries.push(t);
        }
        function resetTryEntry(e) {
          var t = e.completion || {};
          (t.type = "normal"), delete t.arg, (e.completion = t);
        }
        function Context(e) {
          (this.tryEntries = [{ tryLoc: "root" }]),
            e.forEach(pushTryEntry, this),
            this.reset(!0);
        }
        function values(e) {
          if (e) {
            var t = e[o];
            if (t) return t.call(e);
            if ("function" === typeof e.next) return e;
            if (!isNaN(e.length)) {
              var r = -1,
                a = function next() {
                  for (; ++r < e.length; )
                    if (i.call(e, r))
                      return (next.value = e[r]), (next.done = !1), next;
                  return (next.value = n), (next.done = !0), next;
                };
              return (a.next = a);
            }
          }
          return { next: doneResult };
        }
        function doneResult() {
          return { value: n, done: !0 };
        }
      })(
        (function () {
          return this || ("object" === typeof self && self);
        })() || Function("return this")()
      );
    },
    8: function (e, t, n) {
      "use strict";
      function _typeof2(e) {
        return (_typeof2 =
          "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
            ? function _typeof2(e) {
                return typeof e;
              }
            : function _typeof2(e) {
                return e &&
                  "function" === typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? "symbol"
                  : typeof e;
              })(e);
      }
      function _typeof(e) {
        return (_typeof =
          "function" === typeof Symbol && "symbol" === _typeof2(Symbol.iterator)
            ? function _typeof(e) {
                return _typeof2(e);
              }
            : function _typeof(e) {
                return e &&
                  "function" === typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? "symbol"
                  : _typeof2(e);
              })(e);
      }
      var r = n(13);
      function _possibleConstructorReturn(e, t) {
        return !t || ("object" !== _typeof(t) && "function" !== typeof t)
          ? Object(r.a)(e)
          : t;
      }
      n.d(t, "a", function () {
        return _possibleConstructorReturn;
      });
    },
    9: function (e, t, n) {
      "use strict";
      n.d(t, "a", function () {
        return _inherits;
      });
      var r = n(20);
      function _inherits(e, t) {
        if ("function" !== typeof t && null !== t)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (e.prototype = Object.create(t && t.prototype, {
          constructor: { value: e, writable: !0, configurable: !0 },
        })),
          t && Object(r.a)(e, t);
      }
    },
  });
});
//# sourceMappingURL=three.js.map
!(function webpackUniversalModuleDefinition(e, t) {
  "object" === typeof exports && "object" === typeof module
    ? (module.exports = t())
    : "function" === typeof define && define.amd
    ? define([], t)
    : "object" === typeof exports
    ? (exports.buffer = t())
    : (e.buffer = t());
})(window, function () {
  return (function (e) {
    var t = {};
    function __webpack_require__(r) {
      if (t[r]) return t[r].exports;
      var n = (t[r] = { i: r, l: !1, exports: {} });
      return (
        e[r].call(n.exports, n, n.exports, __webpack_require__),
        (n.l = !0),
        n.exports
      );
    }
    return (
      (__webpack_require__.m = e),
      (__webpack_require__.c = t),
      (__webpack_require__.d = function (e, t, r) {
        __webpack_require__.o(e, t) ||
          Object.defineProperty(e, t, { enumerable: !0, get: r });
      }),
      (__webpack_require__.r = function (e) {
        "undefined" !== typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(e, "__esModule", { value: !0 });
      }),
      (__webpack_require__.t = function (e, t) {
        if ((1 & t && (e = __webpack_require__(e)), 8 & t)) return e;
        if (4 & t && "object" === typeof e && e && e.__esModule) return e;
        var r = Object.create(null);
        if (
          (__webpack_require__.r(r),
          Object.defineProperty(r, "default", { enumerable: !0, value: e }),
          2 & t && "string" != typeof e)
        )
          for (var n in e)
            __webpack_require__.d(
              r,
              n,
              function (t) {
                return e[t];
              }.bind(null, n)
            );
        return r;
      }),
      (__webpack_require__.n = function (e) {
        var t =
          e && e.__esModule
            ? function getDefault() {
                return e.default;
              }
            : function getModuleExports() {
                return e;
              };
        return __webpack_require__.d(t, "a", t), t;
      }),
      (__webpack_require__.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }),
      (__webpack_require__.p = "./"),
      __webpack_require__((__webpack_require__.s = 79))
    );
  })({
    79: function (e, t, r) {
      "use strict";
      var n = r(80),
        f = r(81),
        i =
          "function" === typeof Symbol && "function" === typeof Symbol.for
            ? Symbol.for("nodejs.util.inspect.custom")
            : null;
      (t.Buffer = Buffer),
        (t.SlowBuffer = function SlowBuffer(e) {
          +e != e && (e = 0);
          return Buffer.alloc(+e);
        }),
        (t.INSPECT_MAX_BYTES = 50);
      var o = 2147483647;
      function createBuffer(e) {
        if (e > o)
          throw new RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
        var t = new Uint8Array(e);
        return Object.setPrototypeOf(t, Buffer.prototype), t;
      }
      function Buffer(e, t, r) {
        if ("number" === typeof e) {
          if ("string" === typeof t)
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return allocUnsafe(e);
        }
        return from(e, t, r);
      }
      function from(e, t, r) {
        if ("string" === typeof e)
          return (function fromString(e, t) {
            ("string" === typeof t && "" !== t) || (t = "utf8");
            if (!Buffer.isEncoding(t))
              throw new TypeError("Unknown encoding: " + t);
            var r = 0 | byteLength(e, t),
              n = createBuffer(r),
              f = n.write(e, t);
            f !== r && (n = n.slice(0, f));
            return n;
          })(e, t);
        if (ArrayBuffer.isView(e)) return fromArrayLike(e);
        if (null == e)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof e
          );
        if (
          isInstance(e, ArrayBuffer) ||
          (e && isInstance(e.buffer, ArrayBuffer))
        )
          return fromArrayBuffer(e, t, r);
        if (
          "undefined" !== typeof SharedArrayBuffer &&
          (isInstance(e, SharedArrayBuffer) ||
            (e && isInstance(e.buffer, SharedArrayBuffer)))
        )
          return fromArrayBuffer(e, t, r);
        if ("number" === typeof e)
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        var n = e.valueOf && e.valueOf();
        if (null != n && n !== e) return Buffer.from(n, t, r);
        var f = (function fromObject(e) {
          if (Buffer.isBuffer(e)) {
            var t = 0 | checked(e.length),
              r = createBuffer(t);
            return 0 === r.length ? r : (e.copy(r, 0, 0, t), r);
          }
          if (void 0 !== e.length)
            return "number" !== typeof e.length || numberIsNaN(e.length)
              ? createBuffer(0)
              : fromArrayLike(e);
          if ("Buffer" === e.type && Array.isArray(e.data))
            return fromArrayLike(e.data);
        })(e);
        if (f) return f;
        if (
          "undefined" !== typeof Symbol &&
          null != Symbol.toPrimitive &&
          "function" === typeof e[Symbol.toPrimitive]
        )
          return Buffer.from(e[Symbol.toPrimitive]("string"), t, r);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof e
        );
      }
      function assertSize(e) {
        if ("number" !== typeof e)
          throw new TypeError('"size" argument must be of type number');
        if (e < 0)
          throw new RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
      }
      function allocUnsafe(e) {
        return assertSize(e), createBuffer(e < 0 ? 0 : 0 | checked(e));
      }
      function fromArrayLike(e) {
        for (
          var t = e.length < 0 ? 0 : 0 | checked(e.length),
            r = createBuffer(t),
            n = 0;
          n < t;
          n += 1
        )
          r[n] = 255 & e[n];
        return r;
      }
      function fromArrayBuffer(e, t, r) {
        if (t < 0 || e.byteLength < t)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t + (r || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        var n;
        return (
          (n =
            void 0 === t && void 0 === r
              ? new Uint8Array(e)
              : void 0 === r
              ? new Uint8Array(e, t)
              : new Uint8Array(e, t, r)),
          Object.setPrototypeOf(n, Buffer.prototype),
          n
        );
      }
      function checked(e) {
        if (e >= o)
          throw new RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x" +
              o.toString(16) +
              " bytes"
          );
        return 0 | e;
      }
      function byteLength(e, t) {
        if (Buffer.isBuffer(e)) return e.length;
        if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer))
          return e.byteLength;
        if ("string" !== typeof e)
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof e
          );
        var r = e.length,
          n = arguments.length > 2 && !0 === arguments[2];
        if (!n && 0 === r) return 0;
        for (var f = !1; ; )
          switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;
            case "hex":
              return r >>> 1;
            case "base64":
              return base64ToBytes(e).length;
            default:
              if (f) return n ? -1 : utf8ToBytes(e).length;
              (t = ("" + t).toLowerCase()), (f = !0);
          }
      }
      function swap(e, t, r) {
        var n = e[t];
        (e[t] = e[r]), (e[r] = n);
      }
      function bidirectionalIndexOf(e, t, r, n, f) {
        if (0 === e.length) return -1;
        if (
          ("string" === typeof r
            ? ((n = r), (r = 0))
            : r > 2147483647
            ? (r = 2147483647)
            : r < -2147483648 && (r = -2147483648),
          numberIsNaN((r = +r)) && (r = f ? 0 : e.length - 1),
          r < 0 && (r = e.length + r),
          r >= e.length)
        ) {
          if (f) return -1;
          r = e.length - 1;
        } else if (r < 0) {
          if (!f) return -1;
          r = 0;
        }
        if (
          ("string" === typeof t && (t = Buffer.from(t, n)), Buffer.isBuffer(t))
        )
          return 0 === t.length ? -1 : arrayIndexOf(e, t, r, n, f);
        if ("number" === typeof t)
          return (
            (t &= 255),
            "function" === typeof Uint8Array.prototype.indexOf
              ? f
                ? Uint8Array.prototype.indexOf.call(e, t, r)
                : Uint8Array.prototype.lastIndexOf.call(e, t, r)
              : arrayIndexOf(e, [t], r, n, f)
          );
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(e, t, r, n, f) {
        var i,
          o = 1,
          u = e.length,
          a = t.length;
        if (
          void 0 !== n &&
          ("ucs2" === (n = String(n).toLowerCase()) ||
            "ucs-2" === n ||
            "utf16le" === n ||
            "utf-16le" === n)
        ) {
          if (e.length < 2 || t.length < 2) return -1;
          (o = 2), (u /= 2), (a /= 2), (r /= 2);
        }
        function read(e, t) {
          return 1 === o ? e[t] : e.readUInt16BE(t * o);
        }
        if (f) {
          var s = -1;
          for (i = r; i < u; i++)
            if (read(e, i) === read(t, -1 === s ? 0 : i - s)) {
              if ((-1 === s && (s = i), i - s + 1 === a)) return s * o;
            } else -1 !== s && (i -= i - s), (s = -1);
        } else
          for (r + a > u && (r = u - a), i = r; i >= 0; i--) {
            for (var h = !0, c = 0; c < a; c++)
              if (read(e, i + c) !== read(t, c)) {
                h = !1;
                break;
              }
            if (h) return i;
          }
        return -1;
      }
      function hexWrite(e, t, r, n) {
        r = Number(r) || 0;
        var f = e.length - r;
        n ? (n = Number(n)) > f && (n = f) : (n = f);
        var i = t.length;
        n > i / 2 && (n = i / 2);
        for (var o = 0; o < n; ++o) {
          var u = parseInt(t.substr(2 * o, 2), 16);
          if (numberIsNaN(u)) return o;
          e[r + o] = u;
        }
        return o;
      }
      function utf8Write(e, t, r, n) {
        return blitBuffer(utf8ToBytes(t, e.length - r), e, r, n);
      }
      function asciiWrite(e, t, r, n) {
        return blitBuffer(
          (function asciiToBytes(e) {
            for (var t = [], r = 0; r < e.length; ++r)
              t.push(255 & e.charCodeAt(r));
            return t;
          })(t),
          e,
          r,
          n
        );
      }
      function latin1Write(e, t, r, n) {
        return asciiWrite(e, t, r, n);
      }
      function base64Write(e, t, r, n) {
        return blitBuffer(base64ToBytes(t), e, r, n);
      }
      function ucs2Write(e, t, r, n) {
        return blitBuffer(
          (function utf16leToBytes(e, t) {
            for (
              var r, n, f, i = [], o = 0;
              o < e.length && !((t -= 2) < 0);
              ++o
            )
              (r = e.charCodeAt(o)),
                (n = r >> 8),
                (f = r % 256),
                i.push(f),
                i.push(n);
            return i;
          })(t, e.length - r),
          e,
          r,
          n
        );
      }
      function base64Slice(e, t, r) {
        return 0 === t && r === e.length
          ? n.fromByteArray(e)
          : n.fromByteArray(e.slice(t, r));
      }
      function utf8Slice(e, t, r) {
        r = Math.min(e.length, r);
        for (var n = [], f = t; f < r; ) {
          var i,
            o,
            a,
            s,
            h = e[f],
            c = null,
            l = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
          if (f + l <= r)
            switch (l) {
              case 1:
                h < 128 && (c = h);
                break;
              case 2:
                128 === (192 & (i = e[f + 1])) &&
                  (s = ((31 & h) << 6) | (63 & i)) > 127 &&
                  (c = s);
                break;
              case 3:
                (i = e[f + 1]),
                  (o = e[f + 2]),
                  128 === (192 & i) &&
                    128 === (192 & o) &&
                    (s = ((15 & h) << 12) | ((63 & i) << 6) | (63 & o)) >
                      2047 &&
                    (s < 55296 || s > 57343) &&
                    (c = s);
                break;
              case 4:
                (i = e[f + 1]),
                  (o = e[f + 2]),
                  (a = e[f + 3]),
                  128 === (192 & i) &&
                    128 === (192 & o) &&
                    128 === (192 & a) &&
                    (s =
                      ((15 & h) << 18) |
                      ((63 & i) << 12) |
                      ((63 & o) << 6) |
                      (63 & a)) > 65535 &&
                    s < 1114112 &&
                    (c = s);
            }
          null === c
            ? ((c = 65533), (l = 1))
            : c > 65535 &&
              ((c -= 65536),
              n.push(((c >>> 10) & 1023) | 55296),
              (c = 56320 | (1023 & c))),
            n.push(c),
            (f += l);
        }
        return (function decodeCodePointsArray(e) {
          var t = e.length;
          if (t <= u) return String.fromCharCode.apply(String, e);
          var r = "",
            n = 0;
          for (; n < t; )
            r += String.fromCharCode.apply(String, e.slice(n, (n += u)));
          return r;
        })(n);
      }
      (t.kMaxLength = o),
        (Buffer.TYPED_ARRAY_SUPPORT = (function typedArraySupport() {
          try {
            var e = new Uint8Array(1),
              t = {
                foo: function foo() {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(t, Uint8Array.prototype),
              Object.setPrototypeOf(e, t),
              42 === e.foo()
            );
          } catch (r) {
            return !1;
          }
        })()),
        Buffer.TYPED_ARRAY_SUPPORT ||
          "undefined" === typeof console ||
          "function" !== typeof console.error ||
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          ),
        Object.defineProperty(Buffer.prototype, "parent", {
          enumerable: !0,
          get: function get() {
            if (Buffer.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(Buffer.prototype, "offset", {
          enumerable: !0,
          get: function get() {
            if (Buffer.isBuffer(this)) return this.byteOffset;
          },
        }),
        "undefined" !== typeof Symbol &&
          null != Symbol.species &&
          Buffer[Symbol.species] === Buffer &&
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1,
          }),
        (Buffer.poolSize = 8192),
        (Buffer.from = function (e, t, r) {
          return from(e, t, r);
        }),
        Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(Buffer, Uint8Array),
        (Buffer.alloc = function (e, t, r) {
          return (function alloc(e, t, r) {
            return (
              assertSize(e),
              e <= 0
                ? createBuffer(e)
                : void 0 !== t
                ? "string" === typeof r
                  ? createBuffer(e).fill(t, r)
                  : createBuffer(e).fill(t)
                : createBuffer(e)
            );
          })(e, t, r);
        }),
        (Buffer.allocUnsafe = function (e) {
          return allocUnsafe(e);
        }),
        (Buffer.allocUnsafeSlow = function (e) {
          return allocUnsafe(e);
        }),
        (Buffer.isBuffer = function isBuffer(e) {
          return null != e && !0 === e._isBuffer && e !== Buffer.prototype;
        }),
        (Buffer.compare = function compare(e, t) {
          if (
            (isInstance(e, Uint8Array) &&
              (e = Buffer.from(e, e.offset, e.byteLength)),
            isInstance(t, Uint8Array) &&
              (t = Buffer.from(t, t.offset, t.byteLength)),
            !Buffer.isBuffer(e) || !Buffer.isBuffer(t))
          )
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (e === t) return 0;
          for (
            var r = e.length, n = t.length, f = 0, i = Math.min(r, n);
            f < i;
            ++f
          )
            if (e[f] !== t[f]) {
              (r = e[f]), (n = t[f]);
              break;
            }
          return r < n ? -1 : n < r ? 1 : 0;
        }),
        (Buffer.isEncoding = function isEncoding(e) {
          switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (Buffer.concat = function concat(e, t) {
          if (!Array.isArray(e))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return Buffer.alloc(0);
          var r;
          if (void 0 === t)
            for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
          var n = Buffer.allocUnsafe(t),
            f = 0;
          for (r = 0; r < e.length; ++r) {
            var i = e[r];
            if (
              (isInstance(i, Uint8Array) && (i = Buffer.from(i)),
              !Buffer.isBuffer(i))
            )
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            i.copy(n, f), (f += i.length);
          }
          return n;
        }),
        (Buffer.byteLength = byteLength),
        (Buffer.prototype._isBuffer = !0),
        (Buffer.prototype.swap16 = function swap16() {
          var e = this.length;
          if (e % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var t = 0; t < e; t += 2) swap(this, t, t + 1);
          return this;
        }),
        (Buffer.prototype.swap32 = function swap32() {
          var e = this.length;
          if (e % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var t = 0; t < e; t += 4)
            swap(this, t, t + 3), swap(this, t + 1, t + 2);
          return this;
        }),
        (Buffer.prototype.swap64 = function swap64() {
          var e = this.length;
          if (e % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var t = 0; t < e; t += 8)
            swap(this, t, t + 7),
              swap(this, t + 1, t + 6),
              swap(this, t + 2, t + 5),
              swap(this, t + 3, t + 4);
          return this;
        }),
        (Buffer.prototype.toString = function toString() {
          var e = this.length;
          return 0 === e
            ? ""
            : 0 === arguments.length
            ? utf8Slice(this, 0, e)
            : function slowToString(e, t, r) {
                var n = !1;
                if (((void 0 === t || t < 0) && (t = 0), t > this.length))
                  return "";
                if (
                  ((void 0 === r || r > this.length) && (r = this.length),
                  r <= 0)
                )
                  return "";
                if ((r >>>= 0) <= (t >>>= 0)) return "";
                for (e || (e = "utf8"); ; )
                  switch (e) {
                    case "hex":
                      return hexSlice(this, t, r);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, t, r);
                    case "ascii":
                      return asciiSlice(this, t, r);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, t, r);
                    case "base64":
                      return base64Slice(this, t, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, t, r);
                    default:
                      if (n) throw new TypeError("Unknown encoding: " + e);
                      (e = (e + "").toLowerCase()), (n = !0);
                  }
              }.apply(this, arguments);
        }),
        (Buffer.prototype.toLocaleString = Buffer.prototype.toString),
        (Buffer.prototype.equals = function equals(e) {
          if (!Buffer.isBuffer(e))
            throw new TypeError("Argument must be a Buffer");
          return this === e || 0 === Buffer.compare(this, e);
        }),
        (Buffer.prototype.inspect = function inspect() {
          var e = "",
            r = t.INSPECT_MAX_BYTES;
          return (
            (e = this.toString("hex", 0, r)
              .replace(/(.{2})/g, "$1 ")
              .trim()),
            this.length > r && (e += " ... "),
            "<Buffer " + e + ">"
          );
        }),
        i && (Buffer.prototype[i] = Buffer.prototype.inspect),
        (Buffer.prototype.compare = function compare(e, t, r, n, f) {
          if (
            (isInstance(e, Uint8Array) &&
              (e = Buffer.from(e, e.offset, e.byteLength)),
            !Buffer.isBuffer(e))
          )
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof e
            );
          if (
            (void 0 === t && (t = 0),
            void 0 === r && (r = e ? e.length : 0),
            void 0 === n && (n = 0),
            void 0 === f && (f = this.length),
            t < 0 || r > e.length || n < 0 || f > this.length)
          )
            throw new RangeError("out of range index");
          if (n >= f && t >= r) return 0;
          if (n >= f) return -1;
          if (t >= r) return 1;
          if (this === e) return 0;
          for (
            var i = (f >>>= 0) - (n >>>= 0),
              o = (r >>>= 0) - (t >>>= 0),
              u = Math.min(i, o),
              a = this.slice(n, f),
              s = e.slice(t, r),
              h = 0;
            h < u;
            ++h
          )
            if (a[h] !== s[h]) {
              (i = a[h]), (o = s[h]);
              break;
            }
          return i < o ? -1 : o < i ? 1 : 0;
        }),
        (Buffer.prototype.includes = function includes(e, t, r) {
          return -1 !== this.indexOf(e, t, r);
        }),
        (Buffer.prototype.indexOf = function indexOf(e, t, r) {
          return bidirectionalIndexOf(this, e, t, r, !0);
        }),
        (Buffer.prototype.lastIndexOf = function lastIndexOf(e, t, r) {
          return bidirectionalIndexOf(this, e, t, r, !1);
        }),
        (Buffer.prototype.write = function write(e, t, r, n) {
          if (void 0 === t) (n = "utf8"), (r = this.length), (t = 0);
          else if (void 0 === r && "string" === typeof t)
            (n = t), (r = this.length), (t = 0);
          else {
            if (!isFinite(t))
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            (t >>>= 0),
              isFinite(r)
                ? ((r >>>= 0), void 0 === n && (n = "utf8"))
                : ((n = r), (r = void 0));
          }
          var f = this.length - t;
          if (
            ((void 0 === r || r > f) && (r = f),
            (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
          )
            throw new RangeError("Attempt to write outside buffer bounds");
          n || (n = "utf8");
          for (var i = !1; ; )
            switch (n) {
              case "hex":
                return hexWrite(this, e, t, r);
              case "utf8":
              case "utf-8":
                return utf8Write(this, e, t, r);
              case "ascii":
                return asciiWrite(this, e, t, r);
              case "latin1":
              case "binary":
                return latin1Write(this, e, t, r);
              case "base64":
                return base64Write(this, e, t, r);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, e, t, r);
              default:
                if (i) throw new TypeError("Unknown encoding: " + n);
                (n = ("" + n).toLowerCase()), (i = !0);
            }
        }),
        (Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        });
      var u = 4096;
      function asciiSlice(e, t, r) {
        var n = "";
        r = Math.min(e.length, r);
        for (var f = t; f < r; ++f) n += String.fromCharCode(127 & e[f]);
        return n;
      }
      function latin1Slice(e, t, r) {
        var n = "";
        r = Math.min(e.length, r);
        for (var f = t; f < r; ++f) n += String.fromCharCode(e[f]);
        return n;
      }
      function hexSlice(e, t, r) {
        var n = e.length;
        (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
        for (var f = "", i = t; i < r; ++i) f += s[e[i]];
        return f;
      }
      function utf16leSlice(e, t, r) {
        for (var n = e.slice(t, r), f = "", i = 0; i < n.length; i += 2)
          f += String.fromCharCode(n[i] + 256 * n[i + 1]);
        return f;
      }
      function checkOffset(e, t, r) {
        if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
        if (e + t > r)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function checkInt(e, t, r, n, f, i) {
        if (!Buffer.isBuffer(e))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t > f || t < i)
          throw new RangeError('"value" argument is out of bounds');
        if (r + n > e.length) throw new RangeError("Index out of range");
      }
      function checkIEEE754(e, t, r, n, f, i) {
        if (r + n > e.length) throw new RangeError("Index out of range");
        if (r < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(e, t, r, n, i) {
        return (
          (t = +t),
          (r >>>= 0),
          i || checkIEEE754(e, 0, r, 4),
          f.write(e, t, r, n, 23, 4),
          r + 4
        );
      }
      function writeDouble(e, t, r, n, i) {
        return (
          (t = +t),
          (r >>>= 0),
          i || checkIEEE754(e, 0, r, 8),
          f.write(e, t, r, n, 52, 8),
          r + 8
        );
      }
      (Buffer.prototype.slice = function slice(e, t) {
        var r = this.length;
        (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
          (t = void 0 === t ? r : ~~t) < 0
            ? (t += r) < 0 && (t = 0)
            : t > r && (t = r),
          t < e && (t = e);
        var n = this.subarray(e, t);
        return Object.setPrototypeOf(n, Buffer.prototype), n;
      }),
        (Buffer.prototype.readUIntLE = function readUIntLE(e, t, r) {
          (e >>>= 0), (t >>>= 0), r || checkOffset(e, t, this.length);
          for (var n = this[e], f = 1, i = 0; ++i < t && (f *= 256); )
            n += this[e + i] * f;
          return n;
        }),
        (Buffer.prototype.readUIntBE = function readUIntBE(e, t, r) {
          (e >>>= 0), (t >>>= 0), r || checkOffset(e, t, this.length);
          for (var n = this[e + --t], f = 1; t > 0 && (f *= 256); )
            n += this[e + --t] * f;
          return n;
        }),
        (Buffer.prototype.readUInt8 = function readUInt8(e, t) {
          return (e >>>= 0), t || checkOffset(e, 1, this.length), this[e];
        }),
        (Buffer.prototype.readUInt16LE = function readUInt16LE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 2, this.length),
            this[e] | (this[e + 1] << 8)
          );
        }),
        (Buffer.prototype.readUInt16BE = function readUInt16BE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 2, this.length),
            (this[e] << 8) | this[e + 1]
          );
        }),
        (Buffer.prototype.readUInt32LE = function readUInt32LE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 4, this.length),
            (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
              16777216 * this[e + 3]
          );
        }),
        (Buffer.prototype.readUInt32BE = function readUInt32BE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 4, this.length),
            16777216 * this[e] +
              ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
          );
        }),
        (Buffer.prototype.readIntLE = function readIntLE(e, t, r) {
          (e >>>= 0), (t >>>= 0), r || checkOffset(e, t, this.length);
          for (var n = this[e], f = 1, i = 0; ++i < t && (f *= 256); )
            n += this[e + i] * f;
          return n >= (f *= 128) && (n -= Math.pow(2, 8 * t)), n;
        }),
        (Buffer.prototype.readIntBE = function readIntBE(e, t, r) {
          (e >>>= 0), (t >>>= 0), r || checkOffset(e, t, this.length);
          for (var n = t, f = 1, i = this[e + --n]; n > 0 && (f *= 256); )
            i += this[e + --n] * f;
          return i >= (f *= 128) && (i -= Math.pow(2, 8 * t)), i;
        }),
        (Buffer.prototype.readInt8 = function readInt8(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 1, this.length),
            128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
          );
        }),
        (Buffer.prototype.readInt16LE = function readInt16LE(e, t) {
          (e >>>= 0), t || checkOffset(e, 2, this.length);
          var r = this[e] | (this[e + 1] << 8);
          return 32768 & r ? 4294901760 | r : r;
        }),
        (Buffer.prototype.readInt16BE = function readInt16BE(e, t) {
          (e >>>= 0), t || checkOffset(e, 2, this.length);
          var r = this[e + 1] | (this[e] << 8);
          return 32768 & r ? 4294901760 | r : r;
        }),
        (Buffer.prototype.readInt32LE = function readInt32LE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 4, this.length),
            this[e] |
              (this[e + 1] << 8) |
              (this[e + 2] << 16) |
              (this[e + 3] << 24)
          );
        }),
        (Buffer.prototype.readInt32BE = function readInt32BE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 4, this.length),
            (this[e] << 24) |
              (this[e + 1] << 16) |
              (this[e + 2] << 8) |
              this[e + 3]
          );
        }),
        (Buffer.prototype.readFloatLE = function readFloatLE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 4, this.length),
            f.read(this, e, !0, 23, 4)
          );
        }),
        (Buffer.prototype.readFloatBE = function readFloatBE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 4, this.length),
            f.read(this, e, !1, 23, 4)
          );
        }),
        (Buffer.prototype.readDoubleLE = function readDoubleLE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 8, this.length),
            f.read(this, e, !0, 52, 8)
          );
        }),
        (Buffer.prototype.readDoubleBE = function readDoubleBE(e, t) {
          return (
            (e >>>= 0),
            t || checkOffset(e, 8, this.length),
            f.read(this, e, !1, 52, 8)
          );
        }),
        (Buffer.prototype.writeUIntLE = function writeUIntLE(e, t, r, n) {
          ((e = +e), (t >>>= 0), (r >>>= 0), n) ||
            checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
          var f = 1,
            i = 0;
          for (this[t] = 255 & e; ++i < r && (f *= 256); )
            this[t + i] = (e / f) & 255;
          return t + r;
        }),
        (Buffer.prototype.writeUIntBE = function writeUIntBE(e, t, r, n) {
          ((e = +e), (t >>>= 0), (r >>>= 0), n) ||
            checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
          var f = r - 1,
            i = 1;
          for (this[t + f] = 255 & e; --f >= 0 && (i *= 256); )
            this[t + f] = (e / i) & 255;
          return t + r;
        }),
        (Buffer.prototype.writeUInt8 = function writeUInt8(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 1, 255, 0),
            (this[t] = 255 & e),
            t + 1
          );
        }),
        (Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 2, 65535, 0),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
        (Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 2, 65535, 0),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
        (Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 4, 4294967295, 0),
            (this[t + 3] = e >>> 24),
            (this[t + 2] = e >>> 16),
            (this[t + 1] = e >>> 8),
            (this[t] = 255 & e),
            t + 4
          );
        }),
        (Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 4, 4294967295, 0),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
        (Buffer.prototype.writeIntLE = function writeIntLE(e, t, r, n) {
          if (((e = +e), (t >>>= 0), !n)) {
            var f = Math.pow(2, 8 * r - 1);
            checkInt(this, e, t, r, f - 1, -f);
          }
          var i = 0,
            o = 1,
            u = 0;
          for (this[t] = 255 & e; ++i < r && (o *= 256); )
            e < 0 && 0 === u && 0 !== this[t + i - 1] && (u = 1),
              (this[t + i] = (((e / o) >> 0) - u) & 255);
          return t + r;
        }),
        (Buffer.prototype.writeIntBE = function writeIntBE(e, t, r, n) {
          if (((e = +e), (t >>>= 0), !n)) {
            var f = Math.pow(2, 8 * r - 1);
            checkInt(this, e, t, r, f - 1, -f);
          }
          var i = r - 1,
            o = 1,
            u = 0;
          for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); )
            e < 0 && 0 === u && 0 !== this[t + i + 1] && (u = 1),
              (this[t + i] = (((e / o) >> 0) - u) & 255);
          return t + r;
        }),
        (Buffer.prototype.writeInt8 = function writeInt8(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 1, 127, -128),
            e < 0 && (e = 255 + e + 1),
            (this[t] = 255 & e),
            t + 1
          );
        }),
        (Buffer.prototype.writeInt16LE = function writeInt16LE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 2, 32767, -32768),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
        (Buffer.prototype.writeInt16BE = function writeInt16BE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 2, 32767, -32768),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
        (Buffer.prototype.writeInt32LE = function writeInt32LE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 4, 2147483647, -2147483648),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            (this[t + 2] = e >>> 16),
            (this[t + 3] = e >>> 24),
            t + 4
          );
        }),
        (Buffer.prototype.writeInt32BE = function writeInt32BE(e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || checkInt(this, e, t, 4, 2147483647, -2147483648),
            e < 0 && (e = 4294967295 + e + 1),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
        (Buffer.prototype.writeFloatLE = function writeFloatLE(e, t, r) {
          return writeFloat(this, e, t, !0, r);
        }),
        (Buffer.prototype.writeFloatBE = function writeFloatBE(e, t, r) {
          return writeFloat(this, e, t, !1, r);
        }),
        (Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, t, r) {
          return writeDouble(this, e, t, !0, r);
        }),
        (Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, t, r) {
          return writeDouble(this, e, t, !1, r);
        }),
        (Buffer.prototype.copy = function copy(e, t, r, n) {
          if (!Buffer.isBuffer(e))
            throw new TypeError("argument should be a Buffer");
          if (
            (r || (r = 0),
            n || 0 === n || (n = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            n > 0 && n < r && (n = r),
            n === r)
          )
            return 0;
          if (0 === e.length || 0 === this.length) return 0;
          if (t < 0) throw new RangeError("targetStart out of bounds");
          if (r < 0 || r >= this.length)
            throw new RangeError("Index out of range");
          if (n < 0) throw new RangeError("sourceEnd out of bounds");
          n > this.length && (n = this.length),
            e.length - t < n - r && (n = e.length - t + r);
          var f = n - r;
          if (
            this === e &&
            "function" === typeof Uint8Array.prototype.copyWithin
          )
            this.copyWithin(t, r, n);
          else if (this === e && r < t && t < n)
            for (var i = f - 1; i >= 0; --i) e[i + t] = this[i + r];
          else Uint8Array.prototype.set.call(e, this.subarray(r, n), t);
          return f;
        }),
        (Buffer.prototype.fill = function fill(e, t, r, n) {
          if ("string" === typeof e) {
            if (
              ("string" === typeof t
                ? ((n = t), (t = 0), (r = this.length))
                : "string" === typeof r && ((n = r), (r = this.length)),
              void 0 !== n && "string" !== typeof n)
            )
              throw new TypeError("encoding must be a string");
            if ("string" === typeof n && !Buffer.isEncoding(n))
              throw new TypeError("Unknown encoding: " + n);
            if (1 === e.length) {
              var f = e.charCodeAt(0);
              (("utf8" === n && f < 128) || "latin1" === n) && (e = f);
            }
          } else
            "number" === typeof e
              ? (e &= 255)
              : "boolean" === typeof e && (e = Number(e));
          if (t < 0 || this.length < t || this.length < r)
            throw new RangeError("Out of range index");
          if (r <= t) return this;
          var i;
          if (
            ((t >>>= 0),
            (r = void 0 === r ? this.length : r >>> 0),
            e || (e = 0),
            "number" === typeof e)
          )
            for (i = t; i < r; ++i) this[i] = e;
          else {
            var o = Buffer.isBuffer(e) ? e : Buffer.from(e, n),
              u = o.length;
            if (0 === u)
              throw new TypeError(
                'The value "' + e + '" is invalid for argument "value"'
              );
            for (i = 0; i < r - t; ++i) this[i + t] = o[i % u];
          }
          return this;
        });
      var a = /[^+/0-9A-Za-z-_]/g;
      function utf8ToBytes(e, t) {
        var r;
        t = t || 1 / 0;
        for (var n = e.length, f = null, i = [], o = 0; o < n; ++o) {
          if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
            if (!f) {
              if (r > 56319) {
                (t -= 3) > -1 && i.push(239, 191, 189);
                continue;
              }
              if (o + 1 === n) {
                (t -= 3) > -1 && i.push(239, 191, 189);
                continue;
              }
              f = r;
              continue;
            }
            if (r < 56320) {
              (t -= 3) > -1 && i.push(239, 191, 189), (f = r);
              continue;
            }
            r = 65536 + (((f - 55296) << 10) | (r - 56320));
          } else f && (t -= 3) > -1 && i.push(239, 191, 189);
          if (((f = null), r < 128)) {
            if ((t -= 1) < 0) break;
            i.push(r);
          } else if (r < 2048) {
            if ((t -= 2) < 0) break;
            i.push((r >> 6) | 192, (63 & r) | 128);
          } else if (r < 65536) {
            if ((t -= 3) < 0) break;
            i.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
          } else {
            if (!(r < 1114112)) throw new Error("Invalid code point");
            if ((t -= 4) < 0) break;
            i.push(
              (r >> 18) | 240,
              ((r >> 12) & 63) | 128,
              ((r >> 6) & 63) | 128,
              (63 & r) | 128
            );
          }
        }
        return i;
      }
      function base64ToBytes(e) {
        return n.toByteArray(
          (function base64clean(e) {
            if ((e = (e = e.split("=")[0]).trim().replace(a, "")).length < 2)
              return "";
            for (; e.length % 4 !== 0; ) e += "=";
            return e;
          })(e)
        );
      }
      function blitBuffer(e, t, r, n) {
        for (var f = 0; f < n && !(f + r >= t.length || f >= e.length); ++f)
          t[f + r] = e[f];
        return f;
      }
      function isInstance(e, t) {
        return (
          e instanceof t ||
          (null != e &&
            null != e.constructor &&
            null != e.constructor.name &&
            e.constructor.name === t.name)
        );
      }
      function numberIsNaN(e) {
        return e !== e;
      }
      var s = (function () {
        for (var e = new Array(256), t = 0; t < 16; ++t)
          for (var r = 16 * t, n = 0; n < 16; ++n)
            e[r + n] = "0123456789abcdef"[t] + "0123456789abcdef"[n];
        return e;
      })();
    },
    80: function (e, t, r) {
      "use strict";
      (t.byteLength = function byteLength(e) {
        var t = getLens(e),
          r = t[0],
          n = t[1];
        return (3 * (r + n)) / 4 - n;
      }),
        (t.toByteArray = function toByteArray(e) {
          var t,
            r,
            n = getLens(e),
            o = n[0],
            u = n[1],
            a = new i(
              (function _byteLength(e, t, r) {
                return (3 * (t + r)) / 4 - r;
              })(0, o, u)
            ),
            s = 0,
            h = u > 0 ? o - 4 : o;
          for (r = 0; r < h; r += 4)
            (t =
              (f[e.charCodeAt(r)] << 18) |
              (f[e.charCodeAt(r + 1)] << 12) |
              (f[e.charCodeAt(r + 2)] << 6) |
              f[e.charCodeAt(r + 3)]),
              (a[s++] = (t >> 16) & 255),
              (a[s++] = (t >> 8) & 255),
              (a[s++] = 255 & t);
          2 === u &&
            ((t = (f[e.charCodeAt(r)] << 2) | (f[e.charCodeAt(r + 1)] >> 4)),
            (a[s++] = 255 & t));
          1 === u &&
            ((t =
              (f[e.charCodeAt(r)] << 10) |
              (f[e.charCodeAt(r + 1)] << 4) |
              (f[e.charCodeAt(r + 2)] >> 2)),
            (a[s++] = (t >> 8) & 255),
            (a[s++] = 255 & t));
          return a;
        }),
        (t.fromByteArray = function fromByteArray(e) {
          for (
            var t, r = e.length, f = r % 3, i = [], o = 0, u = r - f;
            o < u;
            o += 16383
          )
            i.push(encodeChunk(e, o, o + 16383 > u ? u : o + 16383));
          1 === f
            ? ((t = e[r - 1]), i.push(n[t >> 2] + n[(t << 4) & 63] + "=="))
            : 2 === f &&
              ((t = (e[r - 2] << 8) + e[r - 1]),
              i.push(n[t >> 10] + n[(t >> 4) & 63] + n[(t << 2) & 63] + "="));
          return i.join("");
        });
      for (
        var n = [],
          f = [],
          i = "undefined" !== typeof Uint8Array ? Uint8Array : Array,
          o =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          u = 0,
          a = o.length;
        u < a;
        ++u
      )
        (n[u] = o[u]), (f[o.charCodeAt(u)] = u);
      function getLens(e) {
        var t = e.length;
        if (t % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        return -1 === r && (r = t), [r, r === t ? 0 : 4 - (r % 4)];
      }
      function encodeChunk(e, t, r) {
        for (var f, i, o = [], u = t; u < r; u += 3)
          (f =
            ((e[u] << 16) & 16711680) +
            ((e[u + 1] << 8) & 65280) +
            (255 & e[u + 2])),
            o.push(
              n[((i = f) >> 18) & 63] +
                n[(i >> 12) & 63] +
                n[(i >> 6) & 63] +
                n[63 & i]
            );
        return o.join("");
      }
      (f["-".charCodeAt(0)] = 62), (f["_".charCodeAt(0)] = 63);
    },
    81: function (e, t) {
      (t.read = function (e, t, r, n, f) {
        var i,
          o,
          u = 8 * f - n - 1,
          a = (1 << u) - 1,
          s = a >> 1,
          h = -7,
          c = r ? f - 1 : 0,
          l = r ? -1 : 1,
          p = e[t + c];
        for (
          c += l, i = p & ((1 << -h) - 1), p >>= -h, h += u;
          h > 0;
          i = 256 * i + e[t + c], c += l, h -= 8
        );
        for (
          o = i & ((1 << -h) - 1), i >>= -h, h += n;
          h > 0;
          o = 256 * o + e[t + c], c += l, h -= 8
        );
        if (0 === i) i = 1 - s;
        else {
          if (i === a) return o ? NaN : (1 / 0) * (p ? -1 : 1);
          (o += Math.pow(2, n)), (i -= s);
        }
        return (p ? -1 : 1) * o * Math.pow(2, i - n);
      }),
        (t.write = function (e, t, r, n, f, i) {
          var o,
            u,
            a,
            s = 8 * i - f - 1,
            h = (1 << s) - 1,
            c = h >> 1,
            l = 23 === f ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            p = n ? 0 : i - 1,
            y = n ? 1 : -1,
            g = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
          for (
            t = Math.abs(t),
              isNaN(t) || t === 1 / 0
                ? ((u = isNaN(t) ? 1 : 0), (o = h))
                : ((o = Math.floor(Math.log(t) / Math.LN2)),
                  t * (a = Math.pow(2, -o)) < 1 && (o--, (a *= 2)),
                  (t += o + c >= 1 ? l / a : l * Math.pow(2, 1 - c)) * a >= 2 &&
                    (o++, (a /= 2)),
                  o + c >= h
                    ? ((u = 0), (o = h))
                    : o + c >= 1
                    ? ((u = (t * a - 1) * Math.pow(2, f)), (o += c))
                    : ((u = t * Math.pow(2, c - 1) * Math.pow(2, f)), (o = 0)));
            f >= 8;
            e[r + p] = 255 & u, p += y, u /= 256, f -= 8
          );
          for (
            o = (o << f) | u, s += f;
            s > 0;
            e[r + p] = 255 & o, p += y, o /= 256, s -= 8
          );
          e[r + p - y] |= 128 * g;
        });
    },
  });
});
//# sourceMappingURL=buffer.js.map
!(function webpackUniversalModuleDefinition(e, t) {
  "object" === typeof exports && "object" === typeof module
    ? (module.exports = t(require("three")))
    : "function" === typeof define && define.amd
    ? define(["three"], t)
    : "object" === typeof exports
    ? (exports["rogue-engine"] = t(require("three")))
    : (e["rogue-engine"] = t(e.three));
})(window, function (e) {
  return (function (e) {
    var t = {};
    function __webpack_require__(n) {
      if (t[n]) return t[n].exports;
      var i = (t[n] = { i: n, l: !1, exports: {} });
      return (
        e[n].call(i.exports, i, i.exports, __webpack_require__),
        (i.l = !0),
        i.exports
      );
    }
    return (
      (__webpack_require__.m = e),
      (__webpack_require__.c = t),
      (__webpack_require__.d = function (e, t, n) {
        __webpack_require__.o(e, t) ||
          Object.defineProperty(e, t, { enumerable: !0, get: n });
      }),
      (__webpack_require__.r = function (e) {
        "undefined" !== typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(e, "__esModule", { value: !0 });
      }),
      (__webpack_require__.t = function (e, t) {
        if ((1 & t && (e = __webpack_require__(e)), 8 & t)) return e;
        if (4 & t && "object" === typeof e && e && e.__esModule) return e;
        var n = Object.create(null);
        if (
          (__webpack_require__.r(n),
          Object.defineProperty(n, "default", { enumerable: !0, value: e }),
          2 & t && "string" != typeof e)
        )
          for (var i in e)
            __webpack_require__.d(
              n,
              i,
              function (t) {
                return e[t];
              }.bind(null, i)
            );
        return n;
      }),
      (__webpack_require__.n = function (e) {
        var t =
          e && e.__esModule
            ? function getDefault() {
                return e.default;
              }
            : function getModuleExports() {
                return e;
              };
        return __webpack_require__.d(t, "a", t), t;
      }),
      (__webpack_require__.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }),
      (__webpack_require__.p = "./"),
      __webpack_require__((__webpack_require__.s = 150))
    );
  })({
    0: function (t, n) {
      t.exports = e;
    },
    12: function (e, t, n) {
      "use strict";
      n.d(t, "a", function () {
        return __awaiter;
      });
      function __awaiter(e, t, n, i) {
        return new (n || (n = Promise))(function (s, o) {
          function fulfilled(e) {
            try {
              step(i.next(e));
            } catch (t) {
              o(t);
            }
          }
          function rejected(e) {
            try {
              step(i.throw(e));
            } catch (t) {
              o(t);
            }
          }
          function step(e) {
            e.done
              ? s(e.value)
              : new n(function (t) {
                  t(e.value);
                }).then(fulfilled, rejected);
          }
          step((i = i.apply(e, t || [])).next());
        });
      }
    },
    150: function (e, t, n) {
      "use strict";
      n.r(t);
      var i = n(0),
        s = n(12);
      class Lifecycle {}
      class Debug {
        static clear() {
          this.logs.splice(0, this.logs.length),
            this.flushOnClearLogsCallbacks();
        }
        static log(e) {
          let t = new Log(e);
          this.addLog(t), this.flushOnAddLogCallbacks(t), console.log(e);
        }
        static logError(e) {
          let t = new Debug_Error(e);
          this.addLog(t), this.flushOnAddLogCallbacks(t), console.error(e);
        }
        static logWarning(e) {
          let t = new Warning(e);
          this.addLog(t), this.flushOnAddLogCallbacks(t), console.warn(e);
        }
        static addLog(e) {
          this.logs.length >= this.maxLogs && this.logs.shift(),
            this.logs.push(e);
        }
        static onAddLog(e) {
          return (
            this._onAddLogCallbacks.push(e),
            {
              stop: () => {
                this._onAddLogCallbacks.splice(
                  this._onAddLogCallbacks.indexOf(e),
                  1
                );
              },
            }
          );
        }
        static onClearLogs(e) {
          return (
            this._onClearLogsCallbacks.push(e),
            {
              stop: () => {
                this._onClearLogsCallbacks.splice(
                  this._onClearLogsCallbacks.indexOf(e),
                  1
                );
              },
            }
          );
        }
        static flushOnAddLogCallbacks(e) {
          for (let t in this._onAddLogCallbacks) this._onAddLogCallbacks[t](e);
        }
        static flushOnClearLogsCallbacks() {
          for (let e in this._onClearLogsCallbacks)
            this._onClearLogsCallbacks[e]();
        }
      }
      (Debug.maxLogs = 50),
        (Debug.logs = []),
        (Debug._onAddLogCallbacks = []),
        (Debug._onClearLogsCallbacks = []);
      class Log {
        constructor(e) {
          (this.message = e), (this._type = "Log");
        }
        get type() {
          return this._type;
        }
      }
      class Debug_Error extends Log {
        constructor(e) {
          super(e), (this._type = "Error");
        }
      }
      class Warning extends Log {
        constructor(e) {
          super(e), (this._type = "Warning");
        }
      }
      var o = n(17),
        r = n.n(o);
      const a = [],
        u = [],
        c = (e, t, n) => {
          if (0 === n.length) return;
          const i = [];
          for (let s = 0; s < n.length; s++) i.push(n[s]);
          for (let s = 0; s < i.length; s++) i[s](e, t);
        };
      function onObjectAdded(e) {
        return (
          a.push(e),
          {
            stop: () => {
              let t = a.indexOf(e);
              t < 0 || a.splice(t, 1);
            },
          }
        );
      }
      function onObjectRemoved(e) {
        return (
          u.push(e),
          {
            stop: () => {
              let t = u.indexOf(e);
              t < 0 || u.splice(t, 1);
            },
          }
        );
      }
      function objectAdded(e, t) {
        c(e, t, a);
      }
      const h = [],
        d = [],
        l = [],
        p = (e, t, n) => {
          if (0 === n.length) return;
          const i = [];
          for (let s = 0; s < n.length; s++) i.push(n[s]);
          for (let s = 0; s < i.length; s++) i[s](e, t);
        };
      function onComponentAdded(e) {
        return (
          h.push(e),
          {
            stop: () => {
              let t = h.indexOf(e);
              t < 0 || h.splice(t, 1);
            },
          }
        );
      }
      function onComponentLoaded(e) {
        return (
          d.push(e),
          {
            stop: () => {
              let t = d.indexOf(e);
              t < 0 || d.splice(t, 1);
            },
          }
        );
      }
      function onComponentRemoved(e) {
        return (
          l.push(e),
          {
            stop: () => {
              let t = l.indexOf(e);
              t < 0 || l.splice(t, 1);
            },
          }
        );
      }
      function componentRemoved(e, t) {
        p(e, t, l);
      }
      const f = [],
        m = [],
        _ = [],
        g = [],
        b = (e, t) => {
          if (0 === t.length) return;
          const n = [];
          for (let i = 0; i < t.length; i++) n.push(t[i]);
          for (let i = 0; i < n.length; i++) n[i](e);
        };
      function onBeforeUpdate(e) {
        return (
          f.push(e),
          {
            stop: () => {
              let t = f.indexOf(e);
              t < 0 || f.splice(t, 1);
            },
          }
        );
      }
      function onUpdate(e) {
        return (
          m.push(e),
          {
            stop: () => {
              let t = m.indexOf(e);
              t < 0 || m.splice(t, 1);
            },
          }
        );
      }
      function onAfterUpdate(e) {
        return (
          _.push(e),
          {
            stop: () => {
              let t = _.indexOf(e);
              t < 0 || _.splice(t, 1);
            },
          }
        );
      }
      function onNextFrame(e) {
        const t = (n) => {
          e(n);
          let i = g.indexOf(t);
          i < 0 || g.splice(i, 1);
        };
        g.push(t);
      }
      function isDev() {
        return window.ROGUE_ISDEV || !1;
      }
      function getStaticPath(e) {
        if (isDev()) {
          const t = window.ROGUE_INEDITOR
            ? "localhost"
            : App_App.lanIP || "localhost";
          return `${
            window.RE_Protocol || window.location.protocol
          }//${t}:3110/Static/${e}`;
        }
        return "./Static/" + e;
      }
      function disposeTexture(e) {
        if (e instanceof i.Texture) {
          const t = Q.getAssetConfig(e.uuid);
          if (t && t.keepLoaded) return;
          e.dispose && e.dispose();
        }
      }
      function dispose(e) {
        e &&
          e.traverse((e) => {
            var t, n;
            if (
              (e instanceof i.Mesh &&
                (e.geometry.dispose && e.geometry.dispose(),
                (function disposeMaterial(e) {
                  if (e instanceof i.Material) {
                    const t = Q.getAssetConfig(e.uuid);
                    if (t && t.keepLoaded) return;
                    for (let n in e) disposeTexture(e[n]);
                    e.dispose && e.dispose();
                  } else
                    Array.isArray(e) &&
                      e.forEach((e) => {
                        disposeMaterial(e);
                      });
                })(e.material)),
              e instanceof i.SkinnedMesh &&
                e.skeleton &&
                (e.skeleton.dispose && e.skeleton.dispose(),
                (null === (t = e.skeleton.boneTexture) || void 0 === t
                  ? void 0
                  : t.dispose) &&
                  (null === (n = e.skeleton.boneTexture) ||
                    void 0 === n ||
                    n.dispose())),
              e.parent)
            ) {
              const t = e.parent.children.indexOf(e);
              t >= 0 && (e.parent.children[t] = null), (e.parent = null);
            }
          });
      }
      function isEnabled(e) {
        return !!e && !1 !== e.userData.rogueEnabled;
      }
      function isActive(e) {
        return !!e && !!isEnabled(e) && !1 !== e.userData.rogueParentsEnabled;
      }
      function setEnabled(e, t) {
        e &&
          (t && !isEnabled(e)
            ? (function enable(e) {
                if (!e) return;
                (e.userData.rogueEnabled = !0),
                  awakeObjectComponents(e),
                  (function activateChildren(e) {
                    if (!e) return;
                    for (let t of e.children)
                      (t.userData.rogueParentsEnabled = !0),
                        awakeObjectComponents(t),
                        isEnabled(t) && activateChildren(t);
                  })(e);
              })(e)
            : !t &&
              isEnabled(e) &&
              (function disable(e) {
                if (!e) return;
                (e.userData.rogueEnabled = !1),
                  disableObjectComponents(e),
                  e.traverse((t) => {
                    t !== e &&
                      ((t.userData.rogueParentsEnabled = !1),
                      disableObjectComponents(t));
                  });
              })(e));
      }
      function awakeObjectComponents(e) {
        if (!y.isRunning) return;
        if (!e) return;
        G(e).forEach((e) => {
          e.awake(), (e.__STARTED__ = !1);
        });
      }
      function disableObjectComponents(e) {
        if (!y.isRunning) return;
        if (!e) return;
        G(e).forEach((e) => {
          e.onDisabled();
        });
      }
      class SceneController_SceneController extends Lifecycle {
        constructor() {
          super(),
            (this.renderFunc = () => this.defaultRenderFunc()),
            (this._clock = new i.Clock()),
            (this._onPlayCallbacks = []),
            (this._onStopCallbacks = []),
            (this._throttledAdjustCameraAndRenderer = r()(
              () => this.adjustCameraAndRenderer(),
              1e3,
              {}
            )),
            (this._containerId = "rogue-app"),
            (this._isOffscreen = !1),
            (this._stop = () => {}),
            (this._deltaTime = 0),
            (this._pageVisibilityHandler = () => {
              this._clock.running && this._clock.stop(),
                !this._clock.running && this._clock.start();
            }),
            (this.doOnResize = (e) => {
              this.adjustCameraAndRenderer(!0), this.onResize();
            }),
            (this.onResize = () => {}),
            (this.resizeObserver = new window.ResizeObserver(this.doOnResize)),
            document.removeEventListener(
              "visibilitychange",
              this._pageVisibilityHandler
            ),
            document.addEventListener(
              "visibilitychange",
              this._pageVisibilityHandler
            );
        }
        get defaultRenderFunc() {
          return () =>
            this._renderer.render(
              this._scene,
              this._camera || new i.OrthographicCamera(0, 0, 0, 0, 0, 0)
            );
        }
        get deltaTime() {
          return this._deltaTime || 0;
        }
        get height() {
          return this._height;
        }
        get width() {
          return this._width;
        }
        get containerId() {
          return this._containerId;
        }
        get camera() {
          return this._camera;
        }
        set camera(e) {
          this._camera = e;
        }
        get scene() {
          return this._scene;
        }
        get renderer() {
          return this._renderer;
        }
        get isRunning() {
          return this._isRunning;
        }
        get isPaused() {
          return this._isPaused;
        }
        get rogueDOMContainer() {
          return this._rogueDOMContainer;
        }
        get clock() {
          return this._clock;
        }
        onPlay(e) {
          return (
            this._onPlayCallbacks.push(e),
            {
              stop: () => {
                let t = this._onPlayCallbacks.indexOf(e);
                t < 0 || this._onPlayCallbacks.splice(t, 1);
              },
            }
          );
        }
        onStop(e) {
          this._onStopCallbacks.push(e);
          return {
            stop: () => {
              let t = this._onStopCallbacks.indexOf(e);
              t < 0 || this._onStopCallbacks.splice(t, 1);
            },
          };
        }
        loadMaterials() {
          const e = {};
          App_App.currentScene.traverse((t) => {
            if (t.material instanceof i.Material) {
              if (!Q.getAssetPath(t.material.uuid)) return;
              const n = Q.getAsset(t.material.uuid);
              if (n) return void (t.material = n);
              e[t.material.uuid]
                ? e[t.material.uuid].push(t)
                : (e[t.material.uuid] = [t]);
            }
          });
          for (const t in e)
            Q.loadAsset(t).then((n) => {
              for (const i of e[t]) i.material = n || i.material;
            });
        }
        play(e, t, n) {
          this.isPaused
            ? (this._isPaused = !1)
            : ((this.renderFunc = () => this.defaultRenderFunc()),
              (this._scene = e),
              (this._isRunning = !0),
              this.updateEventsHandler(this._onPlayCallbacks),
              this.loadMaterials(),
              this.startRenderer(t),
              this.resizeObserver.observe(this._rogueDOMContainer),
              this._renderer.setAnimationLoop(this.beginUpdateCycle.bind(this)),
              App_App.currentScene.traverse((e) => {
                if (e instanceof i.Mesh && e.material instanceof i.Material)
                  for (let t in e.material)
                    e.material[t] instanceof i.Texture &&
                      this.renderer.initTexture(e.material[t]);
              }),
              D(App_App.currentScene, n),
              this.awake(),
              this.start(),
              this._clock.start());
        }
        stop() {
          this._isRunning &&
            (this._clock.stop(),
            this.updateEventsHandler(this._onStopCallbacks),
            (this._isRunning = !1),
            this._stop(),
            this._renderer.setAnimationLoop(null),
            this.resizeObserver.unobserve(this._rogueDOMContainer));
        }
        updateEventsHandler(e) {
          if (0 === e.length) return;
          const t = [];
          for (let n = 0; n < e.length; n++) t.push(e[n]);
          for (let n = 0; n < t.length; n++) t[n]();
        }
        pause() {
          this.isRunning &&
            !this.isPaused &&
            ((this._isPaused = !0), this._stop());
        }
        resume() {
          this.isRunning && this.isPaused && this.play(this._scene);
        }
        togglePause() {
          this.isRunning && (this.isPaused ? this.resume() : this.pause());
        }
        traverseObject3d(e, t) {
          for (let n in e.children) {
            let i = e.children[n];
            t(i), this.traverseObject3d(i, t);
          }
        }
        awake() {
          this.traverseSceneComponents((e) => {
            try {
              isActive(e.object3d) && e.awake();
            } catch (t) {
              Debug.logError(`${t.name} in ${e.name}: ${t.stack}`);
            }
          });
        }
        start() {
          this.traverseSceneComponents((e) => {
            try {
              e.isReady &&
                isActive(e.object3d) &&
                (e.start(), (e.__STARTED__ = !0));
            } catch (t) {
              Debug.logError(`${t.name} in ${e.name}: ${t.stack}`);
            }
          });
        }
        beforeUpdate() {
          this.traverseSceneComponents((e) => {
            if (this.isRunning && isActive(e.object3d))
              try {
                e.isReady &&
                  !e.__STARTED__ &&
                  (e.start(), (e.__STARTED__ = !0)),
                  e.isReady && e.__STARTED__ && e.beforeUpdate();
              } catch (t) {
                Debug.logError(`${t.name} in ${e.name}: ${t.stack}`);
              }
          }),
            (function runBeforeUpdate(e) {
              b(e, f);
            })(this);
        }
        update() {
          this.traverseSceneComponents((e) => {
            if (isActive(e.object3d))
              try {
                this.isRunning && e.isReady && e.__STARTED__ && e.update();
              } catch (t) {
                Debug.logError(`${t.name} in ${e.name}: ${t.stack}`);
              }
          }),
            (function runUpdate(e) {
              b(e, m);
            })(this);
        }
        afterUpdate() {
          this.traverseSceneComponents((e) => {
            if (isActive(e.object3d))
              try {
                this.isRunning && e.isReady && e.__STARTED__ && e.afterUpdate();
              } catch (t) {
                Debug.logError(`${t.name} in ${e.name}: ${t.stack}`);
              }
          }),
            (function runAfterUpdate(e) {
              b(e, _);
            })(this);
        }
        startRenderer(e) {
          if (
            ((this._rogueDOMContainer = document.getElementById("rogue-app")),
            !document.getElementById("rogue-canvas"))
          ) {
            const e = document.createElement("canvas");
            (e.id = "rogue-canvas"), this._rogueDOMContainer.appendChild(e);
          }
          const t = document.getElementById("rogue-canvas");
          (t.style.display = "block"),
            (this._isOffscreen = !1),
            this._renderer ||
              (this._renderer = new i.WebGLRenderer({
                canvas: t,
                powerPreference: "high-performance",
                antialias: !0,
                alpha: !0,
              })),
            (this._renderer.shadowMap.enabled = !0),
            this.renderer.setPixelRatio(window.devicePixelRatio),
            this.setSceneDimensions(
              this._rogueDOMContainer.clientWidth / window.devicePixelRatio,
              this._rogueDOMContainer.clientHeight / window.devicePixelRatio
            ),
            (this._width = 0),
            (this._height = 0);
        }
        setSceneDimensions(e, t) {
          this._renderer.setSize(e, t), this.setCameraDimensions(e, t);
        }
        setCameraDimensions(e, t) {
          if (this.camera instanceof i.PerspectiveCamera)
            (this.camera.aspect = e / t), this.camera.updateProjectionMatrix();
          else if (this.camera instanceof i.OrthographicCamera) {
            let n = t / e;
            (this.camera.left = -5),
              (this.camera.right = 5),
              (this.camera.top = (10 * n) / 2),
              (this.camera.bottom = (-10 * n) / 2),
              this.camera.updateProjectionMatrix();
          }
        }
        adjustCameraAndRenderer(e) {
          let { width: t, height: n } =
            this._rogueDOMContainer.getBoundingClientRect();
          (t = this._isOffscreen ? t / window.devicePixelRatio : t),
            (n = this._isOffscreen ? n / window.devicePixelRatio : n),
            ((this.camera && (t !== this._width || n !== this._height)) || e) &&
              ((this._width = t),
              (this._height = n),
              this.renderer.setSize(this._width, this._height),
              this.setCameraDimensions(this._width, this._height));
        }
        beginUpdateCycle() {
          this.isRunning &&
            this._rogueDOMContainer &&
            (this._isPaused
              ? (this._deltaTime = this.clock.getDelta())
              : ((this._deltaTime = this.clock.getDelta()),
                (function runNextFrame(e) {
                  b(e, g);
                })(this),
                this.beforeUpdate(),
                this.update(),
                this.isRunning && (this.renderFunc(), this.afterUpdate())));
        }
      }
      let v = new (n(30).EventEmitter)();
      class RuntimeController_RuntimeController extends SceneController_SceneController {
        constructor() {
          super(...arguments),
            (this.onPlayCbsFlaggedForRemoval = []),
            (this.onStopCbsFlaggedForRemoval = []);
        }
        play(e, t, n) {
          this.isPaused || (v.emit("play"), this.createUIContainer()),
            (Q.sceneController = this);
          let i = App_App.currentScene.getObjectByProperty(
            "uuid",
            App_App.activeCamera
          );
          i ||
            (i = App_App.currentScene.getObjectByProperty(
              "type",
              "PerspectiveCamera"
            )),
            i ||
              (i = App_App.currentScene.getObjectByProperty(
                "type",
                "OrthographicCamera"
              )),
            i ||
              Debug.logWarning("Couldn't find an active camera for this scene"),
            i && ((App_App.activeCamera = i.uuid), (this.camera = i)),
            super.play(e, t, n);
        }
        onPlay(e) {
          const t = super.onPlay(e);
          return this.isRunning && this.onPlayCbsFlaggedForRemoval.push(t), t;
        }
        onStop(e) {
          const t = super.onStop(e);

          return this.isRunning && this.onStopCbsFlaggedForRemoval.push(t), t;
        }
        stop() {
          this.traverseSceneComponents((e) => {
            for (let t in e.interface)
              e[t] instanceof i.Audio && e[t].source && e[t].stop();
          }),
            v.emit("stop"),
            this.isRunning && this.removeUIContainer(),
            super.stop();
          const e = document.getElementById("rogue-canvas");
          e && (e.style.display = "none"),
            this.onPlayCbsFlaggedForRemoval.forEach((e) => {
              e.stop();
            }),
            this.onStopCbsFlaggedForRemoval.forEach((e) => {
              e.stop();
            }),
            (this.onPlayCbsFlaggedForRemoval = []),
            (this.onStopCbsFlaggedForRemoval = []);
        }
        createUIContainer() {
          if (!document.getElementById("rogue-ui")) {
            const e = document.getElementById("rogue-app"),
              t = document.createElement("div");
            (t.id = "rogue-ui"),
              (t.style.position = "absolute"),
              (t.style.width = "100%"),
              (t.style.height = "100%"),
              (t.style.overflow = "hidden"),
              e.insertBefore(t, e.firstChild),
              (this.uiContainer = t);
          }
        }
        removeUIContainer() {
          const e = document.getElementById("rogue-ui");
          e && e.remove();
        }
        afterUpdate() {
          super.afterUpdate();
        }
        traverseSceneComponents(e) {
          for (let t in P) {
            const n = P[t];
            for (let t in n) {
              const i = n[t];
              i.enabled && e(i);
            }
          }
        }
        beginUpdateCycle() {
          this.isRunning &&
            this._rogueDOMContainer &&
            ((this.camera && App_App.activeCamera === this.camera.uuid) ||
              ((this.camera = App_App.currentScene.getObjectByProperty(
                "uuid",
                App_App.activeCamera
              )),
              this.adjustCameraAndRenderer(!0)),
            super.beginUpdateCycle());
        }
      }
      const y = new RuntimeController_RuntimeController();
      var A = function Sky() {
          var e = Sky.SkyShader,
            t = new i.ShaderMaterial({
              fragmentShader: e.fragmentShader,
              vertexShader: e.vertexShader,
              uniforms: i.UniformsUtils.clone(e.uniforms),
              side: i.BackSide,
              depthWrite: !1,
            });
          i.Mesh.call(this, new i.BoxBufferGeometry(1, 1, 1), t);
        },
        C = Object.create(i.Mesh.prototype);
      (A.prototype = C),
        (A.prototype.isSky = !0),
        (A.SkyShader = {
          uniforms: {
            luminance: { value: 1 },
            turbidity: { value: 2 },
            rayleigh: { value: 1 },
            mieCoefficient: { value: 0.005 },
            mieDirectionalG: { value: 0.8 },
            sunPosition: { value: new i.Vector3() },
            up: { value: new i.Vector3(0, 1, 0) },
          },
          vertexShader: [
            "uniform vec3 sunPosition;",
            "uniform float rayleigh;",
            "uniform float turbidity;",
            "uniform float mieCoefficient;",
            "uniform vec3 up;",
            "varying vec3 vWorldPosition;",
            "varying vec3 vSunDirection;",
            "varying float vSunfade;",
            "varying vec3 vBetaR;",
            "varying vec3 vBetaM;",
            "varying float vSunE;",
            "const float e = 2.71828182845904523536028747135266249775724709369995957;",
            "const float pi = 3.141592653589793238462643383279502884197169;",
            "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
            "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
            "const float v = 4.0;",
            "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
            "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
            "const float cutoffAngle = 1.6110731556870734;",
            "const float steepness = 1.5;",
            "const float EE = 1000.0;",
            "float sunIntensity( float zenithAngleCos ) {",
            "\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
            "\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
            "}",
            "vec3 totalMie( float T ) {",
            "\tfloat c = ( 0.2 * T ) * 10E-18;",
            "\treturn 0.434 * c * MieConst;",
            "}",
            "void main() {",
            "\tvec4 worldPosition = vec4( position, 1.0 );",
            "\tvWorldPosition = worldPosition.xyz;",
            "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            " gl_Position.z = gl_Position.w;",
            "\tvSunDirection = normalize( sunPosition );",
            "\tvSunE = sunIntensity( dot( vSunDirection, up ) );",
            "\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
            "\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
            "\tvBetaR = totalRayleigh * rayleighCoefficient;",
            "\tvBetaM = totalMie( turbidity ) * mieCoefficient;",
            "}",
          ].join("\n"),
          fragmentShader: [
            "varying vec3 vWorldPosition;",
            "varying vec3 vSunDirection;",
            "varying float vSunfade;",
            "varying vec3 vBetaR;",
            "varying vec3 vBetaM;",
            "varying float vSunE;",
            "uniform float luminance;",
            "uniform float mieDirectionalG;",
            "uniform vec3 up;",
            "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );",
            "const float pi = 3.141592653589793238462643383279502884197169;",
            "const float n = 1.0003;",
            "const float N = 2.545E25;",
            "const float rayleighZenithLength = 8.4E3;",
            "const float mieZenithLength = 1.25E3;",
            "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
            "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
            "const float ONE_OVER_FOURPI = 0.07957747154594767;",
            "float rayleighPhase( float cosTheta ) {",
            "\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
            "}",
            "float hgPhase( float cosTheta, float g ) {",
            "\tfloat g2 = pow( g, 2.0 );",
            "\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
            "\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
            "}",
            "const float A = 0.15;",
            "const float B = 0.50;",
            "const float C = 0.10;",
            "const float D = 0.20;",
            "const float E = 0.02;",
            "const float F = 0.30;",
            "const float whiteScale = 1.0748724675633854;",
            "vec3 Uncharted2Tonemap( vec3 x ) {",
            "\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
            "}",
            "void main() {",
            " vec3 direction = normalize( vWorldPosition - cameraPos );",
            "\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );",
            "\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
            "\tfloat sR = rayleighZenithLength * inverse;",
            "\tfloat sM = mieZenithLength * inverse;",
            "\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
            "\tfloat cosTheta = dot( direction, vSunDirection );",
            "\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
            "\tvec3 betaRTheta = vBetaR * rPhase;",
            "\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );",
            "\tvec3 betaMTheta = vBetaM * mPhase;",
            "\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
            "\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
            "\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]",
            "\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]",
            "\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
            "\tvec3 L0 = vec3( 0.1 ) * Fex;",
            "\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
            "\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
            "\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
            "\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );",
            "\tvec3 color = curr * whiteScale;",
            "\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
            "\tgl_FragColor = vec4( retColor, 1.0 );",
            "}",
          ].join("\n"),
        });
      let E = new (class Skybox_SkyboxClass {
        constructor() {
          (this._enabled = !0),
            (this._mode = "procedural"),
            (this._showSun = !1),
            (this._inclination = 0.464),
            (this._azimuth = 0.25),
            (this._layers = 1),
            (this.sunSpeed = 0);
        }
        get layers() {
          return this._layers;
        }
        set layers(e) {
          (this._layers = e),
            this._sky && (this._sky.layers.mask = e),
            this._cubemapSky && (this._cubemapSky.layers.mask = e);
        }
        get sky() {
          return this._sky;
        }
        get cubemapSky() {
          return this._cubemapSky;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          (this._enabled = e), this.init(this.toJSON());
        }
        get mode() {
          return this._mode;
        }
        set mode(e) {
          (this._mode = e), this.init(this.toJSON());
        }
        get cubemapTop() {
          return this._cubemapTop;
        }
        set cubemapTop(e) {
          (this._cubemapTop = e),
            "cubemap" === this.mode && this.init(this.toJSON());
        }
        get cubemapBottom() {
          return this._cubemapBottom;
        }
        set cubemapBottom(e) {
          (this._cubemapBottom = e),
            "cubemap" === this.mode && this.init(this.toJSON());
        }
        get cubemapFront() {
          return this._cubemapFront;
        }
        set cubemapFront(e) {
          (this._cubemapFront = e),
            "cubemap" === this.mode && this.init(this.toJSON());
        }
        get cubemapBack() {
          return this._cubemapBack;
        }
        set cubemapBack(e) {
          (this._cubemapBack = e),
            "cubemap" === this.mode && this.init(this.toJSON());
        }
        get cubemapRight() {
          return this._cubemapRight;
        }
        set cubemapRight(e) {
          (this._cubemapRight = e),
            "cubemap" === this.mode && this.init(this.toJSON());
        }
        get cubemapLeft() {
          return this._cubemapLeft;
        }
        set cubemapLeft(e) {
          (this._cubemapLeft = e),
            "cubemap" === this.mode && this.init(this.toJSON());
        }
        get mieDirectionalG() {
          return "procedural" === this.mode && this._sky
            ? this._sky.material.uniforms.mieDirectionalG.value
            : 0;
        }
        set mieDirectionalG(e) {
          this._sky &&
            "procedural" === this.mode &&
            (this._sky.material.uniforms.mieDirectionalG.value = e);
        }
        get mieCoefficient() {
          return "procedural" === this.mode && this._sky
            ? this._sky.material.uniforms.mieCoefficient.value
            : 0;
        }
        set mieCoefficient(e) {
          this._sky &&
            "procedural" === this.mode &&
            (this._sky.material.uniforms.mieCoefficient.value = e);
        }
        get turbidity() {
          return "procedural" === this.mode && this._sky
            ? this._sky.material.uniforms.turbidity.value
            : 0;
        }
        set turbidity(e) {
          this._sky &&
            "procedural" === this.mode &&
            (this._sky.material.uniforms.turbidity.value = e);
        }
        get rayleigh() {
          return "procedural" === this.mode && this._sky
            ? this._sky.material.uniforms.rayleigh.value
            : 0;
        }
        set rayleigh(e) {
          this._sky &&
            "procedural" === this.mode &&
            (this._sky.material.uniforms.rayleigh.value = e);
        }
        get luminance() {
          return "procedural" === this.mode && this._sky
            ? this._sky.material.uniforms.luminance.value
            : 0;
        }
        set luminance(e) {
          this._sky &&
            "procedural" === this.mode &&
            (this._sky.material.uniforms.luminance.value = e);
        }
        get inclination() {
          return this._inclination;
        }
        set inclination(e) {
          (this._inclination = e),
            "procedural" === this.mode && this.setSunPosition();
        }
        get azimuth() {
          return this._azimuth;
        }
        set azimuth(e) {
          (this._azimuth = e),
            "procedural" === this.mode && this.setSunPosition();
        }
        get showSun() {
          return this._showSun;
        }
        set showSun(e) {
          (this._showSun = e),
            "procedural" === this.mode &&
              this._sunSphere &&
              (this._sunSphere.visible = e);
        }
        init(e) {
          if (
            (this._onPlay && this._onPlay.stop(),
            this._onStop && this._onStop.stop(),
            this._onUpdate && this._onUpdate.stop(),
            e && (this._enabled = e._enabled),
            this._sky && this._sky.parent && this._sky.parent.remove(this._sky),
            this._cubemapSky &&
              this._cubemapSky.parent &&
              this._cubemapSky.parent.remove(this._cubemapSky),
            !this.enabled || (e && !e._enabled))
          )
            return;
          let t = e && Object.keys(e).length >= 1 ? e._mode : this.mode;
          "procedural" === t && this.initProceduralSkybox(e),
            "cubemap" === t && this.initCubemapSkybox(e);
        }
        initProceduralSkybox(e) {
          (this._sky = new A()),
            (this._sky.name = "ROGUE_INTERNAL_SKYBOX"),
            this._sky.scale.setScalar(100),
            (this._sky.renderOrder = -999),
            (this._sky.userData.isEditorObject = !0),
            (this._sunSphere = new i.Mesh(
              new i.SphereBufferGeometry(3, 20, 8),
              new i.MeshStandardMaterial({
                color: "#000",
                emissive: "#fff",
                depthTest: !1,
                depthWrite: !1,
              })
            )),
            (this._sunSphere.renderOrder = -100),
            (this._sunSphere.position.y = -100),
            (this._sunSphere.visible = this.showSun),
            (this._sunSphere.name = "Sun"),
            this._sky.add(this._sunSphere),
            e && Object.keys(e).length >= 1
              ? this.fromJSON(e)
              : this.fromJSON(this.getDefaultJSON()),
            App_App.currentScene.add(this._sky),
            window.ROGUE_ISDEV &&
              ((this._onPlay = y.onPlay(() => {
                (this._serializedSkybox = this.toJSON()),
                  (this._directionalLight = void 0);
              })),
              (this._onStop = y.onStop(() => {
                this.fromJSON(this._serializedSkybox),
                  (this._directionalLight = void 0);
              }))),
            (this._onUpdate = onBeforeUpdate((e) => {
              this._enabled &&
                (e.renderer.xr.enabled
                  ? e.renderer.xr
                      .getCamera()
                      .getWorldPosition(this._sky.position)
                  : e.camera.getWorldPosition(this._sky.position),
                this._directionalLight || this.setSunPosition(),
                App_App.sceneController instanceof
                  RuntimeController_RuntimeController &&
                  (this.inclination <= -1 && (this.inclination = 1),
                  this.inclination > 1 && (this.inclination = -1),
                  (this.inclination -= this.sunSpeed)));
            }));
        }
        initCubemapSkybox(e) {
          e && Object.keys(e).length >= 1
            ? this.fromJSON(e)
            : this.fromJSON(this.getDefaultJSON());
          let t = new i.MeshLambertMaterial({
              emissive: this.cubemapRight ? "#fff" : "#000",
              color: "#000",
              emissiveMap: this.cubemapRight,
            }),
            n = new i.MeshLambertMaterial({
              emissive: this.cubemapLeft ? "#fff" : "#000",
              color: "#000",
              emissiveMap: this.cubemapLeft,
            }),
            s = new i.MeshLambertMaterial({
              emissive: this.cubemapTop ? "#fff" : "#000",
              color: "#000",
              emissiveMap: this.cubemapTop,
            }),
            o = new i.MeshLambertMaterial({
              emissive: this.cubemapBottom ? "#fff" : "#000",
              color: "#000",
              emissiveMap: this.cubemapBottom,
            }),
            r = new i.MeshLambertMaterial({
              emissive: this.cubemapFront ? "#fff" : "#000",
              color: "#000",
              emissiveMap: this.cubemapFront,
            }),
            a = new i.MeshLambertMaterial({
              emissive: this.cubemapBack ? "#fff" : "#000",
              color: "#000",
              emissiveMap: this.cubemapBack,
            });
          (t.side = i.BackSide),
            (t.depthWrite = !1),
            (t.depthTest = !1),
            (n.side = i.BackSide),
            (n.depthWrite = !1),
            (n.depthTest = !1),
            (s.side = i.BackSide),
            (s.depthWrite = !1),
            (s.depthTest = !1),
            (o.side = i.BackSide),
            (o.depthWrite = !1),
            (o.depthTest = !1),
            (r.side = i.BackSide),
            (r.depthWrite = !1),
            (r.depthTest = !1),
            (a.side = i.BackSide),
            (a.depthWrite = !1),
            (a.depthTest = !1),
            (this._cubemapSky = new i.Mesh(
              new i.BoxBufferGeometry(100, 100, 100),
              [t, n, s, o, r, a]
            )),
            (this._cubemapSky.renderOrder = -999),
            (this._cubemapSky.name = "ROGUE_INTERNAL_SKYBOX"),
            (this._cubemapSky.userData.isEditorObject = !0),
            App_App.currentScene.add(this._cubemapSky),
            window.ROGUE_ISDEV &&
              ((this._onPlay = y.onPlay(() => {
                this._serializedSkybox = this.toJSON();
              })),
              (this._onStop = y.onStop(() => {
                this.fromJSON(this._serializedSkybox);
              }))),
            (this._onUpdate = onBeforeUpdate((e) => {
              this._enabled &&
                (e.renderer.xr.enabled
                  ? e.renderer.xr
                      .getCamera()
                      .getWorldPosition(this._cubemapSky.position)
                  : e.camera.getWorldPosition(this._cubemapSky.position));
            }));
        }
        toJSON() {
          return {
            _enabled: this._enabled,
            _mode: this._mode,
            layers: this._layers,
            _showSun: this._showSun,
            inclination: this._inclination,
            azimuth: this._azimuth,
            mieDirectionalG: this.mieDirectionalG,
            mieCoefficient: this.mieCoefficient,
            turbidity: this.turbidity,
            rayleigh: this.rayleigh,
            luminance: this.luminance,
            _sunSpeed: this.sunSpeed,
            _cubemapTop:
              this.cubemapTop instanceof i.Texture && this.cubemapTop.toJSON(),
            _cubemapBottom:
              this.cubemapBottom instanceof i.Texture &&
              this.cubemapBottom.toJSON(),
            _cubemapFront:
              this.cubemapFront instanceof i.Texture &&
              this.cubemapFront.toJSON(),
            _cubemapBack:
              this.cubemapBack instanceof i.Texture &&
              this.cubemapBack.toJSON(),
            _cubemapRight:
              this.cubemapRight instanceof i.Texture &&
              this.cubemapRight.toJSON(),
            _cubemapLeft:
              this.cubemapLeft instanceof i.Texture &&
              this.cubemapLeft.toJSON(),
          };
        }
        fromJSON(e) {
          void 0 === e._enabled && (e._enabled = !0);
          for (let t in e) {
            let n = e[t];
            if ("object" === typeof n) {
              const e = Q.getAsset(n.uuid);
              e
                ? (this[t] = e)
                : Q.loadAsset(n.uuid).then((e) => {
                    (this[t] = e),
                      "cubemap" === this.mode && this.init(this.toJSON());
                  });
            } else this[t] = e[t];
          }
        }
        initWithDefaultValues() {
          (this._mode = "procedural"),
            (this.inclination = 0.464),
            (this.azimuth = 0.25),
            (this.mieDirectionalG = 0.998),
            (this.mieCoefficient = 0.004),
            (this.turbidity = 10),
            (this.rayleigh = 1.423),
            (this.luminance = 1),
            (this._showSun = !1);
        }
        getDefaultJSON() {
          return {
            _enabled: !0,
            _mode: "procedural",
            layers: 1,
            _showSun: !1,
            inclination: 0.464,
            azimuth: 0.25,
            mieDirectionalG: 0.998,
            mieCoefficient: 0.004,
            turbidity: 10,
            rayleigh: 1.423,
            luminance: 1,
            _sunSpeed: 0,
            _cubemapTop: void 0,
            _cubemapBottom: void 0,
            _cubemapFront: void 0,
            _cubemapBack: void 0,
            _cubemapRight: void 0,
            _cubemapLeft: void 0,
          };
        }
        setSunPosition() {
          var e = Math.PI * (this.inclination - 0.5),
            t = 2 * Math.PI * (this.azimuth - 0.5);
          this._sunSphere &&
            ((this._sunSphere.position.x = 90 * Math.cos(t)),
            (this._sunSphere.position.y = 90 * Math.sin(t) * Math.sin(e)),
            (this._sunSphere.position.z = 90 * Math.sin(t) * Math.cos(e)),
            this._sky.material.uniforms.sunPosition.value.copy(
              this._sunSphere.position
            ),
            this._directionalLight
              ? this._directionalLight.position.set(
                  this._sunSphere.position.x,
                  this._sunSphere.position.y,
                  this._sunSphere.position.z
                )
              : ((this._directionalLight =
                  App_App.currentScene.getObjectByName("SUNLIGHT")),
                this._directionalLight &&
                  this._directionalLight.position.set(
                    this._sunSphere.position.x,
                    this._sunSphere.position.y,
                    this._sunSphere.position.z
                  )));
        }
      })();
      class GamepadController_GamepadController {
        constructor(e) {
          (this._upButtons = {}),
            (this._downButtons = {}),
            (this._pressedButtons = {}),
            (this.deadZone = 0.1),
            (this._gamepad = e),
            this.update();
        }
        get gamepad() {
          return this._gamepad;
        }
        update() {
          onNextFrame(() => {
            this._gamepad.buttons[0].pressed,
              this._gamepad.buttons.forEach((e, t) => {
                e.pressed &&
                  !this._pressedButtons[t] &&
                  ((this._downButtons[t] = !0),
                  (this._pressedButtons[t] = !0),
                  onNextFrame(() => (this._downButtons[t] = !1))),
                  !e.pressed &&
                    this._pressedButtons[t] &&
                    ((this._pressedButtons[t] = !1),
                    (this._upButtons[t] = !0),
                    onNextFrame(() => (this._upButtons[t] = !1)));
              }),
              this.update();
          });
        }
        getAxis(e) {
          const t = this._gamepad.axes[e];
          if (this.deadZone > 0 && Math.abs(t) > 0) {
            const n = this._gamepad.axes[e % 2 === 0 ? e + 1 : e - 1];
            return Math.abs(n) > this.deadZone
              ? t
              : Math.abs(t) > this.deadZone
              ? t
              : 0;
          }
          return t;
        }
        getButton(e) {
          var t;
          return (
            (null === (t = this._gamepad.buttons[e]) || void 0 === t
              ? void 0
              : t.value) || 0
          );
        }
        getButtonDown(e) {
          return this._downButtons[e] || !1;
        }
        getButtonUp(e) {
          return this._upButtons[e] || !1;
        }
      }
      window.addEventListener("gamepadconnected", (e) => {
        const t = new GamepadController_GamepadController(e.gamepad);
        Input.gamepads.push(t);
      }),
        window.addEventListener("gamepaddisconnected", (e) => {
          Input.gamepads.splice(e.gamepad.index, 1);
        }),
        onUpdate((e) => {
          if (!(e instanceof RuntimeController_RuntimeController)) return;
          const t = navigator.getGamepads ? navigator.getGamepads() : [];
          if (t)
            for (let n = 0; n < t.length; n++) {
              const e = t[n];
              if (!e) return;
              const i = Input.gamepads[n];
              if (!i) return;
              i._gamepad = e;
            }
        });
      class Input {
        static get mouse() {
          return this._mouse;
        }
        static get keyboard() {
          return this._keyboard;
        }
        static get touch() {
          return this._touch;
        }
        static get gamepads() {
          return this._gamepads;
        }
      }
      (Input._mouse = new (class Mouse_Mouse {
        constructor() {
          (this._x = 0),
            (this._y = 0),
            (this._movementX = 0),
            (this._movementY = 0),
            (this._isMoving = !1),
            (this._isLeftButtonDown = !1),
            (this._isLeftButtonPressed = !1),
            (this._isLeftButtonUp = !1),
            (this._isRightButtonDown = !1),
            (this._isRightButtonPressed = !1),
            (this._isRightButtonUp = !1),
            (this._isMidButtonDown = !1),
            (this._isMidButtonPressed = !1),
            (this._isMidButtonUp = !1),
            (this._wheelY = 0),
            (this._wheelX = 0),
            (this._enabled = !0),
            (this.unlockFunction = (e) => {
              "Escape" === e.code && this.unlock();
            });
        }
        get pointerLock() {
          return this._pointerLock;
        }
        get x() {
          return this._x;
        }
        get y() {
          return this._y;
        }
        get movementX() {
          return this._movementX;
        }
        get movementY() {
          return this._movementY;
        }
        get isMoving() {
          return this._isMoving;
        }
        get isLeftButtonDown() {
          return this._isLeftButtonDown;
        }
        get isLeftButtonPressed() {
          return this._isLeftButtonPressed;
        }
        get isLeftButtonUp() {
          return this._isLeftButtonUp;
        }
        get isRightButtonDown() {
          return this._isRightButtonDown;
        }
        get isRightButtonPressed() {
          return this._isRightButtonPressed;
        }
        get isRightButtonUp() {
          return this._isRightButtonUp;
        }
        get isMidButtonDown() {
          return this._isMidButtonDown;
        }
        get isMidButtonPressed() {
          return this._isMidButtonPressed;
        }
        get isMidButtonUp() {
          return this._isMidButtonUp;
        }
        get buttonDown() {
          return this._buttonDown;
        }
        get buttonPressed() {
          return this._buttonPressed;
        }
        get buttonUp() {
          return this._buttonUp;
        }
        get wheelY() {
          return this._wheelY;
        }
        get wheelX() {
          return this._wheelX;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          this._enabled = e;
        }
        init() {
          document.addEventListener(
            "mousemove",
            this.onMouseMove.bind(this),
            !1
          );
          const e = document.getElementById("rogue-app");
          e &&
            (e.addEventListener("mousedown", this.onMouseDown.bind(this)),
            e.addEventListener("mouseup", this.onMouseUp.bind(this)),
            e.addEventListener("wheel", this.onWheelMove.bind(this)));
        }
        getButtonDown(e) {
          return this._buttonDown === e;
        }
        getButtonPressed(e) {
          return this._buttonPressed === e;
        }
        getButtonUp(e) {
          return this._buttonUp === e;
        }
        lock() {
          const e = document.getElementById("rogue-app");
          e &&
            (e && e.requestPointerLock(),
            document.removeEventListener("keyup", this.unlockFunction),
            document.addEventListener("keyup", this.unlockFunction));
        }
        unlock() {
          document.exitPointerLock();
        }
        onMouseMove(e) {
          onNextFrame(this.setMouseMovement.bind(this, e));
        }
        setMouseMovement(e) {
          (this._x = e.clientX),
            (this._y = e.clientY),
            (this._movementX = e.movementX),
            (this._movementY = e.movementY),
            (this._isMoving = !0),
            onNextFrame(this.resetMouseMovement.bind(this));
        }
        resetMouseMovement() {
          (this._movementX = 0), (this._movementY = 0), (this._isMoving = !1);
        }
        onMouseDown(e) {
          !1 !== this._enabled &&
            onNextFrame(() => {
              0 === e.button
                ? ((this._isLeftButtonDown = !0),
                  (this._isLeftButtonPressed = !0))
                : 2 === e.button
                ? ((this._isRightButtonDown = !0),
                  (this._isRightButtonPressed = !0))
                : 1 === e.button &&
                  ((this._isMidButtonDown = !0),
                  (this._isMidButtonPressed = !0)),
                (this._buttonDown = e.button),
                (this._buttonPressed = e.button),
                onNextFrame(() => {
                  0 === e.button
                    ? (this._isLeftButtonDown = !1)
                    : 2 === e.button
                    ? (this._isRightButtonDown = !1)
                    : 1 === e.button && (this._isMidButtonDown = !1),
                    (this._buttonDown = void 0);
                });
            });
        }
        onMouseUp(e) {
          !1 !== this._enabled &&
            onNextFrame(
              (() => {
                0 === e.button
                  ? ((this._isLeftButtonUp = !0),
                    (this._isLeftButtonPressed = !1))
                  : 2 === e.button
                  ? ((this._isRightButtonUp = !0),
                    (this._isRightButtonPressed = !1))
                  : 1 === e.button &&
                    ((this._isMidButtonUp = !0),
                    (this._isMidButtonPressed = !1)),
                  this.getButtonPressed(e.button) &&
                    ((this._buttonUp = e.button),
                    (this._buttonPressed = void 0)),
                  onNextFrame(
                    (() => {
                      0 === e.button
                        ? (this._isLeftButtonUp = !1)
                        : 2 === e.button
                        ? (this._isRightButtonUp = !1)
                        : 1 === e.button && (this._isMidButtonUp = !1),
                        (this._buttonUp = void 0);
                    }).bind(this)
                  );
              }).bind(this)
            );
        }
        onWheelMove(e) {
          !1 !== this._enabled &&
            (e.preventDefault(),
            clearTimeout(this._wheelTimeout),
            (this._wheelY = e.deltaY),
            (this._wheelX = e.deltaX),
            (this._wheelTimeout = setTimeout(() => {
              (this._wheelY = 0), (this._wheelX = 0);
            }, 250)));
        }
      })()),
        (Input._keyboard = new (class Keyboard_Keyboard {
          constructor() {
            (this._upKeys = {}),
              (this._downKeys = {}),
              (this._pressedKeys = {});
          }
          init() {
            document.addEventListener("keydown", (e) => {
              this._pressedKeys[e.code] ||
                onNextFrame(() => {
                  (this._downKeys[e.code] = !0),
                    (this._pressedKeys[e.code] = !0),
                    onNextFrame(() => {
                      this._downKeys[e.code] = !1;
                    });
                });
            }),
              document.addEventListener("keyup", (e) => {
                onNextFrame(() => {
                  (this._upKeys[e.code] = !0),
                    (this._pressedKeys[e.code] = !1),
                    onNextFrame(() => {
                      this._upKeys[e.code] = !1;
                    });
                });
              });
          }
          getKeyDown(e) {
            return this._downKeys[e];
          }
          getKeyPressed(e) {
            return this._pressedKeys[e];
          }
          getKeyUp(e) {
            return this._upKeys[e];
          }
        })()),
        (Input._touch = new (class Touch_TouchController {
          constructor() {
            (this._startTouches = []),
              (this._endTouches = []),
              (this._touches = []),
              (this._enabled = !0);
          }
          get startTouches() {
            return this._startTouches;
          }
          get endTouches() {
            return this._endTouches;
          }
          get touches() {
            return this._touches;
          }
          get enabled() {
            return this._enabled;
          }
          set enabled(e) {
            this._enabled = e;
          }
          init() {
            this._touches.splice(0),
              this._endTouches.splice(0),
              this._startTouches.splice(0),
              (this._enabled = !0);
            const e = document.getElementById("rogue-app");
            e &&
              ((e.ontouchmove = this.onTouchMove.bind(this)),
              (e.ontouchstart = this.onTouchStart.bind(this)),
              (e.ontouchend = this.onTouchEnd.bind(this)));
          }
          onTouchStart(e) {
            e.preventDefault(),
              onNextFrame(() => {
                for (let t = 0; t < e.changedTouches.length; t++) {
                  const n = e.changedTouches[t],
                    i = this.setTouchValues({}, n);
                  this._touches.push(Object.assign({}, i)),
                    this._startTouches.push(Object.assign({}, i));
                }
                onNextFrame(() => {
                  for (let t = 0; t < e.changedTouches.length; t++) {
                    const n = e.changedTouches[t],
                      i = this.getCurrentTouchIndexById(
                        n.identifier,
                        this._startTouches
                      );
                    this._startTouches.splice(i, 1);
                  }
                });
              });
          }
          onTouchEnd(e) {
            e.preventDefault(),
              onNextFrame(() => {
                for (let t = 0; t < e.changedTouches.length; t++) {
                  const n = e.changedTouches[t],
                    i = this.getCurrentTouchIndexById(
                      n.identifier,
                      this._touches
                    ),
                    s = this._touches[i];
                  this._endTouches.push(Object.assign({}, s)),
                    this._touches.splice(i, 1);
                }
                onNextFrame(() => {
                  for (let t = 0; t < e.changedTouches.length; t++) {
                    const n = e.changedTouches[t],
                      i = this.getCurrentTouchIndexById(
                        n.identifier,
                        this._endTouches
                      );
                    this._endTouches.splice(i, 1);
                  }
                });
              });
          }
          onTouchMove(e) {
            e.preventDefault(),
              onNextFrame(() => {
                for (let t = 0; t < e.changedTouches.length; t++) {
                  const n = e.changedTouches[t],
                    i = this.getCurrentTouchIndexById(
                      n.identifier,
                      this._touches
                    );
                  i >= 0 && this.setTouchValues(this._touches[i], n);
                }
                onNextFrame(() => {
                  for (const e of this._touches) (e.deltaX = 0), (e.deltaY = 0);
                });
              });
          }
          getCurrentTouchIndexById(e, t) {
            for (let n = 0; n < t.length; n++) if (t[n].id == e) return n;
            return -1;
          }
          setTouchValues(e, t) {
            const n = void 0 !== e.x ? e.x : 0,
              i = void 0 !== e.y ? e.y : 0;
            return (
              (e.id = void 0 !== e.id ? e.id : t.identifier),
              (e.deltaX = void 0 !== e.x ? t.clientX - n : 0),
              (e.deltaY = void 0 !== e.x ? t.clientY - i : 0),
              (e.x = t.clientX),
              (e.y = t.clientY),
              (e.touch = t),
              e
            );
          }
        })()),
        (Input._gamepads = []);
      class App_App {
        constructor() {}
        static get activeCamera() {
          return this._activeCamera;
        }
        static set activeCamera(e) {
          this._activeCamera = e;
        }
        static get settings() {
          return this._settings;
        }
        static get title() {
          return this._title;
        }
        static set title(e) {
          this._title = e;
        }
        static get currentScene() {
          return this._currentScene;
        }
        static set currentScene(e) {
          this._currentScene = e;
        }
        static get scenes() {
          return this._scenes;
        }
        static get sceneController() {
          return this._sceneController;
        }
        static set sceneController(e) {
          this._sceneController = e;
        }
        static get lanIP() {
          return this._lanIP;
        }
        static toJSON(e) {
          return {
            title: this._title,
            scenes: this._scenes,
            lanIP: this.lanIP,
            assetPaths: Object.assign({}, e),
          };
        }
        static fromJSON(e) {
          (this._title = e.title),
            (this._scenes = e.scenes),
            e.lanIP && (this._lanIP = e.lanIP);
        }
        static play(e) {
          (this._title = e.title),
            (this._scenes = e.scenes),
            Q.setAssetPaths(e.assetPaths),
            Input.mouse.init(),
            Input.keyboard.init(),
            Input.touch.init(),
            this.loadScene(this._scenes[0].name);
        }
        static loadScene(e) {
          return (
            y.stop(),
            dispose(this._currentScene),
            new Promise((t) => {
              this.loadSceneFunc(e).then(() => {
                t();
              });
            })
          );
        }
        static loadSceneFunc(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            let t;
            if (
              ("string" === typeof e
                ? (t = this._scenes.find((t) => t.name === e))
                : "number" === typeof e && (t = this._scenes[e]),
              !t)
            )
              return;
            let n = yield fetch(
                window.ROGUE_ISDEV
                  ? Q.getAssetPath(t.uuid)
                  : this.title + "_DATA/" + t.uuid + ".rogueScene"
              ),
              s = yield n.json();

            y.startRenderer(),
              (App_App.sceneController = y),
              (Q.sceneController = y),
              (App_App.activeCamera = s.initialCameraId),
              Q.loadAssetConfigs(s.assetConfigs),
              yield Q.preloadAssets(),
              (this._currentScene = new i.ObjectLoader().parse(s.scene)),
              this.loadAudioListeners(this._currentScene),
              s.skybox && E.init(s.skybox),
              y.play(this._currentScene, y.renderer, s.components);
          });
        }
        static clone(e, t) {
          if (!e)
            throw new Error(
              "App.clone(...) => The object you are trying to clone does not seem to exist."
            );
          if (!(e instanceof i.Object3D))
            throw new Error(
              "App.clone(...) => The object you are trying to clone is unavailable, try fetching the asset first. object.uuid: " +
                e.uuid
            );
          const n = e.animations;
          let s = e.clone();
          (s.animations = n),
            t
              ? (t.attach(s), s.position.set(0, 0, 0))
              : this.currentScene.add(s),
            this.loadAudioListeners(s),
            this.loadComponentsRecursive(s);
          let o = G(s);
          return (
            y.isRunning &&
              o.forEach((e) => {
                e.awake();
              }),
            y.isRunning &&
              s.traverse((e) => {
                G(e).forEach((e) => {
                  e.awake();
                });
              }),
            s
          );
        }
        static loadComponentsRecursive(e) {
          const t = e.userData && e.userData.components;
          (() =>
            Object(s.a)(this, void 0, void 0, function* () {
              t && T(e, t), e.userData && delete e.userData.components;
            }))();
          for (let n in e.children) this.loadComponentsRecursive(e.children[n]);
        }
        static loadAudioListeners(e) {
          const t = [];
          e.traverse((e) => {
            e instanceof i.AudioListener ||
              !e.userData.__AUDIOLISTENER__ ||
              t.push(e);
          }),
            t.forEach((e) => {
              const t = new i.AudioListener();
              (t.name = e.name),
                (t.userData.__AUDIOLISTENER__ = !0),
                t.position.copy(e.position),
                t.rotation.copy(e.rotation);
              const n = e.uuid;
              e.parent && e.parent.add(t),
                e.parent && e.parent.remove(e),
                (t.uuid = n);
            });
        }
      }
      (App_App._title = "Project"),
        (App_App._scenes = []),
        (App_App._sceneController = y),
        (App_App._lanIP = "localhost");
      class AudioAsset_AudioAsset {
        constructor(e) {
          this._uuid = e.uuid;
          const t = i.AudioContext.getContext().createBuffer(1, 1, 8e3);
          (this._buffer = e.buffer || t),
            (this.userData = { __ASSET__: this._uuid });
        }
        get uuid() {
          return this._uuid;
        }
        get path() {
          return Q.getAssetPath(this._uuid) || "";
        }
        get name() {
          return this.path.substring(
            this.path.lastIndexOf("/") + 1,
            this.path.lastIndexOf(".")
          );
        }
        getAudio() {
          const e =
              App_App.currentScene.getObjectByProperty(
                "type",
                "AudioListener"
              ) || new i.AudioListener(),
            t = new i.Audio(e);
          return (
            t.setBuffer(this._buffer),
            (t.name = this.name),
            (t.userData.__ASSET__ = this.uuid),
            t
          );
        }
        getPositionalAudio() {
          const e =
              App_App.currentScene.getObjectByProperty(
                "type",
                "AudioListener"
              ) || new i.AudioListener(),
            t = new i.PositionalAudio(e);
          return (
            t.setBuffer(this._buffer),
            (t.name = this.name),
            (t.userData.__ASSET__ = this.uuid),
            t
          );
        }
        static fromFile(e, t = () => {}, n = () => {}) {
          return Object(s.a)(this, void 0, void 0, function* () {
            let s = yield fetch(e + ".meta"),
              o = yield s.json();
            return new Promise((s) => {
              let r = new i.AudioLoader();
              r.setCrossOrigin("anonymous"),
                r.load(
                  e,
                  (e) => {
                    const t = new AudioAsset_AudioAsset({
                      uuid: o.uuid,
                      buffer: e,
                    });
                    s(t);
                  },
                  t,
                  n
                );
            });
          });
        }
      }
      class Prefab_Prefab {
        constructor(e) {
          this._uuid = e;
        }
        get uuid() {
          return this._uuid;
        }
        get path() {
          return Q.getAssetPath(this._uuid) || "";
        }
        get name() {
          return this.path.substring(
            this.path.lastIndexOf("/") + 1,
            this.path.lastIndexOf(".")
          );
        }
        instantiate(e) {
          let t = Q.getAsset(this._uuid).clone();
          e
            ? (e.attach(t), t.position.set(0, 0, 0))
            : App_App.currentScene.attach(t),
            t.traverse((e) => {
              let n = e.userData.__NESTED__;
              onNextFrame(() => {
                n &&
                  n.forEach((n) => {
                    n.uuid !== t.userData.__ASSET__ &&
                      onNextFrame(() =>
                        Object(s.a)(this, void 0, void 0, function* () {
                          if (!(yield Q.loadAsset(n.uuid))) return;
                          const t =
                              n.parent === e.userData.__REF__
                                ? e
                                : e.getObjectByProperty("uuid", n.parent),
                            i = new Prefab_Prefab(n.uuid).instantiate(t);
                          n.position && i.position.fromArray(n.position),
                            n.rotation && i.rotation.fromArray(n.rotation),
                            n.scale && i.scale.fromArray(n.scale);
                        })
                      );
                  });
              }),
                n && (e.userData.__NESTED__ = void 0);
            }),
            (function loadAudioListeners(e) {
              const t = [];
              e.traverse((e) => {
                e instanceof i.AudioListener ||
                  !e.userData.__AUDIOLISTENER__ ||
                  t.push(e);
              }),
                t.forEach((e) => {
                  const t = new i.AudioListener();
                  (t.name = e.name),
                    (t.userData.__AUDIOLISTENER__ = !0),
                    t.position.copy(e.position),
                    t.rotation.copy(e.rotation);
                  const n = e.uuid;
                  e.parent && e.parent.add(t),
                    e.parent && e.parent.remove(e),
                    (t.uuid = n);
                });
            })(t),
            (function loadComponentsRecursive(e) {
              const t = e.userData && e.userData.components;
              (() =>
                Object(s.a)(this, void 0, void 0, function* () {
                  t && T(e, t), e.userData && delete e.userData.components;
                }))();
              for (let n in e.children) loadComponentsRecursive(e.children[n]);
            })(t);
          let n = G(t);
          return (
            y.isRunning &&
              n.forEach((e) => {
                e.awake();
              }),
            y.isRunning &&
              t.traverse((e) => {
                G(e).forEach((e) => {
                  e.awake();
                });
              }),
            t
          );
        }
      }
      var S = n(19),
        w = n.n(S);
      const O = new i.AnimationClip("", 0, []);
      class Component_Component extends Lifecycle {
        constructor(e, t) {
          super(),
            (this._name = "component"),
            (this._isReady = !0),
            (this._enabled = !0),
            (this.interface = {}),
            (this.uuid = w()()),
            (this._object3d = t),
            (this._name = e);
        }
        get name() {
          return this._name;
        }
        set name(e) {
          this._name = e;
        }
        get object3d() {
          return this._object3d;
        }
        get isReady() {
          return this._isReady;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e) {
          (this._enabled = e),
            e
              ? (isActive(this.object3d) && this.awake(),
                (this.__STARTED__ = !1))
              : isActive(this.object3d) && this.onDisabled();
        }
        toJSON() {
          return {
            uuid: this.uuid,
            name: this.name,
            componentPrototypeName: this.constructor.name,
            interface: this.constructor.interface || {},
            interfaceRefs: this.serializeInterfaceRefs(),
            enabled: this._enabled,
          };
        }
        fromJSON(e) {
          (this._isReady = !1),
            (this.uuid = e.uuid || this.uuid),
            (this.name = e.name),
            (this.interface = e.interface || {}),
            this.loadInterfaceRefs(e.interfaceRefs),
            (this._enabled = "boolean" !== typeof e.enabled || e.enabled);
        }
        serializePropRef(e, t, n, s) {
          switch (s) {
            case "Data":
            case "String":
            case "Number":
            case "Boolean":
            case "Select":
            case "Code":
              e[t] = n[t];
              break;
            case "Color":
              if (n[t] instanceof i.Color) {
                const i = n[t];
                e[t] = i.getHex();
              }
              break;
            case "Vector2":
              if (n[t] instanceof i.Vector2) {
                const i = n[t];
                e[t] = i.toArray();
              }
              break;
            case "Vector3":
              if (n[t] instanceof i.Vector3) {
                const i = n[t];
                e[t] = i.toArray();
              }
              break;
            case "Texture":
              if (n[t] instanceof i.Texture) {
                const i = n[t];
                e[t] = i.uuid;
              }
              break;
            case "Material":
              if (n[t] instanceof i.Material) {
                const i = n[t];
                e[t] = i.uuid;
              }
              break;
            case "Object3D":
              if (n[t] instanceof i.Object3D) {
                const i = n[t];
                e[t] = i.uuid;
              }
              break;
            case "Prefab":
              if (n[t] instanceof Prefab_Prefab) {
                const i = n[t];
                e[t] = i.uuid;
              }
              break;
            case "AnimationClip":
              if (n[t] instanceof i.AnimationClip) {
                const i = n[t];
                e[t] = i.uuid;
              }
              break;
            case "PositionalAudio":
            case "Audio":
              if (n[t] instanceof AudioAsset_AudioAsset) {
                const i = n[t].userData.__ASSET__;
                e[t] = i;
              }
          }
        }
        serializeInterfaceRefs() {
          if (!this.constructor.interface) return {};
          let e = {};
          for (let t in this.constructor.interface) {
            let n = this.constructor.interface[t];
            if (Array.isArray(n)) {
              const i = this[t];
              Array.isArray(i) || (this[t] = []);
              const s = [],
                o = n[0];
              let r = "string" === typeof o ? o : o.type;
              if ("Button" === r) continue;
              i.forEach((e, t) => {
                this.serializePropRef(s, t, i, r);
              }),
                (e[t] = s);
            } else {
              let i = "string" === typeof n ? n : n.type;
              if ("Button" === i) continue;
              this.serializePropRef(e, t, this, i);
            }
          }
          return e;
        }
        loadInterfaceRefs(e) {
          if (!e || 0 === Object.keys(e).length)
            return void (this._isReady = !0);
          const t = {},
            n = (n) => {
              const i = e[n];
              Array.isArray(i)
                ? ((t[n] = []),
                  i.forEach((e, i) => {
                    t[n][i] = !1;
                  }))
                : (t[n] = !1);
            };
          for (let i in this.interface) n(i);
          0 === Object.keys(this.interface).length && (this._isReady = !0);
          for (let i in this.interface) {
            const n = this.interface[i];
            if (Array.isArray(n)) {
              this[i] = [];
              const s = n[0];
              let o = "string" === typeof s ? s : s.type;
              Array.isArray(e[i]) || (e[i] = []);
              const r = e[i];
              r.forEach((e, n) => {
                this.loadPropRef(r, n, this[i], t, o, i);
              }),
                0 === r.length && this.readyNotifier(t, i);
            } else {
              let s = "string" === typeof n ? n : n.type;
              this.loadPropRef(e, i, this, t, s);
            }
          }
        }
        readyNotifier(e, t, n) {
          n ? (e[n][t] = !0) : (e[t] = !0);
          for (const i in e) {
            const t = e[i];
            if (!1 === t) return !1;
            if (Array.isArray(t))
              for (let e = 0; e < t.length; e++) if (!1 === t[e]) return !1;
          }
          return (this._isReady = !0), !0;
        }
        loadPropRef(e, t, n, s, o, r) {
          switch (o) {
            case "Button":
              this.readyNotifier(s, t, r);
              break;
            case "Data":
            case "String":
            case "Number":
            case "Boolean":
            case "Select":
            case "Code":
              (n[t] = e[t]), this.readyNotifier(s, t, r);
              break;
            case "Color":
              (n[t] = new i.Color(e[t])), this.readyNotifier(s, t, r);
              break;
            case "Vector2":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              (n[t] = new i.Vector2(...e[t])), this.readyNotifier(s, t, r);
              break;
            case "Vector3":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              (n[t] = new i.Vector3(...e[t])), this.readyNotifier(s, t, r);
              break;
            case "Object3D":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              const a = (function getParentPrefab(e) {
                return e.userData.__ASSET__
                  ? e
                  : e.parent
                  ? getParentPrefab(e.parent)
                  : void 0;
              })(this.object3d);
              let u;
              a &&
                a.traverse((n) => {
                  n.userData.__REF__ === e[t] && (u = n);
                }),
                u ||
                  (u = App_App.currentScene.getObjectByProperty("uuid", e[t])),
                (n[t] = u),
                this.readyNotifier(s, t, r);
              break;
            case "Prefab":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              let c = "",
                h = !1;
              if (
                (e[t] &&
                  ((c = e[t]),
                  (n[t] = App_App.currentScene.getObjectByProperty(
                    "uuid",
                    e[t]
                  ))),
                e[t] && !n[t])
              ) {
                c = e[t];
                let i = Q.getAsset(c);
                (n[t] = new Prefab_Prefab(c)),
                  !i && y.isRunning
                    ? ((h = !0),
                      Q.loadAsset(c).then((e) => {
                        this.readyNotifier(s, t, r);
                      }))
                    : this.readyNotifier(s, t, r);
              }
              n[t] ||
                !e[t] ||
                h ||
                Debug.logError(
                  "Component => object reference could not be found for " +
                    this.constructor.name +
                    "." +
                    t +
                    " in Object3D with uuid: " +
                    c
                );
              break;
            case "AnimationClip":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              let d = !1;
              if (e[t] && !n[t]) {
                const i = e[t],
                  o = Q.getAsset(i);
                (n[t] = O),
                  o
                    ? ((n[t] = o), this.readyNotifier(s, t, r))
                    : ((d = !0),
                      Q.loadAsset(i).then((e) => {
                        (n[t] = e), this.readyNotifier(s, t, r);
                      }));
              }
              break;
            case "Audio":
            case "PositionalAudio":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              let l = "";
              const p = (e) => {
                const i = "Audio" === o ? e.getAudio() : e.getPositionalAudio();
                (n[t] = i), this.object3d.add(i);
              };
              if (e[t] && !n[t]) {
                l = e[t];
                let i = Q.getAsset(l);
                if (!y.isRunning) {
                  n[t] = new AudioAsset_AudioAsset({ uuid: l });
                  break;
                }
                if (!i) {
                  Q.loadAsset(l).then((e) => {
                    p(e), this.readyNotifier(s, t, r);
                  });
                  break;
                }
                i instanceof AudioAsset_AudioAsset &&
                  (p(i), this.readyNotifier(s, t, r));
              }
              break;
            case "Texture":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              let f = !1;
              if (e[t] && !n[t]) {
                const i = e[t],
                  o = Q.getAsset(i);
                o
                  ? ((n[t] = o), this.readyNotifier(s, t, r))
                  : ((f = !0),
                    Q.loadAsset(i).then((e) => {
                      (n[t] = e), this.readyNotifier(s, t, r);
                    }));
              }
              break;
            case "Material":
              if (!e[t]) {
                this.readyNotifier(s, t, r);
                break;
              }
              let m = !1;
              if (e[t] && !n[t]) {
                const i = e[t],
                  o = Q.getAsset(i);
                o
                  ? ((n[t] = o), this.readyNotifier(s, t, r))
                  : ((m = !0),
                    Q.loadAsset(i).then((e) => {
                      (n[t] = e), this.readyNotifier(s, t, r);
                    }));
              }
          }
        }
        awake() {}
        start() {}
        beforeUpdate() {}
        update() {}
        afterUpdate() {}
        onBeforeRemoved() {}
        onRemoved() {}
        onBeforeObjectRemoved() {}
        onObjectRemoved() {}
        onDisabled() {}
      }
      class Tags {
        static getTags() {
          return Object.keys(this.tagsMap);
        }
        static getObjects(e) {
          return this.tagsMap[e] || [];
        }
        static getWithAll(...e) {
          const t = [];
          for (let n in this.objectTagsMap) {
            const i = this.objectTagsMap[n];
            let s = void 0,
              o = !0;
            for (let t of e) {
              const e = void 0 !== i[t];
              e && !s && (s = this.tagsMap[t].find((e) => e.uuid === n)),
                e || (o = !1);
            }
            o && s && t.push(s);
          }
          return t;
        }
        static getWithAny(...e) {
          const t = [];
          for (let n in this.objectTagsMap) {
            const i = this.objectTagsMap[n];
            let s = void 0;
            for (let t of e) {
              if (void 0 !== i[t] && !s) {
                s = this.tagsMap[t].find((e) => e.uuid === n);
                break;
              }
            }
            s && t.push(s);
          }
          return t;
        }
        static hasAny(e, ...t) {
          const n = this.objectTagsMap[e.uuid] || {};
          for (let i of t) if (void 0 !== n[i]) return !0;
          return !1;
        }
        static hasAll(e, ...t) {
          const n = this.objectTagsMap[e.uuid] || {};
          for (let i of t) if (void 0 === n[i]) return !1;
          return !0;
        }
        static hasNone(e, ...t) {
          const n = this.objectTagsMap[e.uuid] || {};
          for (let i of t) if (void 0 !== n[i]) return !1;
          return !0;
        }
        static isMissingAll(e, ...t) {
          const n = this.objectTagsMap[e.uuid] || {};
          for (let i of t) if (void 0 === n[i]) return !0;
          return !1;
        }
        static get(e) {
          const t = this.objectTagsMap[e.uuid] || {};
          return Object.keys(t);
        }
        static set(e, ...t) {
          t.forEach((t) => {
            this.tagsMap[t] || this.create(t),
              this.tagsMap[t].push(e),
              this.objectTagsMap[e.uuid] || (this.objectTagsMap[e.uuid] = {}),
              (this.objectTagsMap[e.uuid][t] = t),
              Array.isArray(e.userData.rogueTags) ||
                (e.userData.rogueTags = []),
              e.userData.rogueTags.push(t);
          });
        }
        static remove(e, ...t) {
          t.forEach((t) => {
            const n = this.tagsMap[t],
              i = n.indexOf(e);
            if (
              (i >= 0 && n.splice(i, 1),
              this.objectTagsMap[e.uuid] &&
                this.objectTagsMap[e.uuid][t] &&
                delete this.objectTagsMap[e.uuid][t],
              Array.isArray(e.userData.rogueTags))
            ) {
              const n = e.userData.rogueTags.indexOf(t);
              n >= 0 && e.userData.rogueTags.splice(n, 1);
            }
          });
        }
        static create(...e) {
          e.forEach((e) => {
            Array.isArray(this.tagsMap[e]) || (this.tagsMap[e] = []);
          });
        }
        static delete(...e) {
          e.forEach((e) => {
            this.tagsMap[e].forEach((t) => {
              if (
                (delete this.objectTagsMap[t.uuid][e],
                Array.isArray(t.userData.rogueTags))
              ) {
                const n = t.userData.rogueTags.indexOf(e);
                n >= 0 && t.userData.rogueTags.splice(n, 1);
              }
            }),
              delete this.tagsMap[e];
          });
        }
        static clear() {
          const e = Object.keys(this.tagsMap);
          for (let n in e) delete this.tagsMap[n];
          const t = Object.keys(this.objectTagsMap);
          for (let n in t) delete this.objectTagsMap[n];
        }
      }
      (Tags.tagsMap = {}), (Tags.objectTagsMap = {});
      let x = {},
        k = {},
        P = {},
        R = {},
        j = {};
      function getComponentPrototypes() {
        return x;
      }
      function clearComponents() {
        x = {};
        for (let e in j) x[e] = j[e];
      }
      function registerComponent(e) {
        if (e.prototype instanceof Component_Component) {
          const t = e.isInternalComponent,
            n = e.isEditorComponent;
          if ((n || t || (x[e.name] = e), n)) {
            const n = "Editor_" + e.name,
              i = getComponentByName(n);
            window["rogue-editor"].editorRuntime.editorObjectsContainer &&
              (i && N(i),
              t ? ((j[e.name] = e), (x[e.name] = e)) : (x[e.name] = e),
              B(
                new e(
                  n,
                  window["rogue-editor"].editorRuntime.editorObjectsContainer
                )
              ));
          }
        } else Debug.logWarning(e + " is not a Component");
      }
      const D = (e, t) => {
          (P = {}), t && (k = t);
          for (let n in k) {
            const t = k[n];
            P[n] = [];
            let i = e.getObjectByProperty("uuid", n);
            t.forEach((e, t) => {
              e
                ? x[e.componentPrototypeName]
                  ? ((P[n][t] = new x[e.componentPrototypeName](e.name, i)),
                    P[n][t].fromJSON(e))
                  : Debug.logError(
                      "Component " +
                        e.componentPrototypeName +
                        " does not exist"
                    )
                : Debug.logError("Component does not exist");
            });
          }
        },
        L = (e) => {
          if (!App_App.sceneController.editorObjectsContainer) return;
          const t = {};
          for (let n in R) {
            const e = R[n];
            (t[n] = []),
              e.forEach((e, i) => {
                e && e.onRemoved(), e && t[n].push(e.toJSON());
              });
          }
          for (let n in t) {
            const e = t[n];
            R[n] = [];
            let i =
              App_App.sceneController.editorObjectsContainer.getObjectByProperty(
                "uuid",
                n
              );
            e.forEach((e, t) => {
              e
                ? x[e.componentPrototypeName]
                  ? ((R[n][t] = new x[e.componentPrototypeName](e.name, i)),
                    R[n][t].fromJSON(e))
                  : Debug.logError(
                      "Component " +
                        e.componentPrototypeName +
                        " does not exist"
                    )
                : Debug.logError("Component does not exist");
            });
          }
        };
      function traverseComponents(e) {
        for (let t in P) {
          P[t].forEach((n, i) => {
            e(n, t, i);
          });
        }
      }
      const T = (e, t) => {
          let n = e.uuid;
          (P[e.uuid] = []),
            t.forEach((t, i) => {
              t
                ? x[t.componentPrototypeName]
                  ? ((P[n][i] = new x[t.componentPrototypeName](t.name, e)),
                    P[n][i].fromJSON(t),
                    (function componentLoaded(e, t) {
                      p(e, t, d);
                    })(P[n][i], e))
                  : Debug.logError(
                      "Component " +
                        t.componentPrototypeName +
                        " does not exist"
                    )
                : Debug.logError("Component does not exist");
            });
        },
        M = () => {
          k = {};
          for (let e in P) {
            const t = P[e];
            (k[e] = []),
              t.forEach((t, n) => {
                t && k[e].push(t.toJSON());
              });
          }
          return k;
        },
        B = (e) => {
          var t, n;
          if (!e.object3d) return;
          if (
            e.constructor.isEditorComponent &&
            (null ===
              (n =
                null === (t = window["rogue-editor"]) || void 0 === t
                  ? void 0
                  : t.editorRuntime) || void 0 === n
              ? void 0
              : n.editorObjectsContainer) !== e.object3d
          )
            throw `Failed adding component ${e.constructor.name}. Editor Components cannot be added to scene objects`;
          const i = e.object3d;
          if (i.userData.isEditorObject || e.constructor.isEditorComponent)
            return R[i.uuid] || (R[i.uuid] = []), void R[i.uuid].push(e);
          P[i.uuid] || (P[i.uuid] = []),
            P[i.uuid].push(e),
            (function componentAdded(e, t) {
              p(e, t, h);
            })(e, i),
            y.isRunning && e.awake();
        };
      function copyObjectComponents(e, t) {
        const n = G(e);
        let i = [];
        n.forEach((e) => {
          const t = e.toJSON();
          delete t.uuid, i.push(t);
        }),
          i.forEach((e) => {
            if (e)
              if (x[e.componentPrototypeName]) {
                const n = new x[e.componentPrototypeName](e.name, t);
                n.fromJSON(e), B(n);
              } else
                Debug.logError(
                  "Component " + e.componentPrototypeName + " does not exist"
                );
            else Debug.logError("Component does not exist");
          });
      }
      const N = (e) => {
          const t = e.object3d;
          return (
            !!t &&
            (R[t.uuid]
              ? (!y.isRunning && e.onBeforeRemoved(),
                R[t.uuid].splice(R[t.uuid].indexOf(e), 1),
                !y.isRunning && e.onRemoved(),
                componentRemoved(e, t),
                !0)
              : void 0)
          );
        },
        F = (e) => {
          const t = e.object3d;
          return (
            !!t &&
            (P[t.uuid]
              ? (y.isRunning && e.onBeforeRemoved(),
                P[t.uuid].splice(P[t.uuid].indexOf(e), 1),
                y.isRunning && e.onRemoved(),
                componentRemoved(e, t),
                !0)
              : void 0)
          );
        },
        I = (e, t) => {
          for (let n in P[e.uuid]) F(P[e.uuid][n]);
          if ((delete P[e.uuid], t))
            for (let n in e.children) {
              let t = e.children[n];
              I(t, !0);
            }
        };
      function getObjectComponentByName(e, t) {
        return P[t]
          ? P[t].find((t, n, i) => t.name === e)
          : R[t]
          ? R[t].find((t, n, i) => t.name === e)
          : void 0;
      }
      function getComponentByName(e, t) {
        if (t) return getObjectComponentByName(e, t.uuid);
        for (let n in P) {
          const t = getObjectComponentByName(e, n);
          if (t) return t;
        }
        for (let n in R) {
          const t = getObjectComponentByName(e, n);
          if (t) return t;
        }
      }
      const U = (e, t) => {
          if (t && P[t.uuid])
            return P[t.uuid].find((t, n, i) => t instanceof e);
          if (t && R[t.uuid])
            return R[t.uuid].find((t, n, i) => t instanceof e);
          if (!t)
            for (let n in P) {
              const t = P[n];
              for (let n = 0; n < t.length; n++)
                if (t[n] instanceof e) return t[n];
            }
        },
        z = (e) => {
          const t = [];
          for (let n in P) {
            P[n].forEach((n) => {
              n instanceof e && t.push(n);
            });
          }
          return t;
        },
        G = (e) => P[e.uuid] || [],
        W = i.Object3D.prototype.add,
        J = i.Object3D.prototype.attach,
        V = i.Object3D.prototype.remove,
        $ = i.Object3D.prototype.clone;
      let K = !1;
      function addObject(e) {
        if (
          (Array.isArray(e.userData.rogueTags) &&
            Tags.set(e, ...e.userData.rogueTags),
          e.material instanceof i.Material)
        ) {
          let t = Q.getAsset(e.material.uuid);
          const n = e.userData.__MATERIAL__;
          !t &&
            n &&
            ((t = Q.getAsset(n)) instanceof i.Material
              ? (e.material = t)
              : !t &&
                n &&
                Q.loadAsset(n).then((t) => {
                  t
                    ? (e.material = t)
                    : Debug.logWarning(`Material not found. uuid: ${n}`);
                }));
        }
        Array.isArray(e.userData.__MATERIAL__) &&
          e.userData.__MATERIAL__.forEach((t, n) => {
            if (!t) return;
            let s = Q.getAsset(t);
            s instanceof i.Material
              ? (e.material[n] = s)
              : !s &&
                t &&
                Q.loadAsset(t).then((i) => {
                  i
                    ? (e.material[n] = i)
                    : Debug.logWarning(`Material not found. uuid: ${t}`);
                });
          });
      }
      (i.Object3D.prototype.clone = function (e) {
        K = !0;
        const t = $.bind(this)(e);
        return (K = !1), t;
      }),
        (i.Object3D.prototype.add = function (...e) {
          !this.userData.isEditorObject &&
            e.forEach((e) => {
              addObject(e), (e.userData.__IS_ADDING__ = !0);
            });
          const t = W.bind(this)(...e);
          return (
            !this.userData.isEditorObject &&
              e.forEach((e) => {
                (e.userData.__IS_ADDING__ = !1), K || objectAdded(e, this);
              }),
            t
          );
        }),
        (i.Object3D.prototype.attach = function (e) {
          !this.userData.isEditorObject && addObject(e),
            (e.userData.__IS_ADDING__ = !0);
          const t = J.bind(this)(e);
          return (
            (e.userData.__IS_ADDING__ = !1),
            !this.userData.isEditorObject && !K && objectAdded(e, this),
            t
          );
        });
      let X = (e, t) => {
        if (
          ((function objectRemoved(e, t) {
            c(e, t, u);
          })(e, t),
          P[e.uuid])
        ) {
          const t = P[e.uuid].slice(0);
          for (let e in t) F(t[e]);
          delete P[e.uuid];
        }
        for (let n in e.children) {
          let t = e.children[n];
          X(t, e);
        }
      };
      i.Object3D.prototype.remove = function (e) {
        const t = this === e.parent,
          n = P[e.uuid];
        t &&
          !e.userData.__IS_ADDING__ &&
          n &&
          y.isRunning &&
          !this.userData.isEditorObject &&
          n.forEach((e) => {
            e.onBeforeObjectRemoved();
          });
        const i = V.bind(this)(e);
        return (
          !t ||
            e.userData.__IS_ADDING__ ||
            this.userData.isEditorObject ||
            (y.isRunning &&
              n &&
              n.forEach((e) => {
                e.onObjectRemoved();
              }),
            X(e, this)),
          i
        );
      };
      const q = i.Object3D.prototype.toJSON;
      i.Object3D.prototype.toJSON = function (e) {
        const t = this.children.filter((e) => e.userData.isEditorObject);
        t.forEach((e) => {
          this.remove(e);
        });
        const n = q.bind(this)(e);
        if (
          (t.forEach((e) => {
            this.attach(e);
          }),
          window.__IS_LOADING_MODEL__)
        )
          return n;
        if (n.object.userData && n.object.userData.__IS_MATERIAL__) {
          n.images = [];
          for (let e in n.textures) {
            const t = n.textures[e];
            n.textures[e] = t.uuid;
          }
        } else {
          const e = [],
            t = [];
          n.textures &&
            n.textures.forEach((n) => {
              Q.getAssetPath(n.uuid) && (t.push(n), e.push(n.image));
            }),
            e.forEach((e) => {
              const t = n.images.find((t) => t.uuid === e);
              n.images.splice(n.images.indexOf(t), 1);
            }),
            t.forEach((e) => {
              n.textures.splice(n.textures.indexOf(e), 1);
            });
          const i = [];
          n.materials &&
            n.materials.forEach((e) => {
              Q.getAssetPath(e.uuid) && i.push(e);
            }),
            i.forEach((e) => {
              n.materials.splice(n.materials.indexOf(e), 1);
            });
        }
        return n;
      };
      const Y = [
          "Prefab",
          "Material",
          "Aduio",
          "PositionalAudio",
          "AnimationClip",
        ],
        H = [
          "png",
          "PNG",
          "jpg",
          "JPG",
          "jpeg",
          "JPEG",
          "gif",
          "GIF",
          "webp",
          "WEBP",
          "tga",
          "TGA",
          "tif",
          "tiff",
          "TIF",
          "TIFF",
        ],
        Z = ["mp3", "MP3", "ogg", "OGG", "mkv", "MKV", "wav", "WAV"];
      let Q = new (class AssetManager_AssetManagerClass {
        constructor() {
          (this._assets = {}),
            (this._assetConfigs = {}),
            (this._assetPaths = {}),
            (this._loadingAssets = {}),
            (this._objectLoader = new i.ObjectLoader()),
            (this.textureLoader = new i.TextureLoader());
        }
        get assets() {
          return this._assets;
        }
        get assetConfigs() {
          return this._assetConfigs;
        }
        get assetPaths() {
          return this._assetPaths;
        }
        get totalLoadingAssets() {
          return Object.keys(this._loadingAssets).length;
        }
        onRegisterAsset(e) {
          return (
            v.on("onRegisterAsset", e),
            {
              stop: () => {
                v.removeListener("onRegisterAsset", e);
              },
            }
          );
        }
        onRemoveAsset(e) {
          return (
            v.on("onRemoveAsset", e),
            {
              stop: () => {
                v.removeListener("onRemoveAsset", e);
              },
            }
          );
        }
        onClearAssets(e) {
          return (
            v.on("onClearAssets", e),
            {
              stop: () => {
                v.removeListener("onClearAssets", e);
              },
            }
          );
        }
        onSetAssetConfig(e) {
          return (
            v.on("onSetAssetConfig", e),
            {
              stop: () => {
                v.removeListener("onSetAssetConfig", e);
              },
            }
          );
        }
        onRemoveAssetConfig(e) {
          return (
            v.on("onRemoveAssetConfig", e),
            {
              stop: () => {
                v.removeListener("onRemoveAssetConfig", e);
              },
            }
          );
        }
        onLoadAssetConfigs(e) {
          return (
            v.on("onLoadAssetConfigs", e),
            {
              stop: () => {
                v.removeListener("onLoadAssetConfigs", e);
              },
            }
          );
        }
        onSetAssetPath(e) {
          return (
            v.on("onSetAssetPath", e),
            {
              stop: () => {
                v.removeListener("onSetAssetPath", e);
              },
            }
          );
        }
        onSetAssetPaths(e) {
          return (
            v.on("onSetAssetPaths", e),
            {
              stop: () => {
                v.removeListener("onSetAssetPaths", e);
              },
            }
          );
        }
        onRemoveAssetPath(e) {
          return (
            v.on("onRemoveAssetPath", e),
            {
              stop: () => {
                v.removeListener("onRemoveAssetPath", e);
              },
            }
          );
        }
        setAssetConfig(e, t) {
          (this._assetConfigs[e] = t),
            t.preload ||
              t.keepLoaded ||
              t.override ||
              delete this._assetConfigs[e],
            v.emit("onSetAssetConfig", e, t);
        }
        getAssetConfig(e) {
          return this._assetConfigs[e];
        }
        removeAssetConfig(e) {
          const t = this._assetConfigs[e];
          delete this._assetConfigs[e], v.emit("onRemoveAssetConfig", e, t);
        }
        setAssetPath(e, t) {
          (this._assetPaths[e] = t), v.emit("onSetAssetPath", e, t);
        }
        removeAssetPath(e) {
          const t = this._assetPaths[e];
          delete this._assetPaths[e], v.emit("onRemoveAssetPath", e, t);
        }
        setAssetPaths(e) {
          (this._assetPaths = Object.assign({}, e)),
            v.emit("onSetAssetPaths", e);
        }
        getAssetPath(e) {
          let t;
          return this._assetPaths[e] && (t = this._assetPaths[e]), t;
        }
        registerAsset(e) {
          (this._assets[e.uuid] = e), v.emit("onRegisterAsset", e);
        }
        loadAsset(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            const t = this.getAsset(e);
            if (t) return t;
            const n = this.getAssetPath(e);
            if (!n) return;
            const i = this.getExtension(n);
            return "roguePrefab" === i
              ? yield this.loadObject(n)
              : "rogueAnimation" === i
              ? yield this.loadAnimation(n)
              : Z.indexOf(i) >= 0
              ? yield this.loadAudio(n)
              : "rogueMaterial" === i
              ? yield this.loadMaterial(n)
              : H.indexOf(i) >= 0
              ? yield this.loadTexture(n)
              : void 0;
          });
        }
        getExtension(e) {
          return e.substr(e.lastIndexOf(".") + 1);
        }
        getAsset(e) {
          return this._assets[e];
        }
        loadObject(e) {
          if (this._loadingAssets[e]) return this._loadingAssets[e];
          const t = this.loadObjectFunction(e);
          return this.addLoadingAsset(e, t), t;
        }
        loadObjectFunction(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            let t = yield fetch(e),
              n = yield t.json();

            const i = this._objectLoader.parse(n);

            return (
              (i.uuid = n.object.uuid),
              this.registerAsset(i),
              yield this.loadNestedPrefabs(i),
              this.removeLoadingAsset(e),
              i
            );
          });
        }
        loadNestedPrefabs(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            const t = e.userData.__NESTED__;
            if (t)
              for (let e = 0; e < t.length; e++)
                yield this.loadAsset(t[e].uuid);
            for (let n = 0; n < e.children.length; n++)
              yield this.loadNestedPrefabs(e.children[n]);
          });
        }
        loadAudio(e) {
          if (this._loadingAssets[e]) return this._loadingAssets[e];
          const t = this.loadAudioFunction(e);
          return this.addLoadingAsset(e, t), t;
        }
        loadAudioFunction(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            const t = yield AudioAsset_AudioAsset.fromFile(e);
            return this.registerAsset(t), this.removeLoadingAsset(e), t;
          });
        }
        loadAnimation(e) {
          if (this._loadingAssets[e]) return this._loadingAssets[e];
          const t = this.loadAnimationFunction(e);
          return this.addLoadingAsset(e, t), t;
        }
        loadAnimationFunction(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            let t = yield fetch(e),
              n = yield t.json();
            const s = i.AnimationClip.parse(n);
            return this.registerAsset(s), this.removeLoadingAsset(e), s;
          });
        }
        loadMaterial(e) {
          if (this._loadingAssets[e]) return this._loadingAssets[e];
          const t = this.loadMaterialFunction(e);
          return this.addLoadingAsset(e, t), t;
        }
        loadMaterialFunction(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            const t = yield fetch(e),
              n = yield t.json(),
              i = [];
            for (let e in n.textures) {
              const t = n.textures[e],
                s = "string" === typeof t ? t : t.uuid,
                o = this.getAssetPath(s);
              !this.getAsset(s) && o && (yield this.loadTexture(o)),
                o && i.push(s);
            }
            const s = {};
            for (let e in n.materials[0]) {
              const t = n.materials[0];
              i.forEach((n) => {
                n === t[e] && (s[e] = n);
              });
            }
            const o = n.textures;
            n.textures = [];
            const r = this._objectLoader.parse(n).material;
            n.textures = o;
            for (let e in s) {
              const t = s[e];
              r[e] = this.getAsset(t);
            }
            return this.registerAsset(r), this.removeLoadingAsset(e), r;
          });
        }
        loadTexture(e) {
          if (this._loadingAssets[e]) return this._loadingAssets[e];
          const t = this.loadTextureFunction(e);
          return this.addLoadingAsset(e, t), t;
        }
        loadTextureFunction(e) {
          return Object(s.a)(this, void 0, void 0, function* () {
            let t = yield fetch(e + ".meta"),
              n = yield t.json();
            const i = yield this.loadTextureFile(e, n);
            return this.registerAsset(i), this.removeLoadingAsset(e), i;
          });
        }
        async loadTextureFile(e, t) {
          return new Promise((n) => {
            this.textureLoader.load(e, (e) => {
              Object.keys(t.object).forEach((n) => {
                "repeat" === n || "center" === n || "offset" === n
                  ? ((e[n].x = t.object[n][0]), (e[n].y = t.object[n][1]))
                  : "wrap" === n
                  ? ((e.wrapS = t.object[n][0]), (e.wrapT = t.object[n][1]))
                  : "image" === n || (e[n] = t.object[n]);
              }),
                this.sceneController &&
                  this.sceneController.renderer.initTexture(e),
                n(e);
            });
          });
        }
        addLoadingAsset(e, t) {
          this._loadingAssets[e] = t;
        }
        removeLoadingAsset(e) {
          delete this._loadingAssets[e];
        }
        removeAsset(e) {
          const t = this._assets[e];
          delete this._assets[e], v.emit("onRemoveAsset", e, t);
        }
        clear() {
          for (const e in this._assets) delete this._assets[e];
          v.emit("onClearAssets");
        }
        assetIsOrphan(e) {
          const t = this.getAsset(e);
          if (!t) return !1;
          let n = !0;
          return (
            traverseComponents((e) => {
              for (const i in e.interface)
                Y.indexOf(i) >= 0 && e[i] === t && (n = !1);
            }),
            t instanceof i.Material &&
              App_App.currentScene.traverse((e) => {
                e && e.material === t && (n = !1);
              }),
            t instanceof i.Texture &&
              App_App.currentScene.traverse((e) => {
                if (e && e.material instanceof i.Material)
                  for (let s in e.material)
                    e.material[s] instanceof i.Texture &&
                      e.material[s] === t &&
                      (n = !1);
              }),
            n
          );
        }
        loadAssetConfigs(e = {}) {
          const t = this._assetConfigs,
            n = Object.keys(this._assets);
          for (const i in t) {
            const n = e[i] && e[i].override;
            t[i].override && !n && (e[i] = t[i]);
          }
          n.forEach((n) => {
            const i = !!t[n] && t[n].keepLoaded,
              s = !!e[n] && e[n].preload;
            i || s || this.removeAsset(n);
          }),
            (this._assetConfigs = e),
            v.emit("onLoadAssetConfigs");
        }
        preloadAssets() {
          return Object(s.a)(this, void 0, void 0, function* () {
            for (let e in this._assetConfigs)
              !this._assets[e] &&
                this._assetConfigs[e].preload &&
                (yield this.loadAsset(e));
          });
        }
      })();
      function Prop(e) {
        return function (t, n) {
          t.constructor.interface || (t.constructor.interface = {}),
            (t.constructor.interface[n] = e);
        };
      }
      function PropList(e) {
        return function (t, n) {
          t.constructor.interface || (t.constructor.interface = {}),
            (t.constructor.interface[n] = [e]);
        };
      }
      let ee,
        te = "",
        ne = !1,
        ie = {};
      function decoratorFunc(e, t) {
        if ("button" === te && "function" !== typeof e[t])
          return Decorators_reset();
        e.constructor.interface || (e.constructor.interface = {}),
          (e.constructor.interface = Object.assign(
            {},
            e.constructor.interface
          ));
        const n = { type: te, group: ee, options: ie };
        (e.constructor.interface[t] = ne ? [n] : n), Decorators_reset();
      }
      function Decorators_reset() {
        (ne = !1), (ee = void 0), (ie = {});
      }
      class Decorators {
        num(e, t) {
          return (te = "Number"), (ie.min = e), (ie.max = t), decoratorFunc;
        }
        checkbox() {
          return (te = "Boolean"), decoratorFunc;
        }
        text(e) {
          return (te = "String"), (ie.isTextArea = e), decoratorFunc;
        }
        code(e) {
          return (
            (te = "Code"),
            "json" === e
              ? (ie.lang = "application/json")
              : "html" === e
              ? (ie.lang = "text/html")
              : "glsl" === e && (ie.lang = e),
            decoratorFunc
          );
        }
        select() {
          return (te = "Select"), decoratorFunc;
        }
        vector2() {
          return (te = "Vector2"), decoratorFunc;
        }
        vector3() {
          return (te = "Vector3"), decoratorFunc;
        }
        prefab() {
          return (te = "Prefab"), decoratorFunc;
        }
        material() {
          return (te = "Material"), decoratorFunc;
        }
        texture() {
          return (te = "Texture"), decoratorFunc;
        }
        object3d() {
          return (te = "Object3D"), decoratorFunc;
        }
        audio(e) {
          return (te = e ? "PositionalAudio" : "Audio"), decoratorFunc;
        }
        color() {
          return (te = "Color"), decoratorFunc;
        }
        animation() {
          return (te = "AnimationClip"), decoratorFunc;
        }
        button() {
          return (te = "Button"), decoratorFunc;
        }
      }
      class ListProp extends Decorators {}
      const se = new (class Props extends Decorators {
        constructor() {
          super(...arguments), (this._list = new ListProp());
        }
        get list() {
          return (ne = !0), this._list;
        }
        data() {
          return (te = "Data"), decoratorFunc;
        }
      })();
      function resetClonedSkinnedMeshes(e, t) {
        const n = [],
          i = {},
          s = {};
        !(function parallelTraverse(e, t, n) {
          n(e, t);
          for (var i = 0; i < e.children.length; i++)
            parallelTraverse(e.children[i], t.children[i], n);
        })(e, t, function (e, t) {
          e.isSkinnedMesh && ((i[t.uuid] = e), n.push(t)),
            e.isBone && (s[e.uuid] = t);
        });
        for (let o = 0, r = n.length; o < r; o++) {
          const e = n[o],
            t = i[e.uuid],
            r = t.skeleton.bones;
          (e.skeleton = t.skeleton.clone()),
            e.bindMatrix.copy(t.bindMatrix),
            (e.skeleton.bones = r.map(function (e) {
              return s[e.uuid];
            })),
            e.bind(e.skeleton, e.bindMatrix);
        }
      }
      n.d(t, "AssetManager", function () {
        return Q;
      }),
        n.d(t, "AudioAsset", function () {
          return AudioAsset_AudioAsset;
        }),
        n.d(t, "Prefab", function () {
          return Prefab_Prefab;
        }),
        n.d(t, "Component", function () {
          return Component_Component;
        }),
        n.d(t, "Skybox", function () {
          return E;
        }),
        n.d(t, "Input", function () {
          return Input;
        }),
        n.d(t, "traverseComponents", function () {
          return traverseComponents;
        }),
        n.d(t, "registerComponent", function () {
          return registerComponent;
        }),
        n.d(t, "components", function () {
          return P;
        }),
        n.d(t, "editorComponents", function () {
          return R;
        }),
        n.d(t, "serializeComponents", function () {
          return M;
        }),
        n.d(t, "initComponents", function () {
          return D;
        }),
        n.d(t, "initEditorComponents", function () {
          return L;
        }),
        n.d(t, "clearComponents", function () {
          return clearComponents;
        }),
        n.d(t, "loadComponents", function () {
          return T;
        }),
        n.d(t, "addComponent", function () {
          return B;
        }),
        n.d(t, "removeComponent", function () {
          return F;
        }),
        n.d(t, "removeComponents", function () {
          return I;
        }),
        n.d(t, "getComponent", function () {
          return U;
        }),
        n.d(t, "getComponents", function () {
          return z;
        }),
        n.d(t, "getComponentByName", function () {
          return getComponentByName;
        }),
        n.d(t, "getObjectComponents", function () {
          return G;
        }),
        n.d(t, "getComponentPrototypes", function () {
          return getComponentPrototypes;
        }),
        n.d(t, "copyObjectComponents", function () {
          return copyObjectComponents;
        }),
        n.d(t, "App", function () {
          return App_App;
        }),
        n.d(t, "SceneController", function () {
          return SceneController_SceneController;
        }),
        n.d(t, "Runtime", function () {
          return y;
        }),
        n.d(t, "RuntimeController", function () {
          return RuntimeController_RuntimeController;
        }),
        n.d(t, "Debug", function () {
          return Debug;
        }),
        n.d(t, "Log", function () {
          return Log;
        }),
        n.d(t, "Error", function () {
          return Debug_Error;
        }),
        n.d(t, "Warning", function () {
          return Warning;
        }),
        n.d(t, "onObjectAdded", function () {
          return onObjectAdded;
        }),
        n.d(t, "onComponentAdded", function () {
          return onComponentAdded;
        }),
        n.d(t, "onComponentLoaded", function () {
          return onComponentLoaded;
        }),
        n.d(t, "onComponentRemoved", function () {
          return onComponentRemoved;
        }),
        n.d(t, "onObjectRemoved", function () {
          return onObjectRemoved;
        }),
        n.d(t, "onBeforeUpdate", function () {
          return onBeforeUpdate;
        }),
        n.d(t, "onUpdate", function () {
          return onUpdate;
        }),
        n.d(t, "onAfterUpdate", function () {
          return onAfterUpdate;
        }),
        n.d(t, "onNextFrame", function () {
          return onNextFrame;
        }),
        n.d(t, "isDev", function () {
          return isDev;
        }),
        n.d(t, "getStaticPath", function () {
          return getStaticPath;
        }),
        n.d(t, "dispose", function () {
          return dispose;
        }),
        n.d(t, "isActive", function () {
          return isActive;
        }),
        n.d(t, "isEnabled", function () {
          return isEnabled;
        }),
        n.d(t, "setEnabled", function () {
          return setEnabled;
        }),
        n.d(t, "Prop", function () {
          return Prop;
        }),
        n.d(t, "PropList", function () {
          return PropList;
        }),
        n.d(t, "props", function () {
          return se;
        }),
        n.d(t, "Tags", function () {
          return Tags;
        });
      const oe = i.Object3D.prototype.clone;
      i.Object3D.prototype.clone = function (e) {
        const t = oe.bind(this)(e);
        return resetClonedSkinnedMeshes(this, t), t;
      };
    },
    17: function (e, t, n) {
      var i = n(18),
        s = n(24),
        o = "Expected a function";
      e.exports = function throttle(e, t, n) {
        var r = !0,
          a = !0;
        if ("function" != typeof e) throw new TypeError(o);
        return (
          s(n) &&
            ((r = "leading" in n ? !!n.leading : r),
            (a = "trailing" in n ? !!n.trailing : a)),
          i(e, t, { leading: r, maxWait: t, trailing: a })
        );
      };
    },
    18: function (e, t, n) {
      var i = n(24),
        s = n(37),
        o = n(39),
        r = "Expected a function",
        a = Math.max,
        u = Math.min;
      e.exports = function debounce(e, t, n) {
        var c,
          h,
          d,
          l,
          p,
          f,
          m = 0,
          _ = !1,
          g = !1,
          b = !0;
        if ("function" != typeof e) throw new TypeError(r);
        function invokeFunc(t) {
          var n = c,
            i = h;
          return (c = h = void 0), (m = t), (l = e.apply(i, n));
        }
        function shouldInvoke(e) {
          var n = e - f;
          return void 0 === f || n >= t || n < 0 || (g && e - m >= d);
        }
        function timerExpired() {
          var e = s();
          if (shouldInvoke(e)) return trailingEdge(e);
          p = setTimeout(
            timerExpired,
            (function remainingWait(e) {
              var n = t - (e - f);
              return g ? u(n, d - (e - m)) : n;
            })(e)
          );
        }
        function trailingEdge(e) {
          return (p = void 0), b && c ? invokeFunc(e) : ((c = h = void 0), l);
        }
        function debounced() {
          var e = s(),
            n = shouldInvoke(e);
          if (((c = arguments), (h = this), (f = e), n)) {
            if (void 0 === p)
              return (function leadingEdge(e) {
                return (
                  (m = e),
                  (p = setTimeout(timerExpired, t)),
                  _ ? invokeFunc(e) : l
                );
              })(f);
            if (g)
              return (
                clearTimeout(p),
                (p = setTimeout(timerExpired, t)),
                invokeFunc(f)
              );
          }
          return void 0 === p && (p = setTimeout(timerExpired, t)), l;
        }
        return (
          (t = o(t) || 0),
          i(n) &&
            ((_ = !!n.leading),
            (d = (g = "maxWait" in n) ? a(o(n.maxWait) || 0, t) : d),
            (b = "trailing" in n ? !!n.trailing : b)),
          (debounced.cancel = function cancel() {
            void 0 !== p && clearTimeout(p), (m = 0), (c = f = h = p = void 0);
          }),
          (debounced.flush = function flush() {
            return void 0 === p ? l : trailingEdge(s());
          }),
          debounced
        );
      };
    },
    19: function (e, t, n) {
      var i = n(28),
        s = n(29);
      e.exports = function v4(e, t, n) {
        var o = (t && n) || 0;
        "string" == typeof e &&
          ((t = "binary" === e ? new Array(16) : null), (e = null));
        var r = (e = e || {}).random || (e.rng || i)();
        if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), t))
          for (var a = 0; a < 16; ++a) t[o + a] = r[a];
        return t || s(r);
      };
    },
    24: function (e, t) {
      e.exports = function isObject(e) {
        var t = typeof e;
        return null != e && ("object" == t || "function" == t);
      };
    },
    26: function (e, t, n) {
      var i = n(38),
        s = "object" == typeof self && self && self.Object === Object && self,
        o = i || s || Function("return this")();
      e.exports = o;
    },
    27: function (e, t, n) {
      var i = n(26).Symbol;
      e.exports = i;
    },
    28: function (e, t) {
      var n =
        ("undefined" != typeof crypto &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)) ||
        ("undefined" != typeof msCrypto &&
          "function" == typeof window.msCrypto.getRandomValues &&
          msCrypto.getRandomValues.bind(msCrypto));
      if (n) {
        var i = new Uint8Array(16);
        e.exports = function whatwgRNG() {
          return n(i), i;
        };
      } else {
        var s = new Array(16);
        e.exports = function mathRNG() {
          for (var e, t = 0; t < 16; t++)
            0 === (3 & t) && (e = 4294967296 * Math.random()),
              (s[t] = (e >>> ((3 & t) << 3)) & 255);
          return s;
        };
      }
    },
    29: function (e, t) {
      for (var n = [], i = 0; i < 256; ++i)
        n[i] = (i + 256).toString(16).substr(1);
      e.exports = function bytesToUuid(e, t) {
        var i = t || 0,
          s = n;
        return [
          s[e[i++]],
          s[e[i++]],
          s[e[i++]],
          s[e[i++]],
          "-",
          s[e[i++]],
          s[e[i++]],
          "-",
          s[e[i++]],
          s[e[i++]],
          "-",
          s[e[i++]],
          s[e[i++]],
          "-",
          s[e[i++]],
          s[e[i++]],
          s[e[i++]],
          s[e[i++]],
          s[e[i++]],
          s[e[i++]],
        ].join("");
      };
    },
    30: function (e, t, n) {
      "use strict";
      var i,
        s = "object" === typeof Reflect ? Reflect : null,
        o =
          s && "function" === typeof s.apply
            ? s.apply
            : function ReflectApply(e, t, n) {
                return Function.prototype.apply.call(e, t, n);
              };
      i =
        s && "function" === typeof s.ownKeys
          ? s.ownKeys
          : Object.getOwnPropertySymbols
          ? function ReflectOwnKeys(e) {
              return Object.getOwnPropertyNames(e).concat(
                Object.getOwnPropertySymbols(e)
              );
            }
          : function ReflectOwnKeys(e) {
              return Object.getOwnPropertyNames(e);
            };
      var r =
        Number.isNaN ||
        function NumberIsNaN(e) {
          return e !== e;
        };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      (e.exports = EventEmitter),
        (EventEmitter.EventEmitter = EventEmitter),
        (EventEmitter.prototype._events = void 0),
        (EventEmitter.prototype._eventsCount = 0),
        (EventEmitter.prototype._maxListeners = void 0);
      var a = 10;
      function $getMaxListeners(e) {
        return void 0 === e._maxListeners
          ? EventEmitter.defaultMaxListeners
          : e._maxListeners;
      }
      function _addListener(e, t, n, i) {
        var s, o, r;
        if ("function" !== typeof n)
          throw new TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof n
          );
        if (
          (void 0 === (o = e._events)
            ? ((o = e._events = Object.create(null)), (e._eventsCount = 0))
            : (void 0 !== o.newListener &&
                (e.emit("newListener", t, n.listener ? n.listener : n),
                (o = e._events)),
              (r = o[t])),
          void 0 === r)
        )
          (r = o[t] = n), ++e._eventsCount;
        else if (
          ("function" === typeof r
            ? (r = o[t] = i ? [n, r] : [r, n])
            : i
            ? r.unshift(n)
            : r.push(n),
          (s = $getMaxListeners(e)) > 0 && r.length > s && !r.warned)
        ) {
          r.warned = !0;
          var a = new Error(
            "Possible EventEmitter memory leak detected. " +
              r.length +
              " " +
              String(t) +
              " listeners added. Use emitter.setMaxListeners() to increase limit"
          );
          (a.name = "MaxListenersExceededWarning"),
            (a.emitter = e),
            (a.type = t),
            (a.count = r.length),
            (function ProcessEmitWarning(e) {
              console && console.warn && console.warn(e);
            })(a);
        }
        return e;
      }
      function _onceWrap(e, t, n) {
        var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n },
          s = function onceWrapper() {
            for (var e = [], t = 0; t < arguments.length; t++)
              e.push(arguments[t]);
            this.fired ||
              (this.target.removeListener(this.type, this.wrapFn),
              (this.fired = !0),
              o(this.listener, this.target, e));
          }.bind(i);
        return (s.listener = n), (i.wrapFn = s), s;
      }
      function _listeners(e, t, n) {
        var i = e._events;
        if (void 0 === i) return [];
        var s = i[t];
        return void 0 === s
          ? []
          : "function" === typeof s
          ? n
            ? [s.listener || s]
            : [s]
          : n
          ? (function unwrapListeners(e) {
              for (var t = new Array(e.length), n = 0; n < t.length; ++n)
                t[n] = e[n].listener || e[n];
              return t;
            })(s)
          : arrayClone(s, s.length);
      }
      function listenerCount(e) {
        var t = this._events;
        if (void 0 !== t) {
          var n = t[e];
          if ("function" === typeof n) return 1;
          if (void 0 !== n) return n.length;
        }
        return 0;
      }
      function arrayClone(e, t) {
        for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e[i];
        return n;
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: !0,
        get: function get() {
          return a;
        },
        set: function set(e) {
          if ("number" !== typeof e || e < 0 || r(e))
            throw new RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          a = e;
        },
      }),
        (EventEmitter.init = function () {
          (void 0 !== this._events &&
            this._events !== Object.getPrototypeOf(this)._events) ||
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (EventEmitter.prototype.setMaxListeners = function setMaxListeners(e) {
          if ("number" !== typeof e || e < 0 || r(e))
            throw new RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          return (this._maxListeners = e), this;
        }),
        (EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this);
        }),
        (EventEmitter.prototype.emit = function emit(e) {
          for (var t = [], n = 1; n < arguments.length; n++)
            t.push(arguments[n]);
          var i = "error" === e,
            s = this._events;
          if (void 0 !== s) i = i && void 0 === s.error;
          else if (!i) return !1;
          if (i) {
            var r;
            if ((t.length > 0 && (r = t[0]), r instanceof Error)) throw r;
            var a = new Error(
              "Unhandled error." + (r ? " (" + r.message + ")" : "")
            );
            throw ((a.context = r), a);
          }
          var u = s[e];
          if (void 0 === u) return !1;
          if ("function" === typeof u) o(u, this, t);
          else {
            var c = u.length,
              h = arrayClone(u, c);
            for (n = 0; n < c; ++n) o(h[n], this, t);
          }
          return !0;
        }),
        (EventEmitter.prototype.addListener = function addListener(e, t) {
          return _addListener(this, e, t, !1);
        }),
        (EventEmitter.prototype.on = EventEmitter.prototype.addListener),
        (EventEmitter.prototype.prependListener = function prependListener(
          e,
          t
        ) {
          return _addListener(this, e, t, !0);
        }),
        (EventEmitter.prototype.once = function once(e, t) {
          if ("function" !== typeof t)
            throw new TypeError(
              'The "listener" argument must be of type Function. Received type ' +
                typeof t
            );
          return this.on(e, _onceWrap(this, e, t)), this;
        }),
        (EventEmitter.prototype.prependOnceListener =
          function prependOnceListener(e, t) {
            if ("function" !== typeof t)
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof t
              );
            return this.prependListener(e, _onceWrap(this, e, t)), this;
          }),
        (EventEmitter.prototype.removeListener = function removeListener(e, t) {
          var n, i, s, o, r;
          if ("function" !== typeof t)
            throw new TypeError(
              'The "listener" argument must be of type Function. Received type ' +
                typeof t
            );
          if (void 0 === (i = this._events)) return this;
          if (void 0 === (n = i[e])) return this;
          if (n === t || n.listener === t)
            0 === --this._eventsCount
              ? (this._events = Object.create(null))
              : (delete i[e],
                i.removeListener &&
                  this.emit("removeListener", e, n.listener || t));
          else if ("function" !== typeof n) {
            for (s = -1, o = n.length - 1; o >= 0; o--)
              if (n[o] === t || n[o].listener === t) {
                (r = n[o].listener), (s = o);
                break;
              }
            if (s < 0) return this;
            0 === s
              ? n.shift()
              : (function spliceOne(e, t) {
                  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                  e.pop();
                })(n, s),
              1 === n.length && (i[e] = n[0]),
              void 0 !== i.removeListener &&
                this.emit("removeListener", e, r || t);
          }
          return this;
        }),
        (EventEmitter.prototype.off = EventEmitter.prototype.removeListener),
        (EventEmitter.prototype.removeAllListeners =
          function removeAllListeners(e) {
            var t, n, i;
            if (void 0 === (n = this._events)) return this;
            if (void 0 === n.removeListener)
              return (
                0 === arguments.length
                  ? ((this._events = Object.create(null)),
                    (this._eventsCount = 0))
                  : void 0 !== n[e] &&
                    (0 === --this._eventsCount
                      ? (this._events = Object.create(null))
                      : delete n[e]),
                this
              );
            if (0 === arguments.length) {
              var s,
                o = Object.keys(n);
              for (i = 0; i < o.length; ++i)
                "removeListener" !== (s = o[i]) && this.removeAllListeners(s);
              return (
                this.removeAllListeners("removeListener"),
                (this._events = Object.create(null)),
                (this._eventsCount = 0),
                this
              );
            }
            if ("function" === typeof (t = n[e])) this.removeListener(e, t);
            else if (void 0 !== t)
              for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
            return this;
          }),
        (EventEmitter.prototype.listeners = function listeners(e) {
          return _listeners(this, e, !0);
        }),
        (EventEmitter.prototype.rawListeners = function rawListeners(e) {
          return _listeners(this, e, !1);
        }),
        (EventEmitter.listenerCount = function (e, t) {
          return "function" === typeof e.listenerCount
            ? e.listenerCount(t)
            : listenerCount.call(e, t);
        }),
        (EventEmitter.prototype.listenerCount = listenerCount),
        (EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? i(this._events) : [];
        });
    },
    37: function (e, t, n) {
      var i = n(26);
      e.exports = function now() {
        return i.Date.now();
      };
    },
    38: function (e, t) {
      var n =
        "object" == typeof global &&
        global &&
        global.Object === Object &&
        global;
      e.exports = n;
    },
    39: function (e, t, n) {
      var i = n(24),
        s = n(40),
        o = NaN,
        r = /^\s+|\s+$/g,
        a = /^[-+]0x[0-9a-f]+$/i,
        u = /^0b[01]+$/i,
        c = /^0o[0-7]+$/i,
        h = parseInt;
      e.exports = function toNumber(e) {
        if ("number" == typeof e) return e;
        if (s(e)) return o;
        if (i(e)) {
          var t = "function" == typeof e.valueOf ? e.valueOf() : e;
          e = i(t) ? t + "" : t;
        }
        if ("string" != typeof e) return 0 === e ? e : +e;
        e = e.replace(r, "");
        var n = u.test(e);
        return n || c.test(e) ? h(e.slice(2), n ? 2 : 8) : a.test(e) ? o : +e;
      };
    },
    40: function (e, t, n) {
      var i = n(41),
        s = n(44),
        o = "[object Symbol]";
      e.exports = function isSymbol(e) {
        return "symbol" == typeof e || (s(e) && i(e) == o);
      };
    },
    41: function (e, t, n) {
      var i = n(27),
        s = n(42),
        o = n(43),
        r = "[object Null]",
        a = "[object Undefined]",
        u = i ? i.toStringTag : void 0;
      e.exports = function baseGetTag(e) {
        return null == e
          ? void 0 === e
            ? a
            : r
          : u && u in Object(e)
          ? s(e)
          : o(e);
      };
    },
    42: function (e, t, n) {
      var i = n(27),
        s = Object.prototype,
        o = s.hasOwnProperty,
        r = s.toString,
        a = i ? i.toStringTag : void 0;
      e.exports = function getRawTag(e) {
        var t = o.call(e, a),
          n = e[a];
        try {
          e[a] = void 0;
          var i = !0;
        } catch (u) {}
        var s = r.call(e);
        return i && (t ? (e[a] = n) : delete e[a]), s;
      };
    },
    43: function (e, t) {
      var n = Object.prototype.toString;
      e.exports = function objectToString(e) {
        return n.call(e);
      };
    },
    44: function (e, t) {
      e.exports = function isObjectLike(e) {
        return null != e && "object" == typeof e;
      };
    },
  });
});
//# sourceMappingURL=rogue-engine.js.map
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory(require("rogue-engine"), require("three"));
  else if (typeof define === "function" && define.amd)
    define(["rogue-engine", "three"], factory);
  else if (typeof exports === "object")
    exports["rogue-engine-user-scripts"] = factory(
      require("rogue-engine"),
      require("three")
    );
  else
    root["rogue-engine-user-scripts"] = factory(
      root["rogue-engine"],
      root["three"]
    );
})(
  self,
  function (
    __WEBPACK_EXTERNAL_MODULE_rogue_engine__,
    __WEBPACK_EXTERNAL_MODULE_three__
  ) {
    return /******/ (() => {
      // webpackBootstrap
      /******/ "use strict";
      /******/ var __webpack_modules__ = {
        /***/ "./node_modules/cannon-es/dist/cannon-es.js":
          /*!**************************************************!*\
  !*** ./node_modules/cannon-es/dist/cannon-es.js ***!
  \**************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ AABB: () => /* binding */ AABB,
              /* harmony export */ ArrayCollisionMatrix: () =>
                /* binding */ ArrayCollisionMatrix,
              /* harmony export */ BODY_SLEEP_STATES: () =>
                /* binding */ BODY_SLEEP_STATES,
              /* harmony export */ BODY_TYPES: () => /* binding */ BODY_TYPES,
              /* harmony export */ Body: () => /* binding */ Body,
              /* harmony export */ Box: () => /* binding */ Box,
              /* harmony export */ Broadphase: () => /* binding */ Broadphase,
              /* harmony export */ COLLISION_TYPES: () =>
                /* binding */ COLLISION_TYPES,
              /* harmony export */ ConeTwistConstraint: () =>
                /* binding */ ConeTwistConstraint,
              /* harmony export */ Constraint: () => /* binding */ Constraint,
              /* harmony export */ ContactEquation: () =>
                /* binding */ ContactEquation,
              /* harmony export */ ContactMaterial: () =>
                /* binding */ ContactMaterial,
              /* harmony export */ ConvexPolyhedron: () =>
                /* binding */ ConvexPolyhedron,
              /* harmony export */ Cylinder: () => /* binding */ Cylinder,
              /* harmony export */ DistanceConstraint: () =>
                /* binding */ DistanceConstraint,
              /* harmony export */ Equation: () => /* binding */ Equation,
              /* harmony export */ EventTarget: () => /* binding */ EventTarget,
              /* harmony export */ FrictionEquation: () =>
                /* binding */ FrictionEquation,
              /* harmony export */ GSSolver: () => /* binding */ GSSolver,
              /* harmony export */ GridBroadphase: () =>
                /* binding */ GridBroadphase,
              /* harmony export */ Heightfield: () => /* binding */ Heightfield,
              /* harmony export */ HingeConstraint: () =>
                /* binding */ HingeConstraint,
              /* harmony export */ JacobianElement: () =>
                /* binding */ JacobianElement,
              /* harmony export */ LockConstraint: () =>
                /* binding */ LockConstraint,
              /* harmony export */ Mat3: () => /* binding */ Mat3,
              /* harmony export */ Material: () => /* binding */ Material,
              /* harmony export */ NaiveBroadphase: () =>
                /* binding */ NaiveBroadphase,
              /* harmony export */ Narrowphase: () => /* binding */ Narrowphase,
              /* harmony export */ ObjectCollisionMatrix: () =>
                /* binding */ ObjectCollisionMatrix,
              /* harmony export */ Particle: () => /* binding */ Particle,
              /* harmony export */ Plane: () => /* binding */ Plane,
              /* harmony export */ PointToPointConstraint: () =>
                /* binding */ PointToPointConstraint,
              /* harmony export */ Pool: () => /* binding */ Pool,
              /* harmony export */ Quaternion: () => /* binding */ Quaternion,
              /* harmony export */ RAY_MODES: () => /* binding */ RAY_MODES,
              /* harmony export */ Ray: () => /* binding */ Ray,
              /* harmony export */ RaycastResult: () =>
                /* binding */ RaycastResult,
              /* harmony export */ RaycastVehicle: () =>
                /* binding */ RaycastVehicle,
              /* harmony export */ RigidVehicle: () =>
                /* binding */ RigidVehicle,
              /* harmony export */ RotationalEquation: () =>
                /* binding */ RotationalEquation,
              /* harmony export */ RotationalMotorEquation: () =>
                /* binding */ RotationalMotorEquation,
              /* harmony export */ SAPBroadphase: () =>
                /* binding */ SAPBroadphase,
              /* harmony export */ SHAPE_TYPES: () => /* binding */ SHAPE_TYPES,
              /* harmony export */ SPHSystem: () => /* binding */ SPHSystem,
              /* harmony export */ Shape: () => /* binding */ Shape,
              /* harmony export */ Solver: () => /* binding */ Solver,
              /* harmony export */ Sphere: () => /* binding */ Sphere,
              /* harmony export */ SplitSolver: () => /* binding */ SplitSolver,
              /* harmony export */ Spring: () => /* binding */ Spring,
              /* harmony export */ Transform: () => /* binding */ Transform,
              /* harmony export */ Trimesh: () => /* binding */ Trimesh,
              /* harmony export */ Vec3: () => /* binding */ Vec3,
              /* harmony export */ Vec3Pool: () => /* binding */ Vec3Pool,
              /* harmony export */ WheelInfo: () => /* binding */ WheelInfo,
              /* harmony export */ World: () => /* binding */ World,
              /* harmony export */
            });
            /**
             * Records what objects are colliding with each other
             */
            class ObjectCollisionMatrix {
              /**
               * The matrix storage.
               */

              /**
               * @todo Remove useless constructor
               */
              constructor() {
                this.matrix = void 0;
                this.matrix = {};
              }
              /**
               * get
               */

              get(bi, bj) {
                let { id: i } = bi;
                let { id: j } = bj;

                if (j > i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                return i + "-" + j in this.matrix;
              }
              /**
               * set
               */

              set(bi, bj, value) {
                let { id: i } = bi;
                let { id: j } = bj;

                if (j > i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                if (value) {
                  this.matrix[i + "-" + j] = true;
                } else {
                  delete this.matrix[i + "-" + j];
                }
              }
              /**
               * Empty the matrix
               */

              reset() {
                this.matrix = {};
              }
              /**
               * Set max number of objects
               */

              setNumObjects(n) {}
            }

            /**
             * A 3x3 matrix.
             * Authored by {@link http://github.com/schteppe/ schteppe}
             */
            class Mat3 {
              /**
               * A vector of length 9, containing all matrix elements.
               */

              /**
               * @param elements A vector of length 9, containing all matrix elements.
               */
              constructor(elements = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
                this.elements = void 0;
                this.elements = elements;
              }
              /**
               * Sets the matrix to identity
               * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
               * @todo Create another function that immediately creates an identity matrix eg. `eye()`
               */

              identity() {
                const e = this.elements;
                e[0] = 1;
                e[1] = 0;
                e[2] = 0;
                e[3] = 0;
                e[4] = 1;
                e[5] = 0;
                e[6] = 0;
                e[7] = 0;
                e[8] = 1;
              }
              /**
               * Set all elements to zero
               */

              setZero() {
                const e = this.elements;
                e[0] = 0;
                e[1] = 0;
                e[2] = 0;
                e[3] = 0;
                e[4] = 0;
                e[5] = 0;
                e[6] = 0;
                e[7] = 0;
                e[8] = 0;
              }
              /**
               * Sets the matrix diagonal elements from a Vec3
               */

              setTrace(vector) {
                const e = this.elements;
                e[0] = vector.x;
                e[4] = vector.y;
                e[8] = vector.z;
              }
              /**
               * Gets the matrix diagonal elements
               */

              getTrace(target = new Vec3()) {
                const e = this.elements;
                target.x = e[0];
                target.y = e[4];
                target.z = e[8];
                return target;
              }
              /**
               * Matrix-Vector multiplication
               * @param v The vector to multiply with
               * @param target Optional, target to save the result in.
               */

              vmult(v, target = new Vec3()) {
                const e = this.elements;
                const x = v.x;
                const y = v.y;
                const z = v.z;
                target.x = e[0] * x + e[1] * y + e[2] * z;
                target.y = e[3] * x + e[4] * y + e[5] * z;
                target.z = e[6] * x + e[7] * y + e[8] * z;
                return target;
              }
              /**
               * Matrix-scalar multiplication
               */

              smult(s) {
                for (let i = 0; i < this.elements.length; i++) {
                  this.elements[i] *= s;
                }
              }
              /**
               * Matrix multiplication
               * @param matrix Matrix to multiply with from left side.
               */

              mmult(matrix, target = new Mat3()) {
                const A = this.elements;
                const B = matrix.elements;
                const T = target.elements;
                const a11 = A[0],
                  a12 = A[1],
                  a13 = A[2],
                  a21 = A[3],
                  a22 = A[4],
                  a23 = A[5],
                  a31 = A[6],
                  a32 = A[7],
                  a33 = A[8];
                const b11 = B[0],
                  b12 = B[1],
                  b13 = B[2],
                  b21 = B[3],
                  b22 = B[4],
                  b23 = B[5],
                  b31 = B[6],
                  b32 = B[7],
                  b33 = B[8];
                T[0] = a11 * b11 + a12 * b21 + a13 * b31;
                T[1] = a11 * b12 + a12 * b22 + a13 * b32;
                T[2] = a11 * b13 + a12 * b23 + a13 * b33;
                T[3] = a21 * b11 + a22 * b21 + a23 * b31;
                T[4] = a21 * b12 + a22 * b22 + a23 * b32;
                T[5] = a21 * b13 + a22 * b23 + a23 * b33;
                T[6] = a31 * b11 + a32 * b21 + a33 * b31;
                T[7] = a31 * b12 + a32 * b22 + a33 * b32;
                T[8] = a31 * b13 + a32 * b23 + a33 * b33;
                return target;
              }
              /**
               * Scale each column of the matrix
               */

              scale(vector, target = new Mat3()) {
                const e = this.elements;
                const t = target.elements;

                for (let i = 0; i !== 3; i++) {
                  t[3 * i + 0] = vector.x * e[3 * i + 0];
                  t[3 * i + 1] = vector.y * e[3 * i + 1];
                  t[3 * i + 2] = vector.z * e[3 * i + 2];
                }

                return target;
              }
              /**
               * Solve Ax=b
               * @param b The right hand side
               * @param target Optional. Target vector to save in.
               * @return The solution x
               * @todo should reuse arrays
               */

              solve(b, target = new Vec3()) {
                // Construct equations
                const nr = 3; // num rows

                const nc = 4; // num cols

                const eqns = [];
                let i;
                let j;

                for (i = 0; i < nr * nc; i++) {
                  eqns.push(0);
                }

                for (i = 0; i < 3; i++) {
                  for (j = 0; j < 3; j++) {
                    eqns[i + nc * j] = this.elements[i + 3 * j];
                  }
                }

                eqns[3 + 4 * 0] = b.x;
                eqns[3 + 4 * 1] = b.y;
                eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

                let n = 3;
                const k = n;
                let np;
                const kp = 4; // num rows

                let p;

                do {
                  i = k - n;

                  if (eqns[i + nc * i] === 0) {
                    // the pivot is null, swap lines
                    for (j = i + 1; j < k; j++) {
                      if (eqns[i + nc * j] !== 0) {
                        np = kp;

                        do {
                          // do ligne( i ) = ligne( i ) + ligne( k )
                          p = kp - np;
                          eqns[p + nc * i] += eqns[p + nc * j];
                        } while (--np);

                        break;
                      }
                    }
                  }

                  if (eqns[i + nc * i] !== 0) {
                    for (j = i + 1; j < k; j++) {
                      const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                      np = kp;

                      do {
                        // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                        p = kp - np;
                        eqns[p + nc * j] =
                          p <= i
                            ? 0
                            : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                      } while (--np);
                    }
                  }
                } while (--n); // Get the solution

                target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
                target.y =
                  (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) /
                  eqns[1 * nc + 1];
                target.x =
                  (eqns[0 * nc + 3] -
                    eqns[0 * nc + 2] * target.z -
                    eqns[0 * nc + 1] * target.y) /
                  eqns[0 * nc + 0];

                if (
                  isNaN(target.x) ||
                  isNaN(target.y) ||
                  isNaN(target.z) ||
                  target.x === Infinity ||
                  target.y === Infinity ||
                  target.z === Infinity
                ) {
                  throw (
                    "Could not solve equation! Got x=[" +
                    target.toString() +
                    "], b=[" +
                    b.toString() +
                    "], A=[" +
                    this.toString() +
                    "]"
                  );
                }

                return target;
              }
              /**
               * Get an element in the matrix by index. Index starts at 0, not 1!!!
               * @param value If provided, the matrix element will be set to this value.
               */

              e(row, column, value) {
                if (value === undefined) {
                  return this.elements[column + 3 * row];
                } else {
                  // Set value
                  this.elements[column + 3 * row] = value;
                }
              }
              /**
               * Copy another matrix into this matrix object.
               */

              copy(matrix) {
                for (let i = 0; i < matrix.elements.length; i++) {
                  this.elements[i] = matrix.elements[i];
                }

                return this;
              }
              /**
               * Returns a string representation of the matrix.
               */

              toString() {
                let r = "";
                const sep = ",";

                for (let i = 0; i < 9; i++) {
                  r += this.elements[i] + sep;
                }

                return r;
              }
              /**
               * reverse the matrix
               * @param target Target matrix to save in.
               * @return The solution x
               */

              reverse(target = new Mat3()) {
                // Construct equations
                const nr = 3; // num rows

                const nc = 6; // num cols

                const eqns = reverse_eqns;
                let i;
                let j;

                for (i = 0; i < 3; i++) {
                  for (j = 0; j < 3; j++) {
                    eqns[i + nc * j] = this.elements[i + 3 * j];
                  }
                }

                eqns[3 + 6 * 0] = 1;
                eqns[3 + 6 * 1] = 0;
                eqns[3 + 6 * 2] = 0;
                eqns[4 + 6 * 0] = 0;
                eqns[4 + 6 * 1] = 1;
                eqns[4 + 6 * 2] = 0;
                eqns[5 + 6 * 0] = 0;
                eqns[5 + 6 * 1] = 0;
                eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

                let n = 3;
                const k = n;
                let np;
                const kp = nc; // num rows

                let p;

                do {
                  i = k - n;

                  if (eqns[i + nc * i] === 0) {
                    // the pivot is null, swap lines
                    for (j = i + 1; j < k; j++) {
                      if (eqns[i + nc * j] !== 0) {
                        np = kp;

                        do {
                          // do line( i ) = line( i ) + line( k )
                          p = kp - np;
                          eqns[p + nc * i] += eqns[p + nc * j];
                        } while (--np);

                        break;
                      }
                    }
                  }

                  if (eqns[i + nc * i] !== 0) {
                    for (j = i + 1; j < k; j++) {
                      const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                      np = kp;

                      do {
                        // do line( k ) = line( k ) - multiplier * line( i )
                        p = kp - np;
                        eqns[p + nc * j] =
                          p <= i
                            ? 0
                            : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                      } while (--np);
                    }
                  }
                } while (--n); // eliminate the upper left triangle of the matrix

                i = 2;

                do {
                  j = i - 1;

                  do {
                    const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                    np = nc;

                    do {
                      p = nc - np;
                      eqns[p + nc * j] =
                        eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                    } while (--np);
                  } while (j--);
                } while (--i); // operations on the diagonal

                i = 2;

                do {
                  const multiplier = 1 / eqns[i + nc * i];
                  np = nc;

                  do {
                    p = nc - np;
                    eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
                  } while (--np);
                } while (i--);

                i = 2;

                do {
                  j = 2;

                  do {
                    p = eqns[nr + j + nc * i];

                    if (isNaN(p) || p === Infinity) {
                      throw "Could not reverse! A=[" + this.toString() + "]";
                    }

                    target.e(i, j, p);
                  } while (j--);
                } while (i--);

                return target;
              }
              /**
               * Set the matrix from a quaterion
               */

              setRotationFromQuaternion(q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const e = this.elements;
                e[3 * 0 + 0] = 1 - (yy + zz);
                e[3 * 0 + 1] = xy - wz;
                e[3 * 0 + 2] = xz + wy;
                e[3 * 1 + 0] = xy + wz;
                e[3 * 1 + 1] = 1 - (xx + zz);
                e[3 * 1 + 2] = yz - wx;
                e[3 * 2 + 0] = xz - wy;
                e[3 * 2 + 1] = yz + wx;
                e[3 * 2 + 2] = 1 - (xx + yy);
                return this;
              }
              /**
               * Transpose the matrix
               * @param target Optional. Where to store the result.
               * @return The target Mat3, or a new Mat3 if target was omitted.
               */

              transpose(target = new Mat3()) {
                const M = this.elements;
                const T = target.elements;
                let tmp; //Set diagonals

                T[0] = M[0];
                T[4] = M[4];
                T[8] = M[8];
                tmp = M[1];
                T[1] = M[3];
                T[3] = tmp;
                tmp = M[2];
                T[2] = M[6];
                T[6] = tmp;
                tmp = M[5];
                T[5] = M[7];
                T[7] = tmp;
                return target;
              }
            }
            const reverse_eqns = [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ];

            /**
             * 3-dimensional vector
             * @example
             *     const v = new Vec3(1, 2, 3)
             *     console.log('x=' + v.x) // x=1
             */

            class Vec3 {
              constructor(x = 0.0, y = 0.0, z = 0.0) {
                this.x = void 0;
                this.y = void 0;
                this.z = void 0;
                this.x = x;
                this.y = y;
                this.z = z;
              }
              /**
               * Vector cross product
               * @param target Optional target to save in.
               */

              cross(vector, target = new Vec3()) {
                const vx = vector.x;
                const vy = vector.y;
                const vz = vector.z;
                const x = this.x;
                const y = this.y;
                const z = this.z;
                target.x = y * vz - z * vy;
                target.y = z * vx - x * vz;
                target.z = x * vy - y * vx;
                return target;
              }
              /**
               * Set the vectors' 3 elements
               */

              set(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
              }
              /**
               * Set all components of the vector to zero.
               */

              setZero() {
                this.x = this.y = this.z = 0;
              }
              /**
               * Vector addition
               */

              vadd(vector, target) {
                if (target) {
                  target.x = vector.x + this.x;
                  target.y = vector.y + this.y;
                  target.z = vector.z + this.z;
                } else {
                  return new Vec3(
                    this.x + vector.x,
                    this.y + vector.y,
                    this.z + vector.z
                  );
                }
              }
              /**
               * Vector subtraction
               * @param target Optional target to save in.
               */

              vsub(vector, target) {
                if (target) {
                  target.x = this.x - vector.x;
                  target.y = this.y - vector.y;
                  target.z = this.z - vector.z;
                } else {
                  return new Vec3(
                    this.x - vector.x,
                    this.y - vector.y,
                    this.z - vector.z
                  );
                }
              }
              /**
               * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
               *
               * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}
               */

              crossmat() {
                return new Mat3([
                  0,
                  -this.z,
                  this.y,
                  this.z,
                  0,
                  -this.x,
                  -this.y,
                  this.x,
                  0,
                ]);
              }
              /**
               * Normalize the vector. Note that this changes the values in the vector.
               * @return Returns the norm of the vector
               */

              normalize() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const n = Math.sqrt(x * x + y * y + z * z);

                if (n > 0.0) {
                  const invN = 1 / n;
                  this.x *= invN;
                  this.y *= invN;
                  this.z *= invN;
                } else {
                  // Make something up
                  this.x = 0;
                  this.y = 0;
                  this.z = 0;
                }

                return n;
              }
              /**
               * Get the version of this vector that is of length 1.
               * @param target Optional target to save in
               * @return Returns the unit vector
               */

              unit(target = new Vec3()) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                let ninv = Math.sqrt(x * x + y * y + z * z);

                if (ninv > 0.0) {
                  ninv = 1.0 / ninv;
                  target.x = x * ninv;
                  target.y = y * ninv;
                  target.z = z * ninv;
                } else {
                  target.x = 1;
                  target.y = 0;
                  target.z = 0;
                }

                return target;
              }
              /**
               * Get the length of the vector
               */

              length() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                return Math.sqrt(x * x + y * y + z * z);
              }
              /**
               * Get the squared length of the vector.
               */

              lengthSquared() {
                return this.dot(this);
              }
              /**
               * Get distance from this point to another point
               */

              distanceTo(p) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const px = p.x;
                const py = p.y;
                const pz = p.z;
                return Math.sqrt(
                  (px - x) * (px - x) +
                    (py - y) * (py - y) +
                    (pz - z) * (pz - z)
                );
              }
              /**
               * Get squared distance from this point to another point
               */

              distanceSquared(p) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const px = p.x;
                const py = p.y;
                const pz = p.z;
                return (
                  (px - x) * (px - x) +
                  (py - y) * (py - y) +
                  (pz - z) * (pz - z)
                );
              }
              /**
               * Multiply all the components of the vector with a scalar.
               * @param target The vector to save the result in.
               */

              scale(scalar, target = new Vec3()) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                target.x = scalar * x;
                target.y = scalar * y;
                target.z = scalar * z;
                return target;
              }
              /**
               * Multiply the vector with an other vector, component-wise.
               * @param target The vector to save the result in.
               */

              vmul(vector, target = new Vec3()) {
                target.x = vector.x * this.x;
                target.y = vector.y * this.y;
                target.z = vector.z * this.z;
                return target;
              }
              /**
               * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
               * @param target The vector to save the result in.
               */

              addScaledVector(scalar, vector, target = new Vec3()) {
                target.x = this.x + scalar * vector.x;
                target.y = this.y + scalar * vector.y;
                target.z = this.z + scalar * vector.z;
                return target;
              }
              /**
               * Calculate dot product
               * @param vector
               */

              dot(vector) {
                return (
                  this.x * vector.x + this.y * vector.y + this.z * vector.z
                );
              }

              isZero() {
                return this.x === 0 && this.y === 0 && this.z === 0;
              }
              /**
               * Make the vector point in the opposite direction.
               * @param target Optional target to save in
               */

              negate(target = new Vec3()) {
                target.x = -this.x;
                target.y = -this.y;
                target.z = -this.z;
                return target;
              }
              /**
               * Compute two artificial tangents to the vector
               * @param t1 Vector object to save the first tangent in
               * @param t2 Vector object to save the second tangent in
               */

              tangents(t1, t2) {
                const norm = this.length();

                if (norm > 0.0) {
                  const n = Vec3_tangents_n;
                  const inorm = 1 / norm;
                  n.set(this.x * inorm, this.y * inorm, this.z * inorm);
                  const randVec = Vec3_tangents_randVec;

                  if (Math.abs(n.x) < 0.9) {
                    randVec.set(1, 0, 0);
                    n.cross(randVec, t1);
                  } else {
                    randVec.set(0, 1, 0);
                    n.cross(randVec, t1);
                  }

                  n.cross(t1, t2);
                } else {
                  // The normal length is zero, make something up
                  t1.set(1, 0, 0);
                  t2.set(0, 1, 0);
                }
              }
              /**
               * Converts to a more readable format
               */

              toString() {
                return this.x + "," + this.y + "," + this.z;
              }
              /**
               * Converts to an array
               */

              toArray() {
                return [this.x, this.y, this.z];
              }
              /**
               * Copies value of source to this vector.
               */

              copy(vector) {
                this.x = vector.x;
                this.y = vector.y;
                this.z = vector.z;
                return this;
              }
              /**
               * Do a linear interpolation between two vectors
               * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
               */

              lerp(vector, t, target) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                target.x = x + (vector.x - x) * t;
                target.y = y + (vector.y - y) * t;
                target.z = z + (vector.z - z) * t;
              }
              /**
               * Check if a vector equals is almost equal to another one.
               */

              almostEquals(vector, precision = 1e-6) {
                if (
                  Math.abs(this.x - vector.x) > precision ||
                  Math.abs(this.y - vector.y) > precision ||
                  Math.abs(this.z - vector.z) > precision
                ) {
                  return false;
                }

                return true;
              }
              /**
               * Check if a vector is almost zero
               */

              almostZero(precision = 1e-6) {
                if (
                  Math.abs(this.x) > precision ||
                  Math.abs(this.y) > precision ||
                  Math.abs(this.z) > precision
                ) {
                  return false;
                }

                return true;
              }
              /**
               * Check if the vector is anti-parallel to another vector.
               * @param precision Set to zero for exact comparisons
               */

              isAntiparallelTo(vector, precision) {
                this.negate(antip_neg);
                return antip_neg.almostEquals(vector, precision);
              }
              /**
               * Clone the vector
               */

              clone() {
                return new Vec3(this.x, this.y, this.z);
              }
            }
            Vec3.ZERO = void 0;
            Vec3.UNIT_X = void 0;
            Vec3.UNIT_Y = void 0;
            Vec3.UNIT_Z = void 0;
            Vec3.ZERO = new Vec3(0, 0, 0);
            Vec3.UNIT_X = new Vec3(1, 0, 0);
            Vec3.UNIT_Y = new Vec3(0, 1, 0);
            Vec3.UNIT_Z = new Vec3(0, 0, 1);
            const Vec3_tangents_n = new Vec3();
            const Vec3_tangents_randVec = new Vec3();
            const antip_neg = new Vec3();

            /**
             * Axis aligned bounding box class.
             */
            class AABB {
              /**
               * The lower bound of the bounding box
               */

              /**
               * The upper bound of the bounding box
               */
              constructor(options = {}) {
                this.lowerBound = void 0;
                this.upperBound = void 0;
                this.lowerBound = new Vec3();
                this.upperBound = new Vec3();

                if (options.lowerBound) {
                  this.lowerBound.copy(options.lowerBound);
                }

                if (options.upperBound) {
                  this.upperBound.copy(options.upperBound);
                }
              }
              /**
               * Set the AABB bounds from a set of points.
               * @param points An array of Vec3's.
               * @return The self object
               */

              setFromPoints(points, position, quaternion, skinSize) {
                const l = this.lowerBound;
                const u = this.upperBound;
                const q = quaternion; // Set to the first point

                l.copy(points[0]);

                if (q) {
                  q.vmult(l, l);
                }

                u.copy(l);

                for (let i = 1; i < points.length; i++) {
                  let p = points[i];

                  if (q) {
                    q.vmult(p, tmp$1);
                    p = tmp$1;
                  }

                  if (p.x > u.x) {
                    u.x = p.x;
                  }

                  if (p.x < l.x) {
                    l.x = p.x;
                  }

                  if (p.y > u.y) {
                    u.y = p.y;
                  }

                  if (p.y < l.y) {
                    l.y = p.y;
                  }

                  if (p.z > u.z) {
                    u.z = p.z;
                  }

                  if (p.z < l.z) {
                    l.z = p.z;
                  }
                } // Add offset

                if (position) {
                  position.vadd(l, l);
                  position.vadd(u, u);
                }

                if (skinSize) {
                  l.x -= skinSize;
                  l.y -= skinSize;
                  l.z -= skinSize;
                  u.x += skinSize;
                  u.y += skinSize;
                  u.z += skinSize;
                }

                return this;
              }
              /**
               * Copy bounds from an AABB to this AABB
               * @param aabb Source to copy from
               * @return The this object, for chainability
               */

              copy(aabb) {
                this.lowerBound.copy(aabb.lowerBound);
                this.upperBound.copy(aabb.upperBound);
                return this;
              }
              /**
               * Clone an AABB
               */

              clone() {
                return new AABB().copy(this);
              }
              /**
               * Extend this AABB so that it covers the given AABB too.
               */

              extend(aabb) {
                this.lowerBound.x = Math.min(
                  this.lowerBound.x,
                  aabb.lowerBound.x
                );
                this.upperBound.x = Math.max(
                  this.upperBound.x,
                  aabb.upperBound.x
                );
                this.lowerBound.y = Math.min(
                  this.lowerBound.y,
                  aabb.lowerBound.y
                );
                this.upperBound.y = Math.max(
                  this.upperBound.y,
                  aabb.upperBound.y
                );
                this.lowerBound.z = Math.min(
                  this.lowerBound.z,
                  aabb.lowerBound.z
                );
                this.upperBound.z = Math.max(
                  this.upperBound.z,
                  aabb.upperBound.z
                );
              }
              /**
               * Returns true if the given AABB overlaps this AABB.
               */

              overlaps(aabb) {
                const l1 = this.lowerBound;
                const u1 = this.upperBound;
                const l2 = aabb.lowerBound;
                const u2 = aabb.upperBound; //      l2        u2
                //      |---------|
                // |--------|
                // l1       u1

                const overlapsX =
                  (l2.x <= u1.x && u1.x <= u2.x) ||
                  (l1.x <= u2.x && u2.x <= u1.x);
                const overlapsY =
                  (l2.y <= u1.y && u1.y <= u2.y) ||
                  (l1.y <= u2.y && u2.y <= u1.y);
                const overlapsZ =
                  (l2.z <= u1.z && u1.z <= u2.z) ||
                  (l1.z <= u2.z && u2.z <= u1.z);
                return overlapsX && overlapsY && overlapsZ;
              } // Mostly for debugging

              volume() {
                const l = this.lowerBound;
                const u = this.upperBound;
                return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
              }
              /**
               * Returns true if the given AABB is fully contained in this AABB.
               */

              contains(aabb) {
                const l1 = this.lowerBound;
                const u1 = this.upperBound;
                const l2 = aabb.lowerBound;
                const u2 = aabb.upperBound; //      l2        u2
                //      |---------|
                // |---------------|
                // l1              u1

                return (
                  l1.x <= l2.x &&
                  u1.x >= u2.x &&
                  l1.y <= l2.y &&
                  u1.y >= u2.y &&
                  l1.z <= l2.z &&
                  u1.z >= u2.z
                );
              }

              getCorners(a, b, c, d, e, f, g, h) {
                const l = this.lowerBound;
                const u = this.upperBound;
                a.copy(l);
                b.set(u.x, l.y, l.z);
                c.set(u.x, u.y, l.z);
                d.set(l.x, u.y, u.z);
                e.set(u.x, l.y, u.z);
                f.set(l.x, u.y, l.z);
                g.set(l.x, l.y, u.z);
                h.copy(u);
              }
              /**
               * Get the representation of an AABB in another frame.
               * @return The "target" AABB object.
               */

              toLocalFrame(frame, target) {
                const corners = transformIntoFrame_corners;
                const a = corners[0];
                const b = corners[1];
                const c = corners[2];
                const d = corners[3];
                const e = corners[4];
                const f = corners[5];
                const g = corners[6];
                const h = corners[7]; // Get corners in current frame

                this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

                for (let i = 0; i !== 8; i++) {
                  const corner = corners[i];
                  frame.pointToLocal(corner, corner);
                }

                return target.setFromPoints(corners);
              }
              /**
               * Get the representation of an AABB in the global frame.
               * @return The "target" AABB object.
               */

              toWorldFrame(frame, target) {
                const corners = transformIntoFrame_corners;
                const a = corners[0];
                const b = corners[1];
                const c = corners[2];
                const d = corners[3];
                const e = corners[4];
                const f = corners[5];
                const g = corners[6];
                const h = corners[7]; // Get corners in current frame

                this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

                for (let i = 0; i !== 8; i++) {
                  const corner = corners[i];
                  frame.pointToWorld(corner, corner);
                }

                return target.setFromPoints(corners);
              }
              /**
               * Check if the AABB is hit by a ray.
               */

              overlapsRay(ray) {
                const { direction, from } = ray; // const t = 0
                // ray.direction is unit direction vector of ray

                const dirFracX = 1 / direction.x;
                const dirFracY = 1 / direction.y;
                const dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

                const t1 = (this.lowerBound.x - from.x) * dirFracX;
                const t2 = (this.upperBound.x - from.x) * dirFracX;
                const t3 = (this.lowerBound.y - from.y) * dirFracY;
                const t4 = (this.upperBound.y - from.y) * dirFracY;
                const t5 = (this.lowerBound.z - from.z) * dirFracZ;
                const t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
                // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

                const tmin = Math.max(
                  Math.max(Math.min(t1, t2), Math.min(t3, t4)),
                  Math.min(t5, t6)
                );
                const tmax = Math.min(
                  Math.min(Math.max(t1, t2), Math.max(t3, t4)),
                  Math.max(t5, t6)
                ); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

                if (tmax < 0) {
                  //t = tmax;
                  return false;
                } // if tmin > tmax, ray doesn't intersect AABB

                if (tmin > tmax) {
                  //t = tmax;
                  return false;
                }

                return true;
              }
            }
            const tmp$1 = new Vec3();
            const transformIntoFrame_corners = [
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
            ];

            /**
             * Collision "matrix".
             * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
             */
            class ArrayCollisionMatrix {
              /**
               * The matrix storage.
               */
              constructor() {
                this.matrix = void 0;
                this.matrix = [];
              }
              /**
               * Get an element
               */

              get(bi, bj) {
                let { index: i } = bi;
                let { index: j } = bj;

                if (j > i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                return this.matrix[((i * (i + 1)) >> 1) + j - 1];
              }
              /**
               * Set an element
               */

              set(bi, bj, value) {
                let { index: i } = bi;
                let { index: j } = bj;

                if (j > i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                this.matrix[((i * (i + 1)) >> 1) + j - 1] = value ? 1 : 0;
              }
              /**
               * Sets all elements to zero
               */

              reset() {
                for (let i = 0, l = this.matrix.length; i !== l; i++) {
                  this.matrix[i] = 0;
                }
              }
              /**
               * Sets the max number of objects
               */

              setNumObjects(n) {
                this.matrix.length = (n * (n - 1)) >> 1;
              }
            }

            /**
             * Base class for objects that dispatches events.
             */
            class EventTarget {
              constructor() {
                this._listeners = void 0;
              }

              /**
               * Add an event listener
               * @return The self object, for chainability.
               */
              addEventListener(type, listener) {
                if (this._listeners === undefined) {
                  this._listeners = {};
                }

                const listeners = this._listeners;

                if (listeners[type] === undefined) {
                  listeners[type] = [];
                }

                if (!listeners[type].includes(listener)) {
                  listeners[type].push(listener);
                }

                return this;
              }
              /**
               * Check if an event listener is added
               */

              hasEventListener(type, listener) {
                if (this._listeners === undefined) {
                  return false;
                }

                const listeners = this._listeners;

                if (
                  listeners[type] !== undefined &&
                  listeners[type].includes(listener)
                ) {
                  return true;
                }

                return false;
              }
              /**
               * Check if any event listener of the given type is added
               */

              hasAnyEventListener(type) {
                if (this._listeners === undefined) {
                  return false;
                }

                const listeners = this._listeners;
                return listeners[type] !== undefined;
              }
              /**
               * Remove an event listener
               * @return The self object, for chainability.
               */

              removeEventListener(type, listener) {
                if (this._listeners === undefined) {
                  return this;
                }

                const listeners = this._listeners;

                if (listeners[type] === undefined) {
                  return this;
                }

                const index = listeners[type].indexOf(listener);

                if (index !== -1) {
                  listeners[type].splice(index, 1);
                }

                return this;
              }
              /**
               * Emit an event.
               * @return The self object, for chainability.
               */

              dispatchEvent(event) {
                if (this._listeners === undefined) {
                  return this;
                }

                const listeners = this._listeners;
                const listenerArray = listeners[event.type];

                if (listenerArray !== undefined) {
                  event.target = this;

                  for (let i = 0, l = listenerArray.length; i < l; i++) {
                    listenerArray[i].call(this, event);
                  }
                }

                return this;
              }
            }

            /**
             * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
             * @param x Multiplier of the imaginary basis vector i.
             * @param y Multiplier of the imaginary basis vector j.
             * @param z Multiplier of the imaginary basis vector k.
             * @param w Multiplier of the real part.
             * @see http://en.wikipedia.org/wiki/Quaternion
             */

            class Quaternion {
              constructor(x = 0, y = 0, z = 0, w = 1) {
                this.x = void 0;
                this.y = void 0;
                this.z = void 0;
                this.w = void 0;
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
              }
              /**
               * Set the value of the quaternion.
               */

              set(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
                return this;
              }
              /**
               * Convert to a readable format
               * @return "x,y,z,w"
               */

              toString() {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
              }
              /**
               * Convert to an Array
               * @return [x, y, z, w]
               */

              toArray() {
                return [this.x, this.y, this.z, this.w];
              }
              /**
               * Set the quaternion components given an axis and an angle in radians.
               */

              setFromAxisAngle(vector, angle) {
                const s = Math.sin(angle * 0.5);
                this.x = vector.x * s;
                this.y = vector.y * s;
                this.z = vector.z * s;
                this.w = Math.cos(angle * 0.5);
                return this;
              }
              /**
               * Converts the quaternion to [ axis, angle ] representation.
               * @param targetAxis A vector object to reuse for storing the axis.
               * @return An array, first element is the axis and the second is the angle in radians.
               */

              toAxisAngle(targetAxis = new Vec3()) {
                this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

                const angle = 2 * Math.acos(this.w);
                const s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

                if (s < 0.001) {
                  // test to avoid divide by zero, s is always positive due to sqrt
                  // if s close to zero then direction of axis not important
                  targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

                  targetAxis.y = this.y;
                  targetAxis.z = this.z;
                } else {
                  targetAxis.x = this.x / s; // normalise axis

                  targetAxis.y = this.y / s;
                  targetAxis.z = this.z / s;
                }

                return [targetAxis, angle];
              }
              /**
               * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
               */

              setFromVectors(u, v) {
                if (u.isAntiparallelTo(v)) {
                  const t1 = sfv_t1;
                  const t2 = sfv_t2;
                  u.tangents(t1, t2);
                  this.setFromAxisAngle(t1, Math.PI);
                } else {
                  const a = u.cross(v);
                  this.x = a.x;
                  this.y = a.y;
                  this.z = a.z;
                  this.w =
                    Math.sqrt(u.length() ** 2 * v.length() ** 2) + u.dot(v);
                  this.normalize();
                }

                return this;
              }
              /**
               * Multiply the quaternion with an other quaternion.
               */

              mult(quat, target = new Quaternion()) {
                const ax = this.x;
                const ay = this.y;
                const az = this.z;
                const aw = this.w;
                const bx = quat.x;
                const by = quat.y;
                const bz = quat.z;
                const bw = quat.w;
                target.x = ax * bw + aw * bx + ay * bz - az * by;
                target.y = ay * bw + aw * by + az * bx - ax * bz;
                target.z = az * bw + aw * bz + ax * by - ay * bx;
                target.w = aw * bw - ax * bx - ay * by - az * bz;
                return target;
              }
              /**
               * Get the inverse quaternion rotation.
               */

              inverse(target = new Quaternion()) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                this.conjugate(target);
                const inorm2 = 1 / (x * x + y * y + z * z + w * w);
                target.x *= inorm2;
                target.y *= inorm2;
                target.z *= inorm2;
                target.w *= inorm2;
                return target;
              }
              /**
               * Get the quaternion conjugate
               */

              conjugate(target = new Quaternion()) {
                target.x = -this.x;
                target.y = -this.y;
                target.z = -this.z;
                target.w = this.w;
                return target;
              }
              /**
               * Normalize the quaternion. Note that this changes the values of the quaternion.
               */

              normalize() {
                let l = Math.sqrt(
                  this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                );

                if (l === 0) {
                  this.x = 0;
                  this.y = 0;
                  this.z = 0;
                  this.w = 0;
                } else {
                  l = 1 / l;
                  this.x *= l;
                  this.y *= l;
                  this.z *= l;
                  this.w *= l;
                }

                return this;
              }
              /**
               * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
               * @author unphased, https://github.com/unphased
               */

              normalizeFast() {
                const f =
                  (3.0 -
                    (this.x * this.x +
                      this.y * this.y +
                      this.z * this.z +
                      this.w * this.w)) /
                  2.0;

                if (f === 0) {
                  this.x = 0;
                  this.y = 0;
                  this.z = 0;
                  this.w = 0;
                } else {
                  this.x *= f;
                  this.y *= f;
                  this.z *= f;
                  this.w *= f;
                }

                return this;
              }
              /**
               * Multiply the quaternion by a vector
               */

              vmult(v, target = new Vec3()) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                const qx = this.x;
                const qy = this.y;
                const qz = this.z;
                const qw = this.w; // q*v

                const ix = qw * x + qy * z - qz * y;
                const iy = qw * y + qz * x - qx * z;
                const iz = qw * z + qx * y - qy * x;
                const iw = -qx * x - qy * y - qz * z;
                target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return target;
              }
              /**
               * Copies value of source to this quaternion.
               * @return this
               */

              copy(quat) {
                this.x = quat.x;
                this.y = quat.y;
                this.z = quat.z;
                this.w = quat.w;
                return this;
              }
              /**
               * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
               * @param order Three-character string, defaults to "YZX"
               */

              toEuler(target, order = "YZX") {
                let heading;
                let attitude;
                let bank;
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;

                switch (order) {
                  case "YZX":
                    const test = x * y + z * w;

                    if (test > 0.499) {
                      // singularity at north pole
                      heading = 2 * Math.atan2(x, w);
                      attitude = Math.PI / 2;
                      bank = 0;
                    }

                    if (test < -0.499) {
                      // singularity at south pole
                      heading = -2 * Math.atan2(x, w);
                      attitude = -Math.PI / 2;
                      bank = 0;
                    }

                    if (heading === undefined) {
                      const sqx = x * x;
                      const sqy = y * y;
                      const sqz = z * z;
                      heading = Math.atan2(
                        2 * y * w - 2 * x * z,
                        1 - 2 * sqy - 2 * sqz
                      ); // Heading

                      attitude = Math.asin(2 * test); // attitude

                      bank = Math.atan2(
                        2 * x * w - 2 * y * z,
                        1 - 2 * sqx - 2 * sqz
                      ); // bank
                    }

                    break;

                  default:
                    throw new Error(
                      "Euler order " + order + " not supported yet."
                    );
                }

                target.y = heading;
                target.z = attitude;
                target.x = bank;
              }
              /**
               * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
               *
               * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
               */

              setFromEuler(x, y, z, order = "XYZ") {
                const c1 = Math.cos(x / 2);
                const c2 = Math.cos(y / 2);
                const c3 = Math.cos(z / 2);
                const s1 = Math.sin(x / 2);
                const s2 = Math.sin(y / 2);
                const s3 = Math.sin(z / 2);

                if (order === "XYZ") {
                  this.x = s1 * c2 * c3 + c1 * s2 * s3;
                  this.y = c1 * s2 * c3 - s1 * c2 * s3;
                  this.z = c1 * c2 * s3 + s1 * s2 * c3;
                  this.w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if (order === "YXZ") {
                  this.x = s1 * c2 * c3 + c1 * s2 * s3;
                  this.y = c1 * s2 * c3 - s1 * c2 * s3;
                  this.z = c1 * c2 * s3 - s1 * s2 * c3;
                  this.w = c1 * c2 * c3 + s1 * s2 * s3;
                } else if (order === "ZXY") {
                  this.x = s1 * c2 * c3 - c1 * s2 * s3;
                  this.y = c1 * s2 * c3 + s1 * c2 * s3;
                  this.z = c1 * c2 * s3 + s1 * s2 * c3;
                  this.w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if (order === "ZYX") {
                  this.x = s1 * c2 * c3 - c1 * s2 * s3;
                  this.y = c1 * s2 * c3 + s1 * c2 * s3;
                  this.z = c1 * c2 * s3 - s1 * s2 * c3;
                  this.w = c1 * c2 * c3 + s1 * s2 * s3;
                } else if (order === "YZX") {
                  this.x = s1 * c2 * c3 + c1 * s2 * s3;
                  this.y = c1 * s2 * c3 + s1 * c2 * s3;
                  this.z = c1 * c2 * s3 - s1 * s2 * c3;
                  this.w = c1 * c2 * c3 - s1 * s2 * s3;
                } else if (order === "XZY") {
                  this.x = s1 * c2 * c3 - c1 * s2 * s3;
                  this.y = c1 * s2 * c3 - s1 * c2 * s3;
                  this.z = c1 * c2 * s3 + s1 * s2 * c3;
                  this.w = c1 * c2 * c3 + s1 * s2 * s3;
                }

                return this;
              }

              clone() {
                return new Quaternion(this.x, this.y, this.z, this.w);
              }
              /**
               * Performs a spherical linear interpolation between two quat
               *
               * @param toQuat second operand
               * @param t interpolation amount between the self quaternion and toQuat
               * @param target A quaternion to store the result in. If not provided, a new one will be created.
               * @returns {Quaternion} The "target" object
               */

              slerp(toQuat, t, target = new Quaternion()) {
                const ax = this.x;
                const ay = this.y;
                const az = this.z;
                const aw = this.w;
                let bx = toQuat.x;
                let by = toQuat.y;
                let bz = toQuat.z;
                let bw = toQuat.w;
                let omega;
                let cosom;
                let sinom;
                let scale0;
                let scale1; // calc cosine

                cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

                if (cosom < 0.0) {
                  cosom = -cosom;
                  bx = -bx;
                  by = -by;
                  bz = -bz;
                  bw = -bw;
                } // calculate coefficients

                if (1.0 - cosom > 0.000001) {
                  // standard case (slerp)
                  omega = Math.acos(cosom);
                  sinom = Math.sin(omega);
                  scale0 = Math.sin((1.0 - t) * omega) / sinom;
                  scale1 = Math.sin(t * omega) / sinom;
                } else {
                  // "from" and "to" quaternions are very close
                  //  ... so we can do a linear interpolation
                  scale0 = 1.0 - t;
                  scale1 = t;
                } // calculate final values

                target.x = scale0 * ax + scale1 * bx;
                target.y = scale0 * ay + scale1 * by;
                target.z = scale0 * az + scale1 * bz;
                target.w = scale0 * aw + scale1 * bw;
                return target;
              }
              /**
               * Rotate an absolute orientation quaternion given an angular velocity and a time step.
               */

              integrate(
                angularVelocity,
                dt,
                angularFactor,
                target = new Quaternion()
              ) {
                const ax = angularVelocity.x * angularFactor.x,
                  ay = angularVelocity.y * angularFactor.y,
                  az = angularVelocity.z * angularFactor.z,
                  bx = this.x,
                  by = this.y,
                  bz = this.z,
                  bw = this.w;
                const half_dt = dt * 0.5;
                target.x += half_dt * (ax * bw + ay * bz - az * by);
                target.y += half_dt * (ay * bw + az * bx - ax * bz);
                target.z += half_dt * (az * bw + ax * by - ay * bx);
                target.w += half_dt * (-ax * bx - ay * by - az * bz);
                return target;
              }
            }
            const sfv_t1 = new Vec3();
            const sfv_t2 = new Vec3();

            /**
             * The available shape types.
             */
            const SHAPE_TYPES = {
              /** SPHERE */
              SPHERE: 1,

              /** PLANE */
              PLANE: 2,

              /** BOX */
              BOX: 4,

              /** COMPOUND */
              COMPOUND: 8,

              /** CONVEXPOLYHEDRON */
              CONVEXPOLYHEDRON: 16,

              /** HEIGHTFIELD */
              HEIGHTFIELD: 32,

              /** PARTICLE */
              PARTICLE: 64,

              /** CYLINDER */
              CYLINDER: 128,

              /** TRIMESH */
              TRIMESH: 256,
            };
            /**
             * ShapeType
             */

            /**
             * Base class for shapes
             */
            class Shape {
              /**
               * Identifier of the Shape.
               */

              /**
               * The type of this shape. Must be set to an int > 0 by subclasses.
               */

              /**
               * The local bounding sphere radius of this shape.
               */

              /**
               * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
               * @default true
               */

              /**
               * @default 1
               */

              /**
               * @default -1
               */

              /**
               * Optional material of the shape that regulates contact properties.
               */

              /**
               * The body to which the shape is added to.
               */

              /**
               * All the Shape types.
               */
              constructor(options = {}) {
                this.id = void 0;
                this.type = void 0;
                this.boundingSphereRadius = void 0;
                this.collisionResponse = void 0;
                this.collisionFilterGroup = void 0;
                this.collisionFilterMask = void 0;
                this.material = void 0;
                this.body = void 0;
                this.id = Shape.idCounter++;
                this.type = options.type || 0;
                this.boundingSphereRadius = 0;
                this.collisionResponse = options.collisionResponse
                  ? options.collisionResponse
                  : true;
                this.collisionFilterGroup =
                  options.collisionFilterGroup !== undefined
                    ? options.collisionFilterGroup
                    : 1;
                this.collisionFilterMask =
                  options.collisionFilterMask !== undefined
                    ? options.collisionFilterMask
                    : -1;
                this.material = options.material ? options.material : null;
                this.body = null;
              }
              /**
               * Computes the bounding sphere radius.
               * The result is stored in the property `.boundingSphereRadius`
               */

              updateBoundingSphereRadius() {
                throw (
                  "computeBoundingSphereRadius() not implemented for shape type " +
                  this.type
                );
              }
              /**
               * Get the volume of this shape
               */

              volume() {
                throw "volume() not implemented for shape type " + this.type;
              }
              /**
               * Calculates the inertia in the local frame for this shape.
               * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
               */

              calculateLocalInertia(mass, target) {
                throw (
                  "calculateLocalInertia() not implemented for shape type " +
                  this.type
                );
              }
              /**
               * @todo use abstract for these kind of methods
               */

              calculateWorldAABB(pos, quat, min, max) {
                throw (
                  "calculateWorldAABB() not implemented for shape type " +
                  this.type
                );
              }
            }
            Shape.idCounter = 0;
            Shape.types = SHAPE_TYPES;

            /**
             * Transformation utilities.
             */
            class Transform {
              /**
               * position
               */

              /**
               * quaternion
               */
              constructor(options = {}) {
                this.position = void 0;
                this.quaternion = void 0;
                this.position = new Vec3();
                this.quaternion = new Quaternion();

                if (options.position) {
                  this.position.copy(options.position);
                }

                if (options.quaternion) {
                  this.quaternion.copy(options.quaternion);
                }
              }
              /**
               * Get a global point in local transform coordinates.
               */

              pointToLocal(worldPoint, result) {
                return Transform.pointToLocalFrame(
                  this.position,
                  this.quaternion,
                  worldPoint,
                  result
                );
              }
              /**
               * Get a local point in global transform coordinates.
               */

              pointToWorld(localPoint, result) {
                return Transform.pointToWorldFrame(
                  this.position,
                  this.quaternion,
                  localPoint,
                  result
                );
              }
              /**
               * vectorToWorldFrame
               */

              vectorToWorldFrame(localVector, result = new Vec3()) {
                this.quaternion.vmult(localVector, result);
                return result;
              }
              /**
               * pointToLocalFrame
               */

              static pointToLocalFrame(
                position,
                quaternion,
                worldPoint,
                result = new Vec3()
              ) {
                worldPoint.vsub(position, result);
                quaternion.conjugate(tmpQuat$1);
                tmpQuat$1.vmult(result, result);
                return result;
              }
              /**
               * pointToWorldFrame
               */

              static pointToWorldFrame(
                position,
                quaternion,
                localPoint,
                result = new Vec3()
              ) {
                quaternion.vmult(localPoint, result);
                result.vadd(position, result);
                return result;
              }
              /**
               * vectorToWorldFrame
               */

              static vectorToWorldFrame(
                quaternion,
                localVector,
                result = new Vec3()
              ) {
                quaternion.vmult(localVector, result);
                return result;
              }
              /**
               * vectorToLocalFrame
               */

              static vectorToLocalFrame(
                position,
                quaternion,
                worldVector,
                result = new Vec3()
              ) {
                quaternion.w *= -1;
                quaternion.vmult(worldVector, result);
                quaternion.w *= -1;
                return result;
              }
            }
            const tmpQuat$1 = new Quaternion();

            /**
             * A set of polygons describing a convex shape.
             *
             * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
             * in the same 3D plane), instead these should be merged into one polygon.
             *
             * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
             * @author schteppe / https://github.com/schteppe
             * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
             *
             * @todo Move the clipping functions to ContactGenerator?
             * @todo Automatically merge coplanar polygons in constructor.
             * @example
             *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
             *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
             *     world.addBody(convexBody)
             */
            class ConvexPolyhedron extends Shape {
              /** vertices */

              /**
               * Array of integer arrays, indicating which vertices each face consists of
               */

              /** faceNormals */

              /** worldVertices */

              /** worldVerticesNeedsUpdate */

              /** worldFaceNormals */

              /** worldFaceNormalsNeedsUpdate */

              /**
               * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
               */

              /** uniqueEdges */

              /**
               * @param vertices An array of Vec3's
               * @param faces Array of integer arrays, describing which vertices that is included in each face.
               */
              constructor(props = {}) {
                const {
                  vertices = [],
                  faces = [],
                  normals = [],
                  axes,
                  boundingSphereRadius,
                } = props;
                super({
                  type: Shape.types.CONVEXPOLYHEDRON,
                });
                this.vertices = void 0;
                this.faces = void 0;
                this.faceNormals = void 0;
                this.worldVertices = void 0;
                this.worldVerticesNeedsUpdate = void 0;
                this.worldFaceNormals = void 0;
                this.worldFaceNormalsNeedsUpdate = void 0;
                this.uniqueAxes = void 0;
                this.uniqueEdges = void 0;
                this.vertices = vertices;
                this.faces = faces;
                this.faceNormals = normals;

                if (this.faceNormals.length === 0) {
                  this.computeNormals();
                }

                if (!boundingSphereRadius) {
                  this.updateBoundingSphereRadius();
                } else {
                  this.boundingSphereRadius = boundingSphereRadius;
                }

                this.worldVertices = []; // World transformed version of .vertices

                this.worldVerticesNeedsUpdate = true;
                this.worldFaceNormals = []; // World transformed version of .faceNormals

                this.worldFaceNormalsNeedsUpdate = true;
                this.uniqueAxes = axes ? axes.slice() : null;
                this.uniqueEdges = [];
                this.computeEdges();
              }
              /**
               * Computes uniqueEdges
               */

              computeEdges() {
                const faces = this.faces;
                const vertices = this.vertices;
                const edges = this.uniqueEdges;
                edges.length = 0;
                const edge = new Vec3();

                for (let i = 0; i !== faces.length; i++) {
                  const face = faces[i];
                  const numVertices = face.length;

                  for (let j = 0; j !== numVertices; j++) {
                    const k = (j + 1) % numVertices;
                    vertices[face[j]].vsub(vertices[face[k]], edge);
                    edge.normalize();
                    let found = false;

                    for (let p = 0; p !== edges.length; p++) {
                      if (
                        edges[p].almostEquals(edge) ||
                        edges[p].almostEquals(edge)
                      ) {
                        found = true;
                        break;
                      }
                    }

                    if (!found) {
                      edges.push(edge.clone());
                    }
                  }
                }
              }
              /**
               * Compute the normals of the faces.
               * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
               */

              computeNormals() {
                this.faceNormals.length = this.faces.length; // Generate normals

                for (let i = 0; i < this.faces.length; i++) {
                  // Check so all vertices exists for this face
                  for (let j = 0; j < this.faces[i].length; j++) {
                    if (!this.vertices[this.faces[i][j]]) {
                      throw new Error(
                        "Vertex " + this.faces[i][j] + " not found!"
                      );
                    }
                  }

                  const n = this.faceNormals[i] || new Vec3();
                  this.getFaceNormal(i, n);
                  n.negate(n);
                  this.faceNormals[i] = n;
                  const vertex = this.vertices[this.faces[i][0]];

                  if (n.dot(vertex) < 0) {
                    console.error(
                      ".faceNormals[" +
                        i +
                        "] = Vec3(" +
                        n.toString() +
                        ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."
                    );

                    for (let j = 0; j < this.faces[i].length; j++) {
                      console.warn(
                        ".vertices[" +
                          this.faces[i][j] +
                          "] = Vec3(" +
                          this.vertices[this.faces[i][j]].toString() +
                          ")"
                      );
                    }
                  }
                }
              }
              /**
               * Compute the normal of a face from its vertices
               */

              getFaceNormal(i, target) {
                const f = this.faces[i];
                const va = this.vertices[f[0]];
                const vb = this.vertices[f[1]];
                const vc = this.vertices[f[2]];
                ConvexPolyhedron.computeNormal(va, vb, vc, target);
              }
              /**
               * Get face normal given 3 vertices
               */

              static computeNormal(va, vb, vc, target) {
                const cb = new Vec3();
                const ab = new Vec3();
                vb.vsub(va, ab);
                vc.vsub(vb, cb);
                cb.cross(ab, target);

                if (!target.isZero()) {
                  target.normalize();
                }
              }
              /**
               * @param minDist Clamp distance
               * @param result The an array of contact point objects, see clipFaceAgainstHull
               */

              clipAgainstHull(
                posA,
                quatA,
                hullB,
                posB,
                quatB,
                separatingNormal,
                minDist,
                maxDist,
                result
              ) {
                const WorldNormal = new Vec3();
                let closestFaceB = -1;
                let dmax = -Number.MAX_VALUE;

                for (let face = 0; face < hullB.faces.length; face++) {
                  WorldNormal.copy(hullB.faceNormals[face]);
                  quatB.vmult(WorldNormal, WorldNormal);
                  const d = WorldNormal.dot(separatingNormal);

                  if (d > dmax) {
                    dmax = d;
                    closestFaceB = face;
                  }
                }

                const worldVertsB1 = [];

                for (let i = 0; i < hullB.faces[closestFaceB].length; i++) {
                  const b = hullB.vertices[hullB.faces[closestFaceB][i]];
                  const worldb = new Vec3();
                  worldb.copy(b);
                  quatB.vmult(worldb, worldb);
                  posB.vadd(worldb, worldb);
                  worldVertsB1.push(worldb);
                }

                if (closestFaceB >= 0) {
                  this.clipFaceAgainstHull(
                    separatingNormal,
                    posA,
                    quatA,
                    worldVertsB1,
                    minDist,
                    maxDist,
                    result
                  );
                }
              }
              /**
               * Find the separating axis between this hull and another
               * @param target The target vector to save the axis in
               * @return Returns false if a separation is found, else true
               */

              findSeparatingAxis(
                hullB,
                posA,
                quatA,
                posB,
                quatB,
                target,
                faceListA,
                faceListB
              ) {
                const faceANormalWS3 = new Vec3();
                const Worldnormal1 = new Vec3();
                const deltaC = new Vec3();
                const worldEdge0 = new Vec3();
                const worldEdge1 = new Vec3();
                const Cross = new Vec3();
                let dmin = Number.MAX_VALUE;
                const hullA = this;

                if (!hullA.uniqueAxes) {
                  const numFacesA = faceListA
                    ? faceListA.length
                    : hullA.faces.length; // Test face normals from hullA

                  for (let i = 0; i < numFacesA; i++) {
                    const fi = faceListA ? faceListA[i] : i; // Get world face normal

                    faceANormalWS3.copy(hullA.faceNormals[fi]);
                    quatA.vmult(faceANormalWS3, faceANormalWS3);
                    const d = hullA.testSepAxis(
                      faceANormalWS3,
                      hullB,
                      posA,
                      quatA,
                      posB,
                      quatB
                    );

                    if (d === false) {
                      return false;
                    }

                    if (d < dmin) {
                      dmin = d;
                      target.copy(faceANormalWS3);
                    }
                  }
                } else {
                  // Test unique axes
                  for (let i = 0; i !== hullA.uniqueAxes.length; i++) {
                    // Get world axis
                    quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
                    const d = hullA.testSepAxis(
                      faceANormalWS3,
                      hullB,
                      posA,
                      quatA,
                      posB,
                      quatB
                    );

                    if (d === false) {
                      return false;
                    }

                    if (d < dmin) {
                      dmin = d;
                      target.copy(faceANormalWS3);
                    }
                  }
                }

                if (!hullB.uniqueAxes) {
                  // Test face normals from hullB
                  const numFacesB = faceListB
                    ? faceListB.length
                    : hullB.faces.length;

                  for (let i = 0; i < numFacesB; i++) {
                    const fi = faceListB ? faceListB[i] : i;
                    Worldnormal1.copy(hullB.faceNormals[fi]);
                    quatB.vmult(Worldnormal1, Worldnormal1);
                    const d = hullA.testSepAxis(
                      Worldnormal1,
                      hullB,
                      posA,
                      quatA,
                      posB,
                      quatB
                    );

                    if (d === false) {
                      return false;
                    }

                    if (d < dmin) {
                      dmin = d;
                      target.copy(Worldnormal1);
                    }
                  }
                } else {
                  // Test unique axes in B
                  for (let i = 0; i !== hullB.uniqueAxes.length; i++) {
                    quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
                    const d = hullA.testSepAxis(
                      Worldnormal1,
                      hullB,
                      posA,
                      quatA,
                      posB,
                      quatB
                    );

                    if (d === false) {
                      return false;
                    }

                    if (d < dmin) {
                      dmin = d;
                      target.copy(Worldnormal1);
                    }
                  }
                } // Test edges

                for (let e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
                  // Get world edge
                  quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

                  for (let e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
                    // Get world edge 2
                    quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
                    worldEdge0.cross(worldEdge1, Cross);

                    if (!Cross.almostZero()) {
                      Cross.normalize();
                      const dist = hullA.testSepAxis(
                        Cross,
                        hullB,
                        posA,
                        quatA,
                        posB,
                        quatB
                      );

                      if (dist === false) {
                        return false;
                      }

                      if (dist < dmin) {
                        dmin = dist;
                        target.copy(Cross);
                      }
                    }
                  }
                }

                posB.vsub(posA, deltaC);

                if (deltaC.dot(target) > 0.0) {
                  target.negate(target);
                }

                return true;
              }
              /**
               * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
               * @return The overlap depth, or FALSE if no penetration.
               */

              testSepAxis(axis, hullB, posA, quatA, posB, quatB) {
                const hullA = this;
                ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
                ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
                const maxA = maxminA[0];
                const minA = maxminA[1];
                const maxB = maxminB[0];
                const minB = maxminB[1];

                if (maxA < minB || maxB < minA) {
                  return false; // Separated
                }

                const d0 = maxA - minB;
                const d1 = maxB - minA;
                const depth = d0 < d1 ? d0 : d1;
                return depth;
              }
              /**
               * calculateLocalInertia
               */

              calculateLocalInertia(mass, target) {
                // Approximate with box inertia
                // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
                const aabbmax = new Vec3();
                const aabbmin = new Vec3();
                this.computeLocalAABB(aabbmin, aabbmax);
                const x = aabbmax.x - aabbmin.x;
                const y = aabbmax.y - aabbmin.y;
                const z = aabbmax.z - aabbmin.z;
                target.x =
                  (1.0 / 12.0) * mass * (2 * y * 2 * y + 2 * z * 2 * z);
                target.y =
                  (1.0 / 12.0) * mass * (2 * x * 2 * x + 2 * z * 2 * z);
                target.z =
                  (1.0 / 12.0) * mass * (2 * y * 2 * y + 2 * x * 2 * x);
              }
              /**
               * @param face_i Index of the face
               */

              getPlaneConstantOfFace(face_i) {
                const f = this.faces[face_i];
                const n = this.faceNormals[face_i];
                const v = this.vertices[f[0]];
                const c = -n.dot(v);
                return c;
              }
              /**
               * Clip a face against a hull.
               * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
               * @param minDist Distance clamping
               * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
               */

              clipFaceAgainstHull(
                separatingNormal,
                posA,
                quatA,
                worldVertsB1,
                minDist,
                maxDist,
                result
              ) {
                const faceANormalWS = new Vec3();
                const edge0 = new Vec3();
                const WorldEdge0 = new Vec3();
                const worldPlaneAnormal1 = new Vec3();
                const planeNormalWS1 = new Vec3();
                const worldA1 = new Vec3();
                const localPlaneNormal = new Vec3();
                const planeNormalWS = new Vec3();
                const hullA = this;
                const worldVertsB2 = [];
                const pVtxIn = worldVertsB1;
                const pVtxOut = worldVertsB2;
                let closestFaceA = -1;
                let dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis

                for (let face = 0; face < hullA.faces.length; face++) {
                  faceANormalWS.copy(hullA.faceNormals[face]);
                  quatA.vmult(faceANormalWS, faceANormalWS);
                  const d = faceANormalWS.dot(separatingNormal);

                  if (d < dmin) {
                    dmin = d;
                    closestFaceA = face;
                  }
                }

                if (closestFaceA < 0) {
                  return;
                } // Get the face and construct connected faces

                const polyA = hullA.faces[closestFaceA];
                polyA.connectedFaces = [];

                for (let i = 0; i < hullA.faces.length; i++) {
                  for (let j = 0; j < hullA.faces[i].length; j++) {
                    if (
                      /* Sharing a vertex*/
                      polyA.indexOf(hullA.faces[i][j]) !== -1 &&
                      /* Not the one we are looking for connections from */
                      i !== closestFaceA &&
                      /* Not already added */
                      polyA.connectedFaces.indexOf(i) === -1
                    ) {
                      polyA.connectedFaces.push(i);
                    }
                  }
                } // Clip the polygon to the back of the planes of all faces of hull A,
                // that are adjacent to the witness face

                const numVerticesA = polyA.length;

                for (let i = 0; i < numVerticesA; i++) {
                  const a = hullA.vertices[polyA[i]];
                  const b = hullA.vertices[polyA[(i + 1) % numVerticesA]];
                  a.vsub(b, edge0);
                  WorldEdge0.copy(edge0);
                  quatA.vmult(WorldEdge0, WorldEdge0);
                  posA.vadd(WorldEdge0, WorldEdge0);
                  worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
                  quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
                  posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
                  WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
                  planeNormalWS1.negate(planeNormalWS1);
                  worldA1.copy(a);
                  quatA.vmult(worldA1, worldA1);
                  posA.vadd(worldA1, worldA1);
                  const otherFace = polyA.connectedFaces[i];
                  localPlaneNormal.copy(this.faceNormals[otherFace]);
                  const localPlaneEq = this.getPlaneConstantOfFace(otherFace);
                  planeNormalWS.copy(localPlaneNormal);
                  quatA.vmult(planeNormalWS, planeNormalWS);
                  const planeEqWS = localPlaneEq - planeNormalWS.dot(posA); // Clip face against our constructed plane

                  this.clipFaceAgainstPlane(
                    pVtxIn,
                    pVtxOut,
                    planeNormalWS,
                    planeEqWS
                  ); // Throw away all clipped points, but save the remaining until next clip

                  while (pVtxIn.length) {
                    pVtxIn.shift();
                  }

                  while (pVtxOut.length) {
                    pVtxIn.push(pVtxOut.shift());
                  }
                } // only keep contact points that are behind the witness face

                localPlaneNormal.copy(this.faceNormals[closestFaceA]);
                const localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
                planeNormalWS.copy(localPlaneNormal);
                quatA.vmult(planeNormalWS, planeNormalWS);
                const planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

                for (let i = 0; i < pVtxIn.length; i++) {
                  let depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; // ???

                  if (depth <= minDist) {
                    console.log(
                      "clamped: depth=" + depth + " to minDist=" + minDist
                    );
                    depth = minDist;
                  }

                  if (depth <= maxDist) {
                    const point = pVtxIn[i];

                    if (depth <= 1e-6) {
                      const p = {
                        point,
                        normal: planeNormalWS,
                        depth,
                      };
                      result.push(p);
                    }
                  }
                }
              }
              /**
               * Clip a face in a hull against the back of a plane.
               * @param planeConstant The constant in the mathematical plane equation
               */

              clipFaceAgainstPlane(
                inVertices,
                outVertices,
                planeNormal,
                planeConstant
              ) {
                let n_dot_first;
                let n_dot_last;
                const numVerts = inVertices.length;

                if (numVerts < 2) {
                  return outVertices;
                }

                let firstVertex = inVertices[inVertices.length - 1];
                let lastVertex = inVertices[0];
                n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

                for (let vi = 0; vi < numVerts; vi++) {
                  lastVertex = inVertices[vi];
                  n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

                  if (n_dot_first < 0) {
                    if (n_dot_last < 0) {
                      // Start < 0, end < 0, so output lastVertex
                      const newv = new Vec3();
                      newv.copy(lastVertex);
                      outVertices.push(newv);
                    } else {
                      // Start < 0, end >= 0, so output intersection
                      const newv = new Vec3();
                      firstVertex.lerp(
                        lastVertex,
                        n_dot_first / (n_dot_first - n_dot_last),
                        newv
                      );
                      outVertices.push(newv);
                    }
                  } else {
                    if (n_dot_last < 0) {
                      // Start >= 0, end < 0 so output intersection and end
                      const newv = new Vec3();
                      firstVertex.lerp(
                        lastVertex,
                        n_dot_first / (n_dot_first - n_dot_last),
                        newv
                      );
                      outVertices.push(newv);
                      outVertices.push(lastVertex);
                    }
                  }

                  firstVertex = lastVertex;
                  n_dot_first = n_dot_last;
                }

                return outVertices;
              }
              /**
               * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
               */

              computeWorldVertices(position, quat) {
                while (this.worldVertices.length < this.vertices.length) {
                  this.worldVertices.push(new Vec3());
                }

                const verts = this.vertices;
                const worldVerts = this.worldVertices;

                for (let i = 0; i !== this.vertices.length; i++) {
                  quat.vmult(verts[i], worldVerts[i]);
                  position.vadd(worldVerts[i], worldVerts[i]);
                }

                this.worldVerticesNeedsUpdate = false;
              }

              computeLocalAABB(aabbmin, aabbmax) {
                const vertices = this.vertices;
                aabbmin.set(
                  Number.MAX_VALUE,
                  Number.MAX_VALUE,
                  Number.MAX_VALUE
                );
                aabbmax.set(
                  -Number.MAX_VALUE,
                  -Number.MAX_VALUE,
                  -Number.MAX_VALUE
                );

                for (let i = 0; i < this.vertices.length; i++) {
                  const v = vertices[i];

                  if (v.x < aabbmin.x) {
                    aabbmin.x = v.x;
                  } else if (v.x > aabbmax.x) {
                    aabbmax.x = v.x;
                  }

                  if (v.y < aabbmin.y) {
                    aabbmin.y = v.y;
                  } else if (v.y > aabbmax.y) {
                    aabbmax.y = v.y;
                  }

                  if (v.z < aabbmin.z) {
                    aabbmin.z = v.z;
                  } else if (v.z > aabbmax.z) {
                    aabbmax.z = v.z;
                  }
                }
              }
              /**
               * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
               */

              computeWorldFaceNormals(quat) {
                const N = this.faceNormals.length;

                while (this.worldFaceNormals.length < N) {
                  this.worldFaceNormals.push(new Vec3());
                }

                const normals = this.faceNormals;
                const worldNormals = this.worldFaceNormals;

                for (let i = 0; i !== N; i++) {
                  quat.vmult(normals[i], worldNormals[i]);
                }

                this.worldFaceNormalsNeedsUpdate = false;
              }
              /**
               * updateBoundingSphereRadius
               */

              updateBoundingSphereRadius() {
                // Assume points are distributed with local (0,0,0) as center
                let max2 = 0;
                const verts = this.vertices;

                for (let i = 0; i !== verts.length; i++) {
                  const norm2 = verts[i].lengthSquared();

                  if (norm2 > max2) {
                    max2 = norm2;
                  }
                }

                this.boundingSphereRadius = Math.sqrt(max2);
              }
              /**
               * calculateWorldAABB
               */

              calculateWorldAABB(pos, quat, min, max) {
                const verts = this.vertices;
                let minx;
                let miny;
                let minz;
                let maxx;
                let maxy;
                let maxz;
                let tempWorldVertex = new Vec3();

                for (let i = 0; i < verts.length; i++) {
                  tempWorldVertex.copy(verts[i]);
                  quat.vmult(tempWorldVertex, tempWorldVertex);
                  pos.vadd(tempWorldVertex, tempWorldVertex);
                  const v = tempWorldVertex;

                  if (minx === undefined || v.x < minx) {
                    minx = v.x;
                  }

                  if (maxx === undefined || v.x > maxx) {
                    maxx = v.x;
                  }

                  if (miny === undefined || v.y < miny) {
                    miny = v.y;
                  }

                  if (maxy === undefined || v.y > maxy) {
                    maxy = v.y;
                  }

                  if (minz === undefined || v.z < minz) {
                    minz = v.z;
                  }

                  if (maxz === undefined || v.z > maxz) {
                    maxz = v.z;
                  }
                }

                min.set(minx, miny, minz);
                max.set(maxx, maxy, maxz);
              }
              /**
               * Get approximate convex volume
               */

              volume() {
                return (4.0 * Math.PI * this.boundingSphereRadius) / 3.0;
              }
              /**
               * Get an average of all the vertices positions
               */

              getAveragePointLocal(target = new Vec3()) {
                const verts = this.vertices;

                for (let i = 0; i < verts.length; i++) {
                  target.vadd(verts[i], target);
                }

                target.scale(1 / verts.length, target);
                return target;
              }
              /**
               * Transform all local points. Will change the .vertices
               */

              transformAllPoints(offset, quat) {
                const n = this.vertices.length;
                const verts = this.vertices; // Apply rotation

                if (quat) {
                  // Rotate vertices
                  for (let i = 0; i < n; i++) {
                    const v = verts[i];
                    quat.vmult(v, v);
                  } // Rotate face normals

                  for (let i = 0; i < this.faceNormals.length; i++) {
                    const v = this.faceNormals[i];
                    quat.vmult(v, v);
                  }
                  /*
            // Rotate edges
            for(let i=0; i<this.uniqueEdges.length; i++){
                const v = this.uniqueEdges[i];
                quat.vmult(v,v);
            }*/
                } // Apply offset

                if (offset) {
                  for (let i = 0; i < n; i++) {
                    const v = verts[i];
                    v.vadd(offset, v);
                  }
                }
              }
              /**
               * Checks whether p is inside the polyhedra. Must be in local coords.
               * The point lies outside of the convex hull of the other points if and only if the direction
               * of all the vectors from it to those other points are on less than one half of a sphere around it.
               * @param p A point given in local coordinates
               */

              pointIsInside(p) {
                const verts = this.vertices;
                const faces = this.faces;
                const normals = this.faceNormals;
                const pointInside = new Vec3();
                this.getAveragePointLocal(pointInside);

                for (let i = 0; i < this.faces.length; i++) {
                  let n = normals[i];
                  const v = verts[faces[i][0]]; // We only need one point in the face
                  // This dot product determines which side of the edge the point is

                  const vToP = new Vec3();
                  p.vsub(v, vToP);
                  const r1 = n.dot(vToP);
                  const vToPointInside = new Vec3();
                  pointInside.vsub(v, vToPointInside);
                  const r2 = n.dot(vToPointInside);

                  if ((r1 < 0 && r2 > 0) || (r1 > 0 && r2 < 0)) {
                    return false; // Encountered some other sign. Exit.
                  }
                } // If we got here, all dot products were of the same sign.

                return -1;
              }
              /**
               * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
               * Results are saved in the array maxmin.
               * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
               */

              static project(shape, axis, pos, quat, result) {
                const n = shape.vertices.length;
                const localAxis = project_localAxis;
                let max = 0;
                let min = 0;
                const localOrigin = project_localOrigin;
                const vs = shape.vertices;
                localOrigin.setZero(); // Transform the axis to local

                Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
                Transform.pointToLocalFrame(
                  pos,
                  quat,
                  localOrigin,
                  localOrigin
                );
                const add = localOrigin.dot(localAxis);
                min = max = vs[0].dot(localAxis);

                for (let i = 1; i < n; i++) {
                  const val = vs[i].dot(localAxis);

                  if (val > max) {
                    max = val;
                  }

                  if (val < min) {
                    min = val;
                  }
                }

                min -= add;
                max -= add;

                if (min > max) {
                  // Inconsistent - swap
                  const temp = min;
                  min = max;
                  max = temp;
                } // Output

                result[0] = max;
                result[1] = min;
              }
            }
            const maxminA = [];
            const maxminB = [];
            const project_localAxis = new Vec3();
            const project_localOrigin = new Vec3();

            /**
             * A 3d box shape.
             * @example
             *     const size = 1
             *     const halfExtents = new CANNON.Vec3(size, size, size)
             *     const boxShape = new CANNON.Box(halfExtents)
             *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
             *     world.addBody(boxBody)
             */
            class Box extends Shape {
              /**
               * The half extents of the box.
               */

              /**
               * Used by the contact generator to make contacts with other convex polyhedra for example.
               */
              constructor(halfExtents) {
                super({
                  type: Shape.types.BOX,
                });
                this.halfExtents = void 0;
                this.convexPolyhedronRepresentation = void 0;
                this.halfExtents = halfExtents;
                this.convexPolyhedronRepresentation = null;
                this.updateConvexPolyhedronRepresentation();
                this.updateBoundingSphereRadius();
              }
              /**
               * Updates the local convex polyhedron representation used for some collisions.
               */

              updateConvexPolyhedronRepresentation() {
                const sx = this.halfExtents.x;
                const sy = this.halfExtents.y;
                const sz = this.halfExtents.z;
                const V = Vec3;
                const vertices = [
                  new V(-sx, -sy, -sz),
                  new V(sx, -sy, -sz),
                  new V(sx, sy, -sz),
                  new V(-sx, sy, -sz),
                  new V(-sx, -sy, sz),
                  new V(sx, -sy, sz),
                  new V(sx, sy, sz),
                  new V(-sx, sy, sz),
                ];
                const faces = [
                  [3, 2, 1, 0], // -z
                  [4, 5, 6, 7], // +z
                  [5, 4, 0, 1], // -y
                  [2, 3, 7, 6], // +y
                  [0, 4, 7, 3], // -x
                  [1, 2, 6, 5], // +x
                ];
                const axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
                const h = new ConvexPolyhedron({
                  vertices,
                  faces,
                  axes,
                });
                this.convexPolyhedronRepresentation = h;
                h.material = this.material;
              }
              /**
               * Calculate the inertia of the box.
               */

              calculateLocalInertia(mass, target = new Vec3()) {
                Box.calculateInertia(this.halfExtents, mass, target);
                return target;
              }

              static calculateInertia(halfExtents, mass, target) {
                const e = halfExtents;
                target.x =
                  (1.0 / 12.0) * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
                target.y =
                  (1.0 / 12.0) * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
                target.z =
                  (1.0 / 12.0) * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
              }
              /**
               * Get the box 6 side normals
               * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
               * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
               */

              getSideNormals(sixTargetVectors, quat) {
                const sides = sixTargetVectors;
                const ex = this.halfExtents;
                sides[0].set(ex.x, 0, 0);
                sides[1].set(0, ex.y, 0);
                sides[2].set(0, 0, ex.z);
                sides[3].set(-ex.x, 0, 0);
                sides[4].set(0, -ex.y, 0);
                sides[5].set(0, 0, -ex.z);

                if (quat !== undefined) {
                  for (let i = 0; i !== sides.length; i++) {
                    quat.vmult(sides[i], sides[i]);
                  }
                }

                return sides;
              }
              /**
               * Returns the volume of the box.
               */

              volume() {
                return (
                  8.0 *
                  this.halfExtents.x *
                  this.halfExtents.y *
                  this.halfExtents.z
                );
              }
              /**
               * updateBoundingSphereRadius
               */

              updateBoundingSphereRadius() {
                this.boundingSphereRadius = this.halfExtents.length();
              }
              /**
               * forEachWorldCorner
               */

              forEachWorldCorner(pos, quat, callback) {
                const e = this.halfExtents;
                const corners = [
                  [e.x, e.y, e.z],
                  [-e.x, e.y, e.z],
                  [-e.x, -e.y, e.z],
                  [-e.x, -e.y, -e.z],
                  [e.x, -e.y, -e.z],
                  [e.x, e.y, -e.z],
                  [-e.x, e.y, -e.z],
                  [e.x, -e.y, e.z],
                ];

                for (let i = 0; i < corners.length; i++) {
                  worldCornerTempPos.set(
                    corners[i][0],
                    corners[i][1],
                    corners[i][2]
                  );
                  quat.vmult(worldCornerTempPos, worldCornerTempPos);
                  pos.vadd(worldCornerTempPos, worldCornerTempPos);
                  callback(
                    worldCornerTempPos.x,
                    worldCornerTempPos.y,
                    worldCornerTempPos.z
                  );
                }
              }
              /**
               * calculateWorldAABB
               */

              calculateWorldAABB(pos, quat, min, max) {
                const e = this.halfExtents;
                worldCornersTemp[0].set(e.x, e.y, e.z);
                worldCornersTemp[1].set(-e.x, e.y, e.z);
                worldCornersTemp[2].set(-e.x, -e.y, e.z);
                worldCornersTemp[3].set(-e.x, -e.y, -e.z);
                worldCornersTemp[4].set(e.x, -e.y, -e.z);
                worldCornersTemp[5].set(e.x, e.y, -e.z);
                worldCornersTemp[6].set(-e.x, e.y, -e.z);
                worldCornersTemp[7].set(e.x, -e.y, e.z);
                const wc = worldCornersTemp[0];
                quat.vmult(wc, wc);
                pos.vadd(wc, wc);
                max.copy(wc);
                min.copy(wc);

                for (let i = 1; i < 8; i++) {
                  const wc = worldCornersTemp[i];
                  quat.vmult(wc, wc);
                  pos.vadd(wc, wc);
                  const x = wc.x;
                  const y = wc.y;
                  const z = wc.z;

                  if (x > max.x) {
                    max.x = x;
                  }

                  if (y > max.y) {
                    max.y = y;
                  }

                  if (z > max.z) {
                    max.z = z;
                  }

                  if (x < min.x) {
                    min.x = x;
                  }

                  if (y < min.y) {
                    min.y = y;
                  }

                  if (z < min.z) {
                    min.z = z;
                  }
                } // Get each axis max
                // min.set(Infinity,Infinity,Infinity);
                // max.set(-Infinity,-Infinity,-Infinity);
                // this.forEachWorldCorner(pos,quat,function(x,y,z){
                //     if(x > max.x){
                //         max.x = x;
                //     }
                //     if(y > max.y){
                //         max.y = y;
                //     }
                //     if(z > max.z){
                //         max.z = z;
                //     }
                //     if(x < min.x){
                //         min.x = x;
                //     }
                //     if(y < min.y){
                //         min.y = y;
                //     }
                //     if(z < min.z){
                //         min.z = z;
                //     }
                // });
              }
            }
            const worldCornerTempPos = new Vec3();
            const worldCornersTemp = [
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
            ];

            /**
             * BODY_TYPES
             */
            const BODY_TYPES = {
              /** DYNAMIC */
              DYNAMIC: 1,

              /** STATIC */
              STATIC: 2,

              /** KINEMATIC */
              KINEMATIC: 4,
            };
            /**
             * BodyType
             */

            /**
             * BODY_SLEEP_STATES
             */
            const BODY_SLEEP_STATES = {
              /** AWAKE */
              AWAKE: 0,

              /** SLEEPY */
              SLEEPY: 1,

              /** SLEEPING */
              SLEEPING: 2,
            };
            /**
             * BodySleepState
             */

            /**
             * Base class for all body types.
             * @example
             *     const shape = new CANNON.Sphere(1)
             *     const body = new CANNON.Body({
             *       mass: 1,
             *       shape,
             *     })
             *     world.addBody(body)
             */
            class Body extends EventTarget {
              /**
               * Dispatched after two bodies collide. This event is dispatched on each
               * of the two bodies involved in the collision.
               * @event collide
               * @param body The body that was involved in the collision.
               * @param contact The details of the collision.
               */

              /**
               * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
               */

              /**
               * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
               */

              /**
               * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
               */

              /**
               * AWAKE
               */

              /**
               * SLEEPY
               */

              /**
               * SLEEPING
               */

              /**
               * Dispatched after a sleeping body has woken up.
               * @event wakeup
               */

              /**
               * Dispatched after a body has gone in to the sleepy state.
               * @event sleepy
               */

              /**
               * Dispatched after a body has fallen asleep.
               * @event sleep
               */

              /**
               * Identifier of the body.
               */

              /**
               * Position of body in World.bodies. Updated by World and used in ArrayCollisionMatrix.
               */

              /**
               * Reference to the world the body is living in.
               */

              /**
               * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object. Deprecated - use World events instead.
               * @deprecated Use World events instead
               */

              /**
               * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object. Deprecated - use World events instead.
               * @deprecated Use World events instead
               */

              /**
               * The collision group the body belongs to.
               * @default 1
               */

              /**
               * The collision group the body can collide with.
               * @default -1
               */

              /**
               * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
               */

              /**
               * World space position of the body.
               */

              /**
               * Interpolated position of the body.
               */

              /**
               * Initial position of the body.
               */

              /**
               * World space velocity of the body.
               */

              /**
               * Initial velocity of the body.
               */

              /**
               * Linear force on the body in world space.
               */

              /**
               * The mass of the body.
               * @default 0
               */

              /**
               * The physics material of the body. It defines the body interaction with other bodies.
               */

              /**
               * How much to damp the body velocity each step. It can go from 0 to 1.
               * @default 0.01
               */

              /**
               * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
               */

              /**
               * If true, the body will automatically fall to sleep.
               * @default true
               */

              /**
               * Current sleep state.
               */

              /**
               * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
               * @default 0.1
               */

              /**
               * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
               * @default 1
               */

              /**
               * World space rotational force on the body, around center of mass.
               */

              /**
               * World space orientation of the body.
               */

              /**
               * Initial quaternion of the body.
               */

              /**
               * Interpolated orientation of the body.
               */

              /**
               * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
               */

              /**
               * Initial angular velocity of the body.
               */

              /**
               * List of Shapes that have been added to the body.
               */

              /**
               * Position of each Shape in the body, given in local Body space.
               */

              /**
               * Orientation of each Shape, given in local Body space.
               */

              /**
               * The inertia of the body.
               */

              /**
               * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
               * @default false
               */

              /**
               * How much to damp the body angular velocity each step. It can go from 0 to 1.
               * @default 0.01
               */

              /**
               * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
               */

              /**
               * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
               */

              /**
               * World space bounding box of the body and its shapes.
               */

              /**
               * Indicates if the AABB needs to be updated before use.
               */

              /**
               * Total bounding radius of the Body including its shapes, relative to body.position.
               */

              /**
               * When true the body behaves like a trigger. It does not collide
               * with other bodies but collision events are still triggered.
               * @default false
               */
              constructor(options = {}) {
                super();
                this.id = void 0;
                this.index = void 0;
                this.world = void 0;
                this.preStep = void 0;
                this.postStep = void 0;
                this.vlambda = void 0;
                this.collisionFilterGroup = void 0;
                this.collisionFilterMask = void 0;
                this.collisionResponse = void 0;
                this.position = void 0;
                this.previousPosition = void 0;
                this.interpolatedPosition = void 0;
                this.initPosition = void 0;
                this.velocity = void 0;
                this.initVelocity = void 0;
                this.force = void 0;
                this.mass = void 0;
                this.invMass = void 0;
                this.material = void 0;
                this.linearDamping = void 0;
                this.type = void 0;
                this.allowSleep = void 0;
                this.sleepState = void 0;
                this.sleepSpeedLimit = void 0;
                this.sleepTimeLimit = void 0;
                this.timeLastSleepy = void 0;
                this.wakeUpAfterNarrowphase = void 0;
                this.torque = void 0;
                this.quaternion = void 0;
                this.initQuaternion = void 0;
                this.previousQuaternion = void 0;
                this.interpolatedQuaternion = void 0;
                this.angularVelocity = void 0;
                this.initAngularVelocity = void 0;
                this.shapes = void 0;
                this.shapeOffsets = void 0;
                this.shapeOrientations = void 0;
                this.inertia = void 0;
                this.invInertia = void 0;
                this.invInertiaWorld = void 0;
                this.invMassSolve = void 0;
                this.invInertiaSolve = void 0;
                this.invInertiaWorldSolve = void 0;
                this.fixedRotation = void 0;
                this.angularDamping = void 0;
                this.linearFactor = void 0;
                this.angularFactor = void 0;
                this.aabb = void 0;
                this.aabbNeedsUpdate = void 0;
                this.boundingRadius = void 0;
                this.wlambda = void 0;
                this.isTrigger = void 0;
                this.id = Body.idCounter++;
                this.index = -1;
                this.world = null;
                this.preStep = null;
                this.postStep = null;
                this.vlambda = new Vec3();
                this.collisionFilterGroup =
                  typeof options.collisionFilterGroup === "number"
                    ? options.collisionFilterGroup
                    : 1;
                this.collisionFilterMask =
                  typeof options.collisionFilterMask === "number"
                    ? options.collisionFilterMask
                    : -1;
                this.collisionResponse =
                  typeof options.collisionResponse === "boolean"
                    ? options.collisionResponse
                    : true;
                this.position = new Vec3();
                this.previousPosition = new Vec3();
                this.interpolatedPosition = new Vec3();
                this.initPosition = new Vec3();

                if (options.position) {
                  this.position.copy(options.position);
                  this.previousPosition.copy(options.position);
                  this.interpolatedPosition.copy(options.position);
                  this.initPosition.copy(options.position);
                }

                this.velocity = new Vec3();

                if (options.velocity) {
                  this.velocity.copy(options.velocity);
                }

                this.initVelocity = new Vec3();
                this.force = new Vec3();
                const mass =
                  typeof options.mass === "number" ? options.mass : 0;
                this.mass = mass;
                this.invMass = mass > 0 ? 1.0 / mass : 0;
                this.material = options.material || null;
                this.linearDamping =
                  typeof options.linearDamping === "number"
                    ? options.linearDamping
                    : 0.01;
                this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

                if (typeof options.type === typeof Body.STATIC) {
                  this.type = options.type;
                }

                this.allowSleep =
                  typeof options.allowSleep !== "undefined"
                    ? options.allowSleep
                    : true;
                this.sleepState = Body.AWAKE;
                this.sleepSpeedLimit =
                  typeof options.sleepSpeedLimit !== "undefined"
                    ? options.sleepSpeedLimit
                    : 0.1;
                this.sleepTimeLimit =
                  typeof options.sleepTimeLimit !== "undefined"
                    ? options.sleepTimeLimit
                    : 1;
                this.timeLastSleepy = 0;
                this.wakeUpAfterNarrowphase = false;
                this.torque = new Vec3();
                this.quaternion = new Quaternion();
                this.initQuaternion = new Quaternion();
                this.previousQuaternion = new Quaternion();
                this.interpolatedQuaternion = new Quaternion();

                if (options.quaternion) {
                  this.quaternion.copy(options.quaternion);
                  this.initQuaternion.copy(options.quaternion);
                  this.previousQuaternion.copy(options.quaternion);
                  this.interpolatedQuaternion.copy(options.quaternion);
                }

                this.angularVelocity = new Vec3();

                if (options.angularVelocity) {
                  this.angularVelocity.copy(options.angularVelocity);
                }

                this.initAngularVelocity = new Vec3();
                this.shapes = [];
                this.shapeOffsets = [];
                this.shapeOrientations = [];
                this.inertia = new Vec3();
                this.invInertia = new Vec3();
                this.invInertiaWorld = new Mat3();
                this.invMassSolve = 0;
                this.invInertiaSolve = new Vec3();
                this.invInertiaWorldSolve = new Mat3();
                this.fixedRotation =
                  typeof options.fixedRotation !== "undefined"
                    ? options.fixedRotation
                    : false;
                this.angularDamping =
                  typeof options.angularDamping !== "undefined"
                    ? options.angularDamping
                    : 0.01;
                this.linearFactor = new Vec3(1, 1, 1);

                if (options.linearFactor) {
                  this.linearFactor.copy(options.linearFactor);
                }

                this.angularFactor = new Vec3(1, 1, 1);

                if (options.angularFactor) {
                  this.angularFactor.copy(options.angularFactor);
                }

                this.aabb = new AABB();
                this.aabbNeedsUpdate = true;
                this.boundingRadius = 0;
                this.wlambda = new Vec3();
                this.isTrigger = Boolean(options.isTrigger);

                if (options.shape) {
                  this.addShape(options.shape);
                }

                this.updateMassProperties();
              }
              /**
               * Wake the body up.
               */

              wakeUp() {
                const prevState = this.sleepState;
                this.sleepState = Body.AWAKE;
                this.wakeUpAfterNarrowphase = false;

                if (prevState === Body.SLEEPING) {
                  this.dispatchEvent(Body.wakeupEvent);
                }
              }
              /**
               * Force body sleep
               */

              sleep() {
                this.sleepState = Body.SLEEPING;
                this.velocity.set(0, 0, 0);
                this.angularVelocity.set(0, 0, 0);
                this.wakeUpAfterNarrowphase = false;
              }
              /**
               * Called every timestep to update internal sleep timer and change sleep state if needed.
               * @param time The world time in seconds
               */

              sleepTick(time) {
                if (this.allowSleep) {
                  const sleepState = this.sleepState;
                  const speedSquared =
                    this.velocity.lengthSquared() +
                    this.angularVelocity.lengthSquared();
                  const speedLimitSquared = this.sleepSpeedLimit ** 2;

                  if (
                    sleepState === Body.AWAKE &&
                    speedSquared < speedLimitSquared
                  ) {
                    this.sleepState = Body.SLEEPY; // Sleepy

                    this.timeLastSleepy = time;
                    this.dispatchEvent(Body.sleepyEvent);
                  } else if (
                    sleepState === Body.SLEEPY &&
                    speedSquared > speedLimitSquared
                  ) {
                    this.wakeUp(); // Wake up
                  } else if (
                    sleepState === Body.SLEEPY &&
                    time - this.timeLastSleepy > this.sleepTimeLimit
                  ) {
                    this.sleep(); // Sleeping

                    this.dispatchEvent(Body.sleepEvent);
                  }
                }
              }
              /**
               * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
               */

              updateSolveMassProperties() {
                if (
                  this.sleepState === Body.SLEEPING ||
                  this.type === Body.KINEMATIC
                ) {
                  this.invMassSolve = 0;
                  this.invInertiaSolve.setZero();
                  this.invInertiaWorldSolve.setZero();
                } else {
                  this.invMassSolve = this.invMass;
                  this.invInertiaSolve.copy(this.invInertia);
                  this.invInertiaWorldSolve.copy(this.invInertiaWorld);
                }
              }
              /**
               * Convert a world point to local body frame.
               */

              pointToLocalFrame(worldPoint, result = new Vec3()) {
                worldPoint.vsub(this.position, result);
                this.quaternion.conjugate().vmult(result, result);
                return result;
              }
              /**
               * Convert a world vector to local body frame.
               */

              vectorToLocalFrame(worldVector, result = new Vec3()) {
                this.quaternion.conjugate().vmult(worldVector, result);
                return result;
              }
              /**
               * Convert a local body point to world frame.
               */

              pointToWorldFrame(localPoint, result = new Vec3()) {
                this.quaternion.vmult(localPoint, result);
                result.vadd(this.position, result);
                return result;
              }
              /**
               * Convert a local body point to world frame.
               */

              vectorToWorldFrame(localVector, result = new Vec3()) {
                this.quaternion.vmult(localVector, result);
                return result;
              }
              /**
               * Add a shape to the body with a local offset and orientation.
               * @return The body object, for chainability.
               */

              addShape(shape, _offset, _orientation) {
                const offset = new Vec3();
                const orientation = new Quaternion();

                if (_offset) {
                  offset.copy(_offset);
                }

                if (_orientation) {
                  orientation.copy(_orientation);
                }

                this.shapes.push(shape);
                this.shapeOffsets.push(offset);
                this.shapeOrientations.push(orientation);
                this.updateMassProperties();
                this.updateBoundingRadius();
                this.aabbNeedsUpdate = true;
                shape.body = this;
                return this;
              }
              /**
               * Remove a shape from the body.
               * @return The body object, for chainability.
               */

              removeShape(shape) {
                const index = this.shapes.indexOf(shape);

                if (index === -1) {
                  console.warn("Shape does not belong to the body");
                  return this;
                }

                this.shapes.splice(index, 1);
                this.shapeOffsets.splice(index, 1);
                this.shapeOrientations.splice(index, 1);
                this.updateMassProperties();
                this.updateBoundingRadius();
                this.aabbNeedsUpdate = true;
                shape.body = null;
                return this;
              }
              /**
               * Update the bounding radius of the body. Should be done if any of the shapes are changed.
               */

              updateBoundingRadius() {
                const shapes = this.shapes;
                const shapeOffsets = this.shapeOffsets;
                const N = shapes.length;
                let radius = 0;

                for (let i = 0; i !== N; i++) {
                  const shape = shapes[i];
                  shape.updateBoundingSphereRadius();
                  const offset = shapeOffsets[i].length();
                  const r = shape.boundingSphereRadius;

                  if (offset + r > radius) {
                    radius = offset + r;
                  }
                }

                this.boundingRadius = radius;
              }
              /**
               * Updates the .aabb
               */

              updateAABB() {
                const shapes = this.shapes;
                const shapeOffsets = this.shapeOffsets;
                const shapeOrientations = this.shapeOrientations;
                const N = shapes.length;
                const offset = tmpVec;
                const orientation = tmpQuat;
                const bodyQuat = this.quaternion;
                const aabb = this.aabb;
                const shapeAABB = updateAABB_shapeAABB;

                for (let i = 0; i !== N; i++) {
                  const shape = shapes[i]; // Get shape world position

                  bodyQuat.vmult(shapeOffsets[i], offset);
                  offset.vadd(this.position, offset); // Get shape world quaternion

                  bodyQuat.mult(shapeOrientations[i], orientation); // Get shape AABB

                  shape.calculateWorldAABB(
                    offset,
                    orientation,
                    shapeAABB.lowerBound,
                    shapeAABB.upperBound
                  );

                  if (i === 0) {
                    aabb.copy(shapeAABB);
                  } else {
                    aabb.extend(shapeAABB);
                  }
                }

                this.aabbNeedsUpdate = false;
              }
              /**
               * Update `.inertiaWorld` and `.invInertiaWorld`
               */

              updateInertiaWorld(force) {
                const I = this.invInertia;

                if (I.x === I.y && I.y === I.z && !force);
                else {
                  const m1 = uiw_m1;
                  const m2 = uiw_m2;
                  m1.setRotationFromQuaternion(this.quaternion);
                  m1.transpose(m2);
                  m1.scale(I, m1);
                  m1.mmult(m2, this.invInertiaWorld);
                }
              }
              /**
               * Apply force to a point of the body. This could for example be a point on the Body surface.
               * Applying force this way will add to Body.force and Body.torque.
               * @param force The amount of force to add.
               * @param relativePoint A point relative to the center of mass to apply the force on.
               */

              applyForce(force, relativePoint = new Vec3()) {
                // Needed?
                if (this.type !== Body.DYNAMIC) {
                  return;
                }

                if (this.sleepState === Body.SLEEPING) {
                  this.wakeUp();
                } // Compute produced rotational force

                const rotForce = Body_applyForce_rotForce;
                relativePoint.cross(force, rotForce); // Add linear force

                this.force.vadd(force, this.force); // Add rotational force

                this.torque.vadd(rotForce, this.torque);
              }
              /**
               * Apply force to a local point in the body.
               * @param force The force vector to apply, defined locally in the body frame.
               * @param localPoint A local point in the body to apply the force on.
               */

              applyLocalForce(localForce, localPoint = new Vec3()) {
                if (this.type !== Body.DYNAMIC) {
                  return;
                }

                const worldForce = Body_applyLocalForce_worldForce;
                const relativePointWorld =
                  Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

                this.vectorToWorldFrame(localForce, worldForce);
                this.vectorToWorldFrame(localPoint, relativePointWorld);
                this.applyForce(worldForce, relativePointWorld);
              }
              /**
               * Apply torque to the body.
               * @param torque The amount of torque to add.
               */

              applyTorque(torque) {
                if (this.type !== Body.DYNAMIC) {
                  return;
                }

                if (this.sleepState === Body.SLEEPING) {
                  this.wakeUp();
                } // Add rotational force

                this.torque.vadd(torque, this.torque);
              }
              /**
               * Apply impulse to a point of the body. This could for example be a point on the Body surface.
               * An impulse is a force added to a body during a short period of time (impulse = force * time).
               * Impulses will be added to Body.velocity and Body.angularVelocity.
               * @param impulse The amount of impulse to add.
               * @param relativePoint A point relative to the center of mass to apply the force on.
               */

              applyImpulse(impulse, relativePoint = new Vec3()) {
                if (this.type !== Body.DYNAMIC) {
                  return;
                }

                if (this.sleepState === Body.SLEEPING) {
                  this.wakeUp();
                } // Compute point position relative to the body center

                const r = relativePoint; // Compute produced central impulse velocity

                const velo = Body_applyImpulse_velo;
                velo.copy(impulse);
                velo.scale(this.invMass, velo); // Add linear impulse

                this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

                const rotVelo = Body_applyImpulse_rotVelo;
                r.cross(impulse, rotVelo);
                /*
     rotVelo.x *= this.invInertia.x;
     rotVelo.y *= this.invInertia.y;
     rotVelo.z *= this.invInertia.z;
     */

                this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

                this.angularVelocity.vadd(rotVelo, this.angularVelocity);
              }
              /**
               * Apply locally-defined impulse to a local point in the body.
               * @param force The force vector to apply, defined locally in the body frame.
               * @param localPoint A local point in the body to apply the force on.
               */

              applyLocalImpulse(localImpulse, localPoint = new Vec3()) {
                if (this.type !== Body.DYNAMIC) {
                  return;
                }

                const worldImpulse = Body_applyLocalImpulse_worldImpulse;
                const relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

                this.vectorToWorldFrame(localImpulse, worldImpulse);
                this.vectorToWorldFrame(localPoint, relativePointWorld);
                this.applyImpulse(worldImpulse, relativePointWorld);
              }
              /**
               * Should be called whenever you change the body shape or mass.
               */

              updateMassProperties() {
                const halfExtents = Body_updateMassProperties_halfExtents;
                this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
                const I = this.inertia;
                const fixed = this.fixedRotation; // Approximate with AABB box

                this.updateAABB();
                halfExtents.set(
                  (this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2,
                  (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2,
                  (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2
                );
                Box.calculateInertia(halfExtents, this.mass, I);
                this.invInertia.set(
                  I.x > 0 && !fixed ? 1.0 / I.x : 0,
                  I.y > 0 && !fixed ? 1.0 / I.y : 0,
                  I.z > 0 && !fixed ? 1.0 / I.z : 0
                );
                this.updateInertiaWorld(true);
              }
              /**
               * Get world velocity of a point in the body.
               * @param worldPoint
               * @param result
               * @return The result vector.
               */

              getVelocityAtWorldPoint(worldPoint, result) {
                const r = new Vec3();
                worldPoint.vsub(this.position, r);
                this.angularVelocity.cross(r, result);
                this.velocity.vadd(result, result);
                return result;
              }
              /**
               * Move the body forward in time.
               * @param dt Time step
               * @param quatNormalize Set to true to normalize the body quaternion
               * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
               */

              integrate(dt, quatNormalize, quatNormalizeFast) {
                // Save previous position
                this.previousPosition.copy(this.position);
                this.previousQuaternion.copy(this.quaternion);

                if (
                  !(
                    this.type === Body.DYNAMIC || this.type === Body.KINEMATIC
                  ) ||
                  this.sleepState === Body.SLEEPING
                ) {
                  // Only for dynamic
                  return;
                }

                const velo = this.velocity;
                const angularVelo = this.angularVelocity;
                const pos = this.position;
                const force = this.force;
                const torque = this.torque;
                const quat = this.quaternion;
                const invMass = this.invMass;
                const invInertia = this.invInertiaWorld;
                const linearFactor = this.linearFactor;
                const iMdt = invMass * dt;
                velo.x += force.x * iMdt * linearFactor.x;
                velo.y += force.y * iMdt * linearFactor.y;
                velo.z += force.z * iMdt * linearFactor.z;
                const e = invInertia.elements;
                const angularFactor = this.angularFactor;
                const tx = torque.x * angularFactor.x;
                const ty = torque.y * angularFactor.y;
                const tz = torque.z * angularFactor.z;
                angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
                angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
                angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

                pos.x += velo.x * dt;
                pos.y += velo.y * dt;
                pos.z += velo.z * dt;
                quat.integrate(
                  this.angularVelocity,
                  dt,
                  this.angularFactor,
                  quat
                );

                if (quatNormalize) {
                  if (quatNormalizeFast) {
                    quat.normalizeFast();
                  } else {
                    quat.normalize();
                  }
                }

                this.aabbNeedsUpdate = true; // Update world inertia

                this.updateInertiaWorld();
              }
            }
            Body.idCounter = 0;
            Body.COLLIDE_EVENT_NAME = "collide";
            Body.DYNAMIC = BODY_TYPES.DYNAMIC;
            Body.STATIC = BODY_TYPES.STATIC;
            Body.KINEMATIC = BODY_TYPES.KINEMATIC;
            Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
            Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
            Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
            Body.wakeupEvent = {
              type: "wakeup",
            };
            Body.sleepyEvent = {
              type: "sleepy",
            };
            Body.sleepEvent = {
              type: "sleep",
            };
            const tmpVec = new Vec3();
            const tmpQuat = new Quaternion();
            const updateAABB_shapeAABB = new AABB();
            const uiw_m1 = new Mat3();
            const uiw_m2 = new Mat3();
            const Body_applyForce_rotForce = new Vec3();
            const Body_applyLocalForce_worldForce = new Vec3();
            const Body_applyLocalForce_relativePointWorld = new Vec3();
            const Body_applyImpulse_velo = new Vec3();
            const Body_applyImpulse_rotVelo = new Vec3();
            const Body_applyLocalImpulse_worldImpulse = new Vec3();
            const Body_applyLocalImpulse_relativePoint = new Vec3();
            const Body_updateMassProperties_halfExtents = new Vec3();

            /**
             * Base class for broadphase implementations
             * @author schteppe
             */
            class Broadphase {
              /**
               * The world to search for collisions in.
               */

              /**
               * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
               */

              /**
               * Set to true if the objects in the world moved.
               */
              constructor() {
                this.world = void 0;
                this.useBoundingBoxes = void 0;
                this.dirty = void 0;
                this.world = null;
                this.useBoundingBoxes = false;
                this.dirty = true;
              }
              /**
               * Get the collision pairs from the world
               * @param world The world to search in
               * @param p1 Empty array to be filled with body objects
               * @param p2 Empty array to be filled with body objects
               */

              collisionPairs(world, p1, p2) {
                throw new Error(
                  "collisionPairs not implemented for this BroadPhase class!"
                );
              }
              /**
               * Check if a body pair needs to be intersection tested at all.
               */

              needBroadphaseCollision(bodyA, bodyB) {
                // Check collision filter masks
                if (
                  (bodyA.collisionFilterGroup & bodyB.collisionFilterMask) ===
                    0 ||
                  (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0
                ) {
                  return false;
                } // Check types

                if (
                  ((bodyA.type & Body.STATIC) !== 0 ||
                    bodyA.sleepState === Body.SLEEPING) &&
                  ((bodyB.type & Body.STATIC) !== 0 ||
                    bodyB.sleepState === Body.SLEEPING)
                ) {
                  // Both bodies are static or sleeping. Skip.
                  return false;
                }

                return true;
              }
              /**
               * Check if the bounding volumes of two bodies intersect.
               */

              intersectionTest(bodyA, bodyB, pairs1, pairs2) {
                if (this.useBoundingBoxes) {
                  this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
                } else {
                  this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
                }
              }
              /**
               * Check if the bounding spheres of two bodies are intersecting.
               * @param pairs1 bodyA is appended to this array if intersection
               * @param pairs2 bodyB is appended to this array if intersection
               */

              doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2) {
                const r = Broadphase_collisionPairs_r;
                bodyB.position.vsub(bodyA.position, r);
                const boundingRadiusSum2 =
                  (bodyA.boundingRadius + bodyB.boundingRadius) ** 2;
                const norm2 = r.lengthSquared();

                if (norm2 < boundingRadiusSum2) {
                  pairs1.push(bodyA);
                  pairs2.push(bodyB);
                }
              }
              /**
               * Check if the bounding boxes of two bodies are intersecting.
               */

              doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) {
                if (bodyA.aabbNeedsUpdate) {
                  bodyA.updateAABB();
                }

                if (bodyB.aabbNeedsUpdate) {
                  bodyB.updateAABB();
                } // Check AABB / AABB

                if (bodyA.aabb.overlaps(bodyB.aabb)) {
                  pairs1.push(bodyA);
                  pairs2.push(bodyB);
                }
              }
              /**
               * Removes duplicate pairs from the pair arrays.
               */

              makePairsUnique(pairs1, pairs2) {
                const t = Broadphase_makePairsUnique_temp;
                const p1 = Broadphase_makePairsUnique_p1;
                const p2 = Broadphase_makePairsUnique_p2;
                const N = pairs1.length;

                for (let i = 0; i !== N; i++) {
                  p1[i] = pairs1[i];
                  p2[i] = pairs2[i];
                }

                pairs1.length = 0;
                pairs2.length = 0;

                for (let i = 0; i !== N; i++) {
                  const id1 = p1[i].id;
                  const id2 = p2[i].id;
                  const key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
                  t[key] = i;
                  t.keys.push(key);
                }

                for (let i = 0; i !== t.keys.length; i++) {
                  const key = t.keys.pop();
                  const pairIndex = t[key];
                  pairs1.push(p1[pairIndex]);
                  pairs2.push(p2[pairIndex]);
                  delete t[key];
                }
              }
              /**
               * To be implemented by subcasses
               */

              setWorld(world) {}
              /**
               * Check if the bounding spheres of two bodies overlap.
               */

              static boundingSphereCheck(bodyA, bodyB) {
                const dist = new Vec3(); // bsc_dist;

                bodyA.position.vsub(bodyB.position, dist);
                const sa = bodyA.shapes[0];
                const sb = bodyB.shapes[0];
                return (
                  Math.pow(
                    sa.boundingSphereRadius + sb.boundingSphereRadius,
                    2
                  ) > dist.lengthSquared()
                );
              }
              /**
               * Returns all the bodies within the AABB.
               */

              aabbQuery(world, aabb, result) {
                console.warn(
                  ".aabbQuery is not implemented in this Broadphase subclass."
                );
                return [];
              }
            } // Temp objects

            const Broadphase_collisionPairs_r = new Vec3();
            const Broadphase_makePairsUnique_temp = {
              keys: [],
            };
            const Broadphase_makePairsUnique_p1 = [];
            const Broadphase_makePairsUnique_p2 = [];

            /**
             * Axis aligned uniform grid broadphase.
             * @todo Needs support for more than just planes and spheres.
             */
            class GridBroadphase extends Broadphase {
              /**
               * Number of boxes along x
               */

              /**
               * Number of boxes along y
               */

              /**
               * Number of boxes along z
               */

              /**
               * aabbMin
               */

              /**
               * aabbMax
               */

              /**
               * bins
               */

              /**
               * binLengths
               */

              /**
               * @param nx Number of boxes along x.
               * @param ny Number of boxes along y.
               * @param nz Number of boxes along z.
               */
              constructor(
                aabbMin = new Vec3(100, 100, 100),
                aabbMax = new Vec3(-100, -100, -100),
                nx = 10,
                ny = 10,
                nz = 10
              ) {
                super();
                this.nx = void 0;
                this.ny = void 0;
                this.nz = void 0;
                this.aabbMin = void 0;
                this.aabbMax = void 0;
                this.bins = void 0;
                this.binLengths = void 0;
                this.nx = nx;
                this.ny = ny;
                this.nz = nz;
                this.aabbMin = aabbMin;
                this.aabbMax = aabbMax;
                const nbins = this.nx * this.ny * this.nz;

                if (nbins <= 0) {
                  throw "GridBroadphase: Each dimension's n must be >0";
                }

                this.bins = [];
                this.binLengths = []; // Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow

                this.bins.length = nbins;
                this.binLengths.length = nbins;

                for (let i = 0; i < nbins; i++) {
                  this.bins[i] = [];
                  this.binLengths[i] = 0;
                }
              }
              /**
               * Get all the collision pairs in the physics world
               */

              collisionPairs(world, pairs1, pairs2) {
                const N = world.numObjects();
                const bodies = world.bodies;
                const max = this.aabbMax;
                const min = this.aabbMin;
                const nx = this.nx;
                const ny = this.ny;
                const nz = this.nz;
                const xstep = ny * nz;
                const ystep = nz;
                const zstep = 1;
                const xmax = max.x;
                const ymax = max.y;
                const zmax = max.z;
                const xmin = min.x;
                const ymin = min.y;
                const zmin = min.z;
                const xmult = nx / (xmax - xmin);
                const ymult = ny / (ymax - ymin);
                const zmult = nz / (zmax - zmin);
                const binsizeX = (xmax - xmin) / nx;
                const binsizeY = (ymax - ymin) / ny;
                const binsizeZ = (zmax - zmin) / nz;
                const binRadius =
                  Math.sqrt(
                    binsizeX * binsizeX +
                      binsizeY * binsizeY +
                      binsizeZ * binsizeZ
                  ) * 0.5;
                const types = Shape.types;
                const SPHERE = types.SPHERE;
                const PLANE = types.PLANE;
                types.BOX;
                types.COMPOUND;
                types.CONVEXPOLYHEDRON;
                const bins = this.bins;
                const binLengths = this.binLengths;
                const Nbins = this.bins.length; // Reset bins

                for (let i = 0; i !== Nbins; i++) {
                  binLengths[i] = 0;
                }

                const ceil = Math.ceil;

                function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
                  let xoff0 = ((x0 - xmin) * xmult) | 0;
                  let yoff0 = ((y0 - ymin) * ymult) | 0;
                  let zoff0 = ((z0 - zmin) * zmult) | 0;
                  let xoff1 = ceil((x1 - xmin) * xmult);
                  let yoff1 = ceil((y1 - ymin) * ymult);
                  let zoff1 = ceil((z1 - zmin) * zmult);

                  if (xoff0 < 0) {
                    xoff0 = 0;
                  } else if (xoff0 >= nx) {
                    xoff0 = nx - 1;
                  }

                  if (yoff0 < 0) {
                    yoff0 = 0;
                  } else if (yoff0 >= ny) {
                    yoff0 = ny - 1;
                  }

                  if (zoff0 < 0) {
                    zoff0 = 0;
                  } else if (zoff0 >= nz) {
                    zoff0 = nz - 1;
                  }

                  if (xoff1 < 0) {
                    xoff1 = 0;
                  } else if (xoff1 >= nx) {
                    xoff1 = nx - 1;
                  }

                  if (yoff1 < 0) {
                    yoff1 = 0;
                  } else if (yoff1 >= ny) {
                    yoff1 = ny - 1;
                  }

                  if (zoff1 < 0) {
                    zoff1 = 0;
                  } else if (zoff1 >= nz) {
                    zoff1 = nz - 1;
                  }

                  xoff0 *= xstep;
                  yoff0 *= ystep;
                  zoff0 *= zstep;
                  xoff1 *= xstep;
                  yoff1 *= ystep;
                  zoff1 *= zstep;

                  for (let xoff = xoff0; xoff <= xoff1; xoff += xstep) {
                    for (let yoff = yoff0; yoff <= yoff1; yoff += ystep) {
                      for (let zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                        const idx = xoff + yoff + zoff;
                        bins[idx][binLengths[idx]++] = bi;
                      }
                    }
                  }
                } // Put all bodies into the bins

                for (let i = 0; i !== N; i++) {
                  const bi = bodies[i];
                  const si = bi.shapes[0];

                  switch (si.type) {
                    case SPHERE: {
                      const shape = si; // Put in bin
                      // check if overlap with other bins

                      const x = bi.position.x;
                      const y = bi.position.y;
                      const z = bi.position.z;
                      const r = shape.radius;
                      addBoxToBins(
                        x - r,
                        y - r,
                        z - r,
                        x + r,
                        y + r,
                        z + r,
                        bi
                      );
                      break;
                    }

                    case PLANE: {
                      const shape = si;

                      if (shape.worldNormalNeedsUpdate) {
                        shape.computeWorldNormal(bi.quaternion);
                      }

                      const planeNormal = shape.worldNormal; //Relative position from origin of plane object to the first bin
                      //Incremented as we iterate through the bins

                      const xreset = xmin + binsizeX * 0.5 - bi.position.x;
                      const yreset = ymin + binsizeY * 0.5 - bi.position.y;
                      const zreset = zmin + binsizeZ * 0.5 - bi.position.z;
                      const d = GridBroadphase_collisionPairs_d;
                      d.set(xreset, yreset, zreset);

                      for (
                        let xi = 0, xoff = 0;
                        xi !== nx;
                        xi++, xoff += xstep, d.y = yreset, d.x += binsizeX
                      ) {
                        for (
                          let yi = 0, yoff = 0;
                          yi !== ny;
                          yi++, yoff += ystep, d.z = zreset, d.y += binsizeY
                        ) {
                          for (
                            let zi = 0, zoff = 0;
                            zi !== nz;
                            zi++, zoff += zstep, d.z += binsizeZ
                          ) {
                            if (d.dot(planeNormal) < binRadius) {
                              const idx = xoff + yoff + zoff;
                              bins[idx][binLengths[idx]++] = bi;
                            }
                          }
                        }
                      }

                      break;
                    }

                    default: {
                      if (bi.aabbNeedsUpdate) {
                        bi.updateAABB();
                      }

                      addBoxToBins(
                        bi.aabb.lowerBound.x,
                        bi.aabb.lowerBound.y,
                        bi.aabb.lowerBound.z,
                        bi.aabb.upperBound.x,
                        bi.aabb.upperBound.y,
                        bi.aabb.upperBound.z,
                        bi
                      );
                      break;
                    }
                  }
                } // Check each bin

                for (let i = 0; i !== Nbins; i++) {
                  const binLength = binLengths[i]; //Skip bins with no potential collisions

                  if (binLength > 1) {
                    const bin = bins[i]; // Do N^2 broadphase inside

                    for (let xi = 0; xi !== binLength; xi++) {
                      const bi = bin[xi];

                      for (let yi = 0; yi !== xi; yi++) {
                        const bj = bin[yi];

                        if (this.needBroadphaseCollision(bi, bj)) {
                          this.intersectionTest(bi, bj, pairs1, pairs2);
                        }
                      }
                    }
                  }
                } //	for (let zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
                //		console.log("layer "+zi);
                //		for (let yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
                //			const row = '';
                //			for (let xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
                //				const idx = xoff + yoff + zoff;
                //				row += ' ' + binLengths[idx];
                //			}
                //			console.log(row);
                //		}
                //	}

                this.makePairsUnique(pairs1, pairs2);
              }
            }
            const GridBroadphase_collisionPairs_d = new Vec3();

            /**
             * Naive broadphase implementation, used in lack of better ones.
             *
             * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
             */
            class NaiveBroadphase extends Broadphase {
              /**
               * @todo Remove useless constructor
               */
              constructor() {
                super();
              }
              /**
               * Get all the collision pairs in the physics world
               */

              collisionPairs(world, pairs1, pairs2) {
                const bodies = world.bodies;
                const n = bodies.length;
                let bi;
                let bj; // Naive N^2 ftw!

                for (let i = 0; i !== n; i++) {
                  for (let j = 0; j !== i; j++) {
                    bi = bodies[i];
                    bj = bodies[j];

                    if (!this.needBroadphaseCollision(bi, bj)) {
                      continue;
                    }

                    this.intersectionTest(bi, bj, pairs1, pairs2);
                  }
                }
              }
              /**
               * Returns all the bodies within an AABB.
               * @param result An array to store resulting bodies in.
               */

              aabbQuery(world, aabb, result = []) {
                for (let i = 0; i < world.bodies.length; i++) {
                  const b = world.bodies[i];

                  if (b.aabbNeedsUpdate) {
                    b.updateAABB();
                  } // Ugly hack until Body gets aabb

                  if (b.aabb.overlaps(aabb)) {
                    result.push(b);
                  }
                }

                return result;
              }
            }

            /**
             * Storage for Ray casting data
             */
            class RaycastResult {
              /**
               * rayFromWorld
               */

              /**
               * rayToWorld
               */

              /**
               * hitNormalWorld
               */

              /**
               * hitPointWorld
               */

              /**
               * hasHit
               */

              /**
               * shape
               */

              /**
               * body
               */

              /**
               * The index of the hit triangle, if the hit shape was a trimesh
               */

              /**
               * Distance to the hit. Will be set to -1 if there was no hit
               */

              /**
               * If the ray should stop traversing the bodies
               */
              constructor() {
                this.rayFromWorld = void 0;
                this.rayToWorld = void 0;
                this.hitNormalWorld = void 0;
                this.hitPointWorld = void 0;
                this.hasHit = void 0;
                this.shape = void 0;
                this.body = void 0;
                this.hitFaceIndex = void 0;
                this.distance = void 0;
                this.shouldStop = void 0;
                this.rayFromWorld = new Vec3();
                this.rayToWorld = new Vec3();
                this.hitNormalWorld = new Vec3();
                this.hitPointWorld = new Vec3();
                this.hasHit = false;
                this.shape = null;
                this.body = null;
                this.hitFaceIndex = -1;
                this.distance = -1;
                this.shouldStop = false;
              }
              /**
               * Reset all result data.
               */

              reset() {
                this.rayFromWorld.setZero();
                this.rayToWorld.setZero();
                this.hitNormalWorld.setZero();
                this.hitPointWorld.setZero();
                this.hasHit = false;
                this.shape = null;
                this.body = null;
                this.hitFaceIndex = -1;
                this.distance = -1;
                this.shouldStop = false;
              }
              /**
               * abort
               */

              abort() {
                this.shouldStop = true;
              }
              /**
               * Set result data.
               */

              set(
                rayFromWorld,
                rayToWorld,
                hitNormalWorld,
                hitPointWorld,
                shape,
                body,
                distance
              ) {
                this.rayFromWorld.copy(rayFromWorld);
                this.rayToWorld.copy(rayToWorld);
                this.hitNormalWorld.copy(hitNormalWorld);
                this.hitPointWorld.copy(hitPointWorld);
                this.shape = shape;
                this.body = body;
                this.distance = distance;
              }
            }

            let _Shape$types$SPHERE,
              _Shape$types$PLANE,
              _Shape$types$BOX,
              _Shape$types$CYLINDER,
              _Shape$types$CONVEXPO,
              _Shape$types$HEIGHTFI,
              _Shape$types$TRIMESH;

            /**
             * RAY_MODES
             */
            const RAY_MODES = {
              /** CLOSEST */
              CLOSEST: 1,

              /** ANY */
              ANY: 2,

              /** ALL */
              ALL: 4,
            };
            /**
             * RayMode
             */

            _Shape$types$SPHERE = Shape.types.SPHERE;
            _Shape$types$PLANE = Shape.types.PLANE;
            _Shape$types$BOX = Shape.types.BOX;
            _Shape$types$CYLINDER = Shape.types.CYLINDER;
            _Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON;
            _Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD;
            _Shape$types$TRIMESH = Shape.types.TRIMESH;

            /**
             * A line in 3D space that intersects bodies and return points.
             */
            class Ray {
              /**
               * from
               */

              /**
               * to
               */

              /**
               * direction
               */

              /**
               * The precision of the ray. Used when checking parallelity etc.
               * @default 0.0001
               */

              /**
               * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
               * @default true
               */

              /**
               * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
               * @default false
               */

              /**
               * collisionFilterMask
               * @default -1
               */

              /**
               * collisionFilterGroup
               * @default -1
               */

              /**
               * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
               * @default RAY.ANY
               */

              /**
               * Current result object.
               */

              /**
               * Will be set to `true` during intersectWorld() if the ray hit anything.
               */

              /**
               * User-provided result callback. Will be used if mode is Ray.ALL.
               */

              /**
               * CLOSEST
               */

              /**
               * ANY
               */

              /**
               * ALL
               */
              get [_Shape$types$SPHERE]() {
                return this._intersectSphere;
              }

              get [_Shape$types$PLANE]() {
                return this._intersectPlane;
              }

              get [_Shape$types$BOX]() {
                return this._intersectBox;
              }

              get [_Shape$types$CYLINDER]() {
                return this._intersectConvex;
              }

              get [_Shape$types$CONVEXPO]() {
                return this._intersectConvex;
              }

              get [_Shape$types$HEIGHTFI]() {
                return this._intersectHeightfield;
              }

              get [_Shape$types$TRIMESH]() {
                return this._intersectTrimesh;
              }

              constructor(from = new Vec3(), to = new Vec3()) {
                this.from = void 0;
                this.to = void 0;
                this.direction = void 0;
                this.precision = void 0;
                this.checkCollisionResponse = void 0;
                this.skipBackfaces = void 0;
                this.collisionFilterMask = void 0;
                this.collisionFilterGroup = void 0;
                this.mode = void 0;
                this.result = void 0;
                this.hasHit = void 0;
                this.callback = void 0;
                this.from = from.clone();
                this.to = to.clone();
                this.direction = new Vec3();
                this.precision = 0.0001;
                this.checkCollisionResponse = true;
                this.skipBackfaces = false;
                this.collisionFilterMask = -1;
                this.collisionFilterGroup = -1;
                this.mode = Ray.ANY;
                this.result = new RaycastResult();
                this.hasHit = false;

                this.callback = (result) => {};
              }
              /**
               * Do itersection against all bodies in the given World.
               * @return True if the ray hit anything, otherwise false.
               */

              intersectWorld(world, options) {
                this.mode = options.mode || Ray.ANY;
                this.result = options.result || new RaycastResult();
                this.skipBackfaces = !!options.skipBackfaces;
                this.collisionFilterMask =
                  typeof options.collisionFilterMask !== "undefined"
                    ? options.collisionFilterMask
                    : -1;
                this.collisionFilterGroup =
                  typeof options.collisionFilterGroup !== "undefined"
                    ? options.collisionFilterGroup
                    : -1;
                this.checkCollisionResponse =
                  typeof options.checkCollisionResponse !== "undefined"
                    ? options.checkCollisionResponse
                    : true;

                if (options.from) {
                  this.from.copy(options.from);
                }

                if (options.to) {
                  this.to.copy(options.to);
                }

                this.callback = options.callback || (() => {});

                this.hasHit = false;
                this.result.reset();
                this.updateDirection();
                this.getAABB(tmpAABB$1);
                tmpArray.length = 0;
                world.broadphase.aabbQuery(world, tmpAABB$1, tmpArray);
                this.intersectBodies(tmpArray);
                return this.hasHit;
              }
              /**
               * Shoot a ray at a body, get back information about the hit.
               * @deprecated @param result set the result property of the Ray instead.
               */

              intersectBody(body, result) {
                if (result) {
                  this.result = result;
                  this.updateDirection();
                }

                const checkCollisionResponse = this.checkCollisionResponse;

                if (checkCollisionResponse && !body.collisionResponse) {
                  return;
                }

                if (
                  (this.collisionFilterGroup & body.collisionFilterMask) ===
                    0 ||
                  (body.collisionFilterGroup & this.collisionFilterMask) === 0
                ) {
                  return;
                }

                const xi = intersectBody_xi;
                const qi = intersectBody_qi;

                for (let i = 0, N = body.shapes.length; i < N; i++) {
                  const shape = body.shapes[i];

                  if (checkCollisionResponse && !shape.collisionResponse) {
                    continue; // Skip
                  }

                  body.quaternion.mult(body.shapeOrientations[i], qi);
                  body.quaternion.vmult(body.shapeOffsets[i], xi);
                  xi.vadd(body.position, xi);
                  this.intersectShape(shape, qi, xi, body);

                  if (this.result.shouldStop) {
                    break;
                  }
                }
              }
              /**
               * Shoot a ray at an array bodies, get back information about the hit.
               * @param bodies An array of Body objects.
               * @deprecated @param result set the result property of the Ray instead.
               *
               */

              intersectBodies(bodies, result) {
                if (result) {
                  this.result = result;
                  this.updateDirection();
                }

                for (
                  let i = 0, l = bodies.length;
                  !this.result.shouldStop && i < l;
                  i++
                ) {
                  this.intersectBody(bodies[i]);
                }
              }
              /**
               * Updates the direction vector.
               */

              updateDirection() {
                this.to.vsub(this.from, this.direction);
                this.direction.normalize();
              }

              intersectShape(shape, quat, position, body) {
                const from = this.from; // Checking boundingSphere

                const distance = distanceFromIntersection(
                  from,
                  this.direction,
                  position
                );

                if (distance > shape.boundingSphereRadius) {
                  return;
                }

                const intersectMethod = this[shape.type];

                if (intersectMethod) {
                  intersectMethod.call(
                    this,
                    shape,
                    quat,
                    position,
                    body,
                    shape
                  );
                }
              }

              _intersectBox(box, quat, position, body, reportedShape) {
                return this._intersectConvex(
                  box.convexPolyhedronRepresentation,
                  quat,
                  position,
                  body,
                  reportedShape
                );
              }

              _intersectPlane(shape, quat, position, body, reportedShape) {
                const from = this.from;
                const to = this.to;
                const direction = this.direction; // Get plane normal

                const worldNormal = new Vec3(0, 0, 1);
                quat.vmult(worldNormal, worldNormal);
                const len = new Vec3();
                from.vsub(position, len);
                const planeToFrom = len.dot(worldNormal);
                to.vsub(position, len);
                const planeToTo = len.dot(worldNormal);

                if (planeToFrom * planeToTo > 0) {
                  // "from" and "to" are on the same side of the plane... bail out
                  return;
                }

                if (from.distanceTo(to) < planeToFrom) {
                  return;
                }

                const n_dot_dir = worldNormal.dot(direction);

                if (Math.abs(n_dot_dir) < this.precision) {
                  // No intersection
                  return;
                }

                const planePointToFrom = new Vec3();
                const dir_scaled_with_t = new Vec3();
                const hitPointWorld = new Vec3();
                from.vsub(position, planePointToFrom);
                const t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
                direction.scale(t, dir_scaled_with_t);
                from.vadd(dir_scaled_with_t, hitPointWorld);
                this.reportIntersection(
                  worldNormal,
                  hitPointWorld,
                  reportedShape,
                  body,
                  -1
                );
              }
              /**
               * Get the world AABB of the ray.
               */

              getAABB(aabb) {
                const { lowerBound, upperBound } = aabb;
                const to = this.to;
                const from = this.from;
                lowerBound.x = Math.min(to.x, from.x);
                lowerBound.y = Math.min(to.y, from.y);
                lowerBound.z = Math.min(to.z, from.z);
                upperBound.x = Math.max(to.x, from.x);
                upperBound.y = Math.max(to.y, from.y);
                upperBound.z = Math.max(to.z, from.z);
              }

              _intersectHeightfield(
                shape,
                quat,
                position,
                body,
                reportedShape
              ) {
                shape.data;
                shape.elementSize; // Convert the ray to local heightfield coordinates

                const localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

                localRay.from.copy(this.from);
                localRay.to.copy(this.to);
                Transform.pointToLocalFrame(
                  position,
                  quat,
                  localRay.from,
                  localRay.from
                );
                Transform.pointToLocalFrame(
                  position,
                  quat,
                  localRay.to,
                  localRay.to
                );
                localRay.updateDirection(); // Get the index of the data points to test against

                const index = intersectHeightfield_index;
                let iMinX;
                let iMinY;
                let iMaxX;
                let iMaxY; // Set to max

                iMinX = iMinY = 0;
                iMaxX = iMaxY = shape.data.length - 1;
                const aabb = new AABB();
                localRay.getAABB(aabb);
                shape.getIndexOfPosition(
                  aabb.lowerBound.x,
                  aabb.lowerBound.y,
                  index,
                  true
                );
                iMinX = Math.max(iMinX, index[0]);
                iMinY = Math.max(iMinY, index[1]);
                shape.getIndexOfPosition(
                  aabb.upperBound.x,
                  aabb.upperBound.y,
                  index,
                  true
                );
                iMaxX = Math.min(iMaxX, index[0] + 1);
                iMaxY = Math.min(iMaxY, index[1] + 1);

                for (let i = iMinX; i < iMaxX; i++) {
                  for (let j = iMinY; j < iMaxY; j++) {
                    if (this.result.shouldStop) {
                      return;
                    }

                    shape.getAabbAtIndex(i, j, aabb);

                    if (!aabb.overlapsRay(localRay)) {
                      continue;
                    } // Lower triangle

                    shape.getConvexTrianglePillar(i, j, false);
                    Transform.pointToWorldFrame(
                      position,
                      quat,
                      shape.pillarOffset,
                      worldPillarOffset
                    );

                    this._intersectConvex(
                      shape.pillarConvex,
                      quat,
                      worldPillarOffset,
                      body,
                      reportedShape,
                      intersectConvexOptions
                    );

                    if (this.result.shouldStop) {
                      return;
                    } // Upper triangle

                    shape.getConvexTrianglePillar(i, j, true);
                    Transform.pointToWorldFrame(
                      position,
                      quat,
                      shape.pillarOffset,
                      worldPillarOffset
                    );

                    this._intersectConvex(
                      shape.pillarConvex,
                      quat,
                      worldPillarOffset,
                      body,
                      reportedShape,
                      intersectConvexOptions
                    );
                  }
                }
              }

              _intersectSphere(sphere, quat, position, body, reportedShape) {
                const from = this.from;
                const to = this.to;
                const r = sphere.radius;
                const a =
                  (to.x - from.x) ** 2 +
                  (to.y - from.y) ** 2 +
                  (to.z - from.z) ** 2;
                const b =
                  2 *
                  ((to.x - from.x) * (from.x - position.x) +
                    (to.y - from.y) * (from.y - position.y) +
                    (to.z - from.z) * (from.z - position.z));
                const c =
                  (from.x - position.x) ** 2 +
                  (from.y - position.y) ** 2 +
                  (from.z - position.z) ** 2 -
                  r ** 2;
                const delta = b ** 2 - 4 * a * c;
                const intersectionPoint = Ray_intersectSphere_intersectionPoint;
                const normal = Ray_intersectSphere_normal;

                if (delta < 0) {
                  // No intersection
                  return;
                } else if (delta === 0) {
                  // single intersection point
                  from.lerp(to, delta, intersectionPoint);
                  intersectionPoint.vsub(position, normal);
                  normal.normalize();
                  this.reportIntersection(
                    normal,
                    intersectionPoint,
                    reportedShape,
                    body,
                    -1
                  );
                } else {
                  const d1 = (-b - Math.sqrt(delta)) / (2 * a);
                  const d2 = (-b + Math.sqrt(delta)) / (2 * a);

                  if (d1 >= 0 && d1 <= 1) {
                    from.lerp(to, d1, intersectionPoint);
                    intersectionPoint.vsub(position, normal);
                    normal.normalize();
                    this.reportIntersection(
                      normal,
                      intersectionPoint,
                      reportedShape,
                      body,
                      -1
                    );
                  }

                  if (this.result.shouldStop) {
                    return;
                  }

                  if (d2 >= 0 && d2 <= 1) {
                    from.lerp(to, d2, intersectionPoint);
                    intersectionPoint.vsub(position, normal);
                    normal.normalize();
                    this.reportIntersection(
                      normal,
                      intersectionPoint,
                      reportedShape,
                      body,
                      -1
                    );
                  }
                }
              }

              _intersectConvex(
                shape,
                quat,
                position,
                body,
                reportedShape,
                options
              ) {
                const normal = intersectConvex_normal;
                const vector = intersectConvex_vector;
                const faceList = (options && options.faceList) || null; // Checking faces

                const faces = shape.faces;
                const vertices = shape.vertices;
                const normals = shape.faceNormals;
                const direction = this.direction;
                const from = this.from;
                const to = this.to;
                const fromToDistance = from.distanceTo(to);
                const Nfaces = faceList ? faceList.length : faces.length;
                const result = this.result;

                for (let j = 0; !result.shouldStop && j < Nfaces; j++) {
                  const fi = faceList ? faceList[j] : j;
                  const face = faces[fi];
                  const faceNormal = normals[fi];
                  const q = quat;
                  const x = position; // determine if ray intersects the plane of the face
                  // note: this works regardless of the direction of the face normal
                  // Get plane point in world coordinates...

                  vector.copy(vertices[face[0]]);
                  q.vmult(vector, vector);
                  vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

                  vector.vsub(from, vector); // Get plane normal

                  q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

                  const dot = direction.dot(normal); // Bail out if ray and plane are parallel

                  if (Math.abs(dot) < this.precision) {
                    continue;
                  } // calc distance to plane

                  const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

                  if (scalar < 0) {
                    continue;
                  } // if (dot < 0) {
                  // Intersection point is from + direction * scalar

                  direction.scale(scalar, intersectPoint);
                  intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

                  a.copy(vertices[face[0]]);
                  q.vmult(a, a);
                  x.vadd(a, a);

                  for (
                    let i = 1;
                    !result.shouldStop && i < face.length - 1;
                    i++
                  ) {
                    // Transform 3 vertices to world coords
                    b.copy(vertices[face[i]]);
                    c.copy(vertices[face[i + 1]]);
                    q.vmult(b, b);
                    q.vmult(c, c);
                    x.vadd(b, b);
                    x.vadd(c, c);
                    const distance = intersectPoint.distanceTo(from);

                    if (
                      !(
                        Ray.pointInTriangle(intersectPoint, a, b, c) ||
                        Ray.pointInTriangle(intersectPoint, b, a, c)
                      ) ||
                      distance > fromToDistance
                    ) {
                      continue;
                    }

                    this.reportIntersection(
                      normal,
                      intersectPoint,
                      reportedShape,
                      body,
                      fi
                    );
                  } // }
                }
              }
              /**
               * @todo Optimize by transforming the world to local space first.
               * @todo Use Octree lookup
               */

              _intersectTrimesh(
                mesh,
                quat,
                position,
                body,
                reportedShape,
                options
              ) {
                const normal = intersectTrimesh_normal;
                const triangles = intersectTrimesh_triangles;
                const treeTransform = intersectTrimesh_treeTransform;
                const vector = intersectConvex_vector;
                const localDirection = intersectTrimesh_localDirection;
                const localFrom = intersectTrimesh_localFrom;
                const localTo = intersectTrimesh_localTo;
                const worldIntersectPoint =
                  intersectTrimesh_worldIntersectPoint;
                const worldNormal = intersectTrimesh_worldNormal; // Checking faces

                const indices = mesh.indices;
                mesh.vertices; // const normals = mesh.faceNormals

                const from = this.from;
                const to = this.to;
                const direction = this.direction;
                treeTransform.position.copy(position);
                treeTransform.quaternion.copy(quat); // Transform ray to local space!

                Transform.vectorToLocalFrame(
                  position,
                  quat,
                  direction,
                  localDirection
                );
                Transform.pointToLocalFrame(position, quat, from, localFrom);
                Transform.pointToLocalFrame(position, quat, to, localTo);
                localTo.x *= mesh.scale.x;
                localTo.y *= mesh.scale.y;
                localTo.z *= mesh.scale.z;
                localFrom.x *= mesh.scale.x;
                localFrom.y *= mesh.scale.y;
                localFrom.z *= mesh.scale.z;
                localTo.vsub(localFrom, localDirection);
                localDirection.normalize();
                const fromToDistanceSquared =
                  localFrom.distanceSquared(localTo);
                mesh.tree.rayQuery(this, treeTransform, triangles);

                for (
                  let i = 0, N = triangles.length;
                  !this.result.shouldStop && i !== N;
                  i++
                ) {
                  const trianglesIndex = triangles[i];
                  mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
                  // note: this works regardless of the direction of the face normal
                  // Get plane point in world coordinates...

                  mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

                  a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

                  const dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
                  // if (Math.abs( dot ) < this.precision){
                  //     continue;
                  // }
                  // calc distance to plane

                  const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

                  if (scalar < 0) {
                    continue;
                  } // Intersection point is from + direction * scalar

                  localDirection.scale(scalar, intersectPoint);
                  intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

                  mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
                  mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
                  const squaredDistance =
                    intersectPoint.distanceSquared(localFrom);

                  if (
                    !(
                      Ray.pointInTriangle(intersectPoint, b, a, c) ||
                      Ray.pointInTriangle(intersectPoint, a, b, c)
                    ) ||
                    squaredDistance > fromToDistanceSquared
                  ) {
                    continue;
                  } // transform intersectpoint and normal to world

                  Transform.vectorToWorldFrame(quat, normal, worldNormal);
                  Transform.pointToWorldFrame(
                    position,
                    quat,
                    intersectPoint,
                    worldIntersectPoint
                  );
                  this.reportIntersection(
                    worldNormal,
                    worldIntersectPoint,
                    reportedShape,
                    body,
                    trianglesIndex
                  );
                }

                triangles.length = 0;
              }
              /**
               * @return True if the intersections should continue
               */

              reportIntersection(
                normal,
                hitPointWorld,
                shape,
                body,
                hitFaceIndex
              ) {
                const from = this.from;
                const to = this.to;
                const distance = from.distanceTo(hitPointWorld);
                const result = this.result; // Skip back faces?

                if (this.skipBackfaces && normal.dot(this.direction) > 0) {
                  return;
                }

                result.hitFaceIndex =
                  typeof hitFaceIndex !== "undefined" ? hitFaceIndex : -1;

                switch (this.mode) {
                  case Ray.ALL:
                    this.hasHit = true;
                    result.set(
                      from,
                      to,
                      normal,
                      hitPointWorld,
                      shape,
                      body,
                      distance
                    );
                    result.hasHit = true;
                    this.callback(result);
                    break;

                  case Ray.CLOSEST:
                    // Store if closer than current closest
                    if (distance < result.distance || !result.hasHit) {
                      this.hasHit = true;
                      result.hasHit = true;
                      result.set(
                        from,
                        to,
                        normal,
                        hitPointWorld,
                        shape,
                        body,
                        distance
                      );
                    }

                    break;

                  case Ray.ANY:
                    // Report and stop.
                    this.hasHit = true;
                    result.hasHit = true;
                    result.set(
                      from,
                      to,
                      normal,
                      hitPointWorld,
                      shape,
                      body,
                      distance
                    );
                    result.shouldStop = true;
                    break;
                }
              }
              /**
               * As per "Barycentric Technique" as named
               * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
               */

              static pointInTriangle(p, a, b, c) {
                c.vsub(a, v0);
                b.vsub(a, v1);
                p.vsub(a, v2);
                const dot00 = v0.dot(v0);
                const dot01 = v0.dot(v1);
                const dot02 = v0.dot(v2);
                const dot11 = v1.dot(v1);
                const dot12 = v1.dot(v2);
                let u;
                let v;
                return (
                  (u = dot11 * dot02 - dot01 * dot12) >= 0 &&
                  (v = dot00 * dot12 - dot01 * dot02) >= 0 &&
                  u + v < dot00 * dot11 - dot01 * dot01
                );
              }
            }
            Ray.CLOSEST = RAY_MODES.CLOSEST;
            Ray.ANY = RAY_MODES.ANY;
            Ray.ALL = RAY_MODES.ALL;
            const tmpAABB$1 = new AABB();
            const tmpArray = [];
            const v1 = new Vec3();
            const v2 = new Vec3();
            const intersectBody_xi = new Vec3();
            const intersectBody_qi = new Quaternion();
            const intersectPoint = new Vec3();
            const a = new Vec3();
            const b = new Vec3();
            const c = new Vec3();
            const intersectConvexOptions = {
              faceList: [0],
            };
            const worldPillarOffset = new Vec3();
            const intersectHeightfield_localRay = new Ray();
            const intersectHeightfield_index = [];
            const Ray_intersectSphere_intersectionPoint = new Vec3();
            const Ray_intersectSphere_normal = new Vec3();
            const intersectConvex_normal = new Vec3();
            const intersectConvex_vector = new Vec3();
            const intersectTrimesh_normal = new Vec3();
            const intersectTrimesh_localDirection = new Vec3();
            const intersectTrimesh_localFrom = new Vec3();
            const intersectTrimesh_localTo = new Vec3();
            const intersectTrimesh_worldNormal = new Vec3();
            const intersectTrimesh_worldIntersectPoint = new Vec3();
            new AABB();
            const intersectTrimesh_triangles = [];
            const intersectTrimesh_treeTransform = new Transform();
            const v0 = new Vec3();
            const intersect = new Vec3();

            function distanceFromIntersection(from, direction, position) {
              // v0 is vector from from to position
              position.vsub(from, v0);
              const dot = v0.dot(direction); // intersect = direction*dot + from

              direction.scale(dot, intersect);
              intersect.vadd(from, intersect);
              const distance = position.distanceTo(intersect);
              return distance;
            }

            /**
             * Sweep and prune broadphase along one axis.
             */
            class SAPBroadphase extends Broadphase {
              /**
               * List of bodies currently in the broadphase.
               */

              /**
               * The world to search in.
               */

              /**
               * Axis to sort the bodies along.
               * Set to 0 for x axis, and 1 for y axis.
               * For best performance, pick the axis where bodies are most distributed.
               */

              /**
               * Check if the bounds of two bodies overlap, along the given SAP axis.
               */
              static checkBounds(bi, bj, axisIndex) {
                let biPos;
                let bjPos;

                if (axisIndex === 0) {
                  biPos = bi.position.x;
                  bjPos = bj.position.x;
                } else if (axisIndex === 1) {
                  biPos = bi.position.y;
                  bjPos = bj.position.y;
                } else if (axisIndex === 2) {
                  biPos = bi.position.z;
                  bjPos = bj.position.z;
                }

                const ri = bi.boundingRadius,
                  rj = bj.boundingRadius,
                  boundA2 = biPos + ri,
                  boundB1 = bjPos - rj;
                return boundB1 < boundA2;
              } // Note: these are identical, save for x/y/z lowerbound

              /**
               * insertionSortX
               */

              static insertionSortX(a) {
                for (let i = 1, l = a.length; i < l; i++) {
                  const v = a[i];
                  let j;

                  for (j = i - 1; j >= 0; j--) {
                    if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
                      break;
                    }

                    a[j + 1] = a[j];
                  }

                  a[j + 1] = v;
                }

                return a;
              }
              /**
               * insertionSortY
               */

              static insertionSortY(a) {
                for (let i = 1, l = a.length; i < l; i++) {
                  const v = a[i];
                  let j;

                  for (j = i - 1; j >= 0; j--) {
                    if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
                      break;
                    }

                    a[j + 1] = a[j];
                  }

                  a[j + 1] = v;
                }

                return a;
              }
              /**
               * insertionSortZ
               */

              static insertionSortZ(a) {
                for (let i = 1, l = a.length; i < l; i++) {
                  const v = a[i];
                  let j;

                  for (j = i - 1; j >= 0; j--) {
                    if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
                      break;
                    }

                    a[j + 1] = a[j];
                  }

                  a[j + 1] = v;
                }

                return a;
              }

              constructor(world) {
                super();
                this.axisList = void 0;
                this.world = void 0;
                this.axisIndex = void 0;
                this._addBodyHandler = void 0;
                this._removeBodyHandler = void 0;
                this.axisList = [];
                this.world = null;
                this.axisIndex = 0;
                const axisList = this.axisList;

                this._addBodyHandler = (event) => {
                  axisList.push(event.body);
                };

                this._removeBodyHandler = (event) => {
                  const idx = axisList.indexOf(event.body);

                  if (idx !== -1) {
                    axisList.splice(idx, 1);
                  }
                };

                if (world) {
                  this.setWorld(world);
                }
              }
              /**
               * Change the world
               */

              setWorld(world) {
                // Clear the old axis array
                this.axisList.length = 0; // Add all bodies from the new world

                for (let i = 0; i < world.bodies.length; i++) {
                  this.axisList.push(world.bodies[i]);
                } // Remove old handlers, if any

                world.removeEventListener("addBody", this._addBodyHandler);
                world.removeEventListener(
                  "removeBody",
                  this._removeBodyHandler
                ); // Add handlers to update the list of bodies.

                world.addEventListener("addBody", this._addBodyHandler);
                world.addEventListener("removeBody", this._removeBodyHandler);
                this.world = world;
                this.dirty = true;
              }
              /**
               * Collect all collision pairs
               */

              collisionPairs(world, p1, p2) {
                const bodies = this.axisList;
                const N = bodies.length;
                const axisIndex = this.axisIndex;
                let i;
                let j;

                if (this.dirty) {
                  this.sortList();
                  this.dirty = false;
                } // Look through the list

                for (i = 0; i !== N; i++) {
                  const bi = bodies[i];

                  for (j = i + 1; j < N; j++) {
                    const bj = bodies[j];

                    if (!this.needBroadphaseCollision(bi, bj)) {
                      continue;
                    }

                    if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
                      break;
                    }

                    this.intersectionTest(bi, bj, p1, p2);
                  }
                }
              }

              sortList() {
                const axisList = this.axisList;
                const axisIndex = this.axisIndex;
                const N = axisList.length; // Update AABBs

                for (let i = 0; i !== N; i++) {
                  const bi = axisList[i];

                  if (bi.aabbNeedsUpdate) {
                    bi.updateAABB();
                  }
                } // Sort the list

                if (axisIndex === 0) {
                  SAPBroadphase.insertionSortX(axisList);
                } else if (axisIndex === 1) {
                  SAPBroadphase.insertionSortY(axisList);
                } else if (axisIndex === 2) {
                  SAPBroadphase.insertionSortZ(axisList);
                }
              }
              /**
               * Computes the variance of the body positions and estimates the best axis to use.
               * Will automatically set property `axisIndex`.
               */

              autoDetectAxis() {
                let sumX = 0;
                let sumX2 = 0;
                let sumY = 0;
                let sumY2 = 0;
                let sumZ = 0;
                let sumZ2 = 0;
                const bodies = this.axisList;
                const N = bodies.length;
                const invN = 1 / N;

                for (let i = 0; i !== N; i++) {
                  const b = bodies[i];
                  const centerX = b.position.x;
                  sumX += centerX;
                  sumX2 += centerX * centerX;
                  const centerY = b.position.y;
                  sumY += centerY;
                  sumY2 += centerY * centerY;
                  const centerZ = b.position.z;
                  sumZ += centerZ;
                  sumZ2 += centerZ * centerZ;
                }

                const varianceX = sumX2 - sumX * sumX * invN;
                const varianceY = sumY2 - sumY * sumY * invN;
                const varianceZ = sumZ2 - sumZ * sumZ * invN;

                if (varianceX > varianceY) {
                  if (varianceX > varianceZ) {
                    this.axisIndex = 0;
                  } else {
                    this.axisIndex = 2;
                  }
                } else if (varianceY > varianceZ) {
                  this.axisIndex = 1;
                } else {
                  this.axisIndex = 2;
                }
              }
              /**
               * Returns all the bodies within an AABB.
               * @param result An array to store resulting bodies in.
               */

              aabbQuery(world, aabb, result = []) {
                if (this.dirty) {
                  this.sortList();
                  this.dirty = false;
                }

                const axisIndex = this.axisIndex;
                let axis = "x";

                if (axisIndex === 1) {
                  axis = "y";
                }

                if (axisIndex === 2) {
                  axis = "z";
                }

                const axisList = this.axisList;
                aabb.lowerBound[axis];
                aabb.upperBound[axis];

                for (let i = 0; i < axisList.length; i++) {
                  const b = axisList[i];

                  if (b.aabbNeedsUpdate) {
                    b.updateAABB();
                  }

                  if (b.aabb.overlaps(aabb)) {
                    result.push(b);
                  }
                }

                return result;
              }
            }

            class Utils {
              /**
               * Extend an options object with default values.
               * @param options The options object. May be falsy: in this case, a new object is created and returned.
               * @param defaults An object containing default values.
               * @return The modified options object.
               */
              static defaults(options = {}, defaults) {
                for (let key in defaults) {
                  if (!(key in options)) {
                    options[key] = defaults[key];
                  }
                }

                return options;
              }
            }

            /**
             * Constraint base class
             */
            class Constraint {
              /**
               * Equations to be solved in this constraint.
               */

              /**
               * Body A.
               */

              /**
               * Body B.
               */

              /**
               * Set to false if you don't want the bodies to collide when they are connected.
               */
              constructor(bodyA, bodyB, options = {}) {
                this.equations = void 0;
                this.bodyA = void 0;
                this.bodyB = void 0;
                this.id = void 0;
                this.collideConnected = void 0;
                options = Utils.defaults(options, {
                  collideConnected: true,
                  wakeUpBodies: true,
                });
                this.equations = [];
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.id = Constraint.idCounter++;
                this.collideConnected = options.collideConnected;

                if (options.wakeUpBodies) {
                  if (bodyA) {
                    bodyA.wakeUp();
                  }

                  if (bodyB) {
                    bodyB.wakeUp();
                  }
                }
              }
              /**
               * Update all the equations with data.
               */

              update() {
                throw new Error(
                  "method update() not implmemented in this Constraint subclass!"
                );
              }
              /**
               * Enables all equations in the constraint.
               */

              enable() {
                const eqs = this.equations;

                for (let i = 0; i < eqs.length; i++) {
                  eqs[i].enabled = true;
                }
              }
              /**
               * Disables all equations in the constraint.
               */

              disable() {
                const eqs = this.equations;

                for (let i = 0; i < eqs.length; i++) {
                  eqs[i].enabled = false;
                }
              }
            }
            Constraint.idCounter = 0;

            /**
             * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
             */

            class JacobianElement {
              /**
               * spatial
               */

              /**
               * rotational
               */
              constructor() {
                this.spatial = void 0;
                this.rotational = void 0;
                this.spatial = new Vec3();
                this.rotational = new Vec3();
              }
              /**
               * Multiply with other JacobianElement
               */

              multiplyElement(element) {
                return (
                  element.spatial.dot(this.spatial) +
                  element.rotational.dot(this.rotational)
                );
              }
              /**
               * Multiply with two vectors
               */

              multiplyVectors(spatial, rotational) {
                return (
                  spatial.dot(this.spatial) + rotational.dot(this.rotational)
                );
              }
            }

            /**
             * Equation base class.
             *
             * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
             */
            class Equation {
              /**
               * Minimum (read: negative max) force to be applied by the constraint.
               */

              /**
               * Maximum (read: positive max) force to be applied by the constraint.
               */

              /**
               * SPOOK parameter
               */

              /**
               * SPOOK parameter
               */

              /**
               * SPOOK parameter
               */

              /**
               * A number, proportional to the force added to the bodies.
               */
              constructor(bi, bj, minForce = -1e6, maxForce = 1e6) {
                this.id = void 0;
                this.minForce = void 0;
                this.maxForce = void 0;
                this.bi = void 0;
                this.bj = void 0;
                this.si = void 0;
                this.sj = void 0;
                this.a = void 0;
                this.b = void 0;
                this.eps = void 0;
                this.jacobianElementA = void 0;
                this.jacobianElementB = void 0;
                this.enabled = void 0;
                this.multiplier = void 0;
                this.id = Equation.idCounter++;
                this.minForce = minForce;
                this.maxForce = maxForce;
                this.bi = bi;
                this.bj = bj;
                this.a = 0.0; // SPOOK parameter

                this.b = 0.0; // SPOOK parameter

                this.eps = 0.0; // SPOOK parameter

                this.jacobianElementA = new JacobianElement();
                this.jacobianElementB = new JacobianElement();
                this.enabled = true;
                this.multiplier = 0;
                this.setSpookParams(1e7, 4, 1 / 60); // Set typical spook params
              }
              /**
               * Recalculates a, b, and eps.
               *
               * The Equation constructor sets typical SPOOK parameters as such:
               * * `stiffness` = 1e7
               * * `relaxation` = 4
               * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
               */

              setSpookParams(stiffness, relaxation, timeStep) {
                const d = relaxation;
                const k = stiffness;
                const h = timeStep;
                this.a = 4.0 / (h * (1 + 4 * d));
                this.b = (4.0 * d) / (1 + 4 * d);
                this.eps = 4.0 / (h * h * k * (1 + 4 * d));
              }
              /**
               * Computes the right hand side of the SPOOK equation
               */

              computeB(a, b, h) {
                const GW = this.computeGW();
                const Gq = this.computeGq();
                const GiMf = this.computeGiMf();
                return -Gq * a - GW * b - GiMf * h;
              }
              /**
               * Computes G*q, where q are the generalized body coordinates
               */

              computeGq() {
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const bi = this.bi;
                const bj = this.bj;
                const xi = bi.position;
                const xj = bj.position;
                return GA.spatial.dot(xi) + GB.spatial.dot(xj);
              }
              /**
               * Computes G*W, where W are the body velocities
               */

              computeGW() {
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const bi = this.bi;
                const bj = this.bj;
                const vi = bi.velocity;
                const vj = bj.velocity;
                const wi = bi.angularVelocity;
                const wj = bj.angularVelocity;
                return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
              }
              /**
               * Computes G*Wlambda, where W are the body velocities
               */

              computeGWlambda() {
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const bi = this.bi;
                const bj = this.bj;
                const vi = bi.vlambda;
                const vj = bj.vlambda;
                const wi = bi.wlambda;
                const wj = bj.wlambda;
                return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
              }
              /**
               * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
               */

              computeGiMf() {
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const bi = this.bi;
                const bj = this.bj;
                const fi = bi.force;
                const ti = bi.torque;
                const fj = bj.force;
                const tj = bj.torque;
                const invMassi = bi.invMassSolve;
                const invMassj = bj.invMassSolve;
                fi.scale(invMassi, iMfi);
                fj.scale(invMassj, iMfj);
                bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
                bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
                return (
                  GA.multiplyVectors(iMfi, invIi_vmult_taui) +
                  GB.multiplyVectors(iMfj, invIj_vmult_tauj)
                );
              }
              /**
               * Computes G*inv(M)*G'
               */

              computeGiMGt() {
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const bi = this.bi;
                const bj = this.bj;
                const invMassi = bi.invMassSolve;
                const invMassj = bj.invMassSolve;
                const invIi = bi.invInertiaWorldSolve;
                const invIj = bj.invInertiaWorldSolve;
                let result = invMassi + invMassj;
                invIi.vmult(GA.rotational, tmp);
                result += tmp.dot(GA.rotational);
                invIj.vmult(GB.rotational, tmp);
                result += tmp.dot(GB.rotational);
                return result;
              }
              /**
               * Add constraint velocity to the bodies.
               */

              addToWlambda(deltalambda) {
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const bi = this.bi;
                const bj = this.bj;
                const temp = addToWlambda_temp; // Add to linear velocity
                // v_lambda += inv(M) * delta_lamba * G

                bi.vlambda.addScaledVector(
                  bi.invMassSolve * deltalambda,
                  GA.spatial,
                  bi.vlambda
                );
                bj.vlambda.addScaledVector(
                  bj.invMassSolve * deltalambda,
                  GB.spatial,
                  bj.vlambda
                ); // Add to angular velocity

                bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
                bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
                bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
                bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
              }
              /**
               * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
               */

              computeC() {
                return this.computeGiMGt() + this.eps;
              }
            }
            Equation.idCounter = 0;
            const iMfi = new Vec3();
            const iMfj = new Vec3();
            const invIi_vmult_taui = new Vec3();
            const invIj_vmult_tauj = new Vec3();
            const tmp = new Vec3();
            const addToWlambda_temp = new Vec3();

            /**
             * Contact/non-penetration constraint equation
             */
            class ContactEquation extends Equation {
              /**
               * "bounciness": u1 = -e*u0
               */

              /**
               * World-oriented vector that goes from the center of bi to the contact point.
               */

              /**
               * World-oriented vector that starts in body j position and goes to the contact point.
               */

              /**
               * Contact normal, pointing out of body i.
               */
              constructor(bodyA, bodyB, maxForce = 1e6) {
                super(bodyA, bodyB, 0, maxForce);
                this.restitution = void 0;
                this.ri = void 0;
                this.rj = void 0;
                this.ni = void 0;
                this.restitution = 0.0;
                this.ri = new Vec3();
                this.rj = new Vec3();
                this.ni = new Vec3();
              }

              computeB(h) {
                const a = this.a;
                const b = this.b;
                const bi = this.bi;
                const bj = this.bj;
                const ri = this.ri;
                const rj = this.rj;
                const rixn = ContactEquation_computeB_temp1;
                const rjxn = ContactEquation_computeB_temp2;
                const vi = bi.velocity;
                const wi = bi.angularVelocity;
                bi.force;
                bi.torque;
                const vj = bj.velocity;
                const wj = bj.angularVelocity;
                bj.force;
                bj.torque;
                const penetrationVec = ContactEquation_computeB_temp3;
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                const n = this.ni; // Caluclate cross products

                ri.cross(n, rixn);
                rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
                // G = [ -ni  -rixn  ni  rjxn ]

                n.negate(GA.spatial);
                rixn.negate(GA.rotational);
                GB.spatial.copy(n);
                GB.rotational.copy(rjxn); // Calculate the penetration vector

                penetrationVec.copy(bj.position);
                penetrationVec.vadd(rj, penetrationVec);
                penetrationVec.vsub(bi.position, penetrationVec);
                penetrationVec.vsub(ri, penetrationVec);
                const g = n.dot(penetrationVec); // Compute iteration

                const ePlusOne = this.restitution + 1;
                const GW =
                  ePlusOne * vj.dot(n) -
                  ePlusOne * vi.dot(n) +
                  wj.dot(rjxn) -
                  wi.dot(rixn);
                const GiMf = this.computeGiMf();
                const B = -g * a - GW * b - h * GiMf;
                return B;
              }
              /**
               * Get the current relative velocity in the contact point.
               */

              getImpactVelocityAlongNormal() {
                const vi = ContactEquation_getImpactVelocityAlongNormal_vi;
                const vj = ContactEquation_getImpactVelocityAlongNormal_vj;
                const xi = ContactEquation_getImpactVelocityAlongNormal_xi;
                const xj = ContactEquation_getImpactVelocityAlongNormal_xj;
                const relVel =
                  ContactEquation_getImpactVelocityAlongNormal_relVel;
                this.bi.position.vadd(this.ri, xi);
                this.bj.position.vadd(this.rj, xj);
                this.bi.getVelocityAtWorldPoint(xi, vi);
                this.bj.getVelocityAtWorldPoint(xj, vj);
                vi.vsub(vj, relVel);
                return this.ni.dot(relVel);
              }
            }
            const ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

            const ContactEquation_computeB_temp2 = new Vec3();
            const ContactEquation_computeB_temp3 = new Vec3();
            const ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
            const ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
            const ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
            const ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
            const ContactEquation_getImpactVelocityAlongNormal_relVel =
              new Vec3();

            /**
             * Connects two bodies at given offset points.
             * @example
             *     const bodyA = new Body({ mass: 1 })
             *     const bodyB = new Body({ mass: 1 })
             *     bodyA.position.set(-1, 0, 0)
             *     bodyB.position.set(1, 0, 0)
             *     bodyA.addShape(shapeA)
             *     bodyB.addShape(shapeB)
             *     world.addBody(bodyA)
             *     world.addBody(bodyB)
             *     const localPivotA = new Vec3(1, 0, 0)
             *     const localPivotB = new Vec3(-1, 0, 0)
             *     const constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB)
             *     world.addConstraint(constraint)
             */
            class PointToPointConstraint extends Constraint {
              /**
               * Pivot, defined locally in bodyA.
               */

              /**
               * Pivot, defined locally in bodyB.
               */

              /**
               * @param pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
               * @param bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
               * @param pivotB The point relative to the center of mass of bodyB which bodyB is constrained to.
               * @param maxForce The maximum force that should be applied to constrain the bodies.
               */
              constructor(
                bodyA,
                pivotA = new Vec3(),
                bodyB,
                pivotB = new Vec3(),
                maxForce = 1e6
              ) {
                super(bodyA, bodyB);
                this.pivotA = void 0;
                this.pivotB = void 0;
                this.equationX = void 0;
                this.equationY = void 0;
                this.equationZ = void 0;
                this.pivotA = pivotA.clone();
                this.pivotB = pivotB.clone();
                const x = (this.equationX = new ContactEquation(bodyA, bodyB));
                const y = (this.equationY = new ContactEquation(bodyA, bodyB));
                const z = (this.equationZ = new ContactEquation(bodyA, bodyB)); // Equations to be fed to the solver

                this.equations.push(x, y, z); // Make the equations bidirectional

                x.minForce = y.minForce = z.minForce = -maxForce;
                x.maxForce = y.maxForce = z.maxForce = maxForce;
                x.ni.set(1, 0, 0);
                y.ni.set(0, 1, 0);
                z.ni.set(0, 0, 1);
              }

              update() {
                const bodyA = this.bodyA;
                const bodyB = this.bodyB;
                const x = this.equationX;
                const y = this.equationY;
                const z = this.equationZ; // Rotate the pivots to world space

                bodyA.quaternion.vmult(this.pivotA, x.ri);
                bodyB.quaternion.vmult(this.pivotB, x.rj);
                y.ri.copy(x.ri);
                y.rj.copy(x.rj);
                z.ri.copy(x.ri);
                z.rj.copy(x.rj);
              }
            }

            /**
             * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
             */
            class ConeEquation extends Equation {
              /**
               * Local axis in A
               */

              /**
               * Local axis in B
               */

              /**
               * The "cone angle" to keep
               */
              constructor(bodyA, bodyB, options = {}) {
                const maxForce =
                  typeof options.maxForce !== "undefined"
                    ? options.maxForce
                    : 1e6;
                super(bodyA, bodyB, -maxForce, maxForce);
                this.axisA = void 0;
                this.axisB = void 0;
                this.angle = void 0;
                this.axisA = options.axisA
                  ? options.axisA.clone()
                  : new Vec3(1, 0, 0);
                this.axisB = options.axisB
                  ? options.axisB.clone()
                  : new Vec3(0, 1, 0);
                this.angle =
                  typeof options.angle !== "undefined" ? options.angle : 0;
              }

              computeB(h) {
                const a = this.a;
                const b = this.b;
                const ni = this.axisA;
                const nj = this.axisB;
                const nixnj = tmpVec1$2;
                const njxni = tmpVec2$2;
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB; // Caluclate cross products

                ni.cross(nj, nixnj);
                nj.cross(ni, njxni); // The angle between two vector is:
                // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
                // g = a * b
                // gdot = (b x a) * wi + (a x b) * wj
                // G = [0 bxa 0 axb]
                // W = [vi wi vj wj]

                GA.rotational.copy(njxni);
                GB.rotational.copy(nixnj);
                const g = Math.cos(this.angle) - ni.dot(nj);
                const GW = this.computeGW();
                const GiMf = this.computeGiMf();
                const B = -g * a - GW * b - h * GiMf;
                return B;
              }
            }
            const tmpVec1$2 = new Vec3();
            const tmpVec2$2 = new Vec3();

            /**
             * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
             */
            class RotationalEquation extends Equation {
              /**
               * World oriented rotational axis.
               */

              /**
               * World oriented rotational axis.
               */

              /**
               * maxAngle
               */
              constructor(bodyA, bodyB, options = {}) {
                const maxForce =
                  typeof options.maxForce !== "undefined"
                    ? options.maxForce
                    : 1e6;
                super(bodyA, bodyB, -maxForce, maxForce);
                this.axisA = void 0;
                this.axisB = void 0;
                this.maxAngle = void 0;
                this.axisA = options.axisA
                  ? options.axisA.clone()
                  : new Vec3(1, 0, 0);
                this.axisB = options.axisB
                  ? options.axisB.clone()
                  : new Vec3(0, 1, 0);
                this.maxAngle = Math.PI / 2;
              }

              computeB(h) {
                const a = this.a;
                const b = this.b;
                const ni = this.axisA;
                const nj = this.axisB;
                const nixnj = tmpVec1$1;
                const njxni = tmpVec2$1;
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB; // Caluclate cross products

                ni.cross(nj, nixnj);
                nj.cross(ni, njxni); // g = ni * nj
                // gdot = (nj x ni) * wi + (ni x nj) * wj
                // G = [0 njxni 0 nixnj]
                // W = [vi wi vj wj]

                GA.rotational.copy(njxni);
                GB.rotational.copy(nixnj);
                const g = Math.cos(this.maxAngle) - ni.dot(nj);
                const GW = this.computeGW();
                const GiMf = this.computeGiMf();
                const B = -g * a - GW * b - h * GiMf;
                return B;
              }
            }
            const tmpVec1$1 = new Vec3();
            const tmpVec2$1 = new Vec3();

            /**
             * A Cone Twist constraint, useful for ragdolls.
             */
            class ConeTwistConstraint extends PointToPointConstraint {
              /**
               * The axis direction for the constraint of the body A.
               */

              /**
               * The axis direction for the constraint of the body B.
               */

              /**
               * The aperture angle of the cone.
               */

              /**
               * The twist angle of the joint.
               */
              constructor(bodyA, bodyB, options = {}) {
                const maxForce =
                  typeof options.maxForce !== "undefined"
                    ? options.maxForce
                    : 1e6; // Set pivot point in between

                const pivotA = options.pivotA
                  ? options.pivotA.clone()
                  : new Vec3();
                const pivotB = options.pivotB
                  ? options.pivotB.clone()
                  : new Vec3();
                super(bodyA, pivotA, bodyB, pivotB, maxForce);
                this.axisA = void 0;
                this.axisB = void 0;
                this.angle = void 0;
                this.twistAngle = void 0;
                this.coneEquation = void 0;
                this.twistEquation = void 0;
                this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
                this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
                this.collideConnected = !!options.collideConnected;
                this.angle =
                  typeof options.angle !== "undefined" ? options.angle : 0;
                const c = (this.coneEquation = new ConeEquation(
                  bodyA,
                  bodyB,
                  options
                ));
                const t = (this.twistEquation = new RotationalEquation(
                  bodyA,
                  bodyB,
                  options
                ));
                this.twistAngle =
                  typeof options.twistAngle !== "undefined"
                    ? options.twistAngle
                    : 0; // Make the cone equation push the bodies toward the cone axis, not outward

                c.maxForce = 0;
                c.minForce = -maxForce; // Make the twist equation add torque toward the initial position

                t.maxForce = 0;
                t.minForce = -maxForce;
                this.equations.push(c, t);
              }

              update() {
                const bodyA = this.bodyA;
                const bodyB = this.bodyB;
                const cone = this.coneEquation;
                const twist = this.twistEquation;
                super.update(); // Update the axes to the cone constraint

                bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
                bodyB.vectorToWorldFrame(this.axisB, cone.axisB); // Update the world axes in the twist constraint

                this.axisA.tangents(twist.axisA, twist.axisA);
                bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
                this.axisB.tangents(twist.axisB, twist.axisB);
                bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
                cone.angle = this.angle;
                twist.maxAngle = this.twistAngle;
              }
            }

            /**
             * Constrains two bodies to be at a constant distance from each others center of mass.
             */
            class DistanceConstraint extends Constraint {
              /**
               * The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
               */

              /**
               * @param distance The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB.
               * @param maxForce The maximum force that should be applied to constrain the bodies.
               */
              constructor(bodyA, bodyB, distance, maxForce = 1e6) {
                super(bodyA, bodyB);
                this.distance = void 0;
                this.distanceEquation = void 0;

                if (typeof distance === "undefined") {
                  distance = bodyA.position.distanceTo(bodyB.position);
                }

                this.distance = distance;
                const eq = (this.distanceEquation = new ContactEquation(
                  bodyA,
                  bodyB
                ));
                this.equations.push(eq); // Make it bidirectional

                eq.minForce = -maxForce;
                eq.maxForce = maxForce;
              }
              /**
               * update
               */

              update() {
                const bodyA = this.bodyA;
                const bodyB = this.bodyB;
                const eq = this.distanceEquation;
                const halfDist = this.distance * 0.5;
                const normal = eq.ni;
                bodyB.position.vsub(bodyA.position, normal);
                normal.normalize();
                normal.scale(halfDist, eq.ri);
                normal.scale(-halfDist, eq.rj);
              }
            }

            /**
             * Lock constraint. Will remove all degrees of freedom between the bodies.
             */
            class LockConstraint extends PointToPointConstraint {
              constructor(bodyA, bodyB, options = {}) {
                const maxForce =
                  typeof options.maxForce !== "undefined"
                    ? options.maxForce
                    : 1e6; // Set pivot point in between

                const pivotA = new Vec3();
                const pivotB = new Vec3();
                const halfWay = new Vec3();
                bodyA.position.vadd(bodyB.position, halfWay);
                halfWay.scale(0.5, halfWay);
                bodyB.pointToLocalFrame(halfWay, pivotB);
                bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies

                super(bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces

                this.xA = void 0;
                this.xB = void 0;
                this.yA = void 0;
                this.yB = void 0;
                this.zA = void 0;
                this.zB = void 0;
                this.rotationalEquation1 = void 0;
                this.rotationalEquation2 = void 0;
                this.rotationalEquation3 = void 0;
                this.motorEquation = void 0;
                this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
                this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
                this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
                this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
                this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
                this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place

                const r1 = (this.rotationalEquation1 = new RotationalEquation(
                  bodyA,
                  bodyB,
                  options
                ));
                const r2 = (this.rotationalEquation2 = new RotationalEquation(
                  bodyA,
                  bodyB,
                  options
                ));
                const r3 = (this.rotationalEquation3 = new RotationalEquation(
                  bodyA,
                  bodyB,
                  options
                ));
                this.equations.push(r1, r2, r3);
              }
              /**
               * update
               */

              update() {
                const bodyA = this.bodyA;
                const bodyB = this.bodyB;
                this.motorEquation;
                const r1 = this.rotationalEquation1;
                const r2 = this.rotationalEquation2;
                const r3 = this.rotationalEquation3;
                super.update(); // These vector pairs must be orthogonal

                bodyA.vectorToWorldFrame(this.xA, r1.axisA);
                bodyB.vectorToWorldFrame(this.yB, r1.axisB);
                bodyA.vectorToWorldFrame(this.yA, r2.axisA);
                bodyB.vectorToWorldFrame(this.zB, r2.axisB);
                bodyA.vectorToWorldFrame(this.zA, r3.axisA);
                bodyB.vectorToWorldFrame(this.xB, r3.axisB);
              }
            }

            /**
             * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
             */
            class RotationalMotorEquation extends Equation {
              /**
               * World oriented rotational axis.
               */

              /**
               * World oriented rotational axis.
               */

              /**
               * Motor velocity.
               */
              constructor(bodyA, bodyB, maxForce = 1e6) {
                super(bodyA, bodyB, -maxForce, maxForce);
                this.axisA = void 0;
                this.axisB = void 0;
                this.targetVelocity = void 0;
                this.axisA = new Vec3();
                this.axisB = new Vec3();
                this.targetVelocity = 0;
              }

              computeB(h) {
                this.a;
                const b = this.b;
                this.bi;
                this.bj;
                const axisA = this.axisA;
                const axisB = this.axisB;
                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB; // g = 0
                // gdot = axisA * wi - axisB * wj
                // gdot = G * W = G * [vi wi vj wj]
                // =>
                // G = [0 axisA 0 -axisB]

                GA.rotational.copy(axisA);
                axisB.negate(GB.rotational);
                const GW = this.computeGW() - this.targetVelocity;
                const GiMf = this.computeGiMf();
                const B = -GW * b - h * GiMf;
                return B;
              }
            }

            /**
             * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
             */
            class HingeConstraint extends PointToPointConstraint {
              /**
               * Rotation axis, defined locally in bodyA.
               */

              /**
               * Rotation axis, defined locally in bodyB.
               */
              constructor(bodyA, bodyB, options = {}) {
                const maxForce =
                  typeof options.maxForce !== "undefined"
                    ? options.maxForce
                    : 1e6;
                const pivotA = options.pivotA
                  ? options.pivotA.clone()
                  : new Vec3();
                const pivotB = options.pivotB
                  ? options.pivotB.clone()
                  : new Vec3();
                super(bodyA, pivotA, bodyB, pivotB, maxForce);
                this.axisA = void 0;
                this.axisB = void 0;
                this.rotationalEquation1 = void 0;
                this.rotationalEquation2 = void 0;
                this.motorEquation = void 0;
                const axisA = (this.axisA = options.axisA
                  ? options.axisA.clone()
                  : new Vec3(1, 0, 0));
                axisA.normalize();
                const axisB = (this.axisB = options.axisB
                  ? options.axisB.clone()
                  : new Vec3(1, 0, 0));
                axisB.normalize();
                this.collideConnected = !!options.collideConnected;
                const rotational1 = (this.rotationalEquation1 =
                  new RotationalEquation(bodyA, bodyB, options));
                const rotational2 = (this.rotationalEquation2 =
                  new RotationalEquation(bodyA, bodyB, options));
                const motor = (this.motorEquation = new RotationalMotorEquation(
                  bodyA,
                  bodyB,
                  maxForce
                ));
                motor.enabled = false; // Not enabled by default
                // Equations to be fed to the solver

                this.equations.push(rotational1, rotational2, motor);
              }
              /**
               * enableMotor
               */

              enableMotor() {
                this.motorEquation.enabled = true;
              }
              /**
               * disableMotor
               */

              disableMotor() {
                this.motorEquation.enabled = false;
              }
              /**
               * setMotorSpeed
               */

              setMotorSpeed(speed) {
                this.motorEquation.targetVelocity = speed;
              }
              /**
               * setMotorMaxForce
               */

              setMotorMaxForce(maxForce) {
                this.motorEquation.maxForce = maxForce;
                this.motorEquation.minForce = -maxForce;
              }
              /**
               * update
               */

              update() {
                const bodyA = this.bodyA;
                const bodyB = this.bodyB;
                const motor = this.motorEquation;
                const r1 = this.rotationalEquation1;
                const r2 = this.rotationalEquation2;
                const worldAxisA = HingeConstraint_update_tmpVec1;
                const worldAxisB = HingeConstraint_update_tmpVec2;
                const axisA = this.axisA;
                const axisB = this.axisB;
                super.update(); // Get world axes

                bodyA.quaternion.vmult(axisA, worldAxisA);
                bodyB.quaternion.vmult(axisB, worldAxisB);
                worldAxisA.tangents(r1.axisA, r2.axisA);
                r1.axisB.copy(worldAxisB);
                r2.axisB.copy(worldAxisB);

                if (this.motorEquation.enabled) {
                  bodyA.quaternion.vmult(this.axisA, motor.axisA);
                  bodyB.quaternion.vmult(this.axisB, motor.axisB);
                }
              }
            }
            const HingeConstraint_update_tmpVec1 = new Vec3();
            const HingeConstraint_update_tmpVec2 = new Vec3();

            /**
             * Constrains the slipping in a contact along a tangent
             */
            class FrictionEquation extends Equation {
              // Tangent

              /**
               * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
               */
              constructor(bodyA, bodyB, slipForce) {
                super(bodyA, bodyB, -slipForce, slipForce);
                this.ri = void 0;
                this.rj = void 0;
                this.t = void 0;
                this.ri = new Vec3();
                this.rj = new Vec3();
                this.t = new Vec3();
              }

              computeB(h) {
                this.a;
                const b = this.b;
                this.bi;
                this.bj;
                const ri = this.ri;
                const rj = this.rj;
                const rixt = FrictionEquation_computeB_temp1;
                const rjxt = FrictionEquation_computeB_temp2;
                const t = this.t; // Caluclate cross products

                ri.cross(t, rixt);
                rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
                // And remember, this is a pure velocity constraint, g is always zero!

                const GA = this.jacobianElementA;
                const GB = this.jacobianElementB;
                t.negate(GA.spatial);
                rixt.negate(GA.rotational);
                GB.spatial.copy(t);
                GB.rotational.copy(rjxt);
                const GW = this.computeGW();
                const GiMf = this.computeGiMf();
                const B = -GW * b - h * GiMf;
                return B;
              }
            }
            const FrictionEquation_computeB_temp1 = new Vec3();
            const FrictionEquation_computeB_temp2 = new Vec3();

            /**
             * Defines what happens when two materials meet.
             * @todo Refactor materials to materialA and materialB
             */
            class ContactMaterial {
              /**
               * Identifier of this material.
               */

              /**
               * Participating materials.
               */

              /**
               * Friction coefficient.
               * @default 0.3
               */

              /**
               * Restitution coefficient.
               * @default 0.3
               */

              /**
               * Stiffness of the produced contact equations.
               * @default 1e7
               */

              /**
               * Relaxation time of the produced contact equations.
               * @default 3
               */

              /**
               * Stiffness of the produced friction equations.
               * @default 1e7
               */

              /**
               * Relaxation time of the produced friction equations
               * @default 3
               */
              constructor(m1, m2, options) {
                this.id = void 0;
                this.materials = void 0;
                this.friction = void 0;
                this.restitution = void 0;
                this.contactEquationStiffness = void 0;
                this.contactEquationRelaxation = void 0;
                this.frictionEquationStiffness = void 0;
                this.frictionEquationRelaxation = void 0;
                options = Utils.defaults(options, {
                  friction: 0.3,
                  restitution: 0.3,
                  contactEquationStiffness: 1e7,
                  contactEquationRelaxation: 3,
                  frictionEquationStiffness: 1e7,
                  frictionEquationRelaxation: 3,
                });
                this.id = ContactMaterial.idCounter++;
                this.materials = [m1, m2];
                this.friction = options.friction;
                this.restitution = options.restitution;
                this.contactEquationStiffness =
                  options.contactEquationStiffness;
                this.contactEquationRelaxation =
                  options.contactEquationRelaxation;
                this.frictionEquationStiffness =
                  options.frictionEquationStiffness;
                this.frictionEquationRelaxation =
                  options.frictionEquationRelaxation;
              }
            }
            ContactMaterial.idCounter = 0;

            /**
             * Defines a physics material.
             */
            class Material {
              /**
               * Material name.
               * If options is a string, name will be set to that string.
               * @todo Deprecate this
               */

              /** Material id. */

              /**
               * Friction for this material.
               * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
               */

              /**
               * Restitution for this material.
               * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
               */
              constructor(options = {}) {
                this.name = void 0;
                this.id = void 0;
                this.friction = void 0;
                this.restitution = void 0;
                let name = ""; // Backwards compatibility fix

                if (typeof options === "string") {
                  //console.warn(`Passing a string to MaterialOptions is deprecated, and has no effect`)
                  name = options;
                  options = {};
                }

                this.name = name;
                this.id = Material.idCounter++;
                this.friction =
                  typeof options.friction !== "undefined"
                    ? options.friction
                    : -1;
                this.restitution =
                  typeof options.restitution !== "undefined"
                    ? options.restitution
                    : -1;
              }
            }
            Material.idCounter = 0;

            /**
             * A spring, connecting two bodies.
             * @example
             *     const spring = new Spring(boxBody, sphereBody, {
             *       restLength: 0,
             *       stiffness: 50,
             *       damping: 1,
             *     })
             *
             *     // Compute the force after each step
             *     world.addEventListener('postStep', (event) => {
             *       spring.applyForce()
             *     })
             */
            class Spring {
              /**
               * Rest length of the spring. A number > 0.
               * @default 1
               */

              /**
               * Stiffness of the spring. A number >= 0.
               * @default 100
               */

              /**
               * Damping of the spring. A number >= 0.
               * @default 1
               */

              /**
               * First connected body.
               */

              /**
               * Second connected body.
               */

              /**
               * Anchor for bodyA in local bodyA coordinates.
               * Where to hook the spring to body A, in local body coordinates.
               * @default new Vec3()
               */

              /**
               * Anchor for bodyB in local bodyB coordinates.
               * Where to hook the spring to body B, in local body coordinates.
               * @default new Vec3()
               */
              constructor(bodyA, bodyB, options = {}) {
                this.restLength = void 0;
                this.stiffness = void 0;
                this.damping = void 0;
                this.bodyA = void 0;
                this.bodyB = void 0;
                this.localAnchorA = void 0;
                this.localAnchorB = void 0;
                this.restLength =
                  typeof options.restLength === "number"
                    ? options.restLength
                    : 1;
                this.stiffness = options.stiffness || 100;
                this.damping = options.damping || 1;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.localAnchorA = new Vec3();
                this.localAnchorB = new Vec3();

                if (options.localAnchorA) {
                  this.localAnchorA.copy(options.localAnchorA);
                }

                if (options.localAnchorB) {
                  this.localAnchorB.copy(options.localAnchorB);
                }

                if (options.worldAnchorA) {
                  this.setWorldAnchorA(options.worldAnchorA);
                }

                if (options.worldAnchorB) {
                  this.setWorldAnchorB(options.worldAnchorB);
                }
              }
              /**
               * Set the anchor point on body A, using world coordinates.
               */

              setWorldAnchorA(worldAnchorA) {
                this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
              }
              /**
               * Set the anchor point on body B, using world coordinates.
               */

              setWorldAnchorB(worldAnchorB) {
                this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
              }
              /**
               * Get the anchor point on body A, in world coordinates.
               * @param result The vector to store the result in.
               */

              getWorldAnchorA(result) {
                this.bodyA.pointToWorldFrame(this.localAnchorA, result);
              }
              /**
               * Get the anchor point on body B, in world coordinates.
               * @param result The vector to store the result in.
               */

              getWorldAnchorB(result) {
                this.bodyB.pointToWorldFrame(this.localAnchorB, result);
              }
              /**
               * Apply the spring force to the connected bodies.
               */

              applyForce() {
                const k = this.stiffness;
                const d = this.damping;
                const l = this.restLength;
                const bodyA = this.bodyA;
                const bodyB = this.bodyB;
                const r = applyForce_r;
                const r_unit = applyForce_r_unit;
                const u = applyForce_u;
                const f = applyForce_f;
                const tmp = applyForce_tmp;
                const worldAnchorA = applyForce_worldAnchorA;
                const worldAnchorB = applyForce_worldAnchorB;
                const ri = applyForce_ri;
                const rj = applyForce_rj;
                const ri_x_f = applyForce_ri_x_f;
                const rj_x_f = applyForce_rj_x_f; // Get world anchors

                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB); // Get offset points

                worldAnchorA.vsub(bodyA.position, ri);
                worldAnchorB.vsub(bodyB.position, rj); // Compute distance vector between world anchor points

                worldAnchorB.vsub(worldAnchorA, r);
                const rlen = r.length();
                r_unit.copy(r);
                r_unit.normalize(); // Compute relative velocity of the anchor points, u

                bodyB.velocity.vsub(bodyA.velocity, u); // Add rotational velocity

                bodyB.angularVelocity.cross(rj, tmp);
                u.vadd(tmp, u);
                bodyA.angularVelocity.cross(ri, tmp);
                u.vsub(tmp, u); // F = - k * ( x - L ) - D * ( u )

                r_unit.scale(-k * (rlen - l) - d * u.dot(r_unit), f); // Add forces to bodies

                bodyA.force.vsub(f, bodyA.force);
                bodyB.force.vadd(f, bodyB.force); // Angular force

                ri.cross(f, ri_x_f);
                rj.cross(f, rj_x_f);
                bodyA.torque.vsub(ri_x_f, bodyA.torque);
                bodyB.torque.vadd(rj_x_f, bodyB.torque);
              }
            }
            const applyForce_r = new Vec3();
            const applyForce_r_unit = new Vec3();
            const applyForce_u = new Vec3();
            const applyForce_f = new Vec3();
            const applyForce_worldAnchorA = new Vec3();
            const applyForce_worldAnchorB = new Vec3();
            const applyForce_ri = new Vec3();
            const applyForce_rj = new Vec3();
            const applyForce_ri_x_f = new Vec3();
            const applyForce_rj_x_f = new Vec3();
            const applyForce_tmp = new Vec3();

            /**
             * WheelInfo
             */
            class WheelInfo {
              /**
               * Max travel distance of the suspension, in meters.
               * @default 1
               */

              /**
               * Speed to apply to the wheel rotation when the wheel is sliding.
               * @default -0.1
               */

              /**
               * If the customSlidingRotationalSpeed should be used.
               * @default false
               */

              /**
               * sliding
               */

              /**
               * Connection point, defined locally in the chassis body frame.
               */

              /**
               * chassisConnectionPointWorld
               */

              /**
               * directionLocal
               */

              /**
               * directionWorld
               */

              /**
               * axleLocal
               */

              /**
               * axleWorld
               */

              /**
               * suspensionRestLength
               * @default 1
               */

              /**
               * suspensionMaxLength
               * @default 2
               */

              /**
               * radius
               * @default 1
               */

              /**
               * suspensionStiffness
               * @default 100
               */

              /**
               * dampingCompression
               * @default 10
               */

              /**
               * dampingRelaxation
               * @default 10
               */

              /**
               * frictionSlip
               * @default 10.5
               */

              /** forwardAcceleration */

              /** sideAcceleration */

              /**
               * steering
               * @default 0
               */

              /**
               * Rotation value, in radians.
               * @default 0
               */

              /**
               * deltaRotation
               * @default 0
               */

              /**
               * rollInfluence
               * @default 0.01
               */

              /**
               * maxSuspensionForce
               */

              /**
               * engineForce
               */

              /**
               * brake
               */

              /**
               * isFrontWheel
               * @default true
               */

              /**
               * clippedInvContactDotSuspension
               * @default 1
               */

              /**
               * suspensionRelativeVelocity
               * @default 0
               */

              /**
               * suspensionForce
               * @default 0
               */

              /**
               * slipInfo
               */

              /**
               * skidInfo
               * @default 0
               */

              /**
               * suspensionLength
               * @default 0
               */

              /**
               * sideImpulse
               */

              /**
               * forwardImpulse
               */

              /**
               * The result from raycasting.
               */

              /**
               * Wheel world transform.
               */

              /**
               * isInContact
               */
              constructor(options = {}) {
                this.maxSuspensionTravel = void 0;
                this.customSlidingRotationalSpeed = void 0;
                this.useCustomSlidingRotationalSpeed = void 0;
                this.sliding = void 0;
                this.chassisConnectionPointLocal = void 0;
                this.chassisConnectionPointWorld = void 0;
                this.directionLocal = void 0;
                this.directionWorld = void 0;
                this.axleLocal = void 0;
                this.axleWorld = void 0;
                this.suspensionRestLength = void 0;
                this.suspensionMaxLength = void 0;
                this.radius = void 0;
                this.suspensionStiffness = void 0;
                this.dampingCompression = void 0;
                this.dampingRelaxation = void 0;
                this.frictionSlip = void 0;
                this.forwardAcceleration = void 0;
                this.sideAcceleration = void 0;
                this.steering = void 0;
                this.rotation = void 0;
                this.deltaRotation = void 0;
                this.rollInfluence = void 0;
                this.maxSuspensionForce = void 0;
                this.engineForce = void 0;
                this.brake = void 0;
                this.isFrontWheel = void 0;
                this.clippedInvContactDotSuspension = void 0;
                this.suspensionRelativeVelocity = void 0;
                this.suspensionForce = void 0;
                this.slipInfo = void 0;
                this.skidInfo = void 0;
                this.suspensionLength = void 0;
                this.sideImpulse = void 0;
                this.forwardImpulse = void 0;
                this.raycastResult = void 0;
                this.worldTransform = void 0;
                this.isInContact = void 0;
                options = Utils.defaults(options, {
                  chassisConnectionPointLocal: new Vec3(),
                  chassisConnectionPointWorld: new Vec3(),
                  directionLocal: new Vec3(),
                  directionWorld: new Vec3(),
                  axleLocal: new Vec3(),
                  axleWorld: new Vec3(),
                  suspensionRestLength: 1,
                  suspensionMaxLength: 2,
                  radius: 1,
                  suspensionStiffness: 100,
                  dampingCompression: 10,
                  dampingRelaxation: 10,
                  frictionSlip: 10.5,
                  forwardAcceleration: 1,
                  sideAcceleration: 1,
                  steering: 0,
                  rotation: 0,
                  deltaRotation: 0,
                  rollInfluence: 0.01,
                  maxSuspensionForce: Number.MAX_VALUE,
                  isFrontWheel: true,
                  clippedInvContactDotSuspension: 1,
                  suspensionRelativeVelocity: 0,
                  suspensionForce: 0,
                  slipInfo: 0,
                  skidInfo: 0,
                  suspensionLength: 0,
                  maxSuspensionTravel: 1,
                  useCustomSlidingRotationalSpeed: false,
                  customSlidingRotationalSpeed: -0.1,
                });
                this.maxSuspensionTravel = options.maxSuspensionTravel;
                this.customSlidingRotationalSpeed =
                  options.customSlidingRotationalSpeed;
                this.useCustomSlidingRotationalSpeed =
                  options.useCustomSlidingRotationalSpeed;
                this.sliding = false;
                this.chassisConnectionPointLocal =
                  options.chassisConnectionPointLocal.clone();
                this.chassisConnectionPointWorld =
                  options.chassisConnectionPointWorld.clone();
                this.directionLocal = options.directionLocal.clone();
                this.directionWorld = options.directionWorld.clone();
                this.axleLocal = options.axleLocal.clone();
                this.axleWorld = options.axleWorld.clone();
                this.suspensionRestLength = options.suspensionRestLength;
                this.suspensionMaxLength = options.suspensionMaxLength;
                this.radius = options.radius;
                this.suspensionStiffness = options.suspensionStiffness;
                this.dampingCompression = options.dampingCompression;
                this.dampingRelaxation = options.dampingRelaxation;
                this.frictionSlip = options.frictionSlip;
                this.forwardAcceleration = options.forwardAcceleration;
                this.sideAcceleration = options.sideAcceleration;
                this.steering = 0;
                this.rotation = 0;
                this.deltaRotation = 0;
                this.rollInfluence = options.rollInfluence;
                this.maxSuspensionForce = options.maxSuspensionForce;
                this.engineForce = 0;
                this.brake = 0;
                this.isFrontWheel = options.isFrontWheel;
                this.clippedInvContactDotSuspension = 1;
                this.suspensionRelativeVelocity = 0;
                this.suspensionForce = 0;
                this.slipInfo = 0;
                this.skidInfo = 0;
                this.suspensionLength = 0;
                this.sideImpulse = 0;
                this.forwardImpulse = 0;
                this.raycastResult = new RaycastResult();
                this.worldTransform = new Transform();
                this.isInContact = false;
              }

              updateWheel(chassis) {
                const raycastResult = this.raycastResult;

                if (this.isInContact) {
                  const project = raycastResult.hitNormalWorld.dot(
                    raycastResult.directionWorld
                  );
                  raycastResult.hitPointWorld.vsub(chassis.position, relpos);
                  chassis.getVelocityAtWorldPoint(
                    relpos,
                    chassis_velocity_at_contactPoint
                  );
                  const projVel = raycastResult.hitNormalWorld.dot(
                    chassis_velocity_at_contactPoint
                  );

                  if (project >= -0.1) {
                    this.suspensionRelativeVelocity = 0.0;
                    this.clippedInvContactDotSuspension = 1.0 / 0.1;
                  } else {
                    const inv = -1 / project;
                    this.suspensionRelativeVelocity = projVel * inv;
                    this.clippedInvContactDotSuspension = inv;
                  }
                } else {
                  // Not in contact : position wheel in a nice (rest length) position
                  raycastResult.suspensionLength = this.suspensionRestLength;
                  this.suspensionRelativeVelocity = 0.0;
                  raycastResult.directionWorld.scale(
                    -1,
                    raycastResult.hitNormalWorld
                  );
                  this.clippedInvContactDotSuspension = 1.0;
                }
              }
            }
            const chassis_velocity_at_contactPoint = new Vec3();
            const relpos = new Vec3();

            /**
             * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
             */
            class RaycastVehicle {
              /** The car chassis body. */

              /** The wheels. */

              /** Will be set to true if the car is sliding. */

              /** Index of the right axis. x=0, y=1, z=2 */

              /** Index of the forward axis. x=0, y=1, z=2 */

              /** Index of the up axis. x=0, y=1, z=2 */

              /** The constraints. */

              /** Optional pre-step callback. */

              /** Number of wheels on the ground. */
              constructor(options) {
                this.chassisBody = void 0;
                this.wheelInfos = void 0;
                this.sliding = void 0;
                this.world = void 0;
                this.indexRightAxis = void 0;
                this.indexForwardAxis = void 0;
                this.indexUpAxis = void 0;
                this.constraints = void 0;
                this.preStepCallback = void 0;
                this.currentVehicleSpeedKmHour = void 0;
                this.numWheelsOnGround = void 0;
                this.chassisBody = options.chassisBody;
                this.wheelInfos = [];
                this.sliding = false;
                this.world = null;
                this.indexRightAxis =
                  typeof options.indexRightAxis !== "undefined"
                    ? options.indexRightAxis
                    : 2;
                this.indexForwardAxis =
                  typeof options.indexForwardAxis !== "undefined"
                    ? options.indexForwardAxis
                    : 0;
                this.indexUpAxis =
                  typeof options.indexUpAxis !== "undefined"
                    ? options.indexUpAxis
                    : 1;
                this.constraints = [];

                this.preStepCallback = () => {};

                this.currentVehicleSpeedKmHour = 0;
                this.numWheelsOnGround = 0;
              }
              /**
               * Add a wheel. For information about the options, see `WheelInfo`.
               */

              addWheel(options = {}) {
                const info = new WheelInfo(options);
                const index = this.wheelInfos.length;
                this.wheelInfos.push(info);
                return index;
              }
              /**
               * Set the steering value of a wheel.
               */

              setSteeringValue(value, wheelIndex) {
                const wheel = this.wheelInfos[wheelIndex];
                wheel.steering = value;
              }
              /**
               * Set the wheel force to apply on one of the wheels each time step
               */

              applyEngineForce(value, wheelIndex) {
                this.wheelInfos[wheelIndex].engineForce = value;
              }
              /**
               * Set the braking force of a wheel
               */

              setBrake(brake, wheelIndex) {
                this.wheelInfos[wheelIndex].brake = brake;
              }
              /**
               * Add the vehicle including its constraints to the world.
               */

              addToWorld(world) {
                world.addBody(this.chassisBody);
                const that = this;

                this.preStepCallback = () => {
                  that.updateVehicle(world.dt);
                };

                world.addEventListener("preStep", this.preStepCallback);
                this.world = world;
              }
              /**
               * Get one of the wheel axles, world-oriented.
               */

              getVehicleAxisWorld(axisIndex, result) {
                result.set(
                  axisIndex === 0 ? 1 : 0,
                  axisIndex === 1 ? 1 : 0,
                  axisIndex === 2 ? 1 : 0
                );
                this.chassisBody.vectorToWorldFrame(result, result);
              }

              updateVehicle(timeStep) {
                const wheelInfos = this.wheelInfos;
                const numWheels = wheelInfos.length;
                const chassisBody = this.chassisBody;

                for (let i = 0; i < numWheels; i++) {
                  this.updateWheelTransform(i);
                }

                this.currentVehicleSpeedKmHour =
                  3.6 * chassisBody.velocity.length();
                const forwardWorld = new Vec3();
                this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

                if (forwardWorld.dot(chassisBody.velocity) < 0) {
                  this.currentVehicleSpeedKmHour *= -1;
                } // simulate suspension

                for (let i = 0; i < numWheels; i++) {
                  this.castRay(wheelInfos[i]);
                }

                this.updateSuspension(timeStep);
                const impulse = new Vec3();
                const relpos = new Vec3();

                for (let i = 0; i < numWheels; i++) {
                  //apply suspension force
                  const wheel = wheelInfos[i];
                  let suspensionForce = wheel.suspensionForce;

                  if (suspensionForce > wheel.maxSuspensionForce) {
                    suspensionForce = wheel.maxSuspensionForce;
                  }

                  wheel.raycastResult.hitNormalWorld.scale(
                    suspensionForce * timeStep,
                    impulse
                  );
                  wheel.raycastResult.hitPointWorld.vsub(
                    chassisBody.position,
                    relpos
                  );
                  chassisBody.applyImpulse(impulse, relpos);
                }

                this.updateFriction(timeStep);
                const hitNormalWorldScaledWithProj = new Vec3();
                const fwd = new Vec3();
                const vel = new Vec3();

                for (let i = 0; i < numWheels; i++) {
                  const wheel = wheelInfos[i]; //const relpos = new Vec3();
                  //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);

                  chassisBody.getVelocityAtWorldPoint(
                    wheel.chassisConnectionPointWorld,
                    vel
                  ); // Hack to get the rotation in the correct direction

                  let m = 1;

                  switch (this.indexUpAxis) {
                    case 1:
                      m = -1;
                      break;
                  }

                  if (wheel.isInContact) {
                    this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
                    const proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
                    wheel.raycastResult.hitNormalWorld.scale(
                      proj,
                      hitNormalWorldScaledWithProj
                    );
                    fwd.vsub(hitNormalWorldScaledWithProj, fwd);
                    const proj2 = fwd.dot(vel);
                    wheel.deltaRotation = (m * proj2 * timeStep) / wheel.radius;
                  }

                  if (
                    (wheel.sliding || !wheel.isInContact) &&
                    wheel.engineForce !== 0 &&
                    wheel.useCustomSlidingRotationalSpeed
                  ) {
                    // Apply custom rotation when accelerating and sliding
                    wheel.deltaRotation =
                      (wheel.engineForce > 0 ? 1 : -1) *
                      wheel.customSlidingRotationalSpeed *
                      timeStep;
                  } // Lock wheels

                  if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
                    wheel.deltaRotation = 0;
                  }

                  wheel.rotation += wheel.deltaRotation; // Use the old value

                  wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
                }
              }

              updateSuspension(deltaTime) {
                const chassisBody = this.chassisBody;
                const chassisMass = chassisBody.mass;
                const wheelInfos = this.wheelInfos;
                const numWheels = wheelInfos.length;

                for (let w_it = 0; w_it < numWheels; w_it++) {
                  const wheel = wheelInfos[w_it];

                  if (wheel.isInContact) {
                    let force; // Spring

                    const susp_length = wheel.suspensionRestLength;
                    const current_length = wheel.suspensionLength;
                    const length_diff = susp_length - current_length;
                    force =
                      wheel.suspensionStiffness *
                      length_diff *
                      wheel.clippedInvContactDotSuspension; // Damper

                    const projected_rel_vel = wheel.suspensionRelativeVelocity;
                    let susp_damping;

                    if (projected_rel_vel < 0) {
                      susp_damping = wheel.dampingCompression;
                    } else {
                      susp_damping = wheel.dampingRelaxation;
                    }

                    force -= susp_damping * projected_rel_vel;
                    wheel.suspensionForce = force * chassisMass;

                    if (wheel.suspensionForce < 0) {
                      wheel.suspensionForce = 0;
                    }
                  } else {
                    wheel.suspensionForce = 0;
                  }
                }
              }
              /**
               * Remove the vehicle including its constraints from the world.
               */

              removeFromWorld(world) {
                this.constraints;
                world.removeBody(this.chassisBody);
                world.removeEventListener("preStep", this.preStepCallback);
                this.world = null;
              }

              castRay(wheel) {
                const rayvector = castRay_rayvector;
                const target = castRay_target;
                this.updateWheelTransformWorld(wheel);
                const chassisBody = this.chassisBody;
                let depth = -1;
                const raylen = wheel.suspensionRestLength + wheel.radius;
                wheel.directionWorld.scale(raylen, rayvector);
                const source = wheel.chassisConnectionPointWorld;
                source.vadd(rayvector, target);
                const raycastResult = wheel.raycastResult;
                raycastResult.reset(); // Turn off ray collision with the chassis temporarily

                const oldState = chassisBody.collisionResponse;
                chassisBody.collisionResponse = false; // Cast ray against world

                this.world.rayTest(source, target, raycastResult);
                chassisBody.collisionResponse = oldState;
                const object = raycastResult.body;
                wheel.raycastResult.groundObject = 0;

                if (object) {
                  depth = raycastResult.distance;
                  wheel.raycastResult.hitNormalWorld =
                    raycastResult.hitNormalWorld;
                  wheel.isInContact = true;
                  const hitDistance = raycastResult.distance;
                  wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel

                  const minSuspensionLength =
                    wheel.suspensionRestLength - wheel.maxSuspensionTravel;
                  const maxSuspensionLength =
                    wheel.suspensionRestLength + wheel.maxSuspensionTravel;

                  if (wheel.suspensionLength < minSuspensionLength) {
                    wheel.suspensionLength = minSuspensionLength;
                  }

                  if (wheel.suspensionLength > maxSuspensionLength) {
                    wheel.suspensionLength = maxSuspensionLength;
                    wheel.raycastResult.reset();
                  }

                  const denominator = wheel.raycastResult.hitNormalWorld.dot(
                    wheel.directionWorld
                  );
                  const chassis_velocity_at_contactPoint = new Vec3();
                  chassisBody.getVelocityAtWorldPoint(
                    wheel.raycastResult.hitPointWorld,
                    chassis_velocity_at_contactPoint
                  );
                  const projVel = wheel.raycastResult.hitNormalWorld.dot(
                    chassis_velocity_at_contactPoint
                  );

                  if (denominator >= -0.1) {
                    wheel.suspensionRelativeVelocity = 0;
                    wheel.clippedInvContactDotSuspension = 1 / 0.1;
                  } else {
                    const inv = -1 / denominator;
                    wheel.suspensionRelativeVelocity = projVel * inv;
                    wheel.clippedInvContactDotSuspension = inv;
                  }
                } else {
                  //put wheel info as in rest position
                  wheel.suspensionLength =
                    wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
                  wheel.suspensionRelativeVelocity = 0.0;
                  wheel.directionWorld.scale(
                    -1,
                    wheel.raycastResult.hitNormalWorld
                  );
                  wheel.clippedInvContactDotSuspension = 1.0;
                }

                return depth;
              }

              updateWheelTransformWorld(wheel) {
                wheel.isInContact = false;
                const chassisBody = this.chassisBody;
                chassisBody.pointToWorldFrame(
                  wheel.chassisConnectionPointLocal,
                  wheel.chassisConnectionPointWorld
                );
                chassisBody.vectorToWorldFrame(
                  wheel.directionLocal,
                  wheel.directionWorld
                );
                chassisBody.vectorToWorldFrame(
                  wheel.axleLocal,
                  wheel.axleWorld
                );
              }
              /**
               * Update one of the wheel transform.
               * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
               * @param wheelIndex The wheel index to update.
               */

              updateWheelTransform(wheelIndex) {
                const up = tmpVec4;
                const right = tmpVec5;
                const fwd = tmpVec6;
                const wheel = this.wheelInfos[wheelIndex];
                this.updateWheelTransformWorld(wheel);
                wheel.directionLocal.scale(-1, up);
                right.copy(wheel.axleLocal);
                up.cross(right, fwd);
                fwd.normalize();
                right.normalize(); // Rotate around steering over the wheelAxle

                const steering = wheel.steering;
                const steeringOrn = new Quaternion();
                steeringOrn.setFromAxisAngle(up, steering);
                const rotatingOrn = new Quaternion();
                rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel

                const q = wheel.worldTransform.quaternion;
                this.chassisBody.quaternion.mult(steeringOrn, q);
                q.mult(rotatingOrn, q);
                q.normalize(); // world position of the wheel

                const p = wheel.worldTransform.position;
                p.copy(wheel.directionWorld);
                p.scale(wheel.suspensionLength, p);
                p.vadd(wheel.chassisConnectionPointWorld, p);
              }
              /**
               * Get the world transform of one of the wheels
               */

              getWheelTransformWorld(wheelIndex) {
                return this.wheelInfos[wheelIndex].worldTransform;
              }

              updateFriction(timeStep) {
                const surfNormalWS_scaled_proj =
                  updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards

                const wheelInfos = this.wheelInfos;
                const numWheels = wheelInfos.length;
                const chassisBody = this.chassisBody;
                const forwardWS = updateFriction_forwardWS;
                const axle = updateFriction_axle;
                this.numWheelsOnGround = 0;

                for (let i = 0; i < numWheels; i++) {
                  const wheel = wheelInfos[i];
                  const groundObject = wheel.raycastResult.body;

                  if (groundObject) {
                    this.numWheelsOnGround++;
                  }

                  wheel.sideImpulse = 0;
                  wheel.forwardImpulse = 0;

                  if (!forwardWS[i]) {
                    forwardWS[i] = new Vec3();
                  }

                  if (!axle[i]) {
                    axle[i] = new Vec3();
                  }
                }

                for (let i = 0; i < numWheels; i++) {
                  const wheel = wheelInfos[i];
                  const groundObject = wheel.raycastResult.body;

                  if (groundObject) {
                    const axlei = axle[i];
                    const wheelTrans = this.getWheelTransformWorld(i); // Get world axle

                    wheelTrans.vectorToWorldFrame(
                      directions[this.indexRightAxis],
                      axlei
                    );
                    const surfNormalWS = wheel.raycastResult.hitNormalWorld;
                    const proj = axlei.dot(surfNormalWS);
                    surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
                    axlei.vsub(surfNormalWS_scaled_proj, axlei);
                    axlei.normalize();
                    surfNormalWS.cross(axlei, forwardWS[i]);
                    forwardWS[i].normalize();
                    wheel.sideImpulse = resolveSingleBilateral(
                      chassisBody,
                      wheel.raycastResult.hitPointWorld,
                      groundObject,
                      wheel.raycastResult.hitPointWorld,
                      axlei
                    );
                    wheel.sideImpulse *= sideFrictionStiffness2;
                  }
                }

                const sideFactor = 1;
                const fwdFactor = 0.5;
                this.sliding = false;

                for (let i = 0; i < numWheels; i++) {
                  const wheel = wheelInfos[i];
                  const groundObject = wheel.raycastResult.body;
                  let rollingFriction = 0;
                  wheel.slipInfo = 1;

                  if (groundObject) {
                    const defaultRollingFrictionImpulse = 0;
                    const maxImpulse = wheel.brake
                      ? wheel.brake
                      : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
                    // rollingFriction = calcRollingFriction(contactPt);

                    rollingFriction = calcRollingFriction(
                      chassisBody,
                      groundObject,
                      wheel.raycastResult.hitPointWorld,
                      forwardWS[i],
                      maxImpulse
                    );
                    rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;

                    const factor = maxImpulse / rollingFriction;
                    wheel.slipInfo *= factor;
                  } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

                  wheel.forwardImpulse = 0;
                  wheel.skidInfo = 1;

                  if (groundObject) {
                    wheel.skidInfo = 1;
                    const maximp =
                      wheel.suspensionForce * timeStep * wheel.frictionSlip;
                    const maximpSide = maximp;
                    const maximpSquared = maximp * maximpSide;
                    wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;

                    const x =
                      (wheel.forwardImpulse * fwdFactor) /
                      wheel.forwardAcceleration;
                    const y =
                      (wheel.sideImpulse * sideFactor) / wheel.sideAcceleration;
                    const impulseSquared = x * x + y * y;
                    wheel.sliding = false;

                    if (impulseSquared > maximpSquared) {
                      this.sliding = true;
                      wheel.sliding = true;
                      const factor = maximp / Math.sqrt(impulseSquared);
                      wheel.skidInfo *= factor;
                    }
                  }
                }

                if (this.sliding) {
                  for (let i = 0; i < numWheels; i++) {
                    const wheel = wheelInfos[i];

                    if (wheel.sideImpulse !== 0) {
                      if (wheel.skidInfo < 1) {
                        wheel.forwardImpulse *= wheel.skidInfo;
                        wheel.sideImpulse *= wheel.skidInfo;
                      }
                    }
                  }
                } // apply the impulses

                for (let i = 0; i < numWheels; i++) {
                  const wheel = wheelInfos[i];
                  const rel_pos = new Vec3();
                  wheel.raycastResult.hitPointWorld.vsub(
                    chassisBody.position,
                    rel_pos
                  ); // cannons applyimpulse is using world coord for the position
                  //rel_pos.copy(wheel.raycastResult.hitPointWorld);

                  if (wheel.forwardImpulse !== 0) {
                    const impulse = new Vec3();
                    forwardWS[i].scale(wheel.forwardImpulse, impulse);
                    chassisBody.applyImpulse(impulse, rel_pos);
                  }

                  if (wheel.sideImpulse !== 0) {
                    const groundObject = wheel.raycastResult.body;
                    const rel_pos2 = new Vec3();
                    wheel.raycastResult.hitPointWorld.vsub(
                      groundObject.position,
                      rel_pos2
                    ); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);

                    const sideImp = new Vec3();
                    axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.
                    // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).

                    chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
                    rel_pos["xyz"[this.indexUpAxis]] *= wheel.rollInfluence;
                    chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
                    chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground

                    sideImp.scale(-1, sideImp);
                    groundObject.applyImpulse(sideImp, rel_pos2);
                  }
                }
              }
            }
            const tmpVec4 = new Vec3();
            const tmpVec5 = new Vec3();
            const tmpVec6 = new Vec3();
            new Ray();
            const castRay_rayvector = new Vec3();
            const castRay_target = new Vec3();
            const directions = [
              new Vec3(1, 0, 0),
              new Vec3(0, 1, 0),
              new Vec3(0, 0, 1),
            ];
            const updateFriction_surfNormalWS_scaled_proj = new Vec3();
            const updateFriction_axle = [];
            const updateFriction_forwardWS = [];
            const sideFrictionStiffness2 = 1;
            const calcRollingFriction_vel1 = new Vec3();
            const calcRollingFriction_vel2 = new Vec3();
            const calcRollingFriction_vel = new Vec3();

            function calcRollingFriction(
              body0,
              body1,
              frictionPosWorld,
              frictionDirectionWorld,
              maxImpulse
            ) {
              let j1 = 0;
              const contactPosWorld = frictionPosWorld; // const rel_pos1 = new Vec3();
              // const rel_pos2 = new Vec3();

              const vel1 = calcRollingFriction_vel1;
              const vel2 = calcRollingFriction_vel2;
              const vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);
              // contactPosWorld.vsub(body1.position, rel_pos2);

              body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
              body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
              vel1.vsub(vel2, vel);
              const vrel = frictionDirectionWorld.dot(vel);
              const denom0 = computeImpulseDenominator(
                body0,
                frictionPosWorld,
                frictionDirectionWorld
              );
              const denom1 = computeImpulseDenominator(
                body1,
                frictionPosWorld,
                frictionDirectionWorld
              );
              const relaxation = 1;
              const jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity

              j1 = -vrel * jacDiagABInv;

              if (maxImpulse < j1) {
                j1 = maxImpulse;
              }

              if (j1 < -maxImpulse) {
                j1 = -maxImpulse;
              }

              return j1;
            }

            const computeImpulseDenominator_r0 = new Vec3();
            const computeImpulseDenominator_c0 = new Vec3();
            const computeImpulseDenominator_vec = new Vec3();
            const computeImpulseDenominator_m = new Vec3();

            function computeImpulseDenominator(body, pos, normal) {
              const r0 = computeImpulseDenominator_r0;
              const c0 = computeImpulseDenominator_c0;
              const vec = computeImpulseDenominator_vec;
              const m = computeImpulseDenominator_m;
              pos.vsub(body.position, r0);
              r0.cross(normal, c0);
              body.invInertiaWorld.vmult(c0, m);
              m.cross(r0, vec);
              return body.invMass + normal.dot(vec);
            }

            const resolveSingleBilateral_vel1 = new Vec3();
            const resolveSingleBilateral_vel2 = new Vec3();
            const resolveSingleBilateral_vel = new Vec3(); // bilateral constraint between two dynamic objects

            function resolveSingleBilateral(body1, pos1, body2, pos2, normal) {
              const normalLenSqr = normal.lengthSquared();

              if (normalLenSqr > 1.1) {
                return 0; // no impulse
              } // const rel_pos1 = new Vec3();
              // const rel_pos2 = new Vec3();
              // pos1.vsub(body1.position, rel_pos1);
              // pos2.vsub(body2.position, rel_pos2);

              const vel1 = resolveSingleBilateral_vel1;
              const vel2 = resolveSingleBilateral_vel2;
              const vel = resolveSingleBilateral_vel;
              body1.getVelocityAtWorldPoint(pos1, vel1);
              body2.getVelocityAtWorldPoint(pos2, vel2);
              vel1.vsub(vel2, vel);
              const rel_vel = normal.dot(vel);
              const contactDamping = 0.2;
              const massTerm = 1 / (body1.invMass + body2.invMass);
              const impulse = -contactDamping * rel_vel * massTerm;
              return impulse;
            }

            /**
             * Spherical shape
             * @example
             *     const radius = 1
             *     const sphereShape = new CANNON.Sphere(radius)
             *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })
             *     world.addBody(sphereBody)
             */
            class Sphere extends Shape {
              /**
               * The radius of the sphere.
               */

              /**
               *
               * @param radius The radius of the sphere, a non-negative number.
               */
              constructor(radius) {
                super({
                  type: Shape.types.SPHERE,
                });
                this.radius = void 0;
                this.radius = radius !== undefined ? radius : 1.0;

                if (this.radius < 0) {
                  throw new Error("The sphere radius cannot be negative.");
                }

                this.updateBoundingSphereRadius();
              }
              /** calculateLocalInertia */

              calculateLocalInertia(mass, target = new Vec3()) {
                const I = (2.0 * mass * this.radius * this.radius) / 5.0;
                target.x = I;
                target.y = I;
                target.z = I;
                return target;
              }
              /** volume */

              volume() {
                return (4.0 * Math.PI * Math.pow(this.radius, 3)) / 3.0;
              }

              updateBoundingSphereRadius() {
                this.boundingSphereRadius = this.radius;
              }

              calculateWorldAABB(pos, quat, min, max) {
                const r = this.radius;
                const axes = ["x", "y", "z"];

                for (let i = 0; i < axes.length; i++) {
                  const ax = axes[i];
                  min[ax] = pos[ax] - r;
                  max[ax] = pos[ax] + r;
                }
              }
            }

            /**
             * Simple vehicle helper class with spherical rigid body wheels.
             */
            class RigidVehicle {
              /**
               * The bodies of the wheels.
               */

              /**
               * The chassis body.
               */

              /**
               * The constraints.
               */

              /**
               * The wheel axes.
               */

              /**
               * The wheel forces.
               */
              constructor(options = {}) {
                this.wheelBodies = void 0;
                this.coordinateSystem = void 0;
                this.chassisBody = void 0;
                this.constraints = void 0;
                this.wheelAxes = void 0;
                this.wheelForces = void 0;
                this.wheelBodies = [];
                this.coordinateSystem =
                  typeof options.coordinateSystem !== "undefined"
                    ? options.coordinateSystem.clone()
                    : new Vec3(1, 2, 3);

                if (options.chassisBody) {
                  this.chassisBody = options.chassisBody;
                } else {
                  // No chassis body given. Create it!
                  this.chassisBody = new Body({
                    mass: 1,
                    shape: new Box(new Vec3(5, 0.5, 2)),
                  });
                }

                this.constraints = [];
                this.wheelAxes = [];
                this.wheelForces = [];
              }
              /**
               * Add a wheel
               */

              addWheel(options = {}) {
                let wheelBody;

                if (options.body) {
                  wheelBody = options.body;
                } else {
                  // No wheel body given. Create it!
                  wheelBody = new Body({
                    mass: 1,
                    shape: new Sphere(1.2),
                  });
                }

                this.wheelBodies.push(wheelBody);
                this.wheelForces.push(0); // Position constrain wheels

                const position =
                  typeof options.position !== "undefined"
                    ? options.position.clone()
                    : new Vec3(); // Set position locally to the chassis

                const worldPosition = new Vec3();
                this.chassisBody.pointToWorldFrame(position, worldPosition);
                wheelBody.position.set(
                  worldPosition.x,
                  worldPosition.y,
                  worldPosition.z
                ); // Constrain wheel

                const axis =
                  typeof options.axis !== "undefined"
                    ? options.axis.clone()
                    : new Vec3(0, 0, 1);
                this.wheelAxes.push(axis);
                const hingeConstraint = new HingeConstraint(
                  this.chassisBody,
                  wheelBody,
                  {
                    pivotA: position,
                    axisA: axis,
                    pivotB: Vec3.ZERO,
                    axisB: axis,
                    collideConnected: false,
                  }
                );
                this.constraints.push(hingeConstraint);
                return this.wheelBodies.length - 1;
              }
              /**
               * Set the steering value of a wheel.
               * @todo check coordinateSystem
               */

              setSteeringValue(value, wheelIndex) {
                // Set angle of the hinge axis
                const axis = this.wheelAxes[wheelIndex];
                const c = Math.cos(value);
                const s = Math.sin(value);
                const x = axis.x;
                const z = axis.z;
                this.constraints[wheelIndex].axisA.set(
                  -c * x + s * z,
                  0,
                  s * x + c * z
                );
              }
              /**
               * Set the target rotational speed of the hinge constraint.
               */

              setMotorSpeed(value, wheelIndex) {
                const hingeConstraint = this.constraints[wheelIndex];
                hingeConstraint.enableMotor();
                hingeConstraint.motorTargetVelocity = value;
              }
              /**
               * Set the target rotational speed of the hinge constraint.
               */

              disableMotor(wheelIndex) {
                const hingeConstraint = this.constraints[wheelIndex];
                hingeConstraint.disableMotor();
              }
              /**
               * Set the wheel force to apply on one of the wheels each time step
               */

              setWheelForce(value, wheelIndex) {
                this.wheelForces[wheelIndex] = value;
              }
              /**
               * Apply a torque on one of the wheels.
               */

              applyWheelForce(value, wheelIndex) {
                const axis = this.wheelAxes[wheelIndex];
                const wheelBody = this.wheelBodies[wheelIndex];
                const bodyTorque = wheelBody.torque;
                axis.scale(value, torque);
                wheelBody.vectorToWorldFrame(torque, torque);
                bodyTorque.vadd(torque, bodyTorque);
              }
              /**
               * Add the vehicle including its constraints to the world.
               */

              addToWorld(world) {
                const constraints = this.constraints;
                const bodies = this.wheelBodies.concat([this.chassisBody]);

                for (let i = 0; i < bodies.length; i++) {
                  world.addBody(bodies[i]);
                }

                for (let i = 0; i < constraints.length; i++) {
                  world.addConstraint(constraints[i]);
                }

                world.addEventListener("preStep", this._update.bind(this));
              }

              _update() {
                const wheelForces = this.wheelForces;

                for (let i = 0; i < wheelForces.length; i++) {
                  this.applyWheelForce(wheelForces[i], i);
                }
              }
              /**
               * Remove the vehicle including its constraints from the world.
               */

              removeFromWorld(world) {
                const constraints = this.constraints;
                const bodies = this.wheelBodies.concat([this.chassisBody]);

                for (let i = 0; i < bodies.length; i++) {
                  world.removeBody(bodies[i]);
                }

                for (let i = 0; i < constraints.length; i++) {
                  world.removeConstraint(constraints[i]);
                }
              }
              /**
               * Get current rotational velocity of a wheel
               */

              getWheelSpeed(wheelIndex) {
                const axis = this.wheelAxes[wheelIndex];
                const wheelBody = this.wheelBodies[wheelIndex];
                const w = wheelBody.angularVelocity;
                this.chassisBody.vectorToWorldFrame(axis, worldAxis);
                return w.dot(worldAxis);
              }
            }
            const torque = new Vec3();
            const worldAxis = new Vec3();

            /**
             * Smoothed-particle hydrodynamics system
             * @todo Make parameters customizable in the constructor
             */
            class SPHSystem {
              /**
               * The particles array.
               */

              /**
               * Density of the system (kg/m3).
               * @default 1
               */

              /**
               * Distance below which two particles are considered to be neighbors.
               * It should be adjusted so there are about 15-20 neighbor particles within this radius.
               * @default 1
               */

              /**
               * @default 1
               */

              /**
               * Viscosity of the system.
               * @default 0.01
               */

              /**
               * @default 0.000001
               */
              constructor() {
                this.particles = void 0;
                this.density = void 0;
                this.smoothingRadius = void 0;
                this.speedOfSound = void 0;
                this.viscosity = void 0;
                this.eps = void 0;
                this.pressures = void 0;
                this.densities = void 0;
                this.neighbors = void 0;
                this.particles = [];
                this.density = 1;
                this.smoothingRadius = 1;
                this.speedOfSound = 1;
                this.viscosity = 0.01;
                this.eps = 0.000001; // Stuff Computed per particle

                this.pressures = [];
                this.densities = [];
                this.neighbors = [];
              }
              /**
               * Add a particle to the system.
               */

              add(particle) {
                this.particles.push(particle);

                if (this.neighbors.length < this.particles.length) {
                  this.neighbors.push([]);
                }
              }
              /**
               * Remove a particle from the system.
               */

              remove(particle) {
                const idx = this.particles.indexOf(particle);

                if (idx !== -1) {
                  this.particles.splice(idx, 1);

                  if (this.neighbors.length > this.particles.length) {
                    this.neighbors.pop();
                  }
                }
              }
              /**
               * Get neighbors within smoothing volume, save in the array neighbors
               */

              getNeighbors(particle, neighbors) {
                const N = this.particles.length;
                const id = particle.id;
                const R2 = this.smoothingRadius * this.smoothingRadius;
                const dist = SPHSystem_getNeighbors_dist;

                for (let i = 0; i !== N; i++) {
                  const p = this.particles[i];
                  p.position.vsub(particle.position, dist);

                  if (id !== p.id && dist.lengthSquared() < R2) {
                    neighbors.push(p);
                  }
                }
              }

              update() {
                const N = this.particles.length;
                const dist = SPHSystem_update_dist;
                const cs = this.speedOfSound;
                const eps = this.eps;

                for (let i = 0; i !== N; i++) {
                  const p = this.particles[i]; // Current particle

                  const neighbors = this.neighbors[i]; // Get neighbors

                  neighbors.length = 0;
                  this.getNeighbors(p, neighbors);
                  neighbors.push(this.particles[i]); // Add current too

                  const numNeighbors = neighbors.length; // Accumulate density for the particle

                  let sum = 0.0;

                  for (let j = 0; j !== numNeighbors; j++) {
                    //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
                    p.position.vsub(neighbors[j].position, dist);
                    const len = dist.length();
                    const weight = this.w(len);
                    sum += neighbors[j].mass * weight;
                  } // Save

                  this.densities[i] = sum;
                  this.pressures[i] =
                    cs * cs * (this.densities[i] - this.density);
                } // Add forces
                // Sum to these accelerations

                const a_pressure = SPHSystem_update_a_pressure;
                const a_visc = SPHSystem_update_a_visc;
                const gradW = SPHSystem_update_gradW;
                const r_vec = SPHSystem_update_r_vec;
                const u = SPHSystem_update_u;

                for (let i = 0; i !== N; i++) {
                  const particle = this.particles[i];
                  a_pressure.set(0, 0, 0);
                  a_visc.set(0, 0, 0); // Init vars

                  let Pij;
                  let nabla;

                  const neighbors = this.neighbors[i];
                  const numNeighbors = neighbors.length; //printf("Neighbors: ");

                  for (let j = 0; j !== numNeighbors; j++) {
                    const neighbor = neighbors[j]; //printf("%d ",nj);
                    // Get r once for all..

                    particle.position.vsub(neighbor.position, r_vec);
                    const r = r_vec.length(); // Pressure contribution

                    Pij =
                      -neighbor.mass *
                      (this.pressures[i] /
                        (this.densities[i] * this.densities[i] + eps) +
                        this.pressures[j] /
                          (this.densities[j] * this.densities[j] + eps));
                    this.gradw(r_vec, gradW); // Add to pressure acceleration

                    gradW.scale(Pij, gradW);
                    a_pressure.vadd(gradW, a_pressure); // Viscosity contribution

                    neighbor.velocity.vsub(particle.velocity, u);
                    u.scale(
                      (1.0 / (0.0001 + this.densities[i] * this.densities[j])) *
                        this.viscosity *
                        neighbor.mass,
                      u
                    );
                    nabla = this.nablaw(r);
                    u.scale(nabla, u); // Add to viscosity acceleration

                    a_visc.vadd(u, a_visc);
                  } // Calculate force

                  a_visc.scale(particle.mass, a_visc);
                  a_pressure.scale(particle.mass, a_pressure); // Add force to particles

                  particle.force.vadd(a_visc, particle.force);
                  particle.force.vadd(a_pressure, particle.force);
                }
              } // Calculate the weight using the W(r) weightfunction

              w(r) {
                // 315
                const h = this.smoothingRadius;
                return (
                  (315.0 / (64.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 3
                );
              } // calculate gradient of the weight function

              gradw(rVec, resultVec) {
                const r = rVec.length();
                const h = this.smoothingRadius;
                rVec.scale(
                  (945.0 / (32.0 * Math.PI * h ** 9)) * (h * h - r * r) ** 2,
                  resultVec
                );
              } // Calculate nabla(W)

              nablaw(r) {
                const h = this.smoothingRadius;
                const nabla =
                  (945.0 / (32.0 * Math.PI * h ** 9)) *
                  (h * h - r * r) *
                  (7 * r * r - 3 * h * h);
                return nabla;
              }
            }
            const SPHSystem_getNeighbors_dist = new Vec3(); // Temp vectors for calculation

            const SPHSystem_update_dist = new Vec3(); // Relative velocity

            const SPHSystem_update_a_pressure = new Vec3();
            const SPHSystem_update_a_visc = new Vec3();
            const SPHSystem_update_gradW = new Vec3();
            const SPHSystem_update_r_vec = new Vec3();
            const SPHSystem_update_u = new Vec3();

            /**
             * Cylinder class.
             * @example
             *     const radiusTop = 0.5
             *     const radiusBottom = 0.5
             *     const height = 2
             *     const numSegments = 12
             *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
             *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })
             *     world.addBody(cylinderBody)
             */

            class Cylinder extends ConvexPolyhedron {
              /** The radius of the top of the Cylinder. */

              /** The radius of the bottom of the Cylinder. */

              /** The height of the Cylinder. */

              /** The number of segments to build the cylinder out of. */

              /**
               * @param radiusTop The radius of the top of the Cylinder.
               * @param radiusBottom The radius of the bottom of the Cylinder.
               * @param height The height of the Cylinder.
               * @param numSegments The number of segments to build the cylinder out of.
               */
              constructor(
                radiusTop = 1,
                radiusBottom = 1,
                height = 1,
                numSegments = 8
              ) {
                if (radiusTop < 0) {
                  throw new Error("The cylinder radiusTop cannot be negative.");
                }

                if (radiusBottom < 0) {
                  throw new Error(
                    "The cylinder radiusBottom cannot be negative."
                  );
                }

                const N = numSegments;
                const vertices = [];
                const axes = [];
                const faces = [];
                const bottomface = [];
                const topface = [];
                const cos = Math.cos;
                const sin = Math.sin; // First bottom point

                vertices.push(
                  new Vec3(
                    -radiusBottom * sin(0),
                    -height * 0.5,
                    radiusBottom * cos(0)
                  )
                );
                bottomface.push(0); // First top point

                vertices.push(
                  new Vec3(
                    -radiusTop * sin(0),
                    height * 0.5,
                    radiusTop * cos(0)
                  )
                );
                topface.push(1);

                for (let i = 0; i < N; i++) {
                  const theta = ((2 * Math.PI) / N) * (i + 1);
                  const thetaN = ((2 * Math.PI) / N) * (i + 0.5);

                  if (i < N - 1) {
                    // Bottom
                    vertices.push(
                      new Vec3(
                        -radiusBottom * sin(theta),
                        -height * 0.5,
                        radiusBottom * cos(theta)
                      )
                    );
                    bottomface.push(2 * i + 2); // Top

                    vertices.push(
                      new Vec3(
                        -radiusTop * sin(theta),
                        height * 0.5,
                        radiusTop * cos(theta)
                      )
                    );
                    topface.push(2 * i + 3); // Face

                    faces.push([2 * i, 2 * i + 1, 2 * i + 3, 2 * i + 2]);
                  } else {
                    faces.push([2 * i, 2 * i + 1, 1, 0]); // Connect
                  } // Axis: we can cut off half of them if we have even number of segments

                  if (N % 2 === 1 || i < N / 2) {
                    axes.push(new Vec3(-sin(thetaN), 0, cos(thetaN)));
                  }
                }

                faces.push(bottomface);
                axes.push(new Vec3(0, 1, 0)); // Reorder top face

                const temp = [];

                for (let i = 0; i < topface.length; i++) {
                  temp.push(topface[topface.length - i - 1]);
                }

                faces.push(temp);
                super({
                  vertices,
                  faces,
                  axes,
                });
                this.radiusTop = void 0;
                this.radiusBottom = void 0;
                this.height = void 0;
                this.numSegments = void 0;
                this.type = Shape.types.CYLINDER;
                this.radiusTop = radiusTop;
                this.radiusBottom = radiusBottom;
                this.height = height;
                this.numSegments = numSegments;
              }
            }

            /**
             * Particle shape.
             * @example
             *     const particleShape = new CANNON.Particle()
             *     const particleBody = new CANNON.Body({ mass: 1, shape: particleShape })
             *     world.addBody(particleBody)
             */
            class Particle extends Shape {
              constructor() {
                super({
                  type: Shape.types.PARTICLE,
                });
              }
              /**
               * calculateLocalInertia
               */

              calculateLocalInertia(mass, target = new Vec3()) {
                target.set(0, 0, 0);
                return target;
              }

              volume() {
                return 0;
              }

              updateBoundingSphereRadius() {
                this.boundingSphereRadius = 0;
              }

              calculateWorldAABB(pos, quat, min, max) {
                // Get each axis max
                min.copy(pos);
                max.copy(pos);
              }
            }

            /**
             * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
             * @example
             *     const planeShape = new CANNON.Plane()
             *     const planeBody = new CANNON.Body({ mass: 0, shape:  planeShape })
             *     planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
             *     world.addBody(planeBody)
             */
            class Plane extends Shape {
              /** worldNormal */

              /** worldNormalNeedsUpdate */
              constructor() {
                super({
                  type: Shape.types.PLANE,
                }); // World oriented normal

                this.worldNormal = void 0;
                this.worldNormalNeedsUpdate = void 0;
                this.boundingSphereRadius = void 0;
                this.worldNormal = new Vec3();
                this.worldNormalNeedsUpdate = true;
                this.boundingSphereRadius = Number.MAX_VALUE;
              }
              /** computeWorldNormal */

              computeWorldNormal(quat) {
                const n = this.worldNormal;
                n.set(0, 0, 1);
                quat.vmult(n, n);
                this.worldNormalNeedsUpdate = false;
              }

              calculateLocalInertia(mass, target = new Vec3()) {
                return target;
              }

              volume() {
                return (
                  // The plane is infinite...
                  Number.MAX_VALUE
                );
              }

              calculateWorldAABB(pos, quat, min, max) {
                // The plane AABB is infinite, except if the normal is pointing along any axis
                tempNormal.set(0, 0, 1); // Default plane normal is z

                quat.vmult(tempNormal, tempNormal);
                const maxVal = Number.MAX_VALUE;
                min.set(-maxVal, -maxVal, -maxVal);
                max.set(maxVal, maxVal, maxVal);

                if (tempNormal.x === 1) {
                  max.x = pos.x;
                } else if (tempNormal.x === -1) {
                  min.x = pos.x;
                }

                if (tempNormal.y === 1) {
                  max.y = pos.y;
                } else if (tempNormal.y === -1) {
                  min.y = pos.y;
                }

                if (tempNormal.z === 1) {
                  max.z = pos.z;
                } else if (tempNormal.z === -1) {
                  min.z = pos.z;
                }
              }

              updateBoundingSphereRadius() {
                this.boundingSphereRadius = Number.MAX_VALUE;
              }
            }
            const tempNormal = new Vec3();

            /**
             * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
             * @todo Should be possible to use along all axes, not just y
             * @todo should be possible to scale along all axes
             * @todo Refactor elementSize to elementSizeX and elementSizeY
             *
             * @example
             *     // Generate some height data (y-values).
             *     const data = []
             *     for (let i = 0; i < 1000; i++) {
             *         const y = 0.5 * Math.cos(0.2 * i)
             *         data.push(y)
             *     }
             *
             *     // Create the heightfield shape
             *     const heightfieldShape = new CANNON.Heightfield(data, {
             *         elementSize: 1 // Distance between the data points in X and Y directions
             *     })
             *     const heightfieldBody = new CANNON.Body({ shape: heightfieldShape })
             *     world.addBody(heightfieldBody)
             */
            class Heightfield extends Shape {
              /**
               * An array of numbers, or height values, that are spread out along the x axis.
               */

              /**
               * Max value of the data points in the data array.
               */

              /**
               * Minimum value of the data points in the data array.
               */

              /**
               * World spacing between the data points in X and Y direction.
               * @todo elementSizeX and Y
               * @default 1
               */

              /**
               * @default true
               */

              /**
               * @param data An array of numbers, or height values, that are spread out along the x axis.
               */
              constructor(data, options = {}) {
                options = Utils.defaults(options, {
                  maxValue: null,
                  minValue: null,
                  elementSize: 1,
                });
                super({
                  type: Shape.types.HEIGHTFIELD,
                });
                this.data = void 0;
                this.maxValue = void 0;
                this.minValue = void 0;
                this.elementSize = void 0;
                this.cacheEnabled = void 0;
                this.pillarConvex = void 0;
                this.pillarOffset = void 0;
                this._cachedPillars = void 0;
                this.data = data;
                this.maxValue = options.maxValue;
                this.minValue = options.minValue;
                this.elementSize = options.elementSize;

                if (options.minValue === null) {
                  this.updateMinValue();
                }

                if (options.maxValue === null) {
                  this.updateMaxValue();
                }

                this.cacheEnabled = true;
                this.pillarConvex = new ConvexPolyhedron();
                this.pillarOffset = new Vec3();
                this.updateBoundingSphereRadius(); // "i_j_isUpper" => { convex: ..., offset: ... }
                // for example:
                // _cachedPillars["0_2_1"]

                this._cachedPillars = {};
              }
              /**
               * Call whenever you change the data array.
               */

              update() {
                this._cachedPillars = {};
              }
              /**
               * Update the `minValue` property
               */

              updateMinValue() {
                const data = this.data;
                let minValue = data[0][0];

                for (let i = 0; i !== data.length; i++) {
                  for (let j = 0; j !== data[i].length; j++) {
                    const v = data[i][j];

                    if (v < minValue) {
                      minValue = v;
                    }
                  }
                }

                this.minValue = minValue;
              }
              /**
               * Update the `maxValue` property
               */

              updateMaxValue() {
                const data = this.data;
                let maxValue = data[0][0];

                for (let i = 0; i !== data.length; i++) {
                  for (let j = 0; j !== data[i].length; j++) {
                    const v = data[i][j];

                    if (v > maxValue) {
                      maxValue = v;
                    }
                  }
                }

                this.maxValue = maxValue;
              }
              /**
               * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
               */

              setHeightValueAtIndex(xi, yi, value) {
                const data = this.data;
                data[xi][yi] = value; // Invalidate cache

                this.clearCachedConvexTrianglePillar(xi, yi, false);

                if (xi > 0) {
                  this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
                  this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
                }

                if (yi > 0) {
                  this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
                  this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
                }

                if (yi > 0 && xi > 0) {
                  this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
                }
              }
              /**
               * Get max/min in a rectangle in the matrix data
               * @param result An array to store the results in.
               * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.
               */

              getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, result = []) {
                // Get max and min of the data
                const data = this.data; // Set first value

                let max = this.minValue;

                for (let i = iMinX; i <= iMaxX; i++) {
                  for (let j = iMinY; j <= iMaxY; j++) {
                    const height = data[i][j];

                    if (height > max) {
                      max = height;
                    }
                  }
                }

                result[0] = this.minValue;
                result[1] = max;
              }
              /**
               * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
               * @param result Two-element array
               * @param clamp If the position should be clamped to the heightfield edge.
               */

              getIndexOfPosition(x, y, result, clamp) {
                // Get the index of the data points to test against
                const w = this.elementSize;
                const data = this.data;
                let xi = Math.floor(x / w);
                let yi = Math.floor(y / w);
                result[0] = xi;
                result[1] = yi;

                if (clamp) {
                  // Clamp index to edges
                  if (xi < 0) {
                    xi = 0;
                  }

                  if (yi < 0) {
                    yi = 0;
                  }

                  if (xi >= data.length - 1) {
                    xi = data.length - 1;
                  }

                  if (yi >= data[0].length - 1) {
                    yi = data[0].length - 1;
                  }
                } // Bail out if we are out of the terrain

                if (
                  xi < 0 ||
                  yi < 0 ||
                  xi >= data.length - 1 ||
                  yi >= data[0].length - 1
                ) {
                  return false;
                }

                return true;
              }

              getTriangleAt(x, y, edgeClamp, a, b, c) {
                const idx = getHeightAt_idx;
                this.getIndexOfPosition(x, y, idx, edgeClamp);
                let xi = idx[0];
                let yi = idx[1];
                const data = this.data;

                if (edgeClamp) {
                  xi = Math.min(data.length - 2, Math.max(0, xi));
                  yi = Math.min(data[0].length - 2, Math.max(0, yi));
                }

                const elementSize = this.elementSize;
                const lowerDist2 =
                  (x / elementSize - xi) ** 2 + (y / elementSize - yi) ** 2;
                const upperDist2 =
                  (x / elementSize - (xi + 1)) ** 2 +
                  (y / elementSize - (yi + 1)) ** 2;
                const upper = lowerDist2 > upperDist2;
                this.getTriangle(xi, yi, upper, a, b, c);
                return upper;
              }

              getNormalAt(x, y, edgeClamp, result) {
                const a = getNormalAt_a;
                const b = getNormalAt_b;
                const c = getNormalAt_c;
                const e0 = getNormalAt_e0;
                const e1 = getNormalAt_e1;
                this.getTriangleAt(x, y, edgeClamp, a, b, c);
                b.vsub(a, e0);
                c.vsub(a, e1);
                e0.cross(e1, result);
                result.normalize();
              }
              /**
               * Get an AABB of a square in the heightfield
               * @param xi
               * @param yi
               * @param result
               */

              getAabbAtIndex(xi, yi, { lowerBound, upperBound }) {
                const data = this.data;
                const elementSize = this.elementSize;
                lowerBound.set(
                  xi * elementSize,
                  yi * elementSize,
                  data[xi][yi]
                );
                upperBound.set(
                  (xi + 1) * elementSize,
                  (yi + 1) * elementSize,
                  data[xi + 1][yi + 1]
                );
              }
              /**
               * Get the height in the heightfield at a given position
               */

              getHeightAt(x, y, edgeClamp) {
                const data = this.data;
                const a = getHeightAt_a;
                const b = getHeightAt_b;
                const c = getHeightAt_c;
                const idx = getHeightAt_idx;
                this.getIndexOfPosition(x, y, idx, edgeClamp);
                let xi = idx[0];
                let yi = idx[1];

                if (edgeClamp) {
                  xi = Math.min(data.length - 2, Math.max(0, xi));
                  yi = Math.min(data[0].length - 2, Math.max(0, yi));
                }

                const upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
                barycentricWeights(
                  x,
                  y,
                  a.x,
                  a.y,
                  b.x,
                  b.y,
                  c.x,
                  c.y,
                  getHeightAt_weights
                );
                const w = getHeightAt_weights;

                if (upper) {
                  // Top triangle verts
                  return (
                    data[xi + 1][yi + 1] * w.x +
                    data[xi][yi + 1] * w.y +
                    data[xi + 1][yi] * w.z
                  );
                } else {
                  // Top triangle verts
                  return (
                    data[xi][yi] * w.x +
                    data[xi + 1][yi] * w.y +
                    data[xi][yi + 1] * w.z
                  );
                }
              }

              getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle) {
                return xi + "_" + yi + "_" + (getUpperTriangle ? 1 : 0);
              }

              getCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
                return this._cachedPillars[
                  this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)
                ];
              }

              setCachedConvexTrianglePillar(
                xi,
                yi,
                getUpperTriangle,
                convex,
                offset
              ) {
                this._cachedPillars[
                  this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)
                ] = {
                  convex,
                  offset,
                };
              }

              clearCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
                delete this._cachedPillars[
                  this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)
                ];
              }
              /**
               * Get a triangle from the heightfield
               */

              getTriangle(xi, yi, upper, a, b, c) {
                const data = this.data;
                const elementSize = this.elementSize;

                if (upper) {
                  // Top triangle verts
                  a.set(
                    (xi + 1) * elementSize,
                    (yi + 1) * elementSize,
                    data[xi + 1][yi + 1]
                  );
                  b.set(
                    xi * elementSize,
                    (yi + 1) * elementSize,
                    data[xi][yi + 1]
                  );
                  c.set(
                    (xi + 1) * elementSize,
                    yi * elementSize,
                    data[xi + 1][yi]
                  );
                } else {
                  // Top triangle verts
                  a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
                  b.set(
                    (xi + 1) * elementSize,
                    yi * elementSize,
                    data[xi + 1][yi]
                  );
                  c.set(
                    xi * elementSize,
                    (yi + 1) * elementSize,
                    data[xi][yi + 1]
                  );
                }
              }
              /**
               * Get a triangle in the terrain in the form of a triangular convex shape.
               */

              getConvexTrianglePillar(xi, yi, getUpperTriangle) {
                let result = this.pillarConvex;
                let offsetResult = this.pillarOffset;

                if (this.cacheEnabled) {
                  const data = this.getCachedConvexTrianglePillar(
                    xi,
                    yi,
                    getUpperTriangle
                  );

                  if (data) {
                    this.pillarConvex = data.convex;
                    this.pillarOffset = data.offset;
                    return;
                  }

                  result = new ConvexPolyhedron();
                  offsetResult = new Vec3();
                  this.pillarConvex = result;
                  this.pillarOffset = offsetResult;
                }

                const data = this.data;
                const elementSize = this.elementSize;
                const faces = result.faces; // Reuse verts if possible

                result.vertices.length = 6;

                for (let i = 0; i < 6; i++) {
                  if (!result.vertices[i]) {
                    result.vertices[i] = new Vec3();
                  }
                } // Reuse faces if possible

                faces.length = 5;

                for (let i = 0; i < 5; i++) {
                  if (!faces[i]) {
                    faces[i] = [];
                  }
                }

                const verts = result.vertices;
                const h =
                  (Math.min(
                    data[xi][yi],
                    data[xi + 1][yi],
                    data[xi][yi + 1],
                    data[xi + 1][yi + 1]
                  ) -
                    this.minValue) /
                    2 +
                  this.minValue;

                if (!getUpperTriangle) {
                  // Center of the triangle pillar - all polygons are given relative to this one
                  offsetResult.set(
                    (xi + 0.25) * elementSize, // sort of center of a triangle
                    (yi + 0.25) * elementSize,
                    h // vertical center
                  ); // Top triangle verts

                  verts[0].set(
                    -0.25 * elementSize,
                    -0.25 * elementSize,
                    data[xi][yi] - h
                  );
                  verts[1].set(
                    0.75 * elementSize,
                    -0.25 * elementSize,
                    data[xi + 1][yi] - h
                  );
                  verts[2].set(
                    -0.25 * elementSize,
                    0.75 * elementSize,
                    data[xi][yi + 1] - h
                  ); // bottom triangle verts

                  verts[3].set(
                    -0.25 * elementSize,
                    -0.25 * elementSize,
                    -Math.abs(h) - 1
                  );
                  verts[4].set(
                    0.75 * elementSize,
                    -0.25 * elementSize,
                    -Math.abs(h) - 1
                  );
                  verts[5].set(
                    -0.25 * elementSize,
                    0.75 * elementSize,
                    -Math.abs(h) - 1
                  ); // top triangle

                  faces[0][0] = 0;
                  faces[0][1] = 1;
                  faces[0][2] = 2; // bottom triangle

                  faces[1][0] = 5;
                  faces[1][1] = 4;
                  faces[1][2] = 3; // -x facing quad

                  faces[2][0] = 0;
                  faces[2][1] = 2;
                  faces[2][2] = 5;
                  faces[2][3] = 3; // -y facing quad

                  faces[3][0] = 1;
                  faces[3][1] = 0;
                  faces[3][2] = 3;
                  faces[3][3] = 4; // +xy facing quad

                  faces[4][0] = 4;
                  faces[4][1] = 5;
                  faces[4][2] = 2;
                  faces[4][3] = 1;
                } else {
                  // Center of the triangle pillar - all polygons are given relative to this one
                  offsetResult.set(
                    (xi + 0.75) * elementSize, // sort of center of a triangle
                    (yi + 0.75) * elementSize,
                    h // vertical center
                  ); // Top triangle verts

                  verts[0].set(
                    0.25 * elementSize,
                    0.25 * elementSize,
                    data[xi + 1][yi + 1] - h
                  );
                  verts[1].set(
                    -0.75 * elementSize,
                    0.25 * elementSize,
                    data[xi][yi + 1] - h
                  );
                  verts[2].set(
                    0.25 * elementSize,
                    -0.75 * elementSize,
                    data[xi + 1][yi] - h
                  ); // bottom triangle verts

                  verts[3].set(
                    0.25 * elementSize,
                    0.25 * elementSize,
                    -Math.abs(h) - 1
                  );
                  verts[4].set(
                    -0.75 * elementSize,
                    0.25 * elementSize,
                    -Math.abs(h) - 1
                  );
                  verts[5].set(
                    0.25 * elementSize,
                    -0.75 * elementSize,
                    -Math.abs(h) - 1
                  ); // Top triangle

                  faces[0][0] = 0;
                  faces[0][1] = 1;
                  faces[0][2] = 2; // bottom triangle

                  faces[1][0] = 5;
                  faces[1][1] = 4;
                  faces[1][2] = 3; // +x facing quad

                  faces[2][0] = 2;
                  faces[2][1] = 5;
                  faces[2][2] = 3;
                  faces[2][3] = 0; // +y facing quad

                  faces[3][0] = 3;
                  faces[3][1] = 4;
                  faces[3][2] = 1;
                  faces[3][3] = 0; // -xy facing quad

                  faces[4][0] = 1;
                  faces[4][1] = 4;
                  faces[4][2] = 5;
                  faces[4][3] = 2;
                }

                result.computeNormals();
                result.computeEdges();
                result.updateBoundingSphereRadius();
                this.setCachedConvexTrianglePillar(
                  xi,
                  yi,
                  getUpperTriangle,
                  result,
                  offsetResult
                );
              }

              calculateLocalInertia(mass, target = new Vec3()) {
                target.set(0, 0, 0);
                return target;
              }

              volume() {
                return (
                  // The terrain is infinite
                  Number.MAX_VALUE
                );
              }

              calculateWorldAABB(pos, quat, min, max) {
                /** @TODO do it properly */
                min.set(
                  -Number.MAX_VALUE,
                  -Number.MAX_VALUE,
                  -Number.MAX_VALUE
                );
                max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
              }

              updateBoundingSphereRadius() {
                // Use the bounding box of the min/max values
                const data = this.data;
                const s = this.elementSize;
                this.boundingSphereRadius = new Vec3(
                  data.length * s,
                  data[0].length * s,
                  Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))
                ).length();
              }
              /**
               * Sets the height values from an image. Currently only supported in browser.
               */

              setHeightsFromImage(image, scale) {
                const { x, z, y } = scale;
                const canvas = document.createElement("canvas");
                canvas.width = image.width;
                canvas.height = image.height;
                const context = canvas.getContext("2d");
                context.drawImage(image, 0, 0);
                const imageData = context.getImageData(
                  0,
                  0,
                  image.width,
                  image.height
                );
                const matrix = this.data;
                matrix.length = 0;
                this.elementSize = Math.abs(x) / imageData.width;

                for (let i = 0; i < imageData.height; i++) {
                  const row = [];

                  for (let j = 0; j < imageData.width; j++) {
                    const a = imageData.data[(i * imageData.height + j) * 4];
                    const b =
                      imageData.data[(i * imageData.height + j) * 4 + 1];
                    const c =
                      imageData.data[(i * imageData.height + j) * 4 + 2];
                    const height = ((a + b + c) / 4 / 255) * z;

                    if (x < 0) {
                      row.push(height);
                    } else {
                      row.unshift(height);
                    }
                  }

                  if (y < 0) {
                    matrix.unshift(row);
                  } else {
                    matrix.push(row);
                  }
                }

                this.updateMaxValue();
                this.updateMinValue();
                this.update();
              }
            }
            const getHeightAt_idx = [];
            const getHeightAt_weights = new Vec3();
            const getHeightAt_a = new Vec3();
            const getHeightAt_b = new Vec3();
            const getHeightAt_c = new Vec3();
            const getNormalAt_a = new Vec3();
            const getNormalAt_b = new Vec3();
            const getNormalAt_c = new Vec3();
            const getNormalAt_e0 = new Vec3();
            const getNormalAt_e1 = new Vec3(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system

            function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
              result.x =
                ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) /
                ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
              result.y =
                ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) /
                ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
              result.z = 1 - result.x - result.y;
            }

            /**
             * OctreeNode
             */
            class OctreeNode {
              /** The root node */

              /** Boundary of this node */

              /** Contained data at the current node level */

              /** Children to this node */
              constructor(options = {}) {
                this.root = void 0;
                this.aabb = void 0;
                this.data = void 0;
                this.children = void 0;
                this.root = options.root || null;
                this.aabb = options.aabb ? options.aabb.clone() : new AABB();
                this.data = [];
                this.children = [];
              }
              /**
               * reset
               */

              reset() {
                this.children.length = this.data.length = 0;
              }
              /**
               * Insert data into this node
               * @return True if successful, otherwise false
               */

              insert(aabb, elementData, level = 0) {
                const nodeData = this.data; // Ignore objects that do not belong in this node

                if (!this.aabb.contains(aabb)) {
                  return false; // object cannot be added
                }

                const children = this.children;
                const maxDepth = this.maxDepth || this.root.maxDepth;

                if (level < maxDepth) {
                  // Subdivide if there are no children yet
                  let subdivided = false;

                  if (!children.length) {
                    this.subdivide();
                    subdivided = true;
                  } // add to whichever node will accept it

                  for (let i = 0; i !== 8; i++) {
                    if (children[i].insert(aabb, elementData, level + 1)) {
                      return true;
                    }
                  }

                  if (subdivided) {
                    // No children accepted! Might as well just remove em since they contain none
                    children.length = 0;
                  }
                } // Too deep, or children didnt want it. add it in current node

                nodeData.push(elementData);
                return true;
              }
              /**
               * Create 8 equally sized children nodes and put them in the `children` array.
               */

              subdivide() {
                const aabb = this.aabb;
                const l = aabb.lowerBound;
                const u = aabb.upperBound;
                const children = this.children;
                children.push(
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(0, 0, 0),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(1, 0, 0),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(1, 1, 0),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(1, 1, 1),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(0, 1, 1),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(0, 0, 1),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(1, 0, 1),
                    }),
                  }),
                  new OctreeNode({
                    aabb: new AABB({
                      lowerBound: new Vec3(0, 1, 0),
                    }),
                  })
                );
                u.vsub(l, halfDiagonal);
                halfDiagonal.scale(0.5, halfDiagonal);
                const root = this.root || this;

                for (let i = 0; i !== 8; i++) {
                  const child = children[i]; // Set current node as root

                  child.root = root; // Compute bounds

                  const lowerBound = child.aabb.lowerBound;
                  lowerBound.x *= halfDiagonal.x;
                  lowerBound.y *= halfDiagonal.y;
                  lowerBound.z *= halfDiagonal.z;
                  lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal

                  lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
                }
              }
              /**
               * Get all data, potentially within an AABB
               * @return The "result" object
               */

              aabbQuery(aabb, result) {
                this.data; // abort if the range does not intersect this node
                // if (!this.aabb.overlaps(aabb)){
                //     return result;
                // }
                // Add objects at this level
                // Array.prototype.push.apply(result, nodeData);
                // Add child data
                // @todo unwrap recursion into a queue / loop, that's faster in JS

                this.children; // for (let i = 0, N = this.children.length; i !== N; i++) {
                //     children[i].aabbQuery(aabb, result);
                // }

                const queue = [this];

                while (queue.length) {
                  const node = queue.pop();

                  if (node.aabb.overlaps(aabb)) {
                    Array.prototype.push.apply(result, node.data);
                  }

                  Array.prototype.push.apply(queue, node.children);
                }

                return result;
              }
              /**
               * Get all data, potentially intersected by a ray.
               * @return The "result" object
               */

              rayQuery(ray, treeTransform, result) {
                // Use aabb query for now.

                /** @todo implement real ray query which needs less lookups */
                ray.getAABB(tmpAABB);
                tmpAABB.toLocalFrame(treeTransform, tmpAABB);
                this.aabbQuery(tmpAABB, result);
                return result;
              }
              /**
               * removeEmptyNodes
               */

              removeEmptyNodes() {
                for (let i = this.children.length - 1; i >= 0; i--) {
                  this.children[i].removeEmptyNodes();

                  if (
                    !this.children[i].children.length &&
                    !this.children[i].data.length
                  ) {
                    this.children.splice(i, 1);
                  }
                }
              }
            }
            /**
             * Octree
             */

            class Octree extends OctreeNode {
              /**
               * Maximum subdivision depth
               * @default 8
               */

              /**
               * @param aabb The total AABB of the tree
               */
              constructor(aabb, options = {}) {
                super({
                  root: null,
                  aabb,
                });
                this.maxDepth = void 0;
                this.maxDepth =
                  typeof options.maxDepth !== "undefined"
                    ? options.maxDepth
                    : 8;
              }
            }
            const halfDiagonal = new Vec3();
            const tmpAABB = new AABB();

            /**
             * Trimesh.
             * @example
             *     // How to make a mesh with a single triangle
             *     const vertices = [
             *         0, 0, 0, // vertex 0
             *         1, 0, 0, // vertex 1
             *         0, 1, 0  // vertex 2
             *     ]
             *     const indices = [
             *         0, 1, 2  // triangle 0
             *     ]
             *     const trimeshShape = new CANNON.Trimesh(vertices, indices)
             */
            class Trimesh extends Shape {
              /**
               * vertices
               */

              /**
               * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
               */

              /**
               * The normals data.
               */

              /**
               * The local AABB of the mesh.
               */

              /**
               * References to vertex pairs, making up all unique edges in the trimesh.
               */

              /**
               * Local scaling of the mesh. Use .setScale() to set it.
               */

              /**
               * The indexed triangles. Use .updateTree() to update it.
               */
              constructor(vertices, indices) {
                super({
                  type: Shape.types.TRIMESH,
                });
                this.vertices = void 0;
                this.indices = void 0;
                this.normals = void 0;
                this.aabb = void 0;
                this.edges = void 0;
                this.scale = void 0;
                this.tree = void 0;
                this.vertices = new Float32Array(vertices);
                this.indices = new Int16Array(indices);
                this.normals = new Float32Array(indices.length);
                this.aabb = new AABB();
                this.edges = null;
                this.scale = new Vec3(1, 1, 1);
                this.tree = new Octree();
                this.updateEdges();
                this.updateNormals();
                this.updateAABB();
                this.updateBoundingSphereRadius();
                this.updateTree();
              }
              /**
               * updateTree
               */

              updateTree() {
                const tree = this.tree;
                tree.reset();
                tree.aabb.copy(this.aabb);
                const scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled

                tree.aabb.lowerBound.x *= 1 / scale.x;
                tree.aabb.lowerBound.y *= 1 / scale.y;
                tree.aabb.lowerBound.z *= 1 / scale.z;
                tree.aabb.upperBound.x *= 1 / scale.x;
                tree.aabb.upperBound.y *= 1 / scale.y;
                tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles

                const triangleAABB = new AABB();
                const a = new Vec3();
                const b = new Vec3();
                const c = new Vec3();
                const points = [a, b, c];

                for (let i = 0; i < this.indices.length / 3; i++) {
                  //this.getTriangleVertices(i, a, b, c);
                  // Get unscaled triangle verts
                  const i3 = i * 3;

                  this._getUnscaledVertex(this.indices[i3], a);

                  this._getUnscaledVertex(this.indices[i3 + 1], b);

                  this._getUnscaledVertex(this.indices[i3 + 2], c);

                  triangleAABB.setFromPoints(points);
                  tree.insert(triangleAABB, i);
                }

                tree.removeEmptyNodes();
              }
              /**
               * Get triangles in a local AABB from the trimesh.
               * @param result An array of integers, referencing the queried triangles.
               */

              getTrianglesInAABB(aabb, result) {
                unscaledAABB.copy(aabb); // Scale it to local

                const scale = this.scale;
                const isx = scale.x;
                const isy = scale.y;
                const isz = scale.z;
                const l = unscaledAABB.lowerBound;
                const u = unscaledAABB.upperBound;
                l.x /= isx;
                l.y /= isy;
                l.z /= isz;
                u.x /= isx;
                u.y /= isy;
                u.z /= isz;
                return this.tree.aabbQuery(unscaledAABB, result);
              }
              /**
               * setScale
               */

              setScale(scale) {
                const wasUniform =
                  this.scale.x === this.scale.y &&
                  this.scale.y === this.scale.z;
                const isUniform = scale.x === scale.y && scale.y === scale.z;

                if (!(wasUniform && isUniform)) {
                  // Non-uniform scaling. Need to update normals.
                  this.updateNormals();
                }

                this.scale.copy(scale);
                this.updateAABB();
                this.updateBoundingSphereRadius();
              }
              /**
               * Compute the normals of the faces. Will save in the `.normals` array.
               */

              updateNormals() {
                const n = computeNormals_n; // Generate normals

                const normals = this.normals;

                for (let i = 0; i < this.indices.length / 3; i++) {
                  const i3 = i * 3;
                  const a = this.indices[i3];
                  const b = this.indices[i3 + 1];
                  const c = this.indices[i3 + 2];
                  this.getVertex(a, va);
                  this.getVertex(b, vb);
                  this.getVertex(c, vc);
                  Trimesh.computeNormal(vb, va, vc, n);
                  normals[i3] = n.x;
                  normals[i3 + 1] = n.y;
                  normals[i3 + 2] = n.z;
                }
              }
              /**
               * Update the `.edges` property
               */

              updateEdges() {
                const edges = {};

                const add = (a, b) => {
                  const key = a < b ? a + "_" + b : b + "_" + a;
                  edges[key] = true;
                };

                for (let i = 0; i < this.indices.length / 3; i++) {
                  const i3 = i * 3;
                  const a = this.indices[i3];
                  const b = this.indices[i3 + 1];
                  const c = this.indices[i3 + 2];
                  add(a, b);
                  add(b, c);
                  add(c, a);
                }

                const keys = Object.keys(edges);
                this.edges = new Int16Array(keys.length * 2);

                for (let i = 0; i < keys.length; i++) {
                  const indices = keys[i].split("_");
                  this.edges[2 * i] = parseInt(indices[0], 10);
                  this.edges[2 * i + 1] = parseInt(indices[1], 10);
                }
              }
              /**
               * Get an edge vertex
               * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.
               * @param vertexStore Where to store the result
               */

              getEdgeVertex(edgeIndex, firstOrSecond, vertexStore) {
                const vertexIndex =
                  this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
                this.getVertex(vertexIndex, vertexStore);
              }
              /**
               * Get a vector along an edge.
               */

              getEdgeVector(edgeIndex, vectorStore) {
                const va = getEdgeVector_va;
                const vb = getEdgeVector_vb;
                this.getEdgeVertex(edgeIndex, 0, va);
                this.getEdgeVertex(edgeIndex, 1, vb);
                vb.vsub(va, vectorStore);
              }
              /**
               * Get face normal given 3 vertices
               */

              static computeNormal(va, vb, vc, target) {
                vb.vsub(va, ab);
                vc.vsub(vb, cb);
                cb.cross(ab, target);

                if (!target.isZero()) {
                  target.normalize();
                }
              }
              /**
               * Get vertex i.
               * @return The "out" vector object
               */

              getVertex(i, out) {
                const scale = this.scale;

                this._getUnscaledVertex(i, out);

                out.x *= scale.x;
                out.y *= scale.y;
                out.z *= scale.z;
                return out;
              }
              /**
               * Get raw vertex i
               * @return The "out" vector object
               */

              _getUnscaledVertex(i, out) {
                const i3 = i * 3;
                const vertices = this.vertices;
                return out.set(
                  vertices[i3],
                  vertices[i3 + 1],
                  vertices[i3 + 2]
                );
              }
              /**
               * Get a vertex from the trimesh,transformed by the given position and quaternion.
               * @return The "out" vector object
               */

              getWorldVertex(i, pos, quat, out) {
                this.getVertex(i, out);
                Transform.pointToWorldFrame(pos, quat, out, out);
                return out;
              }
              /**
               * Get the three vertices for triangle i.
               */

              getTriangleVertices(i, a, b, c) {
                const i3 = i * 3;
                this.getVertex(this.indices[i3], a);
                this.getVertex(this.indices[i3 + 1], b);
                this.getVertex(this.indices[i3 + 2], c);
              }
              /**
               * Compute the normal of triangle i.
               * @return The "target" vector object
               */

              getNormal(i, target) {
                const i3 = i * 3;
                return target.set(
                  this.normals[i3],
                  this.normals[i3 + 1],
                  this.normals[i3 + 2]
                );
              }
              /**
               * @return The "target" vector object
               */

              calculateLocalInertia(mass, target) {
                // Approximate with box inertia
                // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
                this.computeLocalAABB(cli_aabb);
                const x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x;
                const y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y;
                const z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
                return target.set(
                  (1.0 / 12.0) * mass * (2 * y * 2 * y + 2 * z * 2 * z),
                  (1.0 / 12.0) * mass * (2 * x * 2 * x + 2 * z * 2 * z),
                  (1.0 / 12.0) * mass * (2 * y * 2 * y + 2 * x * 2 * x)
                );
              }
              /**
               * Compute the local AABB for the trimesh
               */

              computeLocalAABB(aabb) {
                const l = aabb.lowerBound;
                const u = aabb.upperBound;
                const n = this.vertices.length;
                this.vertices;
                const v = computeLocalAABB_worldVert;
                this.getVertex(0, v);
                l.copy(v);
                u.copy(v);

                for (let i = 0; i !== n; i++) {
                  this.getVertex(i, v);

                  if (v.x < l.x) {
                    l.x = v.x;
                  } else if (v.x > u.x) {
                    u.x = v.x;
                  }

                  if (v.y < l.y) {
                    l.y = v.y;
                  } else if (v.y > u.y) {
                    u.y = v.y;
                  }

                  if (v.z < l.z) {
                    l.z = v.z;
                  } else if (v.z > u.z) {
                    u.z = v.z;
                  }
                }
              }
              /**
               * Update the `.aabb` property
               */

              updateAABB() {
                this.computeLocalAABB(this.aabb);
              }
              /**
               * Will update the `.boundingSphereRadius` property
               */

              updateBoundingSphereRadius() {
                // Assume points are distributed with local (0,0,0) as center
                let max2 = 0;
                const vertices = this.vertices;
                const v = new Vec3();

                for (let i = 0, N = vertices.length / 3; i !== N; i++) {
                  this.getVertex(i, v);
                  const norm2 = v.lengthSquared();

                  if (norm2 > max2) {
                    max2 = norm2;
                  }
                }

                this.boundingSphereRadius = Math.sqrt(max2);
              }
              /**
               * calculateWorldAABB
               */

              calculateWorldAABB(pos, quat, min, max) {
                /*
        const n = this.vertices.length / 3,
            verts = this.vertices;
        const minx,miny,minz,maxx,maxy,maxz;
         const v = tempWorldVertex;
        for(let i=0; i<n; i++){
            this.getVertex(i, v);
            quat.vmult(v, v);
            pos.vadd(v, v);
            if (v.x < minx || minx===undefined){
                minx = v.x;
            } else if(v.x > maxx || maxx===undefined){
                maxx = v.x;
            }
             if (v.y < miny || miny===undefined){
                miny = v.y;
            } else if(v.y > maxy || maxy===undefined){
                maxy = v.y;
            }
             if (v.z < minz || minz===undefined){
                minz = v.z;
            } else if(v.z > maxz || maxz===undefined){
                maxz = v.z;
            }
        }
        min.set(minx,miny,minz);
        max.set(maxx,maxy,maxz);
        */
                // Faster approximation using local AABB
                const frame = calculateWorldAABB_frame;
                const result = calculateWorldAABB_aabb;
                frame.position = pos;
                frame.quaternion = quat;
                this.aabb.toWorldFrame(frame, result);
                min.copy(result.lowerBound);
                max.copy(result.upperBound);
              }
              /**
               * Get approximate volume
               */

              volume() {
                return (4.0 * Math.PI * this.boundingSphereRadius) / 3.0;
              }
              /**
               * Create a Trimesh instance, shaped as a torus.
               */

              static createTorus(
                radius = 1,
                tube = 0.5,
                radialSegments = 8,
                tubularSegments = 6,
                arc = Math.PI * 2
              ) {
                const vertices = [];
                const indices = [];

                for (let j = 0; j <= radialSegments; j++) {
                  for (let i = 0; i <= tubularSegments; i++) {
                    const u = (i / tubularSegments) * arc;
                    const v = (j / radialSegments) * Math.PI * 2;
                    const x = (radius + tube * Math.cos(v)) * Math.cos(u);
                    const y = (radius + tube * Math.cos(v)) * Math.sin(u);
                    const z = tube * Math.sin(v);
                    vertices.push(x, y, z);
                  }
                }

                for (let j = 1; j <= radialSegments; j++) {
                  for (let i = 1; i <= tubularSegments; i++) {
                    const a = (tubularSegments + 1) * j + i - 1;
                    const b = (tubularSegments + 1) * (j - 1) + i - 1;
                    const c = (tubularSegments + 1) * (j - 1) + i;
                    const d = (tubularSegments + 1) * j + i;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                  }
                }

                return new Trimesh(vertices, indices);
              }
            }
            const computeNormals_n = new Vec3();
            const unscaledAABB = new AABB();
            const getEdgeVector_va = new Vec3();
            const getEdgeVector_vb = new Vec3();
            const cb = new Vec3();
            const ab = new Vec3();
            const va = new Vec3();
            const vb = new Vec3();
            const vc = new Vec3();
            const cli_aabb = new AABB();
            const computeLocalAABB_worldVert = new Vec3();
            const calculateWorldAABB_frame = new Transform();
            const calculateWorldAABB_aabb = new AABB();

            /**
             * Constraint equation solver base class.
             */
            class Solver {
              /**
               * All equations to be solved
               */

              /**
               * @todo remove useless constructor
               */
              constructor() {
                this.equations = void 0;
                this.equations = [];
              }
              /**
               * Should be implemented in subclasses!
               * @todo use abstract
               * @return number of iterations performed
               */

              solve(dt, world) {
                return (
                  // Should return the number of iterations done!
                  0
                );
              }
              /**
               * Add an equation
               */

              addEquation(eq) {
                if (eq.enabled && !eq.bi.isTrigger && !eq.bj.isTrigger) {
                  this.equations.push(eq);
                }
              }
              /**
               * Remove an equation
               */

              removeEquation(eq) {
                const eqs = this.equations;
                const i = eqs.indexOf(eq);

                if (i !== -1) {
                  eqs.splice(i, 1);
                }
              }
              /**
               * Add all equations
               */

              removeAllEquations() {
                this.equations.length = 0;
              }
            }

            /**
             * Constraint equation Gauss-Seidel solver.
             * @todo The spook parameters should be specified for each constraint, not globally.
             * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
             */
            class GSSolver extends Solver {
              /**
               * The number of solver iterations determines quality of the constraints in the world.
               * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
               */

              /**
               * When tolerance is reached, the system is assumed to be converged.
               */

              /**
               * @todo remove useless constructor
               */
              constructor() {
                super();
                this.iterations = void 0;
                this.tolerance = void 0;
                this.iterations = 10;
                this.tolerance = 1e-7;
              }
              /**
               * Solve
               * @return number of iterations performed
               */

              solve(dt, world) {
                let iter = 0;
                const maxIter = this.iterations;
                const tolSquared = this.tolerance * this.tolerance;
                const equations = this.equations;
                const Neq = equations.length;
                const bodies = world.bodies;
                const Nbodies = bodies.length;
                const h = dt;
                let B;
                let invC;
                let deltalambda;
                let deltalambdaTot;
                let GWlambda;
                let lambdaj; // Update solve mass

                if (Neq !== 0) {
                  for (let i = 0; i !== Nbodies; i++) {
                    bodies[i].updateSolveMassProperties();
                  }
                } // Things that do not change during iteration can be computed once

                const invCs = GSSolver_solve_invCs;
                const Bs = GSSolver_solve_Bs;
                const lambda = GSSolver_solve_lambda;
                invCs.length = Neq;
                Bs.length = Neq;
                lambda.length = Neq;

                for (let i = 0; i !== Neq; i++) {
                  const c = equations[i];
                  lambda[i] = 0.0;
                  Bs[i] = c.computeB(h);
                  invCs[i] = 1.0 / c.computeC();
                }

                if (Neq !== 0) {
                  // Reset vlambda
                  for (let i = 0; i !== Nbodies; i++) {
                    const b = bodies[i];
                    const vlambda = b.vlambda;
                    const wlambda = b.wlambda;
                    vlambda.set(0, 0, 0);
                    wlambda.set(0, 0, 0);
                  } // Iterate over equations

                  for (iter = 0; iter !== maxIter; iter++) {
                    // Accumulate the total error for each iteration.
                    deltalambdaTot = 0.0;

                    for (let j = 0; j !== Neq; j++) {
                      const c = equations[j]; // Compute iteration

                      B = Bs[j];
                      invC = invCs[j];
                      lambdaj = lambda[j];
                      GWlambda = c.computeGWlambda();
                      deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

                      if (lambdaj + deltalambda < c.minForce) {
                        deltalambda = c.minForce - lambdaj;
                      } else if (lambdaj + deltalambda > c.maxForce) {
                        deltalambda = c.maxForce - lambdaj;
                      }

                      lambda[j] += deltalambda;
                      deltalambdaTot +=
                        deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

                      c.addToWlambda(deltalambda);
                    } // If the total error is small enough - stop iterate

                    if (deltalambdaTot * deltalambdaTot < tolSquared) {
                      break;
                    }
                  } // Add result to velocity

                  for (let i = 0; i !== Nbodies; i++) {
                    const b = bodies[i];
                    const v = b.velocity;
                    const w = b.angularVelocity;
                    b.vlambda.vmul(b.linearFactor, b.vlambda);
                    v.vadd(b.vlambda, v);
                    b.wlambda.vmul(b.angularFactor, b.wlambda);
                    w.vadd(b.wlambda, w);
                  } // Set the `.multiplier` property of each equation

                  let l = equations.length;
                  const invDt = 1 / h;

                  while (l--) {
                    equations[l].multiplier = lambda[l] * invDt;
                  }
                }

                return iter;
              }
            } // Just temporary number holders that we want to reuse each iteration.

            const GSSolver_solve_lambda = [];
            const GSSolver_solve_invCs = [];
            const GSSolver_solve_Bs = [];

            /**
             * Splits the equations into islands and solves them independently. Can improve performance.
             */
            class SplitSolver extends Solver {
              /**
               * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
               */

              /**
               * When tolerance is reached, the system is assumed to be converged.
               */

              /** subsolver */
              constructor(subsolver) {
                super();
                this.iterations = void 0;
                this.tolerance = void 0;
                this.subsolver = void 0;
                this.nodes = void 0;
                this.nodePool = void 0;
                this.iterations = 10;
                this.tolerance = 1e-7;
                this.subsolver = subsolver;
                this.nodes = [];
                this.nodePool = []; // Create needed nodes, reuse if possible

                while (this.nodePool.length < 128) {
                  this.nodePool.push(this.createNode());
                }
              }
              /**
               * createNode
               */

              createNode() {
                return {
                  body: null,
                  children: [],
                  eqs: [],
                  visited: false,
                };
              }
              /**
               * Solve the subsystems
               * @return number of iterations performed
               */

              solve(dt, world) {
                const nodes = SplitSolver_solve_nodes;
                const nodePool = this.nodePool;
                const bodies = world.bodies;
                const equations = this.equations;
                const Neq = equations.length;
                const Nbodies = bodies.length;
                const subsolver = this.subsolver; // Create needed nodes, reuse if possible

                while (nodePool.length < Nbodies) {
                  nodePool.push(this.createNode());
                }

                nodes.length = Nbodies;

                for (let i = 0; i < Nbodies; i++) {
                  nodes[i] = nodePool[i];
                } // Reset node values

                for (let i = 0; i !== Nbodies; i++) {
                  const node = nodes[i];
                  node.body = bodies[i];
                  node.children.length = 0;
                  node.eqs.length = 0;
                  node.visited = false;
                }

                for (let k = 0; k !== Neq; k++) {
                  const eq = equations[k];
                  const i = bodies.indexOf(eq.bi);
                  const j = bodies.indexOf(eq.bj);
                  const ni = nodes[i];
                  const nj = nodes[j];
                  ni.children.push(nj);
                  ni.eqs.push(eq);
                  nj.children.push(ni);
                  nj.eqs.push(eq);
                }

                let child;
                let n = 0;
                let eqs = SplitSolver_solve_eqs;
                subsolver.tolerance = this.tolerance;
                subsolver.iterations = this.iterations;
                const dummyWorld = SplitSolver_solve_dummyWorld;

                while ((child = getUnvisitedNode(nodes))) {
                  eqs.length = 0;
                  dummyWorld.bodies.length = 0;
                  bfs(child, visitFunc, dummyWorld.bodies, eqs);
                  const Neqs = eqs.length;
                  eqs = eqs.sort(sortById);

                  for (let i = 0; i !== Neqs; i++) {
                    subsolver.addEquation(eqs[i]);
                  }

                  subsolver.solve(dt, dummyWorld);
                  subsolver.removeAllEquations();
                  n++;
                }

                return n;
              }
            } // Returns the number of subsystems

            const SplitSolver_solve_nodes = []; // All allocated node objects

            const SplitSolver_solve_eqs = []; // Temp array

            const SplitSolver_solve_dummyWorld = {
              bodies: [],
            }; // Temp object

            const STATIC = Body.STATIC;

            function getUnvisitedNode(nodes) {
              const Nnodes = nodes.length;

              for (let i = 0; i !== Nnodes; i++) {
                const node = nodes[i];

                if (!node.visited && !(node.body.type & STATIC)) {
                  return node;
                }
              }

              return false;
            }

            const queue = [];

            function bfs(root, visitFunc, bds, eqs) {
              queue.push(root);
              root.visited = true;
              visitFunc(root, bds, eqs);

              while (queue.length) {
                const node = queue.pop(); // Loop over unvisited child nodes

                let child;

                while ((child = getUnvisitedNode(node.children))) {
                  child.visited = true;
                  visitFunc(child, bds, eqs);
                  queue.push(child);
                }
              }
            }

            function visitFunc(node, bds, eqs) {
              bds.push(node.body);
              const Neqs = node.eqs.length;

              for (let i = 0; i !== Neqs; i++) {
                const eq = node.eqs[i];

                if (!eqs.includes(eq)) {
                  eqs.push(eq);
                }
              }
            }

            function sortById(a, b) {
              return b.id - a.id;
            }

            /**
             * For pooling objects that can be reused.
             */
            class Pool {
              constructor() {
                this.objects = [];
                this.type = Object;
              }

              /**
               * Release an object after use
               */
              release(...args) {
                const Nargs = args.length;

                for (let i = 0; i !== Nargs; i++) {
                  this.objects.push(args[i]);
                }

                return this;
              }
              /**
               * Get an object
               */

              get() {
                if (this.objects.length === 0) {
                  return this.constructObject();
                } else {
                  return this.objects.pop();
                }
              }
              /**
               * Construct an object. Should be implemented in each subclass.
               */

              constructObject() {
                throw new Error(
                  "constructObject() not implemented in this Pool subclass yet!"
                );
              }
              /**
               * @return Self, for chaining
               */

              resize(size) {
                const objects = this.objects;

                while (objects.length > size) {
                  objects.pop();
                }

                while (objects.length < size) {
                  objects.push(this.constructObject());
                }

                return this;
              }
            }

            /**
             * Vec3Pool
             */

            class Vec3Pool extends Pool {
              constructor(...args) {
                super(...args);
                this.type = Vec3;
              }

              /**
               * Construct a vector
               */
              constructObject() {
                return new Vec3();
              }
            }

            let _COLLISION_TYPES$sphe,
              _COLLISION_TYPES$sphe2,
              _COLLISION_TYPES$boxB,
              _COLLISION_TYPES$sphe3,
              _COLLISION_TYPES$plan,
              _COLLISION_TYPES$conv,
              _COLLISION_TYPES$sphe4,
              _COLLISION_TYPES$plan2,
              _COLLISION_TYPES$boxC,
              _COLLISION_TYPES$sphe5,
              _COLLISION_TYPES$boxH,
              _COLLISION_TYPES$conv2,
              _COLLISION_TYPES$sphe6,
              _COLLISION_TYPES$plan3,
              _COLLISION_TYPES$boxP,
              _COLLISION_TYPES$conv3,
              _COLLISION_TYPES$cyli,
              _COLLISION_TYPES$sphe7,
              _COLLISION_TYPES$plan4,
              _COLLISION_TYPES$boxC2,
              _COLLISION_TYPES$conv4,
              _COLLISION_TYPES$heig,
              _COLLISION_TYPES$part,
              _COLLISION_TYPES$sphe8,
              _COLLISION_TYPES$plan5;
            // Naming rule: based of the order in SHAPE_TYPES,
            // the first part of the method is formed by the
            // shape type that comes before, in the second part
            // there is the shape type that comes after in the SHAPE_TYPES list
            const COLLISION_TYPES = {
              sphereSphere: Shape.types.SPHERE,
              spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
              boxBox: Shape.types.BOX | Shape.types.BOX,
              sphereBox: Shape.types.SPHERE | Shape.types.BOX,
              planeBox: Shape.types.PLANE | Shape.types.BOX,
              convexConvex: Shape.types.CONVEXPOLYHEDRON,
              sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
              planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
              boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
              sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
              boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
              convexHeightfield:
                Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
              sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
              planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
              boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
              convexParticle:
                Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
              cylinderCylinder: Shape.types.CYLINDER,
              sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,
              planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,
              boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,
              convexCylinder:
                Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,
              heightfieldCylinder:
                Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,
              particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,
              sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
              planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH,
            };
            _COLLISION_TYPES$sphe = COLLISION_TYPES.sphereSphere;
            _COLLISION_TYPES$sphe2 = COLLISION_TYPES.spherePlane;
            _COLLISION_TYPES$boxB = COLLISION_TYPES.boxBox;
            _COLLISION_TYPES$sphe3 = COLLISION_TYPES.sphereBox;
            _COLLISION_TYPES$plan = COLLISION_TYPES.planeBox;
            _COLLISION_TYPES$conv = COLLISION_TYPES.convexConvex;
            _COLLISION_TYPES$sphe4 = COLLISION_TYPES.sphereConvex;
            _COLLISION_TYPES$plan2 = COLLISION_TYPES.planeConvex;
            _COLLISION_TYPES$boxC = COLLISION_TYPES.boxConvex;
            _COLLISION_TYPES$sphe5 = COLLISION_TYPES.sphereHeightfield;
            _COLLISION_TYPES$boxH = COLLISION_TYPES.boxHeightfield;
            _COLLISION_TYPES$conv2 = COLLISION_TYPES.convexHeightfield;
            _COLLISION_TYPES$sphe6 = COLLISION_TYPES.sphereParticle;
            _COLLISION_TYPES$plan3 = COLLISION_TYPES.planeParticle;
            _COLLISION_TYPES$boxP = COLLISION_TYPES.boxParticle;
            _COLLISION_TYPES$conv3 = COLLISION_TYPES.convexParticle;
            _COLLISION_TYPES$cyli = COLLISION_TYPES.cylinderCylinder;
            _COLLISION_TYPES$sphe7 = COLLISION_TYPES.sphereCylinder;
            _COLLISION_TYPES$plan4 = COLLISION_TYPES.planeCylinder;
            _COLLISION_TYPES$boxC2 = COLLISION_TYPES.boxCylinder;
            _COLLISION_TYPES$conv4 = COLLISION_TYPES.convexCylinder;
            _COLLISION_TYPES$heig = COLLISION_TYPES.heightfieldCylinder;
            _COLLISION_TYPES$part = COLLISION_TYPES.particleCylinder;
            _COLLISION_TYPES$sphe8 = COLLISION_TYPES.sphereTrimesh;
            _COLLISION_TYPES$plan5 = COLLISION_TYPES.planeTrimesh;

            /**
             * Helper class for the World. Generates ContactEquations.
             * @todo Sphere-ConvexPolyhedron contacts
             * @todo Contact reduction
             * @todo should move methods to prototype
             */
            class Narrowphase {
              /**
               * Internal storage of pooled contact points.
               */

              /**
               * Pooled vectors.
               */
              get [_COLLISION_TYPES$sphe]() {
                return this.sphereSphere;
              }

              get [_COLLISION_TYPES$sphe2]() {
                return this.spherePlane;
              }

              get [_COLLISION_TYPES$boxB]() {
                return this.boxBox;
              }

              get [_COLLISION_TYPES$sphe3]() {
                return this.sphereBox;
              }

              get [_COLLISION_TYPES$plan]() {
                return this.planeBox;
              }

              get [_COLLISION_TYPES$conv]() {
                return this.convexConvex;
              }

              get [_COLLISION_TYPES$sphe4]() {
                return this.sphereConvex;
              }

              get [_COLLISION_TYPES$plan2]() {
                return this.planeConvex;
              }

              get [_COLLISION_TYPES$boxC]() {
                return this.boxConvex;
              }

              get [_COLLISION_TYPES$sphe5]() {
                return this.sphereHeightfield;
              }

              get [_COLLISION_TYPES$boxH]() {
                return this.boxHeightfield;
              }

              get [_COLLISION_TYPES$conv2]() {
                return this.convexHeightfield;
              }

              get [_COLLISION_TYPES$sphe6]() {
                return this.sphereParticle;
              }

              get [_COLLISION_TYPES$plan3]() {
                return this.planeParticle;
              }

              get [_COLLISION_TYPES$boxP]() {
                return this.boxParticle;
              }

              get [_COLLISION_TYPES$conv3]() {
                return this.convexParticle;
              }

              get [_COLLISION_TYPES$cyli]() {
                return this.convexConvex;
              }

              get [_COLLISION_TYPES$sphe7]() {
                return this.sphereConvex;
              }

              get [_COLLISION_TYPES$plan4]() {
                return this.planeConvex;
              }

              get [_COLLISION_TYPES$boxC2]() {
                return this.boxConvex;
              }

              get [_COLLISION_TYPES$conv4]() {
                return this.convexConvex;
              }

              get [_COLLISION_TYPES$heig]() {
                return this.heightfieldCylinder;
              }

              get [_COLLISION_TYPES$part]() {
                return this.particleCylinder;
              }

              get [_COLLISION_TYPES$sphe8]() {
                return this.sphereTrimesh;
              }

              get [_COLLISION_TYPES$plan5]() {
                return this.planeTrimesh;
              } // get [COLLISION_TYPES.convexTrimesh]() {
              //   return this.convexTrimesh
              // }

              constructor(world) {
                this.contactPointPool = void 0;
                this.frictionEquationPool = void 0;
                this.result = void 0;
                this.frictionResult = void 0;
                this.v3pool = void 0;
                this.world = void 0;
                this.currentContactMaterial = void 0;
                this.enableFrictionReduction = void 0;
                this.contactPointPool = [];
                this.frictionEquationPool = [];
                this.result = [];
                this.frictionResult = [];
                this.v3pool = new Vec3Pool();
                this.world = world;
                this.currentContactMaterial = world.defaultContactMaterial;
                this.enableFrictionReduction = false;
              }
              /**
               * Make a contact object, by using the internal pool or creating a new one.
               */

              createContactEquation(
                bi,
                bj,
                si,
                sj,
                overrideShapeA,
                overrideShapeB
              ) {
                let c;

                if (this.contactPointPool.length) {
                  c = this.contactPointPool.pop();
                  c.bi = bi;
                  c.bj = bj;
                } else {
                  c = new ContactEquation(bi, bj);
                }

                c.enabled =
                  bi.collisionResponse &&
                  bj.collisionResponse &&
                  si.collisionResponse &&
                  sj.collisionResponse;
                const cm = this.currentContactMaterial;
                c.restitution = cm.restitution;
                c.setSpookParams(
                  cm.contactEquationStiffness,
                  cm.contactEquationRelaxation,
                  this.world.dt
                );
                const matA = si.material || bi.material;
                const matB = sj.material || bj.material;

                if (
                  matA &&
                  matB &&
                  matA.restitution >= 0 &&
                  matB.restitution >= 0
                ) {
                  c.restitution = matA.restitution * matB.restitution;
                }

                c.si = overrideShapeA || si;
                c.sj = overrideShapeB || sj;
                return c;
              }

              createFrictionEquationsFromContact(contactEquation, outArray) {
                const bodyA = contactEquation.bi;
                const bodyB = contactEquation.bj;
                const shapeA = contactEquation.si;
                const shapeB = contactEquation.sj;
                const world = this.world;
                const cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

                let friction = cm.friction;
                const matA = shapeA.material || bodyA.material;
                const matB = shapeB.material || bodyB.material;

                if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
                  friction = matA.friction * matB.friction;
                }

                if (friction > 0) {
                  // Create 2 tangent equations
                  const mug = friction * world.gravity.length();
                  let reducedMass = bodyA.invMass + bodyB.invMass;

                  if (reducedMass > 0) {
                    reducedMass = 1 / reducedMass;
                  }

                  const pool = this.frictionEquationPool;
                  const c1 = pool.length
                    ? pool.pop()
                    : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
                  const c2 = pool.length
                    ? pool.pop()
                    : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
                  c1.bi = c2.bi = bodyA;
                  c1.bj = c2.bj = bodyB;
                  c1.minForce = c2.minForce = -mug * reducedMass;
                  c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

                  c1.ri.copy(contactEquation.ri);
                  c1.rj.copy(contactEquation.rj);
                  c2.ri.copy(contactEquation.ri);
                  c2.rj.copy(contactEquation.rj); // Construct tangents

                  contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

                  c1.setSpookParams(
                    cm.frictionEquationStiffness,
                    cm.frictionEquationRelaxation,
                    world.dt
                  );
                  c2.setSpookParams(
                    cm.frictionEquationStiffness,
                    cm.frictionEquationRelaxation,
                    world.dt
                  );
                  c1.enabled = c2.enabled = contactEquation.enabled;
                  outArray.push(c1, c2);
                  return true;
                }

                return false;
              }
              /**
               * Take the average N latest contact point on the plane.
               */

              createFrictionFromAverage(numContacts) {
                // The last contactEquation
                let c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

                if (
                  !this.createFrictionEquationsFromContact(
                    c,
                    this.frictionResult
                  ) ||
                  numContacts === 1
                ) {
                  return;
                }

                const f1 = this.frictionResult[this.frictionResult.length - 2];
                const f2 = this.frictionResult[this.frictionResult.length - 1];
                averageNormal.setZero();
                averageContactPointA.setZero();
                averageContactPointB.setZero();
                const bodyA = c.bi;
                c.bj;

                for (let i = 0; i !== numContacts; i++) {
                  c = this.result[this.result.length - 1 - i];

                  if (c.bi !== bodyA) {
                    averageNormal.vadd(c.ni, averageNormal);
                    averageContactPointA.vadd(c.ri, averageContactPointA);
                    averageContactPointB.vadd(c.rj, averageContactPointB);
                  } else {
                    averageNormal.vsub(c.ni, averageNormal);
                    averageContactPointA.vadd(c.rj, averageContactPointA);
                    averageContactPointB.vadd(c.ri, averageContactPointB);
                  }
                }

                const invNumContacts = 1 / numContacts;
                averageContactPointA.scale(invNumContacts, f1.ri);
                averageContactPointB.scale(invNumContacts, f1.rj);
                f2.ri.copy(f1.ri); // Should be the same

                f2.rj.copy(f1.rj);
                averageNormal.normalize();
                averageNormal.tangents(f1.t, f2.t); // return eq;
              }
              /**
               * Generate all contacts between a list of body pairs
               * @param p1 Array of body indices
               * @param p2 Array of body indices
               * @param result Array to store generated contacts
               * @param oldcontacts Optional. Array of reusable contact objects
               */

              getContacts(
                p1,
                p2,
                world,
                result,
                oldcontacts,
                frictionResult,
                frictionPool
              ) {
                // Save old contact objects
                this.contactPointPool = oldcontacts;
                this.frictionEquationPool = frictionPool;
                this.result = result;
                this.frictionResult = frictionResult;
                const qi = tmpQuat1;
                const qj = tmpQuat2;
                const xi = tmpVec1;
                const xj = tmpVec2;

                for (let k = 0, N = p1.length; k !== N; k++) {
                  // Get current collision bodies
                  const bi = p1[k];
                  const bj = p2[k]; // Get contact material

                  let bodyContactMaterial = null;

                  if (bi.material && bj.material) {
                    bodyContactMaterial =
                      world.getContactMaterial(bi.material, bj.material) ||
                      null;
                  }

                  const justTest =
                    (bi.type & Body.KINEMATIC && bj.type & Body.STATIC) ||
                    (bi.type & Body.STATIC && bj.type & Body.KINEMATIC) ||
                    (bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC);

                  for (let i = 0; i < bi.shapes.length; i++) {
                    bi.quaternion.mult(bi.shapeOrientations[i], qi);
                    bi.quaternion.vmult(bi.shapeOffsets[i], xi);
                    xi.vadd(bi.position, xi);
                    const si = bi.shapes[i];

                    for (let j = 0; j < bj.shapes.length; j++) {
                      // Compute world transform of shapes
                      bj.quaternion.mult(bj.shapeOrientations[j], qj);
                      bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                      xj.vadd(bj.position, xj);
                      const sj = bj.shapes[j];

                      if (
                        !(
                          si.collisionFilterMask & sj.collisionFilterGroup &&
                          sj.collisionFilterMask & si.collisionFilterGroup
                        )
                      ) {
                        continue;
                      }

                      if (
                        xi.distanceTo(xj) >
                        si.boundingSphereRadius + sj.boundingSphereRadius
                      ) {
                        continue;
                      } // Get collision material

                      let shapeContactMaterial = null;

                      if (si.material && sj.material) {
                        shapeContactMaterial =
                          world.getContactMaterial(si.material, sj.material) ||
                          null;
                      }

                      this.currentContactMaterial =
                        shapeContactMaterial ||
                        bodyContactMaterial ||
                        world.defaultContactMaterial; // Get contacts

                      const resolverIndex = si.type | sj.type;
                      const resolver = this[resolverIndex];

                      if (resolver) {
                        let retval = false; // TO DO: investigate why sphereParticle and convexParticle
                        // resolvers expect si and sj shapes to be in reverse order
                        // (i.e. larger integer value type first instead of smaller first)

                        if (si.type < sj.type) {
                          retval = resolver.call(
                            this,
                            si,
                            sj,
                            xi,
                            xj,
                            qi,
                            qj,
                            bi,
                            bj,
                            si,
                            sj,
                            justTest
                          );
                        } else {
                          retval = resolver.call(
                            this,
                            sj,
                            si,
                            xj,
                            xi,
                            qj,
                            qi,
                            bj,
                            bi,
                            si,
                            sj,
                            justTest
                          );
                        }

                        if (retval && justTest) {
                          // Register overlap
                          world.shapeOverlapKeeper.set(si.id, sj.id);
                          world.bodyOverlapKeeper.set(bi.id, bj.id);
                        }
                      }
                    }
                  }
                }
              }

              sphereSphere(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                if (justTest) {
                  return xi.distanceSquared(xj) < (si.radius + sj.radius) ** 2;
                } // We will have only one contact in this case

                const contactEq = this.createContactEquation(
                  bi,
                  bj,
                  si,
                  sj,
                  rsi,
                  rsj
                ); // Contact normal

                xj.vsub(xi, contactEq.ni);
                contactEq.ni.normalize(); // Contact point locations

                contactEq.ri.copy(contactEq.ni);
                contactEq.rj.copy(contactEq.ni);
                contactEq.ri.scale(si.radius, contactEq.ri);
                contactEq.rj.scale(-sj.radius, contactEq.rj);
                contactEq.ri.vadd(xi, contactEq.ri);
                contactEq.ri.vsub(bi.position, contactEq.ri);
                contactEq.rj.vadd(xj, contactEq.rj);
                contactEq.rj.vsub(bj.position, contactEq.rj);
                this.result.push(contactEq);
                this.createFrictionEquationsFromContact(
                  contactEq,
                  this.frictionResult
                );
              }

              spherePlane(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                // We will have one contact in this case
                const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

                r.ni.set(0, 0, 1);
                qj.vmult(r.ni, r.ni);
                r.ni.negate(r.ni); // body i is the sphere, flip normal

                r.ni.normalize(); // Needed?
                // Vector from sphere center to contact point

                r.ni.scale(si.radius, r.ri); // Project down sphere on plane

                xi.vsub(xj, point_on_plane_to_sphere);
                r.ni.scale(
                  r.ni.dot(point_on_plane_to_sphere),
                  plane_to_sphere_ortho
                );
                point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane

                if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
                  if (justTest) {
                    return true;
                  } // Make it relative to the body

                  const ri = r.ri;
                  const rj = r.rj;
                  ri.vadd(xi, ri);
                  ri.vsub(bi.position, ri);
                  rj.vadd(xj, rj);
                  rj.vsub(bj.position, rj);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  );
                }
              }

              boxBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                si.convexPolyhedronRepresentation.material = si.material;
                sj.convexPolyhedronRepresentation.material = sj.material;
                si.convexPolyhedronRepresentation.collisionResponse =
                  si.collisionResponse;
                sj.convexPolyhedronRepresentation.collisionResponse =
                  sj.collisionResponse;
                return this.convexConvex(
                  si.convexPolyhedronRepresentation,
                  sj.convexPolyhedronRepresentation,
                  xi,
                  xj,
                  qi,
                  qj,
                  bi,
                  bj,
                  si,
                  sj,
                  justTest
                );
              }

              sphereBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                const v3pool = this.v3pool; // we refer to the box as body j

                const sides = sphereBox_sides;
                xi.vsub(xj, box_to_sphere);
                sj.getSideNormals(sides, qj);
                const R = si.radius;

                let found = false; // Store the resulting side penetration info

                const side_ns = sphereBox_side_ns;
                const side_ns1 = sphereBox_side_ns1;
                const side_ns2 = sphereBox_side_ns2;
                let side_h = null;
                let side_penetrations = 0;
                let side_dot1 = 0;
                let side_dot2 = 0;
                let side_distance = null;

                for (
                  let idx = 0, nsides = sides.length;
                  idx !== nsides && found === false;
                  idx++
                ) {
                  // Get the plane side normal (ns)
                  const ns = sphereBox_ns;
                  ns.copy(sides[idx]);
                  const h = ns.length();
                  ns.normalize(); // The normal/distance dot product tells which side of the plane we are

                  const dot = box_to_sphere.dot(ns);

                  if (dot < h + R && dot > 0) {
                    // Intersects plane. Now check the other two dimensions
                    const ns1 = sphereBox_ns1;
                    const ns2 = sphereBox_ns2;
                    ns1.copy(sides[(idx + 1) % 3]);
                    ns2.copy(sides[(idx + 2) % 3]);
                    const h1 = ns1.length();
                    const h2 = ns2.length();
                    ns1.normalize();
                    ns2.normalize();
                    const dot1 = box_to_sphere.dot(ns1);
                    const dot2 = box_to_sphere.dot(ns2);

                    if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
                      const dist = Math.abs(dot - h - R);

                      if (side_distance === null || dist < side_distance) {
                        side_distance = dist;
                        side_dot1 = dot1;
                        side_dot2 = dot2;
                        side_h = h;
                        side_ns.copy(ns);
                        side_ns1.copy(ns1);
                        side_ns2.copy(ns2);
                        side_penetrations++;

                        if (justTest) {
                          return true;
                        }
                      }
                    }
                  }
                }

                if (side_penetrations) {
                  found = true;
                  const r = this.createContactEquation(
                    bi,
                    bj,
                    si,
                    sj,
                    rsi,
                    rsj
                  );
                  side_ns.scale(-R, r.ri); // Sphere r

                  r.ni.copy(side_ns);
                  r.ni.negate(r.ni); // Normal should be out of sphere

                  side_ns.scale(side_h, side_ns);
                  side_ns1.scale(side_dot1, side_ns1);
                  side_ns.vadd(side_ns1, side_ns);
                  side_ns2.scale(side_dot2, side_ns2);
                  side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

                  r.ri.vadd(xi, r.ri);
                  r.ri.vsub(bi.position, r.ri);
                  r.rj.vadd(xj, r.rj);
                  r.rj.vsub(bj.position, r.rj);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  );
                } // Check corners

                let rj = v3pool.get();
                const sphere_to_corner = sphereBox_sphere_to_corner;

                for (let j = 0; j !== 2 && !found; j++) {
                  for (let k = 0; k !== 2 && !found; k++) {
                    for (let l = 0; l !== 2 && !found; l++) {
                      rj.set(0, 0, 0);

                      if (j) {
                        rj.vadd(sides[0], rj);
                      } else {
                        rj.vsub(sides[0], rj);
                      }

                      if (k) {
                        rj.vadd(sides[1], rj);
                      } else {
                        rj.vsub(sides[1], rj);
                      }

                      if (l) {
                        rj.vadd(sides[2], rj);
                      } else {
                        rj.vsub(sides[2], rj);
                      } // World position of corner

                      xj.vadd(rj, sphere_to_corner);
                      sphere_to_corner.vsub(xi, sphere_to_corner);

                      if (sphere_to_corner.lengthSquared() < R * R) {
                        if (justTest) {
                          return true;
                        }

                        found = true;
                        const r = this.createContactEquation(
                          bi,
                          bj,
                          si,
                          sj,
                          rsi,
                          rsj
                        );
                        r.ri.copy(sphere_to_corner);
                        r.ri.normalize();
                        r.ni.copy(r.ri);
                        r.ri.scale(R, r.ri);
                        r.rj.copy(rj); // Make relative to bodies

                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);
                        this.result.push(r);
                        this.createFrictionEquationsFromContact(
                          r,
                          this.frictionResult
                        );
                      }
                    }
                  }
                }

                v3pool.release(rj);
                rj = null; // Check edges

                const edgeTangent = v3pool.get();
                const edgeCenter = v3pool.get();
                const r = v3pool.get(); // r = edge center to sphere center

                const orthogonal = v3pool.get();
                const dist = v3pool.get();
                const Nsides = sides.length;

                for (let j = 0; j !== Nsides && !found; j++) {
                  for (let k = 0; k !== Nsides && !found; k++) {
                    if (j % 3 !== k % 3) {
                      // Get edge tangent
                      sides[k].cross(sides[j], edgeTangent);
                      edgeTangent.normalize();
                      sides[j].vadd(sides[k], edgeCenter);
                      r.copy(xi);
                      r.vsub(edgeCenter, r);
                      r.vsub(xj, r);
                      const orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

                      edgeTangent.scale(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
                      // Find the third side orthogonal to this one

                      let l = 0;

                      while (l === j % 3 || l === k % 3) {
                        l++;
                      } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent

                      dist.copy(xi);
                      dist.vsub(orthogonal, dist);
                      dist.vsub(edgeCenter, dist);
                      dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

                      const tdist = Math.abs(orthonorm);
                      const ndist = dist.length();

                      if (tdist < sides[l].length() && ndist < R) {
                        if (justTest) {
                          return true;
                        }

                        found = true;
                        const res = this.createContactEquation(
                          bi,
                          bj,
                          si,
                          sj,
                          rsi,
                          rsj
                        );
                        edgeCenter.vadd(orthogonal, res.rj); // box rj

                        res.rj.copy(res.rj);
                        dist.negate(res.ni);
                        res.ni.normalize();
                        res.ri.copy(res.rj);
                        res.ri.vadd(xj, res.ri);
                        res.ri.vsub(xi, res.ri);
                        res.ri.normalize();
                        res.ri.scale(R, res.ri); // Make relative to bodies

                        res.ri.vadd(xi, res.ri);
                        res.ri.vsub(bi.position, res.ri);
                        res.rj.vadd(xj, res.rj);
                        res.rj.vsub(bj.position, res.rj);
                        this.result.push(res);
                        this.createFrictionEquationsFromContact(
                          res,
                          this.frictionResult
                        );
                      }
                    }
                  }
                }

                v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
              }

              planeBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                sj.convexPolyhedronRepresentation.material = sj.material;
                sj.convexPolyhedronRepresentation.collisionResponse =
                  sj.collisionResponse;
                sj.convexPolyhedronRepresentation.id = sj.id;
                return this.planeConvex(
                  si,
                  sj.convexPolyhedronRepresentation,
                  xi,
                  xj,
                  qi,
                  qj,
                  bi,
                  bj,
                  si,
                  sj,
                  justTest
                );
              }

              convexConvex(
                si,
                sj,
                xi,
                xj,
                qi,
                qj,
                bi,
                bj,
                rsi,
                rsj,
                justTest,
                faceListA,
                faceListB
              ) {
                const sepAxis = convexConvex_sepAxis;

                if (
                  xi.distanceTo(xj) >
                  si.boundingSphereRadius + sj.boundingSphereRadius
                ) {
                  return;
                }

                if (
                  si.findSeparatingAxis(
                    sj,
                    xi,
                    qi,
                    xj,
                    qj,
                    sepAxis,
                    faceListA,
                    faceListB
                  )
                ) {
                  const res = [];
                  const q = convexConvex_q;
                  si.clipAgainstHull(
                    xi,
                    qi,
                    sj,
                    xj,
                    qj,
                    sepAxis,
                    -100,
                    100,
                    res
                  );
                  let numContacts = 0;

                  for (let j = 0; j !== res.length; j++) {
                    if (justTest) {
                      return true;
                    }

                    const r = this.createContactEquation(
                      bi,
                      bj,
                      si,
                      sj,
                      rsi,
                      rsj
                    );
                    const ri = r.ri;
                    const rj = r.rj;
                    sepAxis.negate(r.ni);
                    res[j].normal.negate(q);
                    q.scale(res[j].depth, q);
                    res[j].point.vadd(q, ri);
                    rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

                    ri.vsub(xi, ri);
                    rj.vsub(xj, rj); // Make relative to bodies

                    ri.vadd(xi, ri);
                    ri.vsub(bi.position, ri);
                    rj.vadd(xj, rj);
                    rj.vsub(bj.position, rj);
                    this.result.push(r);
                    numContacts++;

                    if (!this.enableFrictionReduction) {
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      );
                    }
                  }

                  if (this.enableFrictionReduction && numContacts) {
                    this.createFrictionFromAverage(numContacts);
                  }
                }
              }

              sphereConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                const v3pool = this.v3pool;
                xi.vsub(xj, convex_to_sphere);
                const normals = sj.faceNormals;
                const faces = sj.faces;
                const verts = sj.vertices;
                const R = si.radius;
                //     return;
                // }

                let found = false; // Check corners

                for (let i = 0; i !== verts.length; i++) {
                  const v = verts[i]; // World position of corner

                  const worldCorner = sphereConvex_worldCorner;
                  qj.vmult(v, worldCorner);
                  xj.vadd(worldCorner, worldCorner);
                  const sphere_to_corner = sphereConvex_sphereToCorner;
                  worldCorner.vsub(xi, sphere_to_corner);

                  if (sphere_to_corner.lengthSquared() < R * R) {
                    if (justTest) {
                      return true;
                    }

                    found = true;
                    const r = this.createContactEquation(
                      bi,
                      bj,
                      si,
                      sj,
                      rsi,
                      rsj
                    );
                    r.ri.copy(sphere_to_corner);
                    r.ri.normalize();
                    r.ni.copy(r.ri);
                    r.ri.scale(R, r.ri);
                    worldCorner.vsub(xj, r.rj); // Should be relative to the body.

                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(
                      r,
                      this.frictionResult
                    );
                    return;
                  }
                } // Check side (plane) intersections

                for (
                  let i = 0, nfaces = faces.length;
                  i !== nfaces && found === false;
                  i++
                ) {
                  const normal = normals[i];
                  const face = faces[i]; // Get world-transformed normal of the face

                  const worldNormal = sphereConvex_worldNormal;
                  qj.vmult(normal, worldNormal); // Get a world vertex from the face

                  const worldPoint = sphereConvex_worldPoint;
                  qj.vmult(verts[face[0]], worldPoint);
                  worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

                  const worldSpherePointClosestToPlane =
                    sphereConvex_worldSpherePointClosestToPlane;
                  worldNormal.scale(-R, worldSpherePointClosestToPlane);
                  xi.vadd(
                    worldSpherePointClosestToPlane,
                    worldSpherePointClosestToPlane
                  ); // Vector from a face point to the closest point on the sphere

                  const penetrationVec = sphereConvex_penetrationVec;
                  worldSpherePointClosestToPlane.vsub(
                    worldPoint,
                    penetrationVec
                  ); // The penetration. Negative value means overlap.

                  const penetration = penetrationVec.dot(worldNormal);
                  const worldPointToSphere = sphereConvex_sphereToWorldPoint;
                  xi.vsub(worldPoint, worldPointToSphere);

                  if (
                    penetration < 0 &&
                    worldPointToSphere.dot(worldNormal) > 0
                  ) {
                    // Intersects plane. Now check if the sphere is inside the face polygon
                    const faceVerts = []; // Face vertices, in world coords

                    for (let j = 0, Nverts = face.length; j !== Nverts; j++) {
                      const worldVertex = v3pool.get();
                      qj.vmult(verts[face[j]], worldVertex);
                      xj.vadd(worldVertex, worldVertex);
                      faceVerts.push(worldVertex);
                    }

                    if (pointInPolygon(faceVerts, worldNormal, xi)) {
                      // Is the sphere center in the face polygon?
                      if (justTest) {
                        return true;
                      }

                      found = true;
                      const r = this.createContactEquation(
                        bi,
                        bj,
                        si,
                        sj,
                        rsi,
                        rsj
                      );
                      worldNormal.scale(-R, r.ri); // Contact offset, from sphere center to contact

                      worldNormal.negate(r.ni); // Normal pointing out of sphere

                      const penetrationVec2 = v3pool.get();
                      worldNormal.scale(-penetration, penetrationVec2);
                      const penetrationSpherePoint = v3pool.get();
                      worldNormal.scale(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

                      xi.vsub(xj, r.rj);
                      r.rj.vadd(penetrationSpherePoint, r.rj);
                      r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

                      r.rj.vadd(xj, r.rj);
                      r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

                      r.ri.vadd(xi, r.ri);
                      r.ri.vsub(bi.position, r.ri);
                      v3pool.release(penetrationVec2);
                      v3pool.release(penetrationSpherePoint);
                      this.result.push(r);
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      ); // Release world vertices

                      for (
                        let j = 0, Nfaceverts = faceVerts.length;
                        j !== Nfaceverts;
                        j++
                      ) {
                        v3pool.release(faceVerts[j]);
                      }

                      return; // We only expect *one* face contact
                    } else {
                      // Edge?
                      for (let j = 0; j !== face.length; j++) {
                        // Get two world transformed vertices
                        const v1 = v3pool.get();
                        const v2 = v3pool.get();
                        qj.vmult(verts[face[(j + 1) % face.length]], v1);
                        qj.vmult(verts[face[(j + 2) % face.length]], v2);
                        xj.vadd(v1, v1);
                        xj.vadd(v2, v2); // Construct edge vector

                        const edge = sphereConvex_edge;
                        v2.vsub(v1, edge); // Construct the same vector, but normalized

                        const edgeUnit = sphereConvex_edgeUnit;
                        edge.unit(edgeUnit); // p is xi projected onto the edge

                        const p = v3pool.get();
                        const v1_to_xi = v3pool.get();
                        xi.vsub(v1, v1_to_xi);
                        const dot = v1_to_xi.dot(edgeUnit);
                        edgeUnit.scale(dot, p);
                        p.vadd(v1, p); // Compute a vector from p to the center of the sphere

                        const xi_to_p = v3pool.get();
                        p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
                        // AND if p is in between v1 and v2

                        if (
                          dot > 0 &&
                          dot * dot < edge.lengthSquared() &&
                          xi_to_p.lengthSquared() < R * R
                        ) {
                          // Collision if the edge-sphere distance is less than the radius
                          // Edge contact!
                          if (justTest) {
                            return true;
                          }

                          const r = this.createContactEquation(
                            bi,
                            bj,
                            si,
                            sj,
                            rsi,
                            rsj
                          );
                          p.vsub(xj, r.rj);
                          p.vsub(xi, r.ni);
                          r.ni.normalize();
                          r.ni.scale(R, r.ri); // Should be relative to the body.

                          r.rj.vadd(xj, r.rj);
                          r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

                          r.ri.vadd(xi, r.ri);
                          r.ri.vsub(bi.position, r.ri);
                          this.result.push(r);
                          this.createFrictionEquationsFromContact(
                            r,
                            this.frictionResult
                          ); // Release world vertices

                          for (
                            let j = 0, Nfaceverts = faceVerts.length;
                            j !== Nfaceverts;
                            j++
                          ) {
                            v3pool.release(faceVerts[j]);
                          }

                          v3pool.release(v1);
                          v3pool.release(v2);
                          v3pool.release(p);
                          v3pool.release(xi_to_p);
                          v3pool.release(v1_to_xi);
                          return;
                        }

                        v3pool.release(v1);
                        v3pool.release(v2);
                        v3pool.release(p);
                        v3pool.release(xi_to_p);
                        v3pool.release(v1_to_xi);
                      }
                    } // Release world vertices

                    for (
                      let j = 0, Nfaceverts = faceVerts.length;
                      j !== Nfaceverts;
                      j++
                    ) {
                      v3pool.release(faceVerts[j]);
                    }
                  }
                }
              }

              planeConvex(
                planeShape,
                convexShape,
                planePosition,
                convexPosition,
                planeQuat,
                convexQuat,
                planeBody,
                convexBody,
                si,
                sj,
                justTest
              ) {
                // Simply return the points behind the plane.
                const worldVertex = planeConvex_v;
                const worldNormal = planeConvex_normal;
                worldNormal.set(0, 0, 1);
                planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

                let numContacts = 0;
                const relpos = planeConvex_relpos;

                for (let i = 0; i !== convexShape.vertices.length; i++) {
                  // Get world convex vertex
                  worldVertex.copy(convexShape.vertices[i]);
                  convexQuat.vmult(worldVertex, worldVertex);
                  convexPosition.vadd(worldVertex, worldVertex);
                  worldVertex.vsub(planePosition, relpos);
                  const dot = worldNormal.dot(relpos);

                  if (dot <= 0.0) {
                    if (justTest) {
                      return true;
                    }

                    const r = this.createContactEquation(
                      planeBody,
                      convexBody,
                      planeShape,
                      convexShape,
                      si,
                      sj
                    ); // Get vertex position projected on plane

                    const projected = planeConvex_projected;
                    worldNormal.scale(worldNormal.dot(relpos), projected);
                    worldVertex.vsub(projected, projected);
                    projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

                    r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
                    // rj is now just the vector from the convex center to the vertex

                    worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

                    r.ri.vadd(planePosition, r.ri);
                    r.ri.vsub(planeBody.position, r.ri);
                    r.rj.vadd(convexPosition, r.rj);
                    r.rj.vsub(convexBody.position, r.rj);
                    this.result.push(r);
                    numContacts++;

                    if (!this.enableFrictionReduction) {
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      );
                    }
                  }
                }

                if (this.enableFrictionReduction && numContacts) {
                  this.createFrictionFromAverage(numContacts);
                }
              }

              boxConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                si.convexPolyhedronRepresentation.material = si.material;
                si.convexPolyhedronRepresentation.collisionResponse =
                  si.collisionResponse;
                return this.convexConvex(
                  si.convexPolyhedronRepresentation,
                  sj,
                  xi,
                  xj,
                  qi,
                  qj,
                  bi,
                  bj,
                  si,
                  sj,
                  justTest
                );
              }

              sphereHeightfield(
                sphereShape,
                hfShape,
                spherePos,
                hfPos,
                sphereQuat,
                hfQuat,
                sphereBody,
                hfBody,
                rsi,
                rsj,
                justTest
              ) {
                const data = hfShape.data;
                const radius = sphereShape.radius;
                const w = hfShape.elementSize;
                const worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

                const localSpherePos = sphereHeightfield_tmp1;
                Transform.pointToLocalFrame(
                  hfPos,
                  hfQuat,
                  spherePos,
                  localSpherePos
                ); // Get the index of the data points to test against

                let iMinX = Math.floor((localSpherePos.x - radius) / w) - 1;
                let iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1;
                let iMinY = Math.floor((localSpherePos.y - radius) / w) - 1;
                let iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

                if (
                  iMaxX < 0 ||
                  iMaxY < 0 ||
                  iMinX > data.length ||
                  iMinY > data[0].length
                ) {
                  return;
                } // Clamp index to edges

                if (iMinX < 0) {
                  iMinX = 0;
                }

                if (iMaxX < 0) {
                  iMaxX = 0;
                }

                if (iMinY < 0) {
                  iMinY = 0;
                }

                if (iMaxY < 0) {
                  iMaxY = 0;
                }

                if (iMinX >= data.length) {
                  iMinX = data.length - 1;
                }

                if (iMaxX >= data.length) {
                  iMaxX = data.length - 1;
                }

                if (iMaxY >= data[0].length) {
                  iMaxY = data[0].length - 1;
                }

                if (iMinY >= data[0].length) {
                  iMinY = data[0].length - 1;
                }

                const minMax = [];
                hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                const min = minMax[0];
                const max = minMax[1]; // Bail out if we can't touch the bounding height box

                if (
                  localSpherePos.z - radius > max ||
                  localSpherePos.z + radius < min
                ) {
                  return;
                }

                const result = this.result;

                for (let i = iMinX; i < iMaxX; i++) {
                  for (let j = iMinY; j < iMaxY; j++) {
                    const numContactsBefore = result.length;
                    let intersecting = false; // Lower triangle

                    hfShape.getConvexTrianglePillar(i, j, false);
                    Transform.pointToWorldFrame(
                      hfPos,
                      hfQuat,
                      hfShape.pillarOffset,
                      worldPillarOffset
                    );

                    if (
                      spherePos.distanceTo(worldPillarOffset) <
                      hfShape.pillarConvex.boundingSphereRadius +
                        sphereShape.boundingSphereRadius
                    ) {
                      intersecting = this.sphereConvex(
                        sphereShape,
                        hfShape.pillarConvex,
                        spherePos,
                        worldPillarOffset,
                        sphereQuat,
                        hfQuat,
                        sphereBody,
                        hfBody,
                        sphereShape,
                        hfShape,
                        justTest
                      );
                    }

                    if (justTest && intersecting) {
                      return true;
                    } // Upper triangle

                    hfShape.getConvexTrianglePillar(i, j, true);
                    Transform.pointToWorldFrame(
                      hfPos,
                      hfQuat,
                      hfShape.pillarOffset,
                      worldPillarOffset
                    );

                    if (
                      spherePos.distanceTo(worldPillarOffset) <
                      hfShape.pillarConvex.boundingSphereRadius +
                        sphereShape.boundingSphereRadius
                    ) {
                      intersecting = this.sphereConvex(
                        sphereShape,
                        hfShape.pillarConvex,
                        spherePos,
                        worldPillarOffset,
                        sphereQuat,
                        hfQuat,
                        sphereBody,
                        hfBody,
                        sphereShape,
                        hfShape,
                        justTest
                      );
                    }

                    if (justTest && intersecting) {
                      return true;
                    }

                    const numContacts = result.length - numContactsBefore;

                    if (numContacts > 2) {
                      return;
                    }
                    /*
          // Skip all but 1
          for (let k = 0; k < numContacts - 1; k++) {
              result.pop();
          }
        */
                  }
                }
              }

              boxHeightfield(
                si,
                sj,
                xi,
                xj,
                qi,
                qj,
                bi,
                bj,
                rsi,
                rsj,
                justTest
              ) {
                si.convexPolyhedronRepresentation.material = si.material;
                si.convexPolyhedronRepresentation.collisionResponse =
                  si.collisionResponse;
                return this.convexHeightfield(
                  si.convexPolyhedronRepresentation,
                  sj,
                  xi,
                  xj,
                  qi,
                  qj,
                  bi,
                  bj,
                  si,
                  sj,
                  justTest
                );
              }

              convexHeightfield(
                convexShape,
                hfShape,
                convexPos,
                hfPos,
                convexQuat,
                hfQuat,
                convexBody,
                hfBody,
                rsi,
                rsj,
                justTest
              ) {
                const data = hfShape.data;
                const w = hfShape.elementSize;
                const radius = convexShape.boundingSphereRadius;
                const worldPillarOffset = convexHeightfield_tmp2;
                const faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

                const localConvexPos = convexHeightfield_tmp1;
                Transform.pointToLocalFrame(
                  hfPos,
                  hfQuat,
                  convexPos,
                  localConvexPos
                ); // Get the index of the data points to test against

                let iMinX = Math.floor((localConvexPos.x - radius) / w) - 1;
                let iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1;
                let iMinY = Math.floor((localConvexPos.y - radius) / w) - 1;
                let iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

                if (
                  iMaxX < 0 ||
                  iMaxY < 0 ||
                  iMinX > data.length ||
                  iMinY > data[0].length
                ) {
                  return;
                } // Clamp index to edges

                if (iMinX < 0) {
                  iMinX = 0;
                }

                if (iMaxX < 0) {
                  iMaxX = 0;
                }

                if (iMinY < 0) {
                  iMinY = 0;
                }

                if (iMaxY < 0) {
                  iMaxY = 0;
                }

                if (iMinX >= data.length) {
                  iMinX = data.length - 1;
                }

                if (iMaxX >= data.length) {
                  iMaxX = data.length - 1;
                }

                if (iMaxY >= data[0].length) {
                  iMaxY = data[0].length - 1;
                }

                if (iMinY >= data[0].length) {
                  iMinY = data[0].length - 1;
                }

                const minMax = [];
                hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                const min = minMax[0];
                const max = minMax[1]; // Bail out if we're cant touch the bounding height box

                if (
                  localConvexPos.z - radius > max ||
                  localConvexPos.z + radius < min
                ) {
                  return;
                }

                for (let i = iMinX; i < iMaxX; i++) {
                  for (let j = iMinY; j < iMaxY; j++) {
                    let intersecting = false; // Lower triangle

                    hfShape.getConvexTrianglePillar(i, j, false);
                    Transform.pointToWorldFrame(
                      hfPos,
                      hfQuat,
                      hfShape.pillarOffset,
                      worldPillarOffset
                    );

                    if (
                      convexPos.distanceTo(worldPillarOffset) <
                      hfShape.pillarConvex.boundingSphereRadius +
                        convexShape.boundingSphereRadius
                    ) {
                      intersecting = this.convexConvex(
                        convexShape,
                        hfShape.pillarConvex,
                        convexPos,
                        worldPillarOffset,
                        convexQuat,
                        hfQuat,
                        convexBody,
                        hfBody,
                        null,
                        null,
                        justTest,
                        faceList,
                        null
                      );
                    }

                    if (justTest && intersecting) {
                      return true;
                    } // Upper triangle

                    hfShape.getConvexTrianglePillar(i, j, true);
                    Transform.pointToWorldFrame(
                      hfPos,
                      hfQuat,
                      hfShape.pillarOffset,
                      worldPillarOffset
                    );

                    if (
                      convexPos.distanceTo(worldPillarOffset) <
                      hfShape.pillarConvex.boundingSphereRadius +
                        convexShape.boundingSphereRadius
                    ) {
                      intersecting = this.convexConvex(
                        convexShape,
                        hfShape.pillarConvex,
                        convexPos,
                        worldPillarOffset,
                        convexQuat,
                        hfQuat,
                        convexBody,
                        hfBody,
                        null,
                        null,
                        justTest,
                        faceList,
                        null
                      );
                    }

                    if (justTest && intersecting) {
                      return true;
                    }
                  }
                }
              }

              sphereParticle(
                sj,
                si,
                xj,
                xi,
                qj,
                qi,
                bj,
                bi,
                rsi,
                rsj,
                justTest
              ) {
                // The normal is the unit vector from sphere center to particle center
                const normal = particleSphere_normal;
                normal.set(0, 0, 1);
                xi.vsub(xj, normal);
                const lengthSquared = normal.lengthSquared();

                if (lengthSquared <= sj.radius * sj.radius) {
                  if (justTest) {
                    return true;
                  }

                  const r = this.createContactEquation(
                    bi,
                    bj,
                    si,
                    sj,
                    rsi,
                    rsj
                  );
                  normal.normalize();
                  r.rj.copy(normal);
                  r.rj.scale(sj.radius, r.rj);
                  r.ni.copy(normal); // Contact normal

                  r.ni.negate(r.ni);
                  r.ri.set(0, 0, 0); // Center of particle

                  this.result.push(r);
                  this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  );
                }
              }

              planeParticle(
                sj,
                si,
                xj,
                xi,
                qj,
                qi,
                bj,
                bi,
                rsi,
                rsj,
                justTest
              ) {
                const normal = particlePlane_normal;
                normal.set(0, 0, 1);
                bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

                const relpos = particlePlane_relpos;
                xi.vsub(bj.position, relpos);
                const dot = normal.dot(relpos);

                if (dot <= 0.0) {
                  if (justTest) {
                    return true;
                  }

                  const r = this.createContactEquation(
                    bi,
                    bj,
                    si,
                    sj,
                    rsi,
                    rsj
                  );
                  r.ni.copy(normal); // Contact normal is the plane normal

                  r.ni.negate(r.ni);
                  r.ri.set(0, 0, 0); // Center of particle
                  // Get particle position projected on plane

                  const projected = particlePlane_projected;
                  normal.scale(normal.dot(xi), projected);
                  xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
                  // rj is now the projected world position minus plane position

                  r.rj.copy(projected);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(
                    r,
                    this.frictionResult
                  );
                }
              }

              boxParticle(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
                si.convexPolyhedronRepresentation.material = si.material;
                si.convexPolyhedronRepresentation.collisionResponse =
                  si.collisionResponse;
                return this.convexParticle(
                  si.convexPolyhedronRepresentation,
                  sj,
                  xi,
                  xj,
                  qi,
                  qj,
                  bi,
                  bj,
                  si,
                  sj,
                  justTest
                );
              }

              convexParticle(
                sj,
                si,
                xj,
                xi,
                qj,
                qi,
                bj,
                bi,
                rsi,
                rsj,
                justTest
              ) {
                let penetratedFaceIndex = -1;
                const penetratedFaceNormal =
                  convexParticle_penetratedFaceNormal;
                const worldPenetrationVec = convexParticle_worldPenetrationVec;
                let minPenetration = null;

                const local = convexParticle_local;
                local.copy(xi);
                local.vsub(xj, local); // Convert position to relative the convex origin

                qj.conjugate(cqj);
                cqj.vmult(local, local);

                if (sj.pointIsInside(local)) {
                  if (sj.worldVerticesNeedsUpdate) {
                    sj.computeWorldVertices(xj, qj);
                  }

                  if (sj.worldFaceNormalsNeedsUpdate) {
                    sj.computeWorldFaceNormals(qj);
                  } // For each world polygon in the polyhedra

                  for (let i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
                    // Construct world face vertices
                    const verts = [sj.worldVertices[sj.faces[i][0]]];
                    const normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

                    xi.vsub(verts[0], convexParticle_vertexToParticle);
                    const penetration = -normal.dot(
                      convexParticle_vertexToParticle
                    );

                    if (
                      minPenetration === null ||
                      Math.abs(penetration) < Math.abs(minPenetration)
                    ) {
                      if (justTest) {
                        return true;
                      }

                      minPenetration = penetration;
                      penetratedFaceIndex = i;
                      penetratedFaceNormal.copy(normal);
                    }
                  }

                  if (penetratedFaceIndex !== -1) {
                    // Setup contact
                    const r = this.createContactEquation(
                      bi,
                      bj,
                      si,
                      sj,
                      rsi,
                      rsj
                    );
                    penetratedFaceNormal.scale(
                      minPenetration,
                      worldPenetrationVec
                    ); // rj is the particle position projected to the face

                    worldPenetrationVec.vadd(xi, worldPenetrationVec);
                    worldPenetrationVec.vsub(xj, worldPenetrationVec);
                    r.rj.copy(worldPenetrationVec); //const projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
                    //projectedToFace.copy(r.rj);
                    //qj.vmult(r.rj,r.rj);

                    penetratedFaceNormal.negate(r.ni); // Contact normal

                    r.ri.set(0, 0, 0); // Center of particle

                    const ri = r.ri;
                    const rj = r.rj; // Make relative to bodies

                    ri.vadd(xi, ri);
                    ri.vsub(bi.position, ri);
                    rj.vadd(xj, rj);
                    rj.vsub(bj.position, rj);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(
                      r,
                      this.frictionResult
                    );
                  } else {
                    console.warn(
                      "Point found inside convex, but did not find penetrating face!"
                    );
                  }
                }
              }

              heightfieldCylinder(
                hfShape,
                convexShape,
                hfPos,
                convexPos,
                hfQuat,
                convexQuat,
                hfBody,
                convexBody,
                rsi,
                rsj,
                justTest
              ) {
                return this.convexHeightfield(
                  convexShape,
                  hfShape,
                  convexPos,
                  hfPos,
                  convexQuat,
                  hfQuat,
                  convexBody,
                  hfBody,
                  rsi,
                  rsj,
                  justTest
                );
              }

              particleCylinder(
                si,
                sj,
                xi,
                xj,
                qi,
                qj,
                bi,
                bj,
                rsi,
                rsj,
                justTest
              ) {
                return this.convexParticle(
                  sj,
                  si,
                  xj,
                  xi,
                  qj,
                  qi,
                  bj,
                  bi,
                  rsi,
                  rsj,
                  justTest
                );
              }

              sphereTrimesh(
                sphereShape,
                trimeshShape,
                spherePos,
                trimeshPos,
                sphereQuat,
                trimeshQuat,
                sphereBody,
                trimeshBody,
                rsi,
                rsj,
                justTest
              ) {
                const edgeVertexA = sphereTrimesh_edgeVertexA;
                const edgeVertexB = sphereTrimesh_edgeVertexB;
                const edgeVector = sphereTrimesh_edgeVector;
                const edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
                const localSpherePos = sphereTrimesh_localSpherePos;
                const tmp = sphereTrimesh_tmp;
                const localSphereAABB = sphereTrimesh_localSphereAABB;
                const v2 = sphereTrimesh_v2;
                const relpos = sphereTrimesh_relpos;
                const triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

                Transform.pointToLocalFrame(
                  trimeshPos,
                  trimeshQuat,
                  spherePos,
                  localSpherePos
                ); // Get the aabb of the sphere locally in the trimesh

                const sphereRadius = sphereShape.radius;
                localSphereAABB.lowerBound.set(
                  localSpherePos.x - sphereRadius,
                  localSpherePos.y - sphereRadius,
                  localSpherePos.z - sphereRadius
                );
                localSphereAABB.upperBound.set(
                  localSpherePos.x + sphereRadius,
                  localSpherePos.y + sphereRadius,
                  localSpherePos.z + sphereRadius
                );
                trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (let i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
                // Vertices

                const v = sphereTrimesh_v;
                const radiusSquared = sphereShape.radius * sphereShape.radius;

                for (let i = 0; i < triangles.length; i++) {
                  for (let j = 0; j < 3; j++) {
                    trimeshShape.getVertex(
                      trimeshShape.indices[triangles[i] * 3 + j],
                      v
                    ); // Check vertex overlap in sphere

                    v.vsub(localSpherePos, relpos);

                    if (relpos.lengthSquared() <= radiusSquared) {
                      // Safe up
                      v2.copy(v);
                      Transform.pointToWorldFrame(
                        trimeshPos,
                        trimeshQuat,
                        v2,
                        v
                      );
                      v.vsub(spherePos, relpos);

                      if (justTest) {
                        return true;
                      }

                      let r = this.createContactEquation(
                        sphereBody,
                        trimeshBody,
                        sphereShape,
                        trimeshShape,
                        rsi,
                        rsj
                      );
                      r.ni.copy(relpos);
                      r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

                      r.ri.copy(r.ni);
                      r.ri.scale(sphereShape.radius, r.ri);
                      r.ri.vadd(spherePos, r.ri);
                      r.ri.vsub(sphereBody.position, r.ri);
                      r.rj.copy(v);
                      r.rj.vsub(trimeshBody.position, r.rj); // Store result

                      this.result.push(r);
                      this.createFrictionEquationsFromContact(
                        r,
                        this.frictionResult
                      );
                    }
                  }
                } // Check all edges

                for (let i = 0; i < triangles.length; i++) {
                  for (let j = 0; j < 3; j++) {
                    trimeshShape.getVertex(
                      trimeshShape.indices[triangles[i] * 3 + j],
                      edgeVertexA
                    );
                    trimeshShape.getVertex(
                      trimeshShape.indices[triangles[i] * 3 + ((j + 1) % 3)],
                      edgeVertexB
                    );
                    edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

                    localSpherePos.vsub(edgeVertexB, tmp);
                    const positionAlongEdgeB = tmp.dot(edgeVector);
                    localSpherePos.vsub(edgeVertexA, tmp);
                    let positionAlongEdgeA = tmp.dot(edgeVector);

                    if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
                      // Now check the orthogonal distance from edge to sphere center
                      localSpherePos.vsub(edgeVertexA, tmp);
                      edgeVectorUnit.copy(edgeVector);
                      edgeVectorUnit.normalize();
                      positionAlongEdgeA = tmp.dot(edgeVectorUnit);
                      edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                      tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

                      const dist = tmp.distanceTo(localSpherePos);

                      if (dist < sphereShape.radius) {
                        if (justTest) {
                          return true;
                        }

                        const r = this.createContactEquation(
                          sphereBody,
                          trimeshBody,
                          sphereShape,
                          trimeshShape,
                          rsi,
                          rsj
                        );
                        tmp.vsub(localSpherePos, r.ni);
                        r.ni.normalize();
                        r.ni.scale(sphereShape.radius, r.ri);
                        r.ri.vadd(spherePos, r.ri);
                        r.ri.vsub(sphereBody.position, r.ri);
                        Transform.pointToWorldFrame(
                          trimeshPos,
                          trimeshQuat,
                          tmp,
                          tmp
                        );
                        tmp.vsub(trimeshBody.position, r.rj);
                        Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                        Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                        this.result.push(r);
                        this.createFrictionEquationsFromContact(
                          r,
                          this.frictionResult
                        );
                      }
                    }
                  }
                } // Triangle faces

                const va = sphereTrimesh_va;
                const vb = sphereTrimesh_vb;
                const vc = sphereTrimesh_vc;
                const normal = sphereTrimesh_normal;

                for (let i = 0, N = triangles.length; i !== N; i++) {
                  trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
                  trimeshShape.getNormal(triangles[i], normal);
                  localSpherePos.vsub(va, tmp);
                  let dist = tmp.dot(normal);
                  normal.scale(dist, tmp);
                  localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

                  dist = tmp.distanceTo(localSpherePos);

                  if (
                    Ray.pointInTriangle(tmp, va, vb, vc) &&
                    dist < sphereShape.radius
                  ) {
                    if (justTest) {
                      return true;
                    }

                    let r = this.createContactEquation(
                      sphereBody,
                      trimeshBody,
                      sphereShape,
                      trimeshShape,
                      rsi,
                      rsj
                    );
                    tmp.vsub(localSpherePos, r.ni);
                    r.ni.normalize();
                    r.ni.scale(sphereShape.radius, r.ri);
                    r.ri.vadd(spherePos, r.ri);
                    r.ri.vsub(sphereBody.position, r.ri);
                    Transform.pointToWorldFrame(
                      trimeshPos,
                      trimeshQuat,
                      tmp,
                      tmp
                    );
                    tmp.vsub(trimeshBody.position, r.rj);
                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(
                      r,
                      this.frictionResult
                    );
                  }
                }

                triangles.length = 0;
              }

              planeTrimesh(
                planeShape,
                trimeshShape,
                planePos,
                trimeshPos,
                planeQuat,
                trimeshQuat,
                planeBody,
                trimeshBody,
                rsi,
                rsj,
                justTest
              ) {
                // Make contacts!
                const v = new Vec3();
                const normal = planeTrimesh_normal;
                normal.set(0, 0, 1);
                planeQuat.vmult(normal, normal); // Turn normal according to plane

                for (let i = 0; i < trimeshShape.vertices.length / 3; i++) {
                  // Get world vertex from trimesh
                  trimeshShape.getVertex(i, v); // Safe up

                  const v2 = new Vec3();
                  v2.copy(v);
                  Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

                  const relpos = planeTrimesh_relpos;
                  v.vsub(planePos, relpos);
                  const dot = normal.dot(relpos);

                  if (dot <= 0.0) {
                    if (justTest) {
                      return true;
                    }

                    const r = this.createContactEquation(
                      planeBody,
                      trimeshBody,
                      planeShape,
                      trimeshShape,
                      rsi,
                      rsj
                    );
                    r.ni.copy(normal); // Contact normal is the plane normal
                    // Get vertex position projected on plane

                    const projected = planeTrimesh_projected;
                    normal.scale(relpos.dot(normal), projected);
                    v.vsub(projected, projected); // ri is the projected world position minus plane position

                    r.ri.copy(projected);
                    r.ri.vsub(planeBody.position, r.ri);
                    r.rj.copy(v);
                    r.rj.vsub(trimeshBody.position, r.rj); // Store result

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(
                      r,
                      this.frictionResult
                    );
                  }
                }
              } // convexTrimesh(
              //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
              //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
              //   faceListA?: number[] | null, faceListB?: number[] | null,
              // ) {
              //   const sepAxis = convexConvex_sepAxis;
              //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
              //       return;
              //   }
              //   // Construct a temp hull for each triangle
              //   const hullB = new ConvexPolyhedron();
              //   hullB.faces = [[0,1,2]];
              //   const va = new Vec3();
              //   const vb = new Vec3();
              //   const vc = new Vec3();
              //   hullB.vertices = [
              //       va,
              //       vb,
              //       vc
              //   ];
              //   for (let i = 0; i < sj.indices.length / 3; i++) {
              //       const triangleNormal = new Vec3();
              //       sj.getNormal(i, triangleNormal);
              //       hullB.faceNormals = [triangleNormal];
              //       sj.getTriangleVertices(i, va, vb, vc);
              //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
              //       if(!d){
              //           triangleNormal.scale(-1, triangleNormal);
              //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
              //           if(!d){
              //               continue;
              //           }
              //       }
              //       const res: ConvexPolyhedronContactPoint[] = [];
              //       const q = convexConvex_q;
              //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
              //       for(let j = 0; j !== res.length; j++){
              //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
              //               ri = r.ri,
              //               rj = r.rj;
              //           r.ni.copy(triangleNormal);
              //           r.ni.negate(r.ni);
              //           res[j].normal.negate(q);
              //           q.mult(res[j].depth, q);
              //           res[j].point.vadd(q, ri);
              //           rj.copy(res[j].point);
              //           // Contact points are in world coordinates. Transform back to relative
              //           ri.vsub(xi,ri);
              //           rj.vsub(xj,rj);
              //           // Make relative to bodies
              //           ri.vadd(xi, ri);
              //           ri.vsub(bi.position, ri);
              //           rj.vadd(xj, rj);
              //           rj.vsub(bj.position, rj);
              //           result.push(r);
              //       }
              //   }
              // }
            }
            const averageNormal = new Vec3();
            const averageContactPointA = new Vec3();
            const averageContactPointB = new Vec3();
            const tmpVec1 = new Vec3();
            const tmpVec2 = new Vec3();
            const tmpQuat1 = new Quaternion();
            const tmpQuat2 = new Quaternion();

            const planeTrimesh_normal = new Vec3();
            const planeTrimesh_relpos = new Vec3();
            const planeTrimesh_projected = new Vec3();
            const sphereTrimesh_normal = new Vec3();
            const sphereTrimesh_relpos = new Vec3();
            const sphereTrimesh_v = new Vec3();
            const sphereTrimesh_v2 = new Vec3();
            const sphereTrimesh_edgeVertexA = new Vec3();
            const sphereTrimesh_edgeVertexB = new Vec3();
            const sphereTrimesh_edgeVector = new Vec3();
            const sphereTrimesh_edgeVectorUnit = new Vec3();
            const sphereTrimesh_localSpherePos = new Vec3();
            const sphereTrimesh_tmp = new Vec3();
            const sphereTrimesh_va = new Vec3();
            const sphereTrimesh_vb = new Vec3();
            const sphereTrimesh_vc = new Vec3();
            const sphereTrimesh_localSphereAABB = new AABB();
            const sphereTrimesh_triangles = [];
            const point_on_plane_to_sphere = new Vec3();
            const plane_to_sphere_ortho = new Vec3(); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html

            const pointInPolygon_edge = new Vec3();
            const pointInPolygon_edge_x_normal = new Vec3();
            const pointInPolygon_vtp = new Vec3();

            function pointInPolygon(verts, normal, p) {
              let positiveResult = null;
              const N = verts.length;

              for (let i = 0; i !== N; i++) {
                const v = verts[i]; // Get edge to the next vertex

                const edge = pointInPolygon_edge;
                verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

                const edge_x_normal = pointInPolygon_edge_x_normal; //const edge_x_normal = new Vec3();

                edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

                const vertex_to_p = pointInPolygon_vtp;
                p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

                const r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

                if (
                  positiveResult === null ||
                  (r > 0 && positiveResult === true) ||
                  (r <= 0 && positiveResult === false)
                ) {
                  if (positiveResult === null) {
                    positiveResult = r > 0;
                  }

                  continue;
                } else {
                  return false; // Encountered some other sign. Exit.
                }
              } // If we got here, all dot products were of the same sign.

              return true;
            }

            const box_to_sphere = new Vec3();
            const sphereBox_ns = new Vec3();
            const sphereBox_ns1 = new Vec3();
            const sphereBox_ns2 = new Vec3();
            const sphereBox_sides = [
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
              new Vec3(),
            ];
            const sphereBox_sphere_to_corner = new Vec3();
            const sphereBox_side_ns = new Vec3();
            const sphereBox_side_ns1 = new Vec3();
            const sphereBox_side_ns2 = new Vec3();
            const convex_to_sphere = new Vec3();
            const sphereConvex_edge = new Vec3();
            const sphereConvex_edgeUnit = new Vec3();
            const sphereConvex_sphereToCorner = new Vec3();
            const sphereConvex_worldCorner = new Vec3();
            const sphereConvex_worldNormal = new Vec3();
            const sphereConvex_worldPoint = new Vec3();
            const sphereConvex_worldSpherePointClosestToPlane = new Vec3();
            const sphereConvex_penetrationVec = new Vec3();
            const sphereConvex_sphereToWorldPoint = new Vec3();
            const planeConvex_v = new Vec3();
            const planeConvex_normal = new Vec3();
            const planeConvex_relpos = new Vec3();
            const planeConvex_projected = new Vec3();
            const convexConvex_sepAxis = new Vec3();
            const convexConvex_q = new Vec3();
            const particlePlane_normal = new Vec3();
            const particlePlane_relpos = new Vec3();
            const particlePlane_projected = new Vec3();
            const particleSphere_normal = new Vec3(); // WIP

            const cqj = new Quaternion();
            const convexParticle_local = new Vec3();
            const convexParticle_penetratedFaceNormal = new Vec3();
            const convexParticle_vertexToParticle = new Vec3();
            const convexParticle_worldPenetrationVec = new Vec3();
            const convexHeightfield_tmp1 = new Vec3();
            const convexHeightfield_tmp2 = new Vec3();
            const convexHeightfield_faceList = [0];
            const sphereHeightfield_tmp1 = new Vec3();
            const sphereHeightfield_tmp2 = new Vec3();

            class OverlapKeeper {
              /**
               * @todo Remove useless constructor
               */
              constructor() {
                this.current = void 0;
                this.previous = void 0;
                this.current = [];
                this.previous = [];
              }
              /**
               * getKey
               */

              getKey(i, j) {
                if (j < i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                return (i << 16) | j;
              }
              /**
               * set
               */

              set(i, j) {
                // Insertion sort. This way the diff will have linear complexity.
                const key = this.getKey(i, j);
                const current = this.current;
                let index = 0;

                while (key > current[index]) {
                  index++;
                }

                if (key === current[index]) {
                  return; // Pair was already added
                }

                for (let j = current.length - 1; j >= index; j--) {
                  current[j + 1] = current[j];
                }

                current[index] = key;
              }
              /**
               * tick
               */

              tick() {
                const tmp = this.current;
                this.current = this.previous;
                this.previous = tmp;
                this.current.length = 0;
              }
              /**
               * getDiff
               */

              getDiff(additions, removals) {
                const a = this.current;
                const b = this.previous;
                const al = a.length;
                const bl = b.length;
                let j = 0;

                for (let i = 0; i < al; i++) {
                  let found = false;
                  const keyA = a[i];

                  while (keyA > b[j]) {
                    j++;
                  }

                  found = keyA === b[j];

                  if (!found) {
                    unpackAndPush(additions, keyA);
                  }
                }

                j = 0;

                for (let i = 0; i < bl; i++) {
                  let found = false;
                  const keyB = b[i];

                  while (keyB > a[j]) {
                    j++;
                  }

                  found = a[j] === keyB;

                  if (!found) {
                    unpackAndPush(removals, keyB);
                  }
                }
              }
            }

            function unpackAndPush(array, key) {
              array.push((key & 0xffff0000) >> 16, key & 0x0000ffff);
            }

            /**
             * TupleDictionary
             */
            class TupleDictionary {
              constructor() {
                this.data = {
                  keys: [],
                };
              }

              /** get */
              get(i, j) {
                if (i > j) {
                  // swap
                  const temp = j;
                  j = i;
                  i = temp;
                }

                return this.data[i + "-" + j];
              }
              /** set */

              set(i, j, value) {
                if (i > j) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                const key = i + "-" + j; // Check if key already exists

                if (!this.get(i, j)) {
                  this.data.keys.push(key);
                }

                this.data[key] = value;
              }
              /** reset */

              reset() {
                const data = this.data;
                const keys = data.keys;

                while (keys.length > 0) {
                  const key = keys.pop();
                  delete data[key];
                }
              }
            }

            /**
             * The physics world
             */
            class World extends EventTarget {
              /**
               * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
               */

              /**
               * Makes bodies go to sleep when they've been inactive.
               * @default false
               */

              /**
               * All the current contacts (instances of ContactEquation) in the world.
               */

              /**
               * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
               * @default 0
               */

              /**
               * Set to true to use fast quaternion normalization. It is often enough accurate to use.
               * If bodies tend to explode, set to false.
               * @default false
               */

              /**
               * The wall-clock time since simulation start.
               */

              /**
               * Number of timesteps taken since start.
               */

              /**
               * Default and last timestep sizes.
               */

              /**
               * The gravity of the world.
               */

              /**
               * The broadphase algorithm to use.
               * @default NaiveBroadphase
               */

              /**
               * All bodies in this world
               */

              /**
               * True if any bodies are not sleeping, false if every body is sleeping.
               */

              /**
               * The solver algorithm to use.
               * @default GSSolver
               */

              /**
               * collisionMatrix
               */

              /**
               * CollisionMatrix from the previous step.
               */

              /**
               * All added materials.
               * @deprecated
               * @todo Remove
               */

              /**
               * All added contactmaterials.
               */

              /**
               * Used to look up a ContactMaterial given two instances of Material.
               */

              /**
               * The default material of the bodies.
               */

              /**
               * This contact material is used if no suitable contactmaterial is found for a contact.
               */

              /**
               * Time accumulator for interpolation.
               * @see https://gafferongames.com/game-physics/fix-your-timestep/
               */

              /**
               * Dispatched after a body has been added to the world.
               */

              /**
               * Dispatched after a body has been removed from the world.
               */
              constructor(options = {}) {
                super();
                this.dt = void 0;
                this.allowSleep = void 0;
                this.contacts = void 0;
                this.frictionEquations = void 0;
                this.quatNormalizeSkip = void 0;
                this.quatNormalizeFast = void 0;
                this.time = void 0;
                this.stepnumber = void 0;
                this.default_dt = void 0;
                this.nextId = void 0;
                this.gravity = void 0;
                this.broadphase = void 0;
                this.bodies = void 0;
                this.hasActiveBodies = void 0;
                this.solver = void 0;
                this.constraints = void 0;
                this.narrowphase = void 0;
                this.collisionMatrix = void 0;
                this.collisionMatrixPrevious = void 0;
                this.bodyOverlapKeeper = void 0;
                this.shapeOverlapKeeper = void 0;
                this.materials = void 0;
                this.contactmaterials = void 0;
                this.contactMaterialTable = void 0;
                this.defaultMaterial = void 0;
                this.defaultContactMaterial = void 0;
                this.doProfiling = void 0;
                this.profile = void 0;
                this.accumulator = void 0;
                this.subsystems = void 0;
                this.addBodyEvent = void 0;
                this.removeBodyEvent = void 0;
                this.idToBodyMap = void 0;
                this.dt = -1;
                this.allowSleep = !!options.allowSleep;
                this.contacts = [];
                this.frictionEquations = [];
                this.quatNormalizeSkip =
                  options.quatNormalizeSkip !== undefined
                    ? options.quatNormalizeSkip
                    : 0;
                this.quatNormalizeFast =
                  options.quatNormalizeFast !== undefined
                    ? options.quatNormalizeFast
                    : false;
                this.time = 0.0;
                this.stepnumber = 0;
                this.default_dt = 1 / 60;
                this.nextId = 0;
                this.gravity = new Vec3();

                if (options.gravity) {
                  this.gravity.copy(options.gravity);
                }

                this.broadphase =
                  options.broadphase !== undefined
                    ? options.broadphase
                    : new NaiveBroadphase();
                this.bodies = [];
                this.hasActiveBodies = false;
                this.solver =
                  options.solver !== undefined
                    ? options.solver
                    : new GSSolver();
                this.constraints = [];
                this.narrowphase = new Narrowphase(this);
                this.collisionMatrix = new ArrayCollisionMatrix();
                this.collisionMatrixPrevious = new ArrayCollisionMatrix();
                this.bodyOverlapKeeper = new OverlapKeeper();
                this.shapeOverlapKeeper = new OverlapKeeper();
                this.materials = [];
                this.contactmaterials = [];
                this.contactMaterialTable = new TupleDictionary();
                this.defaultMaterial = new Material("default");
                this.defaultContactMaterial = new ContactMaterial(
                  this.defaultMaterial,
                  this.defaultMaterial,
                  {
                    friction: 0.3,
                    restitution: 0.0,
                  }
                );
                this.doProfiling = false;
                this.profile = {
                  solve: 0,
                  makeContactConstraints: 0,
                  broadphase: 0,
                  integrate: 0,
                  narrowphase: 0,
                };
                this.accumulator = 0;
                this.subsystems = [];
                this.addBodyEvent = {
                  type: "addBody",
                  body: null,
                };
                this.removeBodyEvent = {
                  type: "removeBody",
                  body: null,
                };
                this.idToBodyMap = {};
                this.broadphase.setWorld(this);
              }
              /**
               * Get the contact material between materials m1 and m2
               * @return The contact material if it was found.
               */

              getContactMaterial(m1, m2) {
                return this.contactMaterialTable.get(m1.id, m2.id);
              }
              /**
               * Get number of objects in the world.
               * @deprecated
               */

              numObjects() {
                return this.bodies.length;
              }
              /**
               * Store old collision state info
               */

              collisionMatrixTick() {
                const temp = this.collisionMatrixPrevious;
                this.collisionMatrixPrevious = this.collisionMatrix;
                this.collisionMatrix = temp;
                this.collisionMatrix.reset();
                this.bodyOverlapKeeper.tick();
                this.shapeOverlapKeeper.tick();
              }
              /**
               * Add a constraint to the simulation.
               */

              addConstraint(c) {
                this.constraints.push(c);
              }
              /**
               * Removes a constraint
               */

              removeConstraint(c) {
                const idx = this.constraints.indexOf(c);

                if (idx !== -1) {
                  this.constraints.splice(idx, 1);
                }
              }
              /**
               * Raycast test
               * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
               */

              rayTest(from, to, result) {
                if (result instanceof RaycastResult) {
                  // Do raycastClosest
                  this.raycastClosest(
                    from,
                    to,
                    {
                      skipBackfaces: true,
                    },
                    result
                  );
                } else {
                  // Do raycastAll
                  this.raycastAll(
                    from,
                    to,
                    {
                      skipBackfaces: true,
                    },
                    result
                  );
                }
              }
              /**
               * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
               * @return True if any body was hit.
               */

              raycastAll(from, to, options = {}, callback) {
                options.mode = Ray.ALL;
                options.from = from;
                options.to = to;
                options.callback = callback;
                return tmpRay.intersectWorld(this, options);
              }
              /**
               * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
               * @return True if any body was hit.
               */

              raycastAny(from, to, options = {}, result) {
                options.mode = Ray.ANY;
                options.from = from;
                options.to = to;
                options.result = result;
                return tmpRay.intersectWorld(this, options);
              }
              /**
               * Ray cast, and return information of the closest hit.
               * @return True if any body was hit.
               */

              raycastClosest(from, to, options = {}, result) {
                options.mode = Ray.CLOSEST;
                options.from = from;
                options.to = to;
                options.result = result;
                return tmpRay.intersectWorld(this, options);
              }
              /**
               * Add a rigid body to the simulation.
               * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
               * @todo Adding an array of bodies should be possible. This would save some loops too
               */

              addBody(body) {
                if (this.bodies.includes(body)) {
                  return;
                }

                body.index = this.bodies.length;
                this.bodies.push(body);
                body.world = this;
                body.initPosition.copy(body.position);
                body.initVelocity.copy(body.velocity);
                body.timeLastSleepy = this.time;

                if (body instanceof Body) {
                  body.initAngularVelocity.copy(body.angularVelocity);
                  body.initQuaternion.copy(body.quaternion);
                }

                this.collisionMatrix.setNumObjects(this.bodies.length);
                this.addBodyEvent.body = body;
                this.idToBodyMap[body.id] = body;
                this.dispatchEvent(this.addBodyEvent);
              }
              /**
               * Remove a rigid body from the simulation.
               */

              removeBody(body) {
                body.world = null;
                const n = this.bodies.length - 1;
                const bodies = this.bodies;
                const idx = bodies.indexOf(body);

                if (idx !== -1) {
                  bodies.splice(idx, 1); // Todo: should use a garbage free method
                  // Recompute index

                  for (let i = 0; i !== bodies.length; i++) {
                    bodies[i].index = i;
                  }

                  this.collisionMatrix.setNumObjects(n);
                  this.removeBodyEvent.body = body;
                  delete this.idToBodyMap[body.id];
                  this.dispatchEvent(this.removeBodyEvent);
                }
              }

              getBodyById(id) {
                return this.idToBodyMap[id];
              }
              /**
               * @todo Make a faster map
               */

              getShapeById(id) {
                const bodies = this.bodies;

                for (let i = 0; i < bodies.length; i++) {
                  const shapes = bodies[i].shapes;

                  for (let j = 0; j < shapes.length; j++) {
                    const shape = shapes[j];

                    if (shape.id === id) {
                      return shape;
                    }
                  }
                }

                return null;
              }
              /**
               * Adds a material to the World.
               * @deprecated
               * @todo Remove
               */

              addMaterial(m) {
                this.materials.push(m);
              }
              /**
               * Adds a contact material to the World
               */

              addContactMaterial(cmat) {
                // Add contact material
                this.contactmaterials.push(cmat); // Add current contact material to the material table

                this.contactMaterialTable.set(
                  cmat.materials[0].id,
                  cmat.materials[1].id,
                  cmat
                );
              }
              /**
               * Step the physics world forward in time.
               *
               * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
               *
               * @param dt The fixed time step size to use.
               * @param timeSinceLastCalled The time elapsed since the function was last called.
               * @param maxSubSteps Maximum number of fixed steps to take per function call.
               * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
               * @example
               *     // fixed timestepping without interpolation
               *     world.step(1 / 60)
               */

              step(dt, timeSinceLastCalled, maxSubSteps = 10) {
                if (timeSinceLastCalled === undefined) {
                  // Fixed, simple stepping
                  this.internalStep(dt); // Increment time

                  this.time += dt;
                } else {
                  this.accumulator += timeSinceLastCalled;
                  const t0 = performance.now();
                  let substeps = 0;

                  while (this.accumulator >= dt && substeps < maxSubSteps) {
                    // Do fixed steps to catch up
                    this.internalStep(dt);
                    this.accumulator -= dt;
                    substeps++;

                    if (performance.now() - t0 > dt * 1000) {
                      // The framerate is not interactive anymore.
                      // We are below the target framerate.
                      // Better bail out.
                      break;
                    }
                  } // Remove the excess accumulator, since we may not
                  // have had enough substeps available to catch up

                  this.accumulator = this.accumulator % dt;
                  const t = this.accumulator / dt;

                  for (let j = 0; j !== this.bodies.length; j++) {
                    const b = this.bodies[j];
                    b.previousPosition.lerp(
                      b.position,
                      t,
                      b.interpolatedPosition
                    );
                    b.previousQuaternion.slerp(
                      b.quaternion,
                      t,
                      b.interpolatedQuaternion
                    );
                    b.previousQuaternion.normalize();
                  }

                  this.time += timeSinceLastCalled;
                }
              }

              internalStep(dt) {
                this.dt = dt;
                const contacts = this.contacts;
                const p1 = World_step_p1;
                const p2 = World_step_p2;
                const N = this.numObjects();
                const bodies = this.bodies;
                const solver = this.solver;
                const gravity = this.gravity;
                const doProfiling = this.doProfiling;
                const profile = this.profile;
                const DYNAMIC = Body.DYNAMIC;
                let profilingStart = -Infinity;
                const constraints = this.constraints;
                const frictionEquationPool = World_step_frictionEquationPool;
                gravity.length();
                const gx = gravity.x;
                const gy = gravity.y;
                const gz = gravity.z;
                let i = 0;

                if (doProfiling) {
                  profilingStart = performance.now();
                } // Add gravity to all objects

                for (i = 0; i !== N; i++) {
                  const bi = bodies[i];

                  if (bi.type === DYNAMIC) {
                    // Only for dynamic bodies
                    const f = bi.force;
                    const m = bi.mass;
                    f.x += m * gx;
                    f.y += m * gy;
                    f.z += m * gz;
                  }
                } // Update subsystems

                for (
                  let i = 0, Nsubsystems = this.subsystems.length;
                  i !== Nsubsystems;
                  i++
                ) {
                  this.subsystems[i].update();
                } // Collision detection

                if (doProfiling) {
                  profilingStart = performance.now();
                }

                p1.length = 0; // Clean up pair arrays from last step

                p2.length = 0;
                this.broadphase.collisionPairs(this, p1, p2);

                if (doProfiling) {
                  profile.broadphase = performance.now() - profilingStart;
                } // Remove constrained pairs with collideConnected == false

                let Nconstraints = constraints.length;

                for (i = 0; i !== Nconstraints; i++) {
                  const c = constraints[i];

                  if (!c.collideConnected) {
                    for (let j = p1.length - 1; j >= 0; j -= 1) {
                      if (
                        (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                        (c.bodyB === p1[j] && c.bodyA === p2[j])
                      ) {
                        p1.splice(j, 1);
                        p2.splice(j, 1);
                      }
                    }
                  }
                }

                this.collisionMatrixTick(); // Generate contacts

                if (doProfiling) {
                  profilingStart = performance.now();
                }

                const oldcontacts = World_step_oldContacts;
                const NoldContacts = contacts.length;

                for (i = 0; i !== NoldContacts; i++) {
                  oldcontacts.push(contacts[i]);
                }

                contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

                const NoldFrictionEquations = this.frictionEquations.length;

                for (i = 0; i !== NoldFrictionEquations; i++) {
                  frictionEquationPool.push(this.frictionEquations[i]);
                }

                this.frictionEquations.length = 0;
                this.narrowphase.getContacts(
                  p1,
                  p2,
                  this,
                  contacts,
                  oldcontacts, // To be reused
                  this.frictionEquations,
                  frictionEquationPool
                );

                if (doProfiling) {
                  profile.narrowphase = performance.now() - profilingStart;
                } // Loop over all collisions

                if (doProfiling) {
                  profilingStart = performance.now();
                } // Add all friction eqs

                for (i = 0; i < this.frictionEquations.length; i++) {
                  solver.addEquation(this.frictionEquations[i]);
                }

                const ncontacts = contacts.length;

                for (let k = 0; k !== ncontacts; k++) {
                  // Current contact
                  const c = contacts[k]; // Get current collision indeces

                  const bi = c.bi;
                  const bj = c.bj;
                  const si = c.si;
                  const sj = c.sj; // Get collision properties

                  let cm;

                  if (bi.material && bj.material) {
                    cm =
                      this.getContactMaterial(bi.material, bj.material) ||
                      this.defaultContactMaterial;
                  } else {
                    cm = this.defaultContactMaterial;
                  } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

                  cm.friction; // c.restitution = cm.restitution;
                  // If friction or restitution were specified in the material, use them

                  if (bi.material && bj.material) {
                    if (
                      bi.material.friction >= 0 &&
                      bj.material.friction >= 0
                    ) {
                      bi.material.friction * bj.material.friction;
                    }

                    if (
                      bi.material.restitution >= 0 &&
                      bj.material.restitution >= 0
                    ) {
                      c.restitution =
                        bi.material.restitution * bj.material.restitution;
                    }
                  } // c.setSpookParams(
                  //           cm.contactEquationStiffness,
                  //           cm.contactEquationRelaxation,
                  //           dt
                  //       );

                  solver.addEquation(c); // // Add friction constraint equation
                  // if(mu > 0){
                  // 	// Create 2 tangent equations
                  // 	const mug = mu * gnorm;
                  // 	const reducedMass = (bi.invMass + bj.invMass);
                  // 	if(reducedMass > 0){
                  // 		reducedMass = 1/reducedMass;
                  // 	}
                  // 	const pool = frictionEquationPool;
                  // 	const c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                  // 	const c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                  // 	this.frictionEquations.push(c1, c2);
                  // 	c1.bi = c2.bi = bi;
                  // 	c1.bj = c2.bj = bj;
                  // 	c1.minForce = c2.minForce = -mug*reducedMass;
                  // 	c1.maxForce = c2.maxForce = mug*reducedMass;
                  // 	// Copy over the relative vectors
                  // 	c1.ri.copy(c.ri);
                  // 	c1.rj.copy(c.rj);
                  // 	c2.ri.copy(c.ri);
                  // 	c2.rj.copy(c.rj);
                  // 	// Construct tangents
                  // 	c.ni.tangents(c1.t, c2.t);
                  //           // Set spook params
                  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                  //           c1.enabled = c2.enabled = c.enabled;
                  // 	// Add equations to solver
                  // 	solver.addEquation(c1);
                  // 	solver.addEquation(c2);
                  // }

                  if (
                    bi.allowSleep &&
                    bi.type === Body.DYNAMIC &&
                    bi.sleepState === Body.SLEEPING &&
                    bj.sleepState === Body.AWAKE &&
                    bj.type !== Body.STATIC
                  ) {
                    const speedSquaredB =
                      bj.velocity.lengthSquared() +
                      bj.angularVelocity.lengthSquared();
                    const speedLimitSquaredB = bj.sleepSpeedLimit ** 2;

                    if (speedSquaredB >= speedLimitSquaredB * 2) {
                      bi.wakeUpAfterNarrowphase = true;
                    }
                  }

                  if (
                    bj.allowSleep &&
                    bj.type === Body.DYNAMIC &&
                    bj.sleepState === Body.SLEEPING &&
                    bi.sleepState === Body.AWAKE &&
                    bi.type !== Body.STATIC
                  ) {
                    const speedSquaredA =
                      bi.velocity.lengthSquared() +
                      bi.angularVelocity.lengthSquared();
                    const speedLimitSquaredA = bi.sleepSpeedLimit ** 2;

                    if (speedSquaredA >= speedLimitSquaredA * 2) {
                      bj.wakeUpAfterNarrowphase = true;
                    }
                  } // Now we know that i and j are in contact. Set collision matrix state

                  this.collisionMatrix.set(bi, bj, true);

                  if (!this.collisionMatrixPrevious.get(bi, bj)) {
                    // First contact!
                    // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
                    World_step_collideEvent.body = bj;
                    World_step_collideEvent.contact = c;
                    bi.dispatchEvent(World_step_collideEvent);
                    World_step_collideEvent.body = bi;
                    bj.dispatchEvent(World_step_collideEvent);
                  }

                  this.bodyOverlapKeeper.set(bi.id, bj.id);
                  this.shapeOverlapKeeper.set(si.id, sj.id);
                }

                this.emitContactEvents();

                if (doProfiling) {
                  profile.makeContactConstraints =
                    performance.now() - profilingStart;
                  profilingStart = performance.now();
                } // Wake up bodies

                for (i = 0; i !== N; i++) {
                  const bi = bodies[i];

                  if (bi.wakeUpAfterNarrowphase) {
                    bi.wakeUp();
                    bi.wakeUpAfterNarrowphase = false;
                  }
                } // Add user-added constraints

                Nconstraints = constraints.length;

                for (i = 0; i !== Nconstraints; i++) {
                  const c = constraints[i];
                  c.update();

                  for (let j = 0, Neq = c.equations.length; j !== Neq; j++) {
                    const eq = c.equations[j];
                    solver.addEquation(eq);
                  }
                } // Solve the constrained system

                solver.solve(dt, this);

                if (doProfiling) {
                  profile.solve = performance.now() - profilingStart;
                } // Remove all contacts from solver

                solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

                const pow = Math.pow;

                for (i = 0; i !== N; i++) {
                  const bi = bodies[i];

                  if (bi.type & DYNAMIC) {
                    // Only for dynamic bodies
                    const ld = pow(1.0 - bi.linearDamping, dt);
                    const v = bi.velocity;
                    v.scale(ld, v);
                    const av = bi.angularVelocity;

                    if (av) {
                      const ad = pow(1.0 - bi.angularDamping, dt);
                      av.scale(ad, av);
                    }
                  }
                }

                this.dispatchEvent(World_step_preStepEvent); // Invoke pre-step callbacks

                for (i = 0; i !== N; i++) {
                  const bi = bodies[i];

                  if (bi.preStep) {
                    bi.preStep.call(bi);
                  }
                } // Leap frog
                // vnew = v + h*f/m
                // xnew = x + h*vnew

                if (doProfiling) {
                  profilingStart = performance.now();
                }

                const stepnumber = this.stepnumber;
                const quatNormalize =
                  stepnumber % (this.quatNormalizeSkip + 1) === 0;
                const quatNormalizeFast = this.quatNormalizeFast;

                for (i = 0; i !== N; i++) {
                  bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
                }

                this.clearForces();
                this.broadphase.dirty = true;

                if (doProfiling) {
                  profile.integrate = performance.now() - profilingStart;
                } // Update step number

                this.stepnumber += 1;
                this.dispatchEvent(World_step_postStepEvent); // Invoke post-step callbacks

                for (i = 0; i !== N; i++) {
                  const bi = bodies[i];
                  const postStep = bi.postStep;

                  if (postStep) {
                    postStep.call(bi);
                  }
                } // Sleeping update

                let hasActiveBodies = true;

                if (this.allowSleep) {
                  hasActiveBodies = false;

                  for (i = 0; i !== N; i++) {
                    const bi = bodies[i];
                    bi.sleepTick(this.time);

                    if (bi.sleepState !== Body.SLEEPING) {
                      hasActiveBodies = true;
                    }
                  }
                }

                this.hasActiveBodies = hasActiveBodies;
              }

              emitContactEvents() {
                const hasBeginContact =
                  this.hasAnyEventListener("beginContact");
                const hasEndContact = this.hasAnyEventListener("endContact");

                if (hasBeginContact || hasEndContact) {
                  this.bodyOverlapKeeper.getDiff(additions, removals);
                }

                if (hasBeginContact) {
                  for (let i = 0, l = additions.length; i < l; i += 2) {
                    beginContactEvent.bodyA = this.getBodyById(additions[i]);
                    beginContactEvent.bodyB = this.getBodyById(
                      additions[i + 1]
                    );
                    this.dispatchEvent(beginContactEvent);
                  }

                  beginContactEvent.bodyA = beginContactEvent.bodyB = null;
                }

                if (hasEndContact) {
                  for (let i = 0, l = removals.length; i < l; i += 2) {
                    endContactEvent.bodyA = this.getBodyById(removals[i]);
                    endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
                    this.dispatchEvent(endContactEvent);
                  }

                  endContactEvent.bodyA = endContactEvent.bodyB = null;
                }

                additions.length = removals.length = 0;
                const hasBeginShapeContact =
                  this.hasAnyEventListener("beginShapeContact");
                const hasEndShapeContact =
                  this.hasAnyEventListener("endShapeContact");

                if (hasBeginShapeContact || hasEndShapeContact) {
                  this.shapeOverlapKeeper.getDiff(additions, removals);
                }

                if (hasBeginShapeContact) {
                  for (let i = 0, l = additions.length; i < l; i += 2) {
                    const shapeA = this.getShapeById(additions[i]);
                    const shapeB = this.getShapeById(additions[i + 1]);
                    beginShapeContactEvent.shapeA = shapeA;
                    beginShapeContactEvent.shapeB = shapeB;
                    if (shapeA) beginShapeContactEvent.bodyA = shapeA.body;
                    if (shapeB) beginShapeContactEvent.bodyB = shapeB.body;
                    this.dispatchEvent(beginShapeContactEvent);
                  }

                  beginShapeContactEvent.bodyA =
                    beginShapeContactEvent.bodyB =
                    beginShapeContactEvent.shapeA =
                    beginShapeContactEvent.shapeB =
                      null;
                }

                if (hasEndShapeContact) {
                  for (let i = 0, l = removals.length; i < l; i += 2) {
                    const shapeA = this.getShapeById(removals[i]);
                    const shapeB = this.getShapeById(removals[i + 1]);
                    endShapeContactEvent.shapeA = shapeA;
                    endShapeContactEvent.shapeB = shapeB;
                    if (shapeA) endShapeContactEvent.bodyA = shapeA.body;
                    if (shapeB) endShapeContactEvent.bodyB = shapeB.body;
                    this.dispatchEvent(endShapeContactEvent);
                  }

                  endShapeContactEvent.bodyA =
                    endShapeContactEvent.bodyB =
                    endShapeContactEvent.shapeA =
                    endShapeContactEvent.shapeB =
                      null;
                }
              }
              /**
               * Sets all body forces in the world to zero.
               */

              clearForces() {
                const bodies = this.bodies;
                const N = bodies.length;

                for (let i = 0; i !== N; i++) {
                  const b = bodies[i];
                  b.force;
                  b.torque;
                  b.force.set(0, 0, 0);
                  b.torque.set(0, 0, 0);
                }
              }
            } // Temp stuff

            new AABB();
            const tmpRay = new Ray(); // performance.now() fallback on Date.now()

            const performance = globalThis.performance || {};

            if (!performance.now) {
              let nowOffset = Date.now();

              if (performance.timing && performance.timing.navigationStart) {
                nowOffset = performance.timing.navigationStart;
              }

              performance.now = () => Date.now() - nowOffset;
            }
            // Reusable event objects to save memory.

            const World_step_postStepEvent = {
              type: "postStep",
            }; // Dispatched before the world steps forward in time.

            const World_step_preStepEvent = {
              type: "preStep",
            };
            const World_step_collideEvent = {
              type: Body.COLLIDE_EVENT_NAME,
              body: null,
              contact: null,
            }; // Pools for unused objects

            const World_step_oldContacts = [];
            const World_step_frictionEquationPool = []; // Reusable arrays for collision pairs

            const World_step_p1 = [];
            const World_step_p2 = []; // Stuff for emitContactEvents

            const additions = [];
            const removals = [];
            const beginContactEvent = {
              type: "beginContact",
              bodyA: null,
              bodyB: null,
            };
            const endContactEvent = {
              type: "endContact",
              bodyA: null,
              bodyB: null,
            };
            const beginShapeContactEvent = {
              type: "beginShapeContact",
              bodyA: null,
              bodyB: null,
              shapeA: null,
              shapeB: null,
            };
            const endShapeContactEvent = {
              type: "endShapeContact",
              bodyA: null,
              bodyB: null,
              shapeA: null,
              shapeB: null,
            };

            /***/
          },

        /***/ "./Assets/Components/Animator.re.ts":
          /*!******************************************!*\
  !*** ./Assets/Components/Animator.re.ts ***!
  \******************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ Animator,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class Animator extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.animations = [];
                this._curAnimations = [];
                this.data = [];
                this._selected = 0;
                this.selectedOptions = this.animations.map((elem, i) =>
                  i.toString()
                );
                this.stopped = false;
                this.stopping = false;
                this.playLabel = "Play";
                this.actions = {};
                this.animationFinishedListeners = [];
                this.animationFinished = /* @__PURE__ */ __name(() => {
                  if (this.stopping) {
                    this.stopped = true;
                    this.stopping = false;
                  }
                  this.animationFinishedListeners.forEach((listener) =>
                    listener()
                  );
                  if (
                    this.activeAction.loop ===
                      three__WEBPACK_IMPORTED_MODULE_1__.LoopOnce &&
                    !this.activeAction.clampWhenFinished
                  ) {
                    this.mix(this.defaultActionName, 1e-3, false);
                  }
                }, "animationFinished");
              }
              animationsHaveChanged() {
                if (this._curAnimations.length !== this.animations.length)
                  return true;
                for (let i = 0; i < this._curAnimations.length; i++) {
                  if (this._curAnimations[i] !== this.animations[i])
                    return true;
                }
                return false;
              }
              updateConfigs() {
                const newConfigs = [];
                for (let i = 0; i < this.animations.length; i++) {
                  if (this.data[i]) {
                    newConfigs[i] = this.data[i];
                    continue;
                  }
                  newConfigs[i] = {
                    actionName: i.toString(),
                    playOnce: false,
                    maxWeight: 1,
                    duration: 1,
                    speed: 1,
                  };
                }
                this._curAnimations = this.animations.slice();
                this.data.splice(0);
                newConfigs.forEach((config) => this.data.push(config));
                this._mixer = this._mixer =
                  new three__WEBPACK_IMPORTED_MODULE_1__.AnimationMixer(
                    this.object3d
                  );
                this.animations.forEach((clip, i) => {
                  const action = this._mixer.clipAction(clip);
                  clip.name = this.data[i].actionName;
                  this.data[i].playOnce &&
                    action.setLoop(
                      three__WEBPACK_IMPORTED_MODULE_1__.LoopOnce,
                      0
                    );
                  this.actions[this.data[i].actionName] = {
                    action,
                    config: this.data[i],
                  };
                });
              }
              get selected() {
                this.selectedOptions.splice(
                  0,
                  this.selectedOptions.length,
                  ...this.animations.map((_, i) => i.toString())
                );
                this.isReady &&
                  this.animationsHaveChanged() &&
                  this.updateConfigs();
                return this._selected;
              }
              set selected(value) {
                this._selected = value;
                this.updateAnimationConfigInputs();
                this.animationsHaveChanged() && this.updateConfigs();
                if (
                  this.playLabel === "Stop" &&
                  !rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.isRunning
                ) {
                  this.playAction();
                }
              }
              updateAnimationConfigInputs() {
                this.data = this.data;
                const activeConfig = this.data[this._selected];
                this.actionName = activeConfig.actionName;
                this.playOnce = activeConfig.playOnce;
                this.duration = activeConfig.duration;
                this.speed = activeConfig.speed;
              }
              get actionName() {
                const activeConfig = this.data[this.selected];
                return activeConfig ? activeConfig.actionName : "";
              }
              set actionName(value) {
                if (this.selected < 0) return;
                const activeConfig = this.data[this.selected];
                if (!activeConfig) return;
                activeConfig.actionName = value;
              }
              get playOnce() {
                const activeConfig = this.data[this.selected];
                return activeConfig ? activeConfig.playOnce : false;
              }
              set playOnce(value) {
                if (this.selected < 0) return;
                const activeConfig = this.data[this.selected];
                if (!activeConfig) return;
                activeConfig.playOnce = value;
              }
              get duration() {
                const activeConfig = this.data[this.selected];
                return activeConfig ? activeConfig.duration : 1;
              }
              set duration(value) {
                if (this.selected < 0) return;
                const activeConfig = this.data[this.selected];
                if (!activeConfig) return;
                activeConfig.duration = value;
              }
              get speed() {
                const activeConfig = this.data[this.selected];
                return activeConfig ? activeConfig.speed : 1;
              }
              set speed(value) {
                if (this.selected < 0) return;
                const activeConfig = this.data[this.selected];
                if (!activeConfig) return;
                activeConfig.speed = Number(value);
              }
              get isActive() {
                return !this.stopped && !this.stopping;
              }
              stop() {
                this.stopping = true;
              }
              resume() {
                this.stopped = false;
                this.stopping = false;
              }
              play() {
                if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.isRunning)
                  return;
                if (this.playLabel === "Play" && !this.editorUpdate) {
                  this.mixer;
                  this.animationsHaveChanged() && this.updateConfigs();
                  this.playAction();
                  this.editorUpdate =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.onUpdate(
                      (sceneController) => {
                        if (
                          sceneController ===
                          rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime
                        )
                          return;
                        this.mixer.update(
                          sceneController.deltaTime * this.speed
                        );
                      }
                    );
                } else if (this.playLabel === "Stop") {
                  this.playLabel = "Play";
                  this.stopAction();
                  this.editorUpdate?.stop();
                  this.editorUpdate = void 0;
                }
              }
              stopAction() {
                this.mixer
                  .existingAction(this.animations[this.selected])
                  ?.reset();
                this.mixer.stopAllAction();
              }
              playAction() {
                this.stopAction();
                const action = this.actions[this.actionName];
                if (!this.actions[this.actionName]) return;
                this.playLabel = "Stop";
                action.action.play();
              }
              get mixer() {
                if (!this._mixer) {
                  this._mixer =
                    new three__WEBPACK_IMPORTED_MODULE_1__.AnimationMixer(
                      this.object3d
                    );
                  this.animations.forEach((clip, i) => {
                    const action = this._mixer.clipAction(clip);
                    clip.name = this.data[i].actionName;
                    this.data[i].playOnce &&
                      action.setLoop(
                        three__WEBPACK_IMPORTED_MODULE_1__.LoopOnce,
                        0
                      );
                    this.actions[this.data[i].actionName] = {
                      action,
                      config: this.data[i],
                    };
                  });
                }
                return this._mixer;
              }
              awake() {
                this.editorUpdate?.stop();
                this.editorUpdate = void 0;
              }
              start() {
                this.mixer
                  .existingAction(this.animations[this.selected])
                  ?.reset();
                this.mixer.stopAllAction();
                const configs = this.data;
                this.animations.forEach((clip, i) => {
                  const clipConfig = configs[i];
                  clipConfig.duration && (clip.duration = clipConfig.duration);
                  const action = this.mixer.existingAction(clip);
                  if (!action) return;
                  action.play();
                  clipConfig.playOnce &&
                    action.setLoop(
                      three__WEBPACK_IMPORTED_MODULE_1__.LoopOnce,
                      0
                    );
                  this.setWeight(action, this.selected === i ? 1 : 0);
                });
                this.mixer.removeEventListener(
                  "finished",
                  this.animationFinished
                );
                this.mixer.addEventListener("finished", this.animationFinished);
                this.activeAction = this.defaultAction;
                this.mix(Object.keys(this.actions)[0]);
              }
              update() {
                if (this.stopped) return;
                this.mixer.update(
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.deltaTime *
                    this.actions[this.activeAction.getClip().name].config.speed
                );
              }
              getAction(index) {
                return this.actions[index].action;
              }
              setWeight(action, weight) {
                action.enabled = true;
                action.time = 0;
                action.setEffectiveTimeScale(1);
                action.setEffectiveWeight(weight);
              }
              getWeight(actionName) {
                return this.getAction(actionName).getEffectiveWeight();
              }
              get defaultAction() {
                return this.getAction(this.defaultActionName);
              }
              get defaultActionName() {
                return Object.keys(this.actions)[0];
              }
              onAnimationFinished(cb) {
                this.animationFinishedListeners.push(cb);
              }
              mix(actionName, transitionTime = 0.1, warp = true, weight = 1) {
                const action = this.getAction(actionName);
                action.reset();
                this.setWeight(action, weight);
                action.crossFadeFrom(this.activeAction, transitionTime, warp);
                this.activeAction = action;
              }
            }
            __name(Animator, "Animator");
            __decorateClass(
              [
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.list.animation(),
              ],
              Animator.prototype,
              "animations",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.data()],
              Animator.prototype,
              "data",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.select()],
              Animator.prototype,
              "selected",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.text()],
              Animator.prototype,
              "actionName",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              Animator.prototype,
              "playOnce",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              Animator.prototype,
              "duration",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              Animator.prototype,
              "speed",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.button()],
              Animator.prototype,
              "play",
              1
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              Animator
            );

            /***/
          },

        /***/ "./Assets/Components/CharacterController.re.ts":
          /*!*****************************************************!*\
  !*** ./Assets/Components/CharacterController.re.ts ***!
  \*****************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CharacterController,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_5__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _Animator_re__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ./Animator.re */ "./Assets/Components/Animator.re.ts"
              );
            /* harmony import */ var _CharacterStatus_re__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! ./CharacterStatus.re */ "./Assets/Components/CharacterStatus.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            const actions = {
              idle: "idle",
              run: "run",
              jump: "jump",
              death: "death",
            };
            class CharacterController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.gamepadIndex = 0;
                this.fwdSpeed = 3;
                this.jumpSpeed = 5;
                this.isGrounded = false;
                this.isJumping = false;
                this.isDead = false;
                this.localFWD =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.appliedDirection =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.rayPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.raycaster =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();
                this.downDirection =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0);
                this.inputAngularVelocity =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_5__.Vec3();
                this.inputVelocity =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_5__.Vec3();
                this.inputDirection =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.isDamaged = false;
              }
              get rigidbody() {
                if (!this._rigidbody) {
                  this._rigidbody =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                      _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__[
                        "default"
                      ],
                      this.object3d
                    );
                }
                return this._rigidbody;
              }
              get animator() {
                if (!this._animator) {
                  this._animator =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                      _Animator_re__WEBPACK_IMPORTED_MODULE_3__["default"],
                      this.object3d
                    );
                }
                return this._animator;
              }
              get characterStatus() {
                if (!this._characterStatus) {
                  this._characterStatus =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                      _CharacterStatus_re__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ],
                      this.object3d
                    );
                }
                return this._characterStatus;
              }
              get curAction() {
                return this.animator.activeAction;
              }
              get gamepad() {
                return rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.gamepads[
                  this.gamepadIndex
                ];
              }
              update() {
                if (!this.rigidbody) return;
                if (!this.animator) return;
                if (!this.isDead && this.characterStatus.isDead) this.setDead();
                if (this.isDead || this.isDamaged) {
                  this.rigidbody.body.velocity.x = 0;
                  this.rigidbody.body.velocity.z = 0;
                  return;
                }
                if (this.characterStatus.isDamaged && !this.isDamaged) {
                  this.setDamaged();
                }
                this.object3d.getWorldDirection(this.localFWD);
                this.groundCheck();
                if (
                  this.curAction &&
                  this.curAction.loop !==
                    three__WEBPACK_IMPORTED_MODULE_1__.LoopRepeat &&
                  this.curAction !== this.getAction(actions.jump)
                )
                  return;
                this.inputVelocity.setZero();
                this.setRotation();
                this.inputVelocity.z = this.inputDirection.length();
                if (
                  this.inputVelocity.z > 0 &&
                  this.animator.getWeight(actions.run) === 0 &&
                  this.isGrounded &&
                  !this.isJumping
                ) {
                  this.animator.mix(actions.run, 0.1);
                }
                if (this.curAction === this.getAction(actions.run)) {
                  this.getAction(actions.run).setEffectiveWeight(
                    this.inputVelocity.z
                  );
                }
                if (
                  this.inputVelocity.z === 0 &&
                  this.animator.getWeight(actions.idle) === 0 &&
                  !this.isJumping
                ) {
                  this.animator.mix(actions.idle, 0.1);
                }
                this.inputVelocity.scale(this.fwdSpeed, this.inputVelocity);
                if (this.isGrounded && this.getJumpInput()) {
                  this.jump();
                }
                this.translate();
              }
              getAction(actionName) {
                return this.animator.getAction(actionName);
              }
              setDead() {
                this.isDead = true;
                this.inputVelocity.setZero();
                this.getAction(actions.death).clampWhenFinished = true;
                this.animator.mix(actions.death, 0.1);
                this.animator.stop();
              }
              setDamaged() {
                this.isDamaged = true;
                this.inputVelocity.setZero();
                this.animator.mix("damaged", 0.1);
                setTimeout(() => {
                  this.isDamaged = false;
                  !this.isDead && this.animator.mix(actions.idle, 0.1);
                }, 300);
              }
              getHorizontal() {
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyA"
                  )
                )
                  return -1;
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyD"
                  )
                )
                  return 1;
                if (this.gamepad && Math.abs(this.gamepad.getAxis(0)) > 0) {
                  return this.gamepad.getAxis(0);
                }
                return 0;
              }
              getVertical() {
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyW"
                  )
                )
                  return -1;
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyS"
                  )
                )
                  return 1;
                if (this.gamepad && Math.abs(this.gamepad.getAxis(1)) > 0) {
                  return this.gamepad.getAxis(1);
                }
                return 0;
              }
              getJumpInput() {
                return (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyDown(
                    "Space"
                  ) ||
                  (this.gamepad && this.gamepad.getButtonDown(0))
                );
              }
              translate() {
                this.rigidbody.body.angularVelocity.y =
                  this.inputAngularVelocity.y;
                this.rigidbody.body.vectorToWorldFrame(
                  this.inputVelocity,
                  this.inputVelocity
                );
                this.rigidbody.body.velocity.x = this.inputVelocity.x;
                this.rigidbody.body.velocity.z = this.inputVelocity.z;
              }
              groundCheck() {
                this.rayPos.copy(this.object3d.position).addScalar(0.1);
                this.raycaster.set(this.rayPos, this.downDirection);
                this.raycaster.far = 0.6;
                const targets = rogue_engine__WEBPACK_IMPORTED_MODULE_0__
                  .getComponents(
                    _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__[
                      "default"
                    ]
                  )
                  .filter((comp) => comp.object3d !== this.object3d)
                  .map((comp) => comp.object3d);
                if (targets) {
                  let intersections = this.raycaster.intersectObjects(
                    targets,
                    true
                  );
                  if (intersections.length === 0) {
                    this.rayPos.addScaledVector(this.localFWD, 0.7);
                    this.raycaster.set(this.rayPos, this.downDirection);
                    intersections = this.raycaster.intersectObjects(
                      targets,
                      true
                    );
                  }
                  if (intersections.length === 0) {
                    this.rayPos.addScaledVector(this.localFWD, -0.7);
                    this.raycaster.set(this.rayPos, this.downDirection);
                    intersections = this.raycaster.intersectObjects(
                      targets,
                      true
                    );
                  }
                  if (intersections.length > 0) {
                    this.isGrounded = true;
                    this.isJumping = false;
                  } else {
                    this.isGrounded = false;
                  }
                }
              }
              jump() {
                this.getAction(actions.jump).clampWhenFinished = true;
                this.animator.mix(actions.jump, 0.05);
                this.isJumping = true;
                this.rigidbody.body.position.y += 0.6;
                this.rigidbody.body.velocity.y = this.jumpSpeed;
              }
              setRotation() {
                const hAxis = this.getHorizontal();
                const vAxis = this.getVertical();
                this.inputDirection.set(hAxis, 0, vAxis);
                this.inputDirection.length() > 1 &&
                  this.inputDirection.normalize();
                this.appliedDirection
                  .copy(this.object3d.position)
                  .add(this.inputDirection);
                if (this.inputDirection.length() > 0)
                  this.object3d.lookAt(this.appliedDirection);
                this.rigidbody.setQuaternion(this.object3d.quaternion);
              }
            }
            __name(CharacterController, "CharacterController");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CharacterController.prototype,
              "gamepadIndex",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CharacterController.prototype,
              "fwdSpeed",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CharacterController.prototype,
              "jumpSpeed",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CharacterController
            );

            /***/
          },

        /***/ "./Assets/Components/CharacterStatus.re.ts":
          /*!*************************************************!*\
  !*** ./Assets/Components/CharacterStatus.re.ts ***!
  \*************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CharacterStatus,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CharacterStatus extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.tag = "";
                this.hp = 100;
                this.curHP = 100;
                this.isDead = false;
                this.isDamaged = false;
              }
              applyDamage(amount) {
                this.curHP -= amount;
                if (this.curHP <= 0) {
                  this.curHP = 0;
                  this.isDead = true;
                  return;
                }
                this.isDamaged = true;
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__.onNextFrame(() =>
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.onNextFrame(
                    () => (this.isDamaged = false)
                  )
                );
              }
            }
            __name(CharacterStatus, "CharacterStatus");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.text()],
              CharacterStatus.prototype,
              "tag",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CharacterStatus.prototype,
              "hp",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CharacterStatus.prototype,
              "curHP",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CharacterStatus
            );

            /***/
          },

        /***/ "./Assets/Components/EnemyAI.re.ts":
          /*!*****************************************!*\
  !*** ./Assets/Components/EnemyAI.re.ts ***!
  \*****************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ EnemyAI,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_7__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _rogue_packages_rogue_cannon_Components_Shapes_CannonShape__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ../rogue_packages/rogue-cannon/Components/Shapes/CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
              );
            /* harmony import */ var _CharacterController_re__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! ./CharacterController.re */ "./Assets/Components/CharacterController.re.ts"
              );
            /* harmony import */ var _Animator_re__WEBPACK_IMPORTED_MODULE_5__ =
              __webpack_require__(
                /*! ./Animator.re */ "./Assets/Components/Animator.re.ts"
              );
            /* harmony import */ var _rogue_packages_rogue_cannon_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_6__ =
              __webpack_require__(
                /*! ../rogue_packages/rogue-cannon/Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            const actions = {
              idle: "idle",
              run: "run",
              attack: "attack",
              death: "death",
            };
            class EnemyAI extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.speed = 12;
                this.isAttacking = false;
                this.isDead = false;
                this.focus = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.focusCannon =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_7__.Vec3();
                this.localDirection =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this._attackStartPos =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.onCollide = /* @__PURE__ */ __name((event) => {
                  if (!this.isAttacking) return;
                  const shape =
                    event.contact.si.body === this.rigidbody?.body
                      ? event.contact.si
                      : event.contact.sj;
                  if (shape.body !== this.rigidbody?.body) return;
                  const otherBodyComponent =
                    _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__[
                      "default"
                    ].findByBody(event.other);
                  const shapeComponent =
                    _rogue_packages_rogue_cannon_Components_Shapes_CannonShape__WEBPACK_IMPORTED_MODULE_3__[
                      "default"
                    ].findByShape(shape);
                  const characterController =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                      _CharacterController_re__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ]
                    );
                  if (
                    shapeComponent?.name === "AttackRange" &&
                    otherBodyComponent?.object3d ===
                      characterController?.object3d
                  ) {
                    const playerController =
                      rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                        _CharacterController_re__WEBPACK_IMPORTED_MODULE_4__[
                          "default"
                        ],
                        otherBodyComponent?.object3d
                      );
                    !playerController?.isDead && playerController?.setDead();
                  }
                }, "onCollide");
              }
              get rigidbody() {
                if (!this._rigidbody) {
                  this._rigidbody =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                      _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__[
                        "default"
                      ],
                      this.object3d
                    );
                  this._rigidbody.onCollide(this.onCollide);
                }
                return this._rigidbody;
              }
              get animator() {
                if (!this._animator) {
                  this._animator =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                      _Animator_re__WEBPACK_IMPORTED_MODULE_5__["default"],
                      this.object3d
                    );
                }
                return this._animator;
              }
              get curAction() {
                return this.animator.activeAction;
              }
              setDead() {
                this.isDead = true;
                this.animator.getAction(actions.death).clampWhenFinished = true;
                this.animator.mix(actions.death);
              }
              update() {
                if (!this.rigidbody) return;
                if (this.isDead) {
                  this.rigidbody.body.velocity.x = 0;
                  this.rigidbody.body.velocity.z = 0;
                  return;
                }
                this.rigidbody.body.velocity.x = this.focusCannon.x;
                this.rigidbody.body.velocity.z = this.focusCannon.z;
                const characterController =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CharacterController_re__WEBPACK_IMPORTED_MODULE_4__[
                      "default"
                    ]
                  );
                if (
                  characterController &&
                  !characterController.isDead &&
                  this.object3d.position.distanceTo(
                    characterController.object3d.position
                  ) <= 15
                ) {
                  this.engaging = characterController.object3d;
                }
                if (characterController?.isDead) {
                  this.engaging = void 0;
                  this.isAttacking = false;
                  this.focusCannon.setZero();
                }
                if (
                  !this.isAttacking &&
                  this.focusCannon.length() === 0 &&
                  this.curAction !== this.animator.getAction(actions.idle)
                ) {
                  this.animator.mix(actions.idle);
                }
                if (
                  !this.isAttacking &&
                  this.focusCannon.length() > 0 &&
                  this.curAction !== this.animator.getAction(actions.run)
                ) {
                  this.animator.mix(actions.run);
                }
                if (!this.engaging) return;
                if (
                  this.isAttacking &&
                  this._attackStartPos.distanceTo(this.object3d.position) > 12
                ) {
                  this.focusCannon.setZero();
                }
                if (
                  this.isAttacking &&
                  this.curAction !== this.animator.getAction(actions.attack)
                ) {
                  this.engage();
                }
                if (!this.isAttacking && this.engaging) {
                  this.follow();
                }
                if (
                  this.object3d.position.distanceTo(this.engaging.position) <=
                    8 &&
                  !this.isAttacking
                ) {
                  this.attack();
                }
              }
              engage() {
                if (!this.engaging) return;
                this.focus.set(
                  this.engaging.position.x,
                  this.object3d.position.y,
                  this.engaging.position.z
                );
                this.object3d.lookAt(this.focus);
                this.rigidbody.setQuaternion(this.object3d.quaternion);
              }
              follow() {
                this.engage();
                this.object3d.getWorldDirection(this.localDirection);
                (0,
                _rogue_packages_rogue_cannon_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_6__.copyThreeV3)(
                  this.localDirection,
                  this.focusCannon
                );
                this.focusCannon.scale(this.speed, this.focusCannon);
              }
              attack() {
                this.isAttacking = true;
                this.animator.mix(actions.idle);
                this.focusCannon.setZero();
                setTimeout(() => {
                  this.animator.mix(actions.attack);
                  this.object3d.getWorldDirection(this.localDirection);
                  this._attackStartPos.copy(this.object3d.position);
                  (0,
                  _rogue_packages_rogue_cannon_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_6__.copyThreeV3)(
                    this.localDirection,
                    this.focusCannon
                  );
                  this.focusCannon.scale(this.speed * 3, this.focusCannon);
                  setTimeout(() => {
                    this.isAttacking = false;
                    this.focusCannon.setZero();
                  }, 1200);
                }, 200);
              }
            }
            __name(EnemyAI, "EnemyAI");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              EnemyAI.prototype,
              "speed",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              EnemyAI.prototype,
              "isAttacking",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              EnemyAI
            );

            /***/
          },

        /***/ "./Assets/Components/MeleeAttack.re.ts":
          /*!*********************************************!*\
  !*** ./Assets/Components/MeleeAttack.re.ts ***!
  \*********************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ MeleeAttack,
              /* harmony export */
            });
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_7__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var _Animator_re__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./Animator.re */ "./Assets/Components/Animator.re.ts"
              );
            /* harmony import */ var _rogue_packages_rogue_cannon_Components_Shapes_CannonShape__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ../rogue_packages/rogue-cannon/Components/Shapes/CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
              );
            /* harmony import */ var _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! ../rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _CharacterController_re__WEBPACK_IMPORTED_MODULE_5__ =
              __webpack_require__(
                /*! ./CharacterController.re */ "./Assets/Components/CharacterController.re.ts"
              );
            /* harmony import */ var _CharacterStatus_re__WEBPACK_IMPORTED_MODULE_6__ =
              __webpack_require__(
                /*! ./CharacterStatus.re */ "./Assets/Components/CharacterStatus.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class MeleeAttack extends rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Component {
              constructor() {
                super(...arguments);
                this.selectedAction = 0;
                this.damage = 10;
                this.isAttacking = false;
                this.localFWD =
                  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                this.impulse =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_7__.Vec3();
                this.onCollisionEnter = /* @__PURE__ */ __name((event) => {
                  const characterStatus =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(
                      _CharacterStatus_re__WEBPACK_IMPORTED_MODULE_6__[
                        "default"
                      ],
                      event.other.object3d
                    );
                  if (characterStatus === this.characterStatus) return;
                  !characterStatus?.isDead &&
                    characterStatus?.applyDamage(this.damage);
                }, "onCollisionEnter");
                this.worldPos =
                  new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                this.worldQuaternion =
                  new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
              }
              get selectedActionOptions() {
                this.animator.mixer;
                return Object.keys(this.animator.actions);
              }
              get actionName() {
                return this.selectedActionOptions[this.selectedAction];
              }
              get animator() {
                if (!this._animator) {
                  this._animator =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(
                      _Animator_re__WEBPACK_IMPORTED_MODULE_2__["default"],
                      this.object3d
                    );
                }
                return this._animator;
              }
              get characterController() {
                if (!this._characterController) {
                  this._characterController =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(
                      _CharacterController_re__WEBPACK_IMPORTED_MODULE_5__[
                        "default"
                      ],
                      this.object3d
                    );
                }
                return this._characterController;
              }
              get characterStatus() {
                if (!this._characterStatus) {
                  this._characterStatus =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(
                      _CharacterStatus_re__WEBPACK_IMPORTED_MODULE_6__[
                        "default"
                      ],
                      this.object3d
                    );
                }
                return this._characterStatus;
              }
              get rigidbody() {
                if (!this._rigidbody) {
                  this._rigidbody =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(
                      _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ],
                      this.object3d
                    );
                }
                return this._rigidbody;
              }
              get attackBody() {
                if (!this._attackBody) {
                  this._attackBody =
                    rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(
                      _rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_4__[
                        "default"
                      ],
                      this.attack
                    );
                  this._attackBody.onCollisionEnter(this.onCollisionEnter);
                }
                return this._attackBody;
              }
              get gamepad() {
                return this.characterController.gamepad;
              }
              disableColliders() {
                this.attackBody.body.shapes.forEach((shape) => {
                  _rogue_packages_rogue_cannon_Components_Shapes_CannonShape__WEBPACK_IMPORTED_MODULE_3__[
                    "default"
                  ].findByShape(shape).enabled = false;
                });
              }
              enableColliders() {
                this.attackBody.body.shapes.forEach((shape) => {
                  _rogue_packages_rogue_cannon_Components_Shapes_CannonShape__WEBPACK_IMPORTED_MODULE_3__[
                    "default"
                  ].findByShape(shape).enabled = true;
                });
              }
              getMeleeInput() {
                return (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.keyboard.getKeyDown(
                    "KeyF"
                  ) ||
                  (this.gamepad && this.gamepad.getButtonDown(2))
                );
              }
              start() {
                this.attack = this.attackPrefab.instantiate();
                this.attackBody.enabled = false;
              }
              update() {
                if (!this.animator.isActive) return;
                if (!this.attack) return;
                this.updateColliderTransform();
                this.object3d.getWorldDirection(this.localFWD);
                if (
                  this.animator.activeAction !==
                    this.animator.getAction(this.actionName) &&
                  this.attackBody.enabled
                ) {
                  this.attackBody.enabled = false;
                }
                if (this.getMeleeInput() && !this.isAttacking) {
                  this.isAttacking = true;
                  this.animator.mix(this.actionName, 0.1, true);
                  this.updateColliderTransform();
                  this.attackBody.enabled = true;
                  setTimeout(() => {
                    this.isAttacking = false;
                    this.attackBody.enabled = false;
                  }, 250);
                }
                if (
                  this.animator.activeAction ===
                  this.animator.getAction(this.actionName)
                ) {
                  this.rigidbody.body.velocity.x = this.localFWD.x;
                  this.rigidbody.body.velocity.z = this.localFWD.z;
                }
              }
              updateColliderTransform() {
                this.origin.getWorldPosition(this.worldPos);
                this.attackBody.setPosition(this.worldPos);
                this.origin.getWorldQuaternion(this.worldQuaternion);
                this.attackBody.setQuaternion(this.worldQuaternion);
              }
            }
            __name(MeleeAttack, "MeleeAttack");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_1__.props.prefab()],
              MeleeAttack.prototype,
              "attackPrefab",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_1__.props.object3d()],
              MeleeAttack.prototype,
              "origin",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_1__.props.select()],
              MeleeAttack.prototype,
              "selectedAction",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_1__.props.num()],
              MeleeAttack.prototype,
              "damage",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_1__.registerComponent(
              MeleeAttack
            );

            /***/
          },

        /***/ "./Assets/Components/UIElement.re.ts":
          /*!*******************************************!*\
  !*** ./Assets/Components/UIElement.re.ts ***!
  \*******************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ UIElement,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class UIElement extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.containerID = "";
                this.html = ``;
              }
              get container() {
                if (!this._container) {
                  this._container = document.createElement("div");
                  this._container.id = this.containerID;
                }
                return this._container;
              }
              awake() {
                this.container.innerHTML = this.html;
                // rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.uiContainer.append(
                //   this.container
                // );
              }
            }
            __name(UIElement, "UIElement");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.text()],
              UIElement.prototype,
              "containerID",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.code("html")],
              UIElement.prototype,
              "html",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              UIElement
            );

            /***/
          },

        /***/ "./Assets/Components/UIHealthBarsController.re.ts":
          /*!********************************************************!*\
  !*** ./Assets/Components/UIHealthBarsController.re.ts ***!
  \********************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ UIHealthBarsController,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            var __defProp = Object.defineProperty;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });

            class UIHealthBarsController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.p1HP = 0;
                this.p2HP = 0;
              }
              get healthBar1() {
                return document.querySelector("#health-bar-1 > div");
              }
              get healthBar2() {
                return document.querySelector("#health-bar-2 > div");
              }
              get player1Status() {
                return rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponentByName(
                  "Player1"
                );
              }
              get player2Status() {
                return rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponentByName(
                  "Player2"
                );
              }
              update() {
                const p1 = this.player1Status;
                const p2 = this.player2Status;
                if (p1.curHP !== this.p1HP)
                  this.updateHealthbar(this.healthBar1, p1);
                if (p2.curHP !== this.p2HP)
                  this.updateHealthbar(this.healthBar2, p2);
                this.p1HP = p1.curHP;
                this.p2HP = p2.curHP;
              }
              updateHealthbar(healthbar, player) {
                healthbar.style.width = (player.curHP * 100) / player.hp + "%";
              }
            }
            __name(UIHealthBarsController, "UIHealthBarsController");
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              UIHealthBarsController
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts":
          /*!************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts ***!
  \************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonBody,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            const _CannonBody = class extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this._isTrigger = false;
                this._angularDamping = 0;
                this._linearDamping = 0;
                this._angularFactor =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                this._linearFactor =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                this._mass = 1;
                this._useDefaultMass = true;
                this._type = 0;
                this.typeOptions = ["Dynamic", "Static", "Kinematic"];
                this.worldPos =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.worldRot =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                this.newBodyPos =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
                this.newBodyRot =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Quaternion();
                this.newPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.newRot =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                this.matrixA = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.matrixB = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.matrixC = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.onCollisionEnterListeners = [];
                this.onCollisionStayListeners = [];
                this.onCollisionExitListeners = [];
                this.handleOnCollide = /* @__PURE__ */ __name((event) => {
                  const bj = event.contact.bj;
                  const bi = event.contact.bi;
                  const collision = {
                    other: bj !== this.body ? bj : bi,
                    contact: event.contact,
                  };
                  this.triggerCollision = collision;
                }, "handleOnCollide");
              }
              get type() {
                return this._type;
              }
              set type(value) {
                this._type = value;
                let type = 1;
                if (value === 0) type = 1;
                if (value === 1) type = 2;
                if (value === 2) type = 4;
                this.body && (this.body.type = type);
              }
              get angularDamping() {
                return this._angularDamping;
              }
              set angularDamping(value) {
                this._angularDamping = value;
                this.body && (this.body.angularDamping = value);
              }
              get linearDamping() {
                return this._linearDamping;
              }
              set linearDamping(value) {
                this._linearDamping = value;
                this.body && (this.body.linearDamping = value);
              }
              get mass() {
                return this._mass;
              }
              set mass(value) {
                this._mass = value;
                this.body && (this.body.mass = value);
                this.body && this.body.updateMassProperties();
              }
              get linearFactor() {
                return this._linearFactor;
              }
              set linearFactor(value) {
                this._linearFactor = value;
                this.body &&
                  this.body.linearFactor.set(value.x, value.y, value.z);
              }
              get angularFactor() {
                return this._angularFactor;
              }
              set angularFactor(value) {
                this._angularFactor = value;
                this.body &&
                  this.body.angularFactor.set(value.x, value.y, value.z);
              }
              get isTrigger() {
                return this._isTrigger;
              }
              set isTrigger(value) {
                this._isTrigger = value;
                this.body && (this.body.isTrigger = value);
              }
              static findByBody(body) {
                let bodyComponent;
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__.traverseComponents(
                  (component) => {
                    if (bodyComponent) return;
                    if (
                      component instanceof _CannonBody &&
                      component.body === body
                    ) {
                      bodyComponent = component;
                    }
                  }
                );
                return bodyComponent;
              }
              awake() {
                if (!this.body) {
                  this.createBody();
                }
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.onStop(() => {
                  this.handleOnCollide &&
                    this.body.removeEventListener(
                      "collide",
                      this.handleOnCollide
                    );
                });
              }
              start() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .addBody(this.body);
                this.copyObjectTransform();
              }
              onDisabled() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .removeBody(this.body);
              }
              beforeUpdate() {
                if (this.body.mass !== this._mass) {
                  this.mass = this._mass;
                }
                this.body && (this.body.type = this.getBodyType());
                this.body.type !==
                  cannon_es__WEBPACK_IMPORTED_MODULE_3__.BODY_TYPES.STATIC &&
                  this.updatePhysics();
                if (this.triggerCollision !== void 0 && this.onCollideCB) {
                  this.onCollideCB(this.triggerCollision);
                  this.triggerCollision = void 0;
                }
              }
              onBeforeRemoved() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .removeBody(this.body);
              }
              onCollisionEnter(cb) {
                this.onCollisionEnterListeners.push(cb);
              }
              onCollisionStay(cb) {
                this.onCollisionStayListeners.push(cb);
              }
              onCollisionExit(cb) {
                this.onCollisionExitListeners.push(cb);
              }
              onCollide(callback) {
                this.onCollideCB = callback;
                this.body.removeEventListener("collide", this.handleOnCollide);
                this.body.addEventListener("collide", this.handleOnCollide);
              }
              setQuaternion(quaternion) {
                const q = quaternion;
                this.body.quaternion.set(q.x, q.y, q.z, q.w);
              }
              setPosition(position) {
                const pos = position;
                this.body.position.set(pos.x, pos.y, pos.z);
              }
              getBodyType() {
                let type = 1;
                if (this._type === 0) type = 1;
                if (this._type === 1) type = 2;
                if (this._type === 2) type = 4;
                return type;
              }
              createBody() {
                this.body = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Body({
                  type: this.getBodyType(),
                  angularDamping: this.angularDamping,
                  linearDamping: this.linearDamping,
                  linearFactor: new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(
                    this.linearFactor.x,
                    this.linearFactor.y,
                    this.linearFactor.z
                  ),
                  angularFactor:
                    new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(
                      this.angularFactor.x,
                      this.angularFactor.y,
                      this.angularFactor.z
                    ),
                  isTrigger: this.isTrigger,
                  mass: this._mass,
                });
                this.copyObjectTransform();
              }
              createShape() {}
              copyObjectTransform() {
                this.object3d.parent?.updateMatrixWorld(true);
                this.object3d.getWorldPosition(this.worldPos);
                this.object3d.getWorldQuaternion(this.worldRot);
                this.newBodyPos.set(
                  this.worldPos.x,
                  this.worldPos.y,
                  this.worldPos.z
                );
                this.newBodyRot.set(
                  this.worldRot.x,
                  this.worldRot.y,
                  this.worldRot.z,
                  this.worldRot.w
                );
                this.body.quaternion.copy(this.newBodyRot);
                this.body.position.copy(this.newBodyPos);
              }
              copyBodyTransform() {
                this.copyBodyPosition();
                this.copyBodyRotation();
              }
              copyBodyPosition() {
                this.newPos.set(
                  this.body.interpolatedPosition.x,
                  this.body.interpolatedPosition.y,
                  this.body.interpolatedPosition.z
                );
                if (!this.object3d.parent) return;
                this.object3d.parent?.worldToLocal(this.newPos);
                this.object3d.position.copy(this.newPos);
              }
              copyBodyRotation() {
                this.newRot.set(
                  this.body.quaternion.x,
                  this.body.quaternion.y,
                  this.body.quaternion.z,
                  this.body.quaternion.w
                );
                this.matrixA.makeRotationFromQuaternion(this.newRot);
                this.object3d.updateMatrixWorld();
                this.matrixB.copy(this.object3d.parent.matrixWorld).invert();
                this.matrixC.extractRotation(this.matrixB);
                this.matrixA.premultiply(this.matrixC);
                this.object3d.quaternion.setFromRotationMatrix(this.matrixA);
              }
              updatePhysics() {
                this.copyBodyTransform();
              }
            };
            let CannonBody = _CannonBody;
            __name(CannonBody, "CannonBody");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.select()],
              CannonBody.prototype,
              "type",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonBody.prototype,
              "angularDamping",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonBody.prototype,
              "linearDamping",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonBody.prototype,
              "mass",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonBody.prototype,
              "linearFactor",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonBody.prototype,
              "angularFactor",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonBody.prototype,
              "isTrigger",
              1
            );

            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonBody
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/CannonConfig.re.ts":
          /*!**************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/CannonConfig.re.ts ***!
  \**************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonConfig,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ./CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonConfig extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this._defaultFriction = 0.01;
                this._defaultRestitution = 0;
                this.maxSubSteps = 1;
                this.gravity = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(
                  0,
                  -9.82,
                  0
                );
                this.contacts = [];
                this.activeCollisions = {};
              }
              get defaultFriction() {
                return this._defaultFriction;
              }
              set defaultFriction(value) {
                this._defaultFriction = value;
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.friction =
                  value;
              }
              get defaultRestitution() {
                return this._defaultRestitution;
              }
              set defaultRestitution(value) {
                this._defaultRestitution = value;
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.restitution =
                  value;
              }
              awake() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.setWorld(
                  new cannon_es__WEBPACK_IMPORTED_MODULE_4__.World()
                );
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .gravity.set(this.gravity.x, this.gravity.y, this.gravity.z);
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().broadphase =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_4__.NaiveBroadphase();
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.friction =
                  this.defaultFriction;
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.restitution =
                  this.defaultRestitution;
              }
              beforeUpdate() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .step(
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.deltaTime,
                    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.deltaTime,
                    this.maxSubSteps || 1
                  );
              }
              afterUpdate() {
                this.checkCollisions();
              }
              checkCollisions() {
                const contacts =
                  _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld()
                    .contacts;
                const newContacts = [];
                contacts.forEach((contact) => {
                  newContacts[contact.id] = contact;
                  const key1 = contact.bi.id + "_" + contact.bj.id;
                  const key2 = contact.bj.id + "_" + contact.bi.id;
                  const key1Collision = this.activeCollisions[key1];
                  const key2Collision = this.activeCollisions[key2];
                  if (
                    !this.contacts[contact.id] &&
                    !key1Collision &&
                    !key2Collision
                  ) {
                    this.activeCollisions[key1] = true;
                    this.activeCollisions[key2] = true;
                    this.sendNewCollisionEvents(contact);
                  }
                });
                this.contacts.forEach((contact) => {
                  const key1 = contact.bi.id + "_" + contact.bj.id;
                  const key2 = contact.bj.id + "_" + contact.bi.id;
                  const foundActiveCollision = this.findActiveCollision(
                    newContacts,
                    contact
                  );
                  const newContact = newContacts[contact.id];
                  if (
                    (newContact && newContact.enabled) ||
                    foundActiveCollision
                  ) {
                    this.sendOnCollisionStayEvents(contact);
                  }
                  if (
                    (!newContact || (newContact && !newContact.enabled)) &&
                    !foundActiveCollision
                  ) {
                    this.activeCollisions[key1] = false;
                    this.activeCollisions[key2] = false;
                    this.sendOnCollisionExitEvents(contact);
                  }
                });
                this.contacts = newContacts;
              }
              findActiveCollision(contactList, sample) {
                return contactList.find((contact) => {
                  if (!contact || !contact.enabled) return false;
                  if (contact.bi === sample.bi && contact.bj === sample.bj)
                    return true;
                  if (contact.bi === sample.bj && contact.bj === sample.bi)
                    return true;
                  return false;
                });
              }
              sendOnCollisionStayEvents(contact) {
                const bodyA = _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__[
                  "default"
                ].findByBody(contact.bi);
                const bodyB = _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__[
                  "default"
                ].findByBody(contact.bj);
                if (!bodyB || !bodyA) return;
                bodyA.onCollisionStayListeners.forEach((cb) => {
                  cb({ other: bodyB, contact });
                });
                bodyB.onCollisionStayListeners.forEach((cb) => {
                  cb({ other: bodyA, contact });
                });
              }
              sendOnCollisionExitEvents(contact) {
                const bodyA = _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__[
                  "default"
                ].findByBody(contact.bi);
                const bodyB = _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__[
                  "default"
                ].findByBody(contact.bj);
                if (!bodyB || !bodyA) return;
                bodyA.onCollisionExitListeners.forEach((cb) => {
                  cb({ other: bodyB, contact });
                });
                bodyB.onCollisionExitListeners.forEach((cb) => {
                  cb({ other: bodyA, contact });
                });
              }
              sendNewCollisionEvents(contact) {
                const bodyA = _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__[
                  "default"
                ].findByBody(contact.bi);
                const bodyB = _CannonBody_re__WEBPACK_IMPORTED_MODULE_3__[
                  "default"
                ].findByBody(contact.bj);
                if (!bodyB || !bodyA) return;
                bodyA.onCollisionEnterListeners.forEach((cb) => {
                  cb({ other: bodyB, contact });
                });
                bodyB.onCollisionEnterListeners.forEach((cb) => {
                  cb({ other: bodyA, contact });
                });
              }
            }
            __name(CannonConfig, "CannonConfig");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonConfig.prototype,
              "maxSubSteps",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonConfig.prototype,
              "defaultFriction",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonConfig.prototype,
              "defaultRestitution",
              1
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonConfig.prototype,
              "gravity",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonConfig
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts":
          /*!***************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts ***!
  \***************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonConstraint,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });

            class CannonConstraint extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              start() {
                this.createConstraint();
              }
              getCannonBodyComponent(object3d) {
                const cannonBody =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"],
                    object3d
                  );
                if (!cannonBody) {
                  throw "CannonHinge targets must have a Cannon Body Component";
                }
                return cannonBody;
              }
              createConstraint() {}
              onRemoved() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .removeConstraint(this.constraint);
              }
            }
            __name(CannonConstraint, "CannonConstraint");

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonDistanceConstraint.re.ts":
          /*!**************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonDistanceConstraint.re.ts ***!
  \**************************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonDistanceConstraint,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonDistanceConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.distance = 1;
                this.maxForce = 1e6;
              }
              createConstraint() {
                if (!this.target) throw "CannonHinge requires a target";
                const bodyA = this.getCannonBodyComponent(this.object3d).body;
                const bodyB = this.getCannonBodyComponent(this.target).body;
                this.constraint =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.DistanceConstraint(
                    bodyA,
                    bodyB,
                    this.distance,
                    this.maxForce
                  );
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .addConstraint(this.constraint);
              }
            }
            __name(CannonDistanceConstraint, "CannonDistanceConstraint");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonDistanceConstraint.prototype,
              "target",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonDistanceConstraint.prototype,
              "distance",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonDistanceConstraint.prototype,
              "maxForce",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonDistanceConstraint
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonHingeConstraint.re.ts":
          /*!***********************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonHingeConstraint.re.ts ***!
  \***********************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonHingeConstraint,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonHingeConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.pivotA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(
                  0.1,
                  0,
                  0
                );
                this.axisA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(
                  0,
                  1,
                  0
                );
                this.pivotB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(
                  -1,
                  0,
                  0
                );
                this.axisB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(
                  0,
                  1,
                  0
                );
                this.maxForce = 1e6;
              }
              createConstraint() {
                if (!this.target) throw "CannonHinge requires a target";
                const bodyA = this.getCannonBodyComponent(this.object3d).body;
                const bodyB = this.getCannonBodyComponent(this.target).body;
                this.constraint =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_4__.HingeConstraint(
                    bodyA,
                    bodyB,
                    {
                      pivotA: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                        this.pivotA.x,
                        this.pivotA.y,
                        this.pivotA.z
                      ),
                      axisA: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                        this.axisA.x,
                        this.axisA.y,
                        this.axisA.z
                      ),
                      pivotB: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                        this.pivotB.x,
                        this.pivotB.y,
                        this.pivotB.z
                      ),
                      axisB: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                        this.axisB.x,
                        this.axisB.y,
                        this.axisB.z
                      ),
                      collideConnected: this.collideConnected,
                      maxForce: this.maxForce,
                    }
                  );
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__
                  .getWorld()
                  .addConstraint(this.constraint);
              }
            }
            __name(CannonHingeConstraint, "CannonHingeConstraint");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonHingeConstraint.prototype,
              "target",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonHingeConstraint.prototype,
              "pivotA",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonHingeConstraint.prototype,
              "axisA",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonHingeConstraint.prototype,
              "pivotB",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonHingeConstraint.prototype,
              "axisB",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonHingeConstraint.prototype,
              "collideConnected",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonHingeConstraint.prototype,
              "maxForce",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonHingeConstraint
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonLockConstraint.re.ts":
          /*!**********************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonLockConstraint.re.ts ***!
  \**********************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonLockConstraint,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonLockConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.maxForce = 1e6;
              }
              createConstraint() {
                if (!this.target) throw "CannonHinge requires a target";
                const bodyA = this.getCannonBodyComponent(this.object3d).body;
                const bodyB = this.getCannonBodyComponent(this.target).body;
                this.constraint =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.LockConstraint(
                    bodyA,
                    bodyB,
                    {
                      maxForce: this.maxForce,
                    }
                  );
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .addConstraint(this.constraint);
              }
            }
            __name(CannonLockConstraint, "CannonLockConstraint");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonLockConstraint.prototype,
              "target",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonLockConstraint.prototype,
              "maxForce",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonLockConstraint
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonPointToPointConstraint.re.ts":
          /*!******************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonPointToPointConstraint.re.ts ***!
  \******************************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonPointToPointConstraint,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonPointToPointConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.privotA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.privotB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.maxForce = 1e6;
              }
              createConstraint() {
                if (!this.target) throw "CannonHinge requires a target";
                const bodyA = this.getCannonBodyComponent(this.object3d).body;
                const bodyB = this.getCannonBodyComponent(this.target).body;
                this.constraint =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_4__.PointToPointConstraint(
                    bodyA,
                    new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                      this.privotA.x,
                      this.privotA.y,
                      this.privotA.z
                    ),
                    bodyB,
                    new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                      this.privotB.x,
                      this.privotB.y,
                      this.privotB.z
                    ),
                    this.maxForce
                  );
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__
                  .getWorld()
                  .addConstraint(this.constraint);
              }
            }
            __name(
              CannonPointToPointConstraint,
              "CannonPointToPointConstraint"
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonPointToPointConstraint.prototype,
              "target",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonPointToPointConstraint.prototype,
              "privotA",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonPointToPointConstraint.prototype,
              "privotB",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonPointToPointConstraint.prototype,
              "maxForce",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonPointToPointConstraint
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonSimpleCharacterController.re.ts":
          /*!*********************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonSimpleCharacterController.re.ts ***!
  \*********************************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonSimpleCharacterController,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonSimpleCharacterController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.fwdSpeed = 3;
                this.jumpSpeed = 5;
                this.canJump = false;
                this.contactNormal =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3();
                this.upAxis = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3(
                  0,
                  1,
                  0
                );
                this.inputAngularVelocity =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3();
                this.inputVelocity =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3();
              }
              awake() {
                this.rigidbody =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"],
                    this.object3d
                  );
                this.rigidbody?.onCollide((event) => {
                  event.contact.ni.negate(this.contactNormal);
                  if (this.contactNormal.dot(this.upAxis) > 0.5) {
                    this.canJump = true;
                  }
                });
                if (!this.rigidbody) return;
                this.rigidbody.body.type =
                  cannon_es__WEBPACK_IMPORTED_MODULE_2__.Body.DYNAMIC;
              }
              update() {
                if (!this.rigidbody) return;
                this.inputVelocity.setZero();
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyW"
                  )
                ) {
                  this.inputVelocity.z = -1;
                } else if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyS"
                  )
                ) {
                  this.inputVelocity.z = 1;
                } else {
                  this.inputVelocity.z = 0;
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyA"
                  )
                ) {
                  this.inputVelocity.x = -1;
                } else if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyD"
                  )
                ) {
                  this.inputVelocity.x = 1;
                } else {
                  this.inputVelocity.x = 0;
                }
                this.inputVelocity.normalize();
                this.inputVelocity.scale(this.fwdSpeed, this.inputVelocity);
                if (
                  this.canJump &&
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyDown(
                    "Space"
                  )
                ) {
                  this.rigidbody.body.velocity.y = this.jumpSpeed;
                  this.canJump = false;
                }
                this.rigidbody.body.angularVelocity.y =
                  this.inputAngularVelocity.y;
                this.rigidbody.body.vectorToWorldFrame(
                  this.inputVelocity,
                  this.inputVelocity
                );
                if (!this.canJump) return;
                this.rigidbody.body.velocity.x = this.inputVelocity.x;
                this.rigidbody.body.velocity.z = this.inputVelocity.z;
              }
            }
            __name(
              CannonSimpleCharacterController,
              "CannonSimpleCharacterController"
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonSimpleCharacterController.prototype,
              "fwdSpeed",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonSimpleCharacterController.prototype,
              "jumpSpeed",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonSimpleCharacterController
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonVehicleController.re.ts":
          /*!*************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonVehicleController.re.ts ***!
  \*************************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonVehicleController,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var _Objects_CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../Objects/CannonRaycastVehicle.re */ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonVehicleController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.maxForce = 200;
                this.reverseForce = 50;
                this.breakForce = 250;
                this.maxSteering = 0.5;
              }
              start() {
                this.raycastVehicle =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponentByName(
                    "CannonRaycastVehicle",
                    this.object3d
                  );
              }
              update() {
                if (
                  !(
                    this.raycastVehicle instanceof
                    _Objects_CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_1__[
                      "default"
                    ]
                  )
                )
                  return;
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyW"
                  )
                ) {
                  this.releaseBreaks();
                  this.raycastVehicle.vehicle.applyEngineForce(
                    this.maxForce,
                    2
                  );
                  this.raycastVehicle.vehicle.applyEngineForce(
                    this.maxForce,
                    3
                  );
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyS"
                  )
                ) {
                  const speed =
                    -this.raycastVehicle.vehicle.currentVehicleSpeedKmHour;
                  if (speed <= 0) {
                    this.releaseBreaks();
                    this.raycastVehicle.vehicle.applyEngineForce(
                      -this.reverseForce,
                      2
                    );
                    this.raycastVehicle.vehicle.applyEngineForce(
                      -this.reverseForce,
                      3
                    );
                  } else if (speed > 0.05) {
                    this.raycastVehicle.vehicle.applyEngineForce(
                      -this.maxForce,
                      2
                    );
                    this.raycastVehicle.vehicle.applyEngineForce(
                      -this.maxForce,
                      3
                    );
                  }
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp(
                    "KeyW"
                  )
                ) {
                  this.raycastVehicle.vehicle.applyEngineForce(0, 2);
                  this.raycastVehicle.vehicle.applyEngineForce(0, 3);
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp(
                    "KeyS"
                  )
                ) {
                  const speed = Math.abs(
                    this.raycastVehicle.vehicle.currentVehicleSpeedKmHour
                  );
                  this.raycastVehicle.vehicle.applyEngineForce(0, 2);
                  this.raycastVehicle.vehicle.applyEngineForce(0, 3);
                  if (speed < 1) {
                    this.break();
                  } else {
                    this.releaseBreaks();
                  }
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyA"
                  )
                ) {
                  this.raycastVehicle.vehicle.setSteeringValue(
                    this.maxSteering,
                    0
                  );
                  this.raycastVehicle.vehicle.setSteeringValue(
                    this.maxSteering,
                    1
                  );
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed(
                    "KeyD"
                  )
                ) {
                  this.raycastVehicle.vehicle.setSteeringValue(
                    -this.maxSteering,
                    0
                  );
                  this.raycastVehicle.vehicle.setSteeringValue(
                    -this.maxSteering,
                    1
                  );
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp(
                    "KeyA"
                  )
                ) {
                  this.raycastVehicle.vehicle.setSteeringValue(0, 0);
                  this.raycastVehicle.vehicle.setSteeringValue(0, 1);
                }
                if (
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp(
                    "KeyD"
                  )
                ) {
                  this.raycastVehicle.vehicle.setSteeringValue(0, 0);
                  this.raycastVehicle.vehicle.setSteeringValue(0, 1);
                }
              }
              break() {
                this.raycastVehicle.vehicle.setBrake(this.breakForce, 0);
                this.raycastVehicle.vehicle.setBrake(this.breakForce, 1);
                this.raycastVehicle.vehicle.setBrake(this.breakForce, 2);
                this.raycastVehicle.vehicle.setBrake(this.breakForce, 3);
              }
              releaseBreaks() {
                this.raycastVehicle.vehicle.setBrake(0, 0);
                this.raycastVehicle.vehicle.setBrake(0, 1);
                this.raycastVehicle.vehicle.setBrake(0, 2);
                this.raycastVehicle.vehicle.setBrake(0, 3);
              }
            }
            __name(CannonVehicleController, "CannonVehicleController");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonVehicleController.prototype,
              "maxForce",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonVehicleController.prototype,
              "reverseForce",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonVehicleController.prototype,
              "breakForce",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonVehicleController.prototype,
              "maxSteering",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonVehicleController
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Material/CannonContactMaterial.re.ts":
          /*!********************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Material/CannonContactMaterial.re.ts ***!
  \********************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonContactMaterial,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonContactMaterial extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              start() {
                this.createContactMaterial();
              }
              getMaterial(materialName) {
                return _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_1__
                  .getWorld()
                  .materials.find((material) => material.name === materialName);
              }
              createContactMaterial() {
                const cannonMaterialA = this.getMaterial(this.materialA);
                const cannonMaterialB = this.getMaterial(this.materialB);
                if (!cannonMaterialA || !cannonMaterialB) return;
                this.contactMaterial =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_2__.ContactMaterial(
                    cannonMaterialA,
                    cannonMaterialB,
                    {
                      friction: this.friction,
                      restitution: this.restitution,
                    }
                  );
                this.contactMaterial.friction = this.friction;
                this.contactMaterial.restitution = this.restitution;
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_1__
                  .getWorld()
                  .addContactMaterial(this.contactMaterial);
              }
            }
            __name(CannonContactMaterial, "CannonContactMaterial");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.text()],
              CannonContactMaterial.prototype,
              "materialA",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.text()],
              CannonContactMaterial.prototype,
              "materialB",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonContactMaterial.prototype,
              "friction",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonContactMaterial.prototype,
              "restitution",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonContactMaterial
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Material/CannonMaterial.re.ts":
          /*!*************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Material/CannonMaterial.re.ts ***!
  \*************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonMaterial,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonMaterial extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              awake() {
                this.createMaterial();
              }
              start() {
                this.setMaterial();
              }
              createMaterial() {
                this.material =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Material(
                    this.name
                  );
                this.material.friction = this.friction;
                this.material.restitution = this.restitution;
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .addMaterial(this.material);
              }
              setMaterial() {
                const cannonBody =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"],
                    this.object3d
                  );
                if (cannonBody) {
                  cannonBody.body.shapes.forEach(
                    (shape) => (shape.material = this.material)
                  );
                }
              }
            }
            __name(CannonMaterial, "CannonMaterial");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonMaterial.prototype,
              "friction",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonMaterial.prototype,
              "restitution",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonMaterial
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Material/SetCannonMaterial.re.ts":
          /*!****************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Material/SetCannonMaterial.re.ts ***!
  \****************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ SetCannonMaterial,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class SetCannonMaterial extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              start() {
                this.setMaterial();
              }
              getMaterial() {
                return _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__
                  .getWorld()
                  .materials.find(
                    (material) => material.name === this.materialName
                  );
              }
              setMaterial() {
                const material = this.getMaterial();
                if (!material) return;
                this.material = material;
                const cannonBody =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"],
                    this.object3d
                  );
                if (cannonBody) {
                  cannonBody.body.shapes.forEach(
                    (shape) => (shape.material = this.material)
                  );
                }
              }
            }
            __name(SetCannonMaterial, "SetCannonMaterial");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.text()],
              SetCannonMaterial.prototype,
              "materialName",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              SetCannonMaterial
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts":
          /*!******************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts ***!
  \******************************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () =>
                /* binding */ CannonRaycastVehicle,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonRaycastVehicle extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.mass = 500;
                this.suspensionStiffness = 30;
                this.suspensionRestLength = 0.1;
                this.frictionSlip = 0.7;
                this.maxSuspensionTravel = 0.2;
                this.customSlidingRotationalSpeed = -30;
                this.useCustomSlidingRotationalSpeed = true;
              }
              start() {
                if (!_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld())
                  return;
                let body =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"],
                    this.object3d
                  );
                if (!body) {
                  body = new _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__[
                    "default"
                  ]("CarBody", this.object3d);
                  body.mass = this.mass;
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.addComponent(body);
                }
                if (!this.chasis) return;
                const chassisBody =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"],
                    this.chasis
                  );
                if (
                  !(
                    chassisBody instanceof
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"]
                  )
                )
                  return;
                this.vehicle =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.RaycastVehicle({
                    chassisBody: body.body,
                    indexForwardAxis: 2,
                    indexUpAxis: 1,
                    indexRightAxis: 0,
                  });
                this.vehicle.addToWorld(
                  _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld()
                );
              }
            }
            __name(CannonRaycastVehicle, "CannonRaycastVehicle");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonRaycastVehicle.prototype,
              "chasis",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "mass",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "suspensionStiffness",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "suspensionRestLength",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "frictionSlip",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "dampingRelaxation",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "dampingCompression",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "maxSuspensionForce",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "rollInfluence",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "maxSuspensionTravel",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonRaycastVehicle.prototype,
              "customSlidingRotationalSpeed",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonRaycastVehicle.prototype,
              "useCustomSlidingRotationalSpeed",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonRaycastVehicle
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonSpring.re.ts":
          /*!**********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonSpring.re.ts ***!
  \**********************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonSpring,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonSpring extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.anchorA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.anchorB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.restLength = 0;
                this.stiffness = 50;
                this.damping = 1;
                this.applyForce = /* @__PURE__ */ __name(() => {
                  this.spring.applyForce();
                }, "applyForce");
              }
              start() {
                this.createSpring();
              }
              getCannonBodyComponent(object3d) {
                const cannonBody =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_2__["default"],
                    object3d
                  );
                if (!cannonBody) {
                  throw "CannonSpring targets must have a Cannon Body Component";
                }
                return cannonBody;
              }
              createSpring() {
                if (!this.target) throw "CannonSpring requires a target";
                const bodyA = this.getCannonBodyComponent(this.object3d).body;
                const bodyB = this.getCannonBodyComponent(this.target).body;
                this.spring = new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Spring(
                  bodyA,
                  bodyB,
                  {
                    localAnchorA:
                      new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                        this.anchorA.x,
                        this.anchorA.y,
                        this.anchorA.z
                      ),
                    localAnchorB:
                      new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(
                        this.anchorB.x,
                        this.anchorB.y,
                        this.anchorB.z
                      ),
                    restLength: this.restLength,
                    stiffness: this.stiffness,
                    damping: this.damping,
                  }
                );
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__
                  .getWorld()
                  .addEventListener("postStep", this.applyForce);
              }
              onBeforeRemoved() {
                _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__
                  .getWorld()
                  .removeEventListener("postStep", this.applyForce);
              }
            }
            __name(CannonSpring, "CannonSpring");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonSpring.prototype,
              "target",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonSpring.prototype,
              "anchorA",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonSpring.prototype,
              "anchorB",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonSpring.prototype,
              "restLength",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonSpring.prototype,
              "stiffness",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonSpring.prototype,
              "damping",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonSpring
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonWheel.re.ts":
          /*!*********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonWheel.re.ts ***!
  \*********************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonWheel,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./CannonRaycastVehicle.re */ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonWheel extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.radiusOffset = 0;
                this.connectionPoint =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                this.matrixA = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.matrixB = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.matrixC = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
              }
              start() {
                this.raycastVehicle =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_2__[
                      "default"
                    ],
                    this.object3d
                  );
                if (
                  !(
                    this.raycastVehicle instanceof
                    _CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_2__[
                      "default"
                    ]
                  )
                )
                  return;
                let radius = 0.3;
                if (this.wheel) {
                  this.connectionPoint.copy(this.wheel.position);
                  const bbox =
                    new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(
                      this.wheel
                    );
                  radius = bbox.max.x - bbox.min.x;
                }
                this.wheelInfo =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.WheelInfo({
                    radius: radius + this.radiusOffset,
                    directionLocal:
                      new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(0, -1, 0),
                    suspensionStiffness:
                      this.raycastVehicle.suspensionStiffness,
                    suspensionRestLength:
                      this.raycastVehicle.suspensionRestLength,
                    frictionSlip: this.raycastVehicle.frictionSlip,
                    dampingRelaxation: this.raycastVehicle.dampingRelaxation,
                    dampingCompression: this.raycastVehicle.dampingCompression,
                    maxSuspensionForce: this.raycastVehicle.maxSuspensionForce,
                    rollInfluence: this.raycastVehicle.rollInfluence,
                    axleLocal: new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(
                      -1,
                      0,
                      0
                    ),
                    chassisConnectionPointLocal:
                      new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(
                        this.connectionPoint.x,
                        this.connectionPoint.y,
                        this.connectionPoint.z
                      ),
                    maxSuspensionTravel:
                      this.raycastVehicle.maxSuspensionTravel,
                    customSlidingRotationalSpeed:
                      this.raycastVehicle.customSlidingRotationalSpeed,
                    useCustomSlidingRotationalSpeed:
                      this.raycastVehicle.useCustomSlidingRotationalSpeed,
                  });
                this.raycastVehicle.vehicle.wheelInfos.push(this.wheelInfo);
              }
              afterUpdate() {
                if (!this.wheel) return;
                const wheel = this.wheelInfo;
                if (!wheel) return;
                const pos = wheel.worldTransform.position;
                const rot = wheel.worldTransform.quaternion;
                this.wheel.position.set(pos.x, pos.y, pos.z);
                this.wheel.parent?.worldToLocal(this.wheel.position);
                this.wheel.quaternion.set(rot.x, rot.y, rot.z, rot.w);
                this.matrixA.makeRotationFromQuaternion(this.wheel.quaternion);
                this.wheel.updateMatrixWorld();
                this.matrixB.copy(this.wheel.parent.matrixWorld).invert();
                this.matrixC.extractRotation(this.matrixB);
                this.matrixA.premultiply(this.matrixC);
                this.wheel.quaternion.setFromRotationMatrix(this.matrixA);
              }
            }
            __name(CannonWheel, "CannonWheel");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.object3d()],
              CannonWheel.prototype,
              "wheel",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonWheel.prototype,
              "radiusOffset",
              2
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonWheel
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonBox.re.ts":
          /*!******************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonBox.re.ts ***!
  \******************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonBox,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonBox extends _CannonShape__WEBPACK_IMPORTED_MODULE_2__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.sizeOffset =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                this._collisionResponse = true;
                this.worldScale =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
              }
              get collisionResponse() {
                return this._collisionResponse;
              }
              set collisionResponse(value) {
                this._collisionResponse = value;
                if (!this.shape) return;
                this.shape.collisionResponse = value;
              }
              createShape() {
                this.object3d.getWorldScale(this.worldScale);
                this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Box(
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(
                    this.sizeOffset.x * (this.worldScale.x / 2),
                    this.sizeOffset.y * (this.worldScale.y / 2),
                    this.sizeOffset.z * (this.worldScale.z / 2)
                  )
                );
                this.shape.collisionResponse = this._collisionResponse;
              }
            }
            __name(CannonBox, "CannonBox");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonBox.prototype,
              "sizeOffset",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonBox.prototype,
              "collisionResponse",
              1
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonBox
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonCylinder.re.ts":
          /*!***********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonCylinder.re.ts ***!
  \***********************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonCylinder,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonCylinder extends _CannonShape__WEBPACK_IMPORTED_MODULE_2__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.radiusTopOffset = 1;
                this.radiusBottomOffset = 1;
                this.heightOffset = 1;
                this.segments = 100;
                this._collisionResponse = true;
                this.worldScale =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
              }
              get collisionResponse() {
                return this._collisionResponse;
              }
              set collisionResponse(value) {
                this._collisionResponse = value;
                if (!this.shape) return;
                this.shape.collisionResponse = value;
              }
              createShape() {
                this.object3d.getWorldScale(this.worldScale);
                this.shape =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Cylinder(
                    this.radiusTopOffset * this.worldScale.x,
                    this.radiusBottomOffset * this.worldScale.x,
                    this.heightOffset * this.worldScale.y,
                    this.segments
                  );
                this.shape.collisionResponse = this._collisionResponse;
              }
            }
            __name(CannonCylinder, "CannonCylinder");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonCylinder.prototype,
              "radiusTopOffset",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonCylinder.prototype,
              "radiusBottomOffset",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonCylinder.prototype,
              "heightOffset",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonCylinder.prototype,
              "segments",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonCylinder.prototype,
              "collisionResponse",
              1
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonCylinder
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts":
          /*!*****************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts ***!
  \*****************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonShape,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
              );
            var __defProp = Object.defineProperty;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });

            class CannonShape extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
              constructor() {
                super(...arguments);
                this.localPos =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.worldPos =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.oldPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.localRot =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                this.worldQuaternion =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                this.matrixA = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.matrixB = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
                this.matrixC = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
              }
              static findByShape(shape) {
                let shapeComponent;
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__.traverseComponents(
                  (component) => {
                    if (shapeComponent) return;
                    if (
                      component instanceof CannonShape &&
                      component.shape === shape
                    ) {
                      shapeComponent = component;
                    }
                  }
                );
                return shapeComponent;
              }
              awake() {
                this.createShape();
              }
              start() {
                if (!this.shape) return;
                this.bodyComponent = this.getBodyComponent(this.object3d);
                if (!this.bodyComponent) return;
                if (!this.bodyComponent.body) return;
                this.body = this.bodyComponent.body;
                const bodyIsShape =
                  this.object3d === this.bodyComponent.object3d;
                this.object3d.getWorldPosition(this.worldPos);
                this.localPos.copy(this.worldPos);
                this.bodyComponent.object3d.updateWorldMatrix(true, true);
                this.bodyComponent.object3d.worldToLocal(this.localPos);
                let position = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(
                  this.localPos.x,
                  this.localPos.y,
                  this.localPos.z
                );
                this.object3d.updateWorldMatrix(true, true);
                this.object3d.getWorldQuaternion(this.worldQuaternion);
                this.matrixA.makeRotationFromQuaternion(this.worldQuaternion);
                this.object3d.updateWorldMatrix(true, true);
                this.matrixB
                  .copy(this.bodyComponent.object3d.matrixWorld)
                  .invert();
                this.matrixC.extractRotation(this.matrixB);
                this.matrixA.premultiply(this.matrixC);
                this.localRot.setFromRotationMatrix(this.matrixA);
                let rotation =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Quaternion(
                    this.localRot.x,
                    this.localRot.y,
                    this.localRot.z,
                    this.localRot.w
                  );
                if (bodyIsShape) {
                  this.body.addShape(this.shape);
                } else {
                  this.body.addShape(this.shape, position, rotation);
                }
              }
              update() {
                if (!this.shape) return;
                if (!this.shape.body) return;
                if (
                  this.shape.body.type ===
                    cannon_es__WEBPACK_IMPORTED_MODULE_3__.BODY_TYPES.STATIC ||
                  this.shape.body.mass === 0
                )
                  return;
                const shapeIndex = this.shape.body?.shapes.indexOf(this.shape);
                if (shapeIndex === void 0) return;
                this.oldPos.copy(this.worldPos);
                this.object3d.getWorldPosition(this.worldPos);
                if (this.oldPos.equals(this.worldPos)) return;
                this.localPos.copy(this.worldPos);
                this.bodyComponent?.object3d.updateWorldMatrix(true, true);
                this.bodyComponent?.object3d.worldToLocal(this.localPos);
                this.shape.body?.shapeOffsets[shapeIndex].set(
                  this.localPos.x,
                  this.localPos.y,
                  this.localPos.z
                );
                this.shape.updateBoundingSphereRadius();
                this.shape.body?.updateAABB();
              }
              onDisabled() {
                this.body?.removeShape(this.shape);
              }
              onBeforeObjectRemoved() {
                this.body?.removeShape(this.shape);
              }
              getBodyComponent(object3d) {
                const bodyComponent =
                  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(
                    _CannonBody_re__WEBPACK_IMPORTED_MODULE_2__["default"],
                    object3d
                  );
                if (bodyComponent) {
                  return bodyComponent;
                }
                if (!object3d.parent) return;
                return this.getBodyComponent(object3d.parent);
              }
              createShape() {}
            }
            __name(CannonShape, "CannonShape");

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonSphere.re.ts":
          /*!*********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonSphere.re.ts ***!
  \*********************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonSphere,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(
                /*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonSphere extends _CannonShape__WEBPACK_IMPORTED_MODULE_1__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.radiusOffset = 1;
                this._collisionResponse = true;
              }
              get collisionResponse() {
                return this._collisionResponse;
              }
              set collisionResponse(value) {
                this._collisionResponse = value;
                if (!this.shape) return;
                this.shape.collisionResponse = value;
              }
              createShape() {
                const scale = this.object3d.scale;
                const maxSide = Math.max(scale.x, scale.y, scale.z);
                this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Sphere(
                  this.radiusOffset * maxSide
                );
                this.shape.collisionResponse = this._collisionResponse;
              }
            }
            __name(CannonSphere, "CannonSphere");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.num()],
              CannonSphere.prototype,
              "radiusOffset",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonSphere.prototype,
              "collisionResponse",
              1
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonSphere
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonTrimesh.re.ts":
          /*!**********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonTrimesh.re.ts ***!
  \**********************************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ default: () => /* binding */ CannonTrimesh,
              /* harmony export */
            });
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(/*! rogue-engine */ "rogue-engine");
            /* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __webpack_require__.n(
                rogue_engine__WEBPACK_IMPORTED_MODULE_0__
              );
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ =
              __webpack_require__(/*! three */ "three");
            /* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __webpack_require__.n(
                three__WEBPACK_IMPORTED_MODULE_1__
              );
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            /* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_2__ =
              __webpack_require__(
                /*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
              );
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });
            var __decorateClass = (decorators, target, key, kind) => {
              var result =
                kind > 1
                  ? void 0
                  : kind
                  ? __getOwnPropDesc(target, key)
                  : target;
              for (var i = decorators.length - 1, decorator; i >= 0; i--)
                if ((decorator = decorators[i]))
                  result =
                    (kind
                      ? decorator(target, key, result)
                      : decorator(result)) || result;
              if (kind && result) __defProp(target, key, result);
              return result;
            };

            class CannonTrimesh extends _CannonShape__WEBPACK_IMPORTED_MODULE_2__[
              "default"
            ] {
              constructor() {
                super(...arguments);
                this.sizeOffset =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
                this._collisionResponse = true;
                this.worldScale =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.worldPos =
                  new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
                this.tmpVec0 =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
                this.tmpVec1 =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
                this.tmpVec2 =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
                this.tmpQuat0 =
                  new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
              }
              get collisionResponse() {
                return this._collisionResponse;
              }
              set collisionResponse(value) {
                this._collisionResponse = value;
                if (!this.shape) return;
                this.shape.collisionResponse = value;
              }
              createShape() {
                if (
                  !(
                    this.object3d instanceof
                    three__WEBPACK_IMPORTED_MODULE_1__.Mesh
                  )
                )
                  return;
                this.object3d.updateWorldMatrix(true, true);
                this.object3d.getWorldScale(this.worldScale);
                this.object3d.getWorldPosition(this.worldPos);
                this.object3d.getWorldQuaternion(this.worldQuaternion);
                const mesh = this.object3d;
                let geometry = mesh.geometry;
                geometry.computeBoundingSphere();
                geometry.normalizeNormals();
                if (geometry.index !== null) {
                  const nonIndexedGeo = geometry.toNonIndexed();
                  geometry.copy(nonIndexedGeo);
                }
                const vertices = this.getVertices(geometry);
                if (!vertices.length) return;
                const indices = Object.keys(vertices).map(Number);
                this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Trimesh(
                  vertices,
                  indices
                );
                this.shape.collisionResponse = this._collisionResponse;
              }
              getVertices(geometry) {
                const position = geometry.attributes.position;
                const vertices = new Float32Array(position.count * 3);
                for (let i = 0; i < position.count; i++) {
                  vertices[i * 3] = position.getX(i) * this.worldScale.x;
                  vertices[i * 3 + 1] = position.getY(i) * this.worldScale.y;
                  vertices[i * 3 + 2] = position.getZ(i) * this.worldScale.z;
                }
                return vertices;
              }
            }
            __name(CannonTrimesh, "CannonTrimesh");
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.vector3()],
              CannonTrimesh.prototype,
              "sizeOffset",
              2
            );
            __decorateClass(
              [rogue_engine__WEBPACK_IMPORTED_MODULE_0__.props.checkbox()],
              CannonTrimesh.prototype,
              "collisionResponse",
              1
            );
            rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(
              CannonTrimesh
            );

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts":
          /*!***************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts ***!
  \***************************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ getWorld: () => /* binding */ getWorld,
              /* harmony export */ setWorld: () => /* binding */ setWorld,
              /* harmony export */ copyThreeV3: () => /* binding */ copyThreeV3,
              /* harmony export */ copyThreeQuaternion: () =>
                /* binding */ copyThreeQuaternion,
              /* harmony export */ copyCannonV3: () =>
                /* binding */ copyCannonV3,
              /* harmony export */ copyCannonQuaternion: () =>
                /* binding */ copyCannonQuaternion,
              /* harmony export */
            });
            /* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(
                /*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js"
              );
            var __defProp = Object.defineProperty;
            var __name = (target, value) =>
              __defProp(target, "name", { value, configurable: true });

            let world = new cannon_es__WEBPACK_IMPORTED_MODULE_0__.World();
            function getWorld() {
              return world;
            }
            __name(getWorld, "getWorld");
            function setWorld(newWorld) {
              world = newWorld;
            }
            __name(setWorld, "setWorld");
            function copyThreeV3(vector3, target) {
              target.set(vector3.x, vector3.y, vector3.z);
            }
            __name(copyThreeV3, "copyThreeV3");
            function copyThreeQuaternion(quaternion, target) {
              const q = quaternion;
              target.set(q.x, q.y, q.z, q.w);
            }
            __name(copyThreeQuaternion, "copyThreeQuaternion");
            function copyCannonV3(vector3, target) {
              target.set(vector3.x, vector3.y, vector3.z);
            }
            __name(copyCannonV3, "copyCannonV3");
            function copyCannonQuaternion(quaternion, target) {
              const q = quaternion;
              target.set(q.x, q.y, q.z, q.w);
            }
            __name(copyCannonQuaternion, "copyCannonQuaternion");

            /***/
          },

        /***/ "./Assets/rogue_packages/rogue-cannon/index.ts":
          /*!*****************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/index.ts ***!
  \*****************************************************/
          /***/ (
            __unused_webpack_module,
            __webpack_exports__,
            __webpack_require__
          ) => {
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
              /* harmony export */ RogueCannon: () =>
                /* reexport module object */ _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_0__,
              /* harmony export */
            });
            /* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_0__ =
              __webpack_require__(
                /*! ./Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
              );

            /***/
          },

        /***/ "rogue-engine":
          /*!******************************************************************************************************************!*\
  !*** external {"commonjs":"rogue-engine","commonjs2":"rogue-engine","amd":"rogue-engine","root":"rogue-engine"} ***!
  \******************************************************************************************************************/
          /***/ (module) => {
            module.exports = __WEBPACK_EXTERNAL_MODULE_rogue_engine__;

            /***/
          },

        /***/ three:
          /*!**************************************************************************************!*\
  !*** external {"commonjs":"three","commonjs2":"three","amd":"three","root":"three"} ***!
  \**************************************************************************************/
          /***/ (module) => {
            module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

            /***/
          },

        /******/
      };
      /************************************************************************/
      /******/ // The module cache
      /******/ var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/ function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/ var cachedModule = __webpack_module_cache__[moduleId];
        /******/ if (cachedModule !== undefined) {
          /******/ return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/ var module = (__webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/ exports: {},
          /******/
        });
        /******/
        /******/ // Execute the module function
        /******/ __webpack_modules__[moduleId](
          module,
          module.exports,
          __webpack_require__
        );
        /******/
        /******/ // Return the exports of the module
        /******/ return module.exports;
        /******/
      }
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/ __webpack_require__.m = __webpack_modules__;
      /******/
      /************************************************************************/
      /******/ /* webpack/runtime/chunk loaded */
      /******/ (() => {
        /******/ var deferred = [];
        /******/ __webpack_require__.O = (result, chunkIds, fn, priority) => {
          /******/ if (chunkIds) {
            /******/ priority = priority || 0;
            /******/ for (
              var i = deferred.length;
              i > 0 && deferred[i - 1][2] > priority;
              i--
            )
              deferred[i] = deferred[i - 1];
            /******/ deferred[i] = [chunkIds, fn, priority];
            /******/ return;
            /******/
          }
          /******/ var notFulfilled = Infinity;
          /******/ for (var i = 0; i < deferred.length; i++) {
            /******/ var [chunkIds, fn, priority] = deferred[i];
            /******/ var fulfilled = true;
            /******/ for (var j = 0; j < chunkIds.length; j++) {
              /******/ if (
                (priority & (1 === 0) || notFulfilled >= priority) &&
                Object.keys(__webpack_require__.O).every((key) =>
                  __webpack_require__.O[key](chunkIds[j])
                )
              ) {
                /******/ chunkIds.splice(j--, 1);
                /******/
              } else {
                /******/ fulfilled = false;
                /******/ if (priority < notFulfilled) notFulfilled = priority;
                /******/
              }
              /******/
            }
            /******/ if (fulfilled) {
              /******/ deferred.splice(i--, 1);
              /******/ var r = fn();
              /******/ if (r !== undefined) result = r;
              /******/
            }
            /******/
          }
          /******/ return result;
          /******/
        };
        /******/
      })();
      /******/
      /******/ /* webpack/runtime/compat get default export */
      /******/ (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = (module) => {
          /******/ var getter =
            module && module.__esModule
              ? /******/ () => module["default"]
              : /******/ () => module;
          /******/ __webpack_require__.d(getter, { a: getter });
          /******/ return getter;
          /******/
        };
        /******/
      })();
      /******/
      /******/ /* webpack/runtime/define property getters */
      /******/ (() => {
        /******/ // define getter functions for harmony exports
        /******/ __webpack_require__.d = (exports, definition) => {
          /******/ for (var key in definition) {
            /******/ if (
              __webpack_require__.o(definition, key) &&
              !__webpack_require__.o(exports, key)
            ) {
              /******/ Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key],
              });
              /******/
            }
            /******/
          }
          /******/
        };
        /******/
      })();
      /******/
      /******/ /* webpack/runtime/hasOwnProperty shorthand */
      /******/ (() => {
        /******/ __webpack_require__.o = (obj, prop) =>
          Object.prototype.hasOwnProperty.call(obj, prop);
        /******/
      })();
      /******/
      /******/ /* webpack/runtime/make namespace object */
      /******/ (() => {
        /******/ // define __esModule on exports
        /******/ __webpack_require__.r = (exports) => {
          /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
              value: "Module",
            });
            /******/
          }
          /******/ Object.defineProperty(exports, "__esModule", {
            value: true,
          });
          /******/
        };
        /******/
      })();
      /******/
      /******/ /* webpack/runtime/jsonp chunk loading */
      /******/ (() => {
        /******/ // no baseURI
        /******/
        /******/ // object to store loaded and loading chunks
        /******/ // undefined = chunk not loaded, null = chunk preloaded/prefetched
        /******/ // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
        /******/ var installedChunks = {
          /******/ "rogue-engine-user-scripts": 0,
          /******/
        };
        /******/
        /******/ // no chunk on demand loading
        /******/
        /******/ // no prefetching
        /******/
        /******/ // no preloaded
        /******/
        /******/ // no HMR
        /******/
        /******/ // no HMR manifest
        /******/
        /******/ __webpack_require__.O.j = (chunkId) =>
          installedChunks[chunkId] === 0;
        /******/
        /******/ // install a JSONP callback for chunk loading
        /******/ var webpackJsonpCallback = (
          parentChunkLoadingFunction,
          data
        ) => {
          /******/ var [chunkIds, moreModules, runtime] = data;
          /******/ // add "moreModules" to the modules object,
          /******/ // then flag all "chunkIds" as loaded and fire callback
          /******/ var moduleId,
            chunkId,
            i = 0;
          /******/ if (chunkIds.some((id) => installedChunks[id] !== 0)) {
            /******/ for (moduleId in moreModules) {
              /******/ if (__webpack_require__.o(moreModules, moduleId)) {
                /******/ __webpack_require__.m[moduleId] =
                  moreModules[moduleId];
                /******/
              }
              /******/
            }
            /******/ if (runtime) var result = runtime(__webpack_require__);
            /******/
          }
          /******/ if (parentChunkLoadingFunction)
            parentChunkLoadingFunction(data);
          /******/ for (; i < chunkIds.length; i++) {
            /******/ chunkId = chunkIds[i];
            /******/ if (
              __webpack_require__.o(installedChunks, chunkId) &&
              installedChunks[chunkId]
            ) {
              /******/ installedChunks[chunkId][0]();
              /******/
            }
            /******/ installedChunks[chunkId] = 0;
            /******/
          }
          /******/ return __webpack_require__.O(result);
          /******/
        };
        /******/
        /******/ var chunkLoadingGlobal = (self["webpackChunk_name_"] =
          self["webpackChunk_name_"] || []);
        /******/ chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
        /******/ chunkLoadingGlobal.push = webpackJsonpCallback.bind(
          null,
          chunkLoadingGlobal.push.bind(chunkLoadingGlobal)
        );
        /******/
      })();
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/ __webpack_require__("./Assets/Components/Animator.re.ts");
      /******/ __webpack_require__(
        "./Assets/Components/CharacterController.re.ts"
      );
      /******/ __webpack_require__("./Assets/Components/CharacterStatus.re.ts");
      /******/ __webpack_require__("./Assets/Components/EnemyAI.re.ts");
      /******/ __webpack_require__("./Assets/Components/MeleeAttack.re.ts");
      /******/ __webpack_require__("./Assets/Components/UIElement.re.ts");
      /******/ __webpack_require__(
        "./Assets/Components/UIHealthBarsController.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/CannonConfig.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonDistanceConstraint.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonHingeConstraint.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonLockConstraint.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonPointToPointConstraint.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonSimpleCharacterController.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonVehicleController.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Material/CannonContactMaterial.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Material/CannonMaterial.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Material/SetCannonMaterial.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonSpring.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonWheel.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonBox.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonCylinder.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonSphere.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonTrimesh.re.ts"
      );
      /******/ __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/index.ts"
      );
      /******/ var __webpack_exports__ = __webpack_require__(
        "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts"
      );
      /******/ __webpack_exports__ = __webpack_require__.O(__webpack_exports__);
      /******/
      /******/ return __webpack_exports__;
      /******/
    })();
  }
);
//# sourceMappingURL=rogue-engine-user-scripts.js.map
window["rogue-engine"].App.play({
  title: "WarriorsArena",
  scenes: [{ name: "Arena", uuid: "24549984-58C7-4F4C-822F-82377662F1A8" }],
  assetPaths: {
    "731F73B5-B626-4B42-B3C7-9C560627AE48":
      "WarriorsArena_DATA/731F73B5-B626-4B42-B3C7-9C560627AE48.rogueAnimation",
    "F511E1A6-F792-4A92-9B3F-090F2AC85AB7":
      "WarriorsArena_DATA/F511E1A6-F792-4A92-9B3F-090F2AC85AB7.rogueAnimation",
    "DA2CD6CB-F7D0-489A-AB8E-B56A6E064561":
      "WarriorsArena_DATA/DA2CD6CB-F7D0-489A-AB8E-B56A6E064561.rogueAnimation",
    "4E831F9C-B0A0-494C-AB03-65A499EC7F25":
      "WarriorsArena_DATA/4E831F9C-B0A0-494C-AB03-65A499EC7F25.rogueAnimation",
    "FF5F4350-5237-4342-8CF7-BBFA42A1C13E":
      "WarriorsArena_DATA/FF5F4350-5237-4342-8CF7-BBFA42A1C13E.rogueAnimation",
    "1E336055-FEAA-43B9-9E08-905873E7E9F4":
      "WarriorsArena_DATA/1E336055-FEAA-43B9-9E08-905873E7E9F4.rogueAnimation",
    "C239703D-264A-4DD6-A4DA-DF9F571D55C4":
      "WarriorsArena_DATA/C239703D-264A-4DD6-A4DA-DF9F571D55C4.roguePrefab",
    "CF2088B9-B45F-49B8-8101-A781CFBF10D1":
      "WarriorsArena_DATA/CF2088B9-B45F-49B8-8101-A781CFBF10D1.png",
    "5729FD77-1CF5-484C-B7A9-C7E794E454E1":
      "WarriorsArena_DATA/5729FD77-1CF5-484C-B7A9-C7E794E454E1.rogueMaterial",
    "D32ECF7F-9073-4ADC-BC8C-FE9D2417EBD3":
      "WarriorsArena_DATA/D32ECF7F-9073-4ADC-BC8C-FE9D2417EBD3.png",
    "94BEDA31-94D7-4F51-9B2C-FC6E155B22B5":
      "WarriorsArena_DATA/94BEDA31-94D7-4F51-9B2C-FC6E155B22B5.rogueMaterial",
    "24549984-58C7-4F4C-822F-82377662F1A8":
      "WarriorsArena_DATA/24549984-58C7-4F4C-822F-82377662F1A8.rogueScene",
  },
});
